<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vim 笔记</title>
    <link href="/2025/09/19/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/vim%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/09/19/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/vim%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="vim-note">vim note</h1><p>算了没必要学这东西</p><p>vim 功能太多了还是键盘鼠标好用</p><hr /><p>In this note, I use neovim as the example.</p><h2 id="basic-commands">basic commands</h2><p>In terminal, type <code>nvim</code> to open neovim.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvim<br></code></pre></td></tr></table></figure><p>to create a new file, type <code>nvim filename</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvim test.txt<br></code></pre></td></tr></table></figure><p>After opening the file, we are in the editor.</p><h3 id="modes">modes</h3><p>there are three modles in Vim:</p><ol type="1"><li>normal mode: for navigation and manipulation</li><li>insert mode: for inserting text</li><li>command mode: for executing commands</li></ol><p>usually we start in normal mode.</p><h4 id="normal-mode">normal mode</h4><p>we can go through and use commends in normal mode</p><p>In normal mode, we can use keys to move the cursor</p><ul><li><kbd>h</kbd>: move left</li><li><kbd>j</kbd>: move down</li><li><kbd>k</kbd>: move up</li><li><kbd>l</kbd>: move right</li></ul><h4 id="insert-mode">insert mode</h4><p>We can edit text in insert mode.</p><p>there are several ways to enter insert mode</p><ul><li><kbd>i</kbd>: insert</li><li><kbd>a</kbd>: append</li><li><kbd>o</kbd>: open a new line below</li><li><kbd>I</kbd>: insert before the line</li><li><kbd>A</kbd>: append at the end of the line</li><li><kbd>O</kbd>: open a new line above</li></ul><p>and use <kbd>Esc</kbd> to exit insert mode and return to normalmode</p>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
      <tag>编辑器</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义基本原理</title>
    <link href="/2025/09/19/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E9%A9%AC%E5%8E%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/09/19/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E9%A9%AC%E5%8E%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="马克思主义基本原理">马克思主义基本原理</h1>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>公共课程</category>
      
      <category>马克思主义基本原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>马原</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    <url>/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能导论">人工智能导论</h1><h2 id="人工智能的概念">人工智能的概念</h2><h3 id="定义与理解">定义与理解</h3><p>人工智能（Artificial Intelligence,AI）已经深入我们的日常生活。从智能问答、内容推荐到自动驾驶和智能家居，AI技术无处不在。</p><blockquote><p><strong>艾伦·图灵</strong> 对 AI的定义是：<em>能使计算机完成那些需要人类智力才能完成的工作的科学。</em></p></blockquote><p>尽管 AI发展迅速，但智能与智能体的本质，至今仍是哲学家和科学家持续探索的课题。</p><h3 id="ai-的类型">AI 的类型</h3><p>AI可以根据其<strong>能力</strong>和<strong>功能</strong>两个维度进行分类。</p><table><thead><tr><th style="text-align: left;">分类维度</th><th style="text-align: left;">类型</th><th style="text-align: left;">功能描述</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>基于能力</strong></td><td style="text-align: left;">狭窄 AI (Narrow AI)</td><tdstyle="text-align: left;">经过训练后可执行特定任务，以目标为导向。</td></tr><tr><td style="text-align: left;"></td><td style="text-align: left;">通用 AI (General AI)</td><tdstyle="text-align: left;">能够像人类一样独立思考的系统（<em>目前尚未实现</em>）。</td></tr><tr><td style="text-align: left;"></td><td style="text-align: left;">超级 AI (Super AI)</td><tdstyle="text-align: left;">超越人类智能，能比人类更好地完成任务（<em>理论概念</em>）。</td></tr><tr><td style="text-align: left;"><strong>基于功能</strong></td><td style="text-align: left;">反应型机器 (Reactive Machines)</td><tdstyle="text-align: left;">专注于当前场景，根据最佳行动做出反应，没有记忆功能。</td></tr><tr><td style="text-align: left;"></td><td style="text-align: left;">有限记忆机器 (Limited Memory)</td><tdstyle="text-align: left;">可以在短时间内存储和使用过去的经验或数据。</td></tr><tr><td style="text-align: left;"></td><td style="text-align: left;">理论型 AI (Theory of Mind AI)</td><tdstyle="text-align: left;">能够理解人类情感并进行社交互动（<em>研发中</em>）。</td></tr><tr><td style="text-align: left;"></td><td style="text-align: left;">自我意识 AI (Self-Awareness AI)</td><tdstyle="text-align: left;">拥有自我意识和自我理解，能独立思考决策（<em>理论概念</em>）。</td></tr></tbody></table><h2 id="第二部分发展简史">第二部分：发展简史</h2><h3 id="早期思想与概念诞生-1921-1956">早期思想与概念诞生(1921-1956)</h3><ul><li><strong>1921 年</strong>：捷克作家卡雷尔·恰佩克在其科幻剧中首次提出<strong>“机器人”</strong> (Robot) 的概念。</li><li><strong>1949 年</strong>：信息论之父 <strong>克劳德·香农</strong>发表《编写计算机下棋程序》，表明计算机可用于复杂的逻辑推理。</li><li><strong>1950 年</strong>：<strong>艾伦·图灵</strong>发表《计算机与智能》，提出 <strong>“模仿游戏”</strong>，即后来的<strong>“图灵测试”</strong>，用以判断机器是否能够思考。</li><li><strong>1956年</strong>：在达特茅斯夏季会议上，<strong>约翰·麦卡锡</strong> 首次提出<strong>“人工智能”</strong> 这一术语，标志着 AI作为一个独立研究领域的诞生。</li></ul><h3 id="第一个夏天与寒冬-1957-1980s">第一个夏天与寒冬 (1957-1980s)</h3><ul><li><strong>AI 的第一个夏天 (1957-1973)</strong>：<ul><li><strong>1957 年</strong>：弗兰克·罗森布拉特制造了 <strong>Mark I感知器</strong>，这是最早的模拟神经网络之一，为现代神经网络奠定了基础。</li><li><strong>1958 年</strong>：约翰·麦卡锡开发了 AI 研究的高级编程语言<strong>Lisp</strong>。</li><li><strong>1965 年</strong>：诞生了历史上第一个对话模型<strong>ELIZA</strong>，可以模仿心理治疗师与人对话。</li></ul></li><li><strong>AI 的第一个寒冬 (1970 年代)</strong>：<ul><li>由于 <strong>计算能力不足</strong> 和<strong>数据存储限制</strong>，AI研究进展缓慢，经费被削减，发展陷入停滞。</li></ul></li></ul><h3 id="复苏与第二个寒冬-1980s-1990s">复苏与第二个寒冬(1980s-1990s)</h3><ul><li><strong>专家系统的兴起 (1980 年代初)</strong>：爱德华·费根鲍姆引入了<strong>专家系统</strong>，它能模仿人类专家的决策过程，在商业上取得成功，推动了AI 的再次发展。</li><li><strong>AI 的第二个寒冬 (1987-1990年代中期)</strong>：专家系统维护成本高昂且无法“学习”，市场最终崩溃。“人工智能”一词成为禁忌，研究者转向使用<strong>“机器学习”</strong> 等术语。</li></ul><h3 id="现代-ai-的崛起-1997-至今">现代 AI 的崛起 (1997-至今)</h3><ul><li><strong>1997 年</strong>：IBM 的 <strong>“深蓝”</strong> (Deep Blue)计算机击败国际象棋世界冠军卡斯帕罗夫，展示了强大的计算能力。</li><li><strong>2006 年</strong>：杰弗里·辛顿提出<strong>“深度置信网络”</strong>，解决了神经网络训练中的梯度消失问题，开启了现代深度学习的时代。</li><li><strong>2012 年</strong>：<strong>AlexNet</strong> 在 ImageNet图像识别竞赛中取得压倒性胜利，标志着深度学习开始广泛进入人们的视野。</li><li><strong>2016 年</strong>：DeepMind 开发的 <strong>AlphaGo</strong>击败世界围棋冠军李世石，证明了 AI 在复杂决策任务上的巨大潜力。</li><li><strong>2022 年</strong>：OpenAI 发布<strong>ChatGPT</strong>，引发了全球对生成式 AI 的关注。</li><li><strong>未来展望</strong>：<ol type="1"><li>从 AI 大模型迈向通用人工智能 (AGI)。</li><li>利用合成数据打破训练数据瓶颈。</li><li>量子计算机与 AI 的结合。</li><li>提升 AI 在关键场景下的可靠性与可解释性。</li><li>重视 AI 带来的伦理问题。</li></ol></li></ul><h2 id="第三部分重要概念">第三部分：重要概念</h2><h3 id="ai-领域的核心组成部分">AI 领域的核心组成部分</h3><table><thead><tr><th style="text-align: left;">组成部分</th><th style="text-align: left;">作用</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>神经网络</strong></td><td style="text-align: left;">利用多层结构进行数据分析。</td></tr><tr><td style="text-align: left;"><strong>机器学习</strong></td><td style="text-align: left;">让计算机从数据中学习和改进。</td></tr><tr><td style="text-align: left;"><strong>深度学习</strong></td><tdstyle="text-align: left;">模仿人脑结构的计算模型，是机器学习的高级分支。</td></tr><tr><td style="text-align: left;"><strong>认知计算</strong></td><td style="text-align: left;">模拟人类思维进行交互。</td></tr><tr><td style="text-align: left;"><strong>计算机视觉</strong></td><td style="text-align: left;">使计算机理解和解释视觉信息。</td></tr><tr><td style="text-align: left;"><strong>自然语言处理</strong></td><td style="text-align: left;">理解和生成人类语言文本。</td></tr></tbody></table><h3 id="神经网络-neural-network-nn">神经网络 (Neural Network, NN)</h3><p>神经网络通过模仿人类大脑的结构和特征来进行计算。</p><ul><li><strong>单个神经元</strong>：是神经网络的基本单元。它接收多个输入信号，通过加权求和与激活函数处理后，产生一个输出信号。<span class="math display">\[a = \sum w_i x_i, \quad y = \sigma(a)\]</span></li><li><strong>网络结构</strong>：一个完整的神经网络由许多神经元在不同的层次（输入层、隐藏层、输出层）上相互连接而成，能够执行复杂的任务。</li><li><strong>通用近似定理</strong>：理论上，一个具有足够层数和神经元的神经网络，可以逼近任意给定的连续函数。</li></ul><h3 id="机器学习-machine-learning-ml">机器学习 (Machine Learning,ML)</h3><p>机器学习是实现人工智能的一种核心方法，其本质是让机器具备<strong>寻找一个函数</strong>的能力，“学习”的过程就是确定这个函数中待定系数的过程。</p><h4 id="机器学习的类别">机器学习的类别</h4><ol type="1"><li><strong>监督学习 (Supervised Learning)</strong></li><li><strong>非监督学习 (Unsupervised Learning)</strong></li><li><strong>强化学习 (Reinforcement Learning)</strong></li></ol><h4 id="监督学习-vs.-非监督学习">监督学习 vs. 非监督学习</h4><table><thead><tr><th style="text-align: left;">特征</th><th style="text-align: left;">监督学习 (Supervised Learning)</th><th style="text-align: left;">非监督学习 (Unsupervised Learning)</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>数据</strong></td><td style="text-align: left;">包含输入 <code>x</code> 和对应的标签<code>y</code>，即 <span class="math inline">\((x, y)\)</span></td><td style="text-align: left;">只包含输入 <code>x</code>，没有标签</td></tr><tr><td style="text-align: left;"><strong>目标</strong></td><td style="text-align: left;">学习一个从输入到输出的映射函数 <spanclass="math inline">\(x \to y\)</span></td><td style="text-align: left;">学习数据潜在的分布和特征</td></tr><tr><td style="text-align: left;"><strong>示例</strong></td><tdstyle="text-align: left;"><strong>分类</strong>（如水果识别）、<strong>回归</strong>（如房价预测）</td><tdstyle="text-align: left;"><strong>聚类</strong>（如客户分群）、<strong>降维</strong>（如特征提取）</td></tr></tbody></table><h4 id="强化学习-reinforcement-learning">强化学习 (ReinforcementLearning)</h4><p>强化学习是一种<strong>从与环境的互动中学习</strong>的范式。</p><ul><li>智能体 (Agent) 在特定状态 (State) 下采取行动 (Action)。</li><li>环境 (Environment) 根据行动给予奖励 (Reward)。</li><li>智能体的目标是学习一个策略，以<strong>最大化长期累积奖励</strong>。</li><li><em>AlphaGo</em> 就是强化学习的经典应用案例。</li></ul><h3 id="深度学习-deep-learning-dl">深度学习 (Deep Learning, DL)</h3><p>深度学习是机器学习的一个高级分支，它利用<strong>深层神经网络</strong>（包含多个隐藏层）来处理数据和任务。</p><ul><li><strong>与传统机器学习的区别</strong>：<ul><li><strong>传统机器学习</strong>：特征提取和分类是独立的步骤，通常需要人为干预和设计。</li><li><strong>深度学习</strong>：特征提取和分类是一个集成的过程，由深层神经网络自动完成，特别适合处理大规模、高维度的数据。</li></ul></li></ul><h2 id="传统人工智能技术">传统人工智能技术</h2><h3 id="知识表示">知识表示</h3><p>将显示世界的知识和信息以</p><ol type="1"><li>逻辑表示</li><li>语义网络表示</li><li>框架表示</li><li>生产规则</li></ol><h4 id="逻辑表示">逻辑表示</h4><p>逻辑表示氛围两种类型</p><ol type="1"><li><p>命题逻辑 以 Bool 值表示对象</p><p><span class="math display">\[P\rightarrow Q\]</span></p><p>即如果 P 为真，则 Q 也为真</p></li><li><p>一阶逻辑 用量词和谓词来表示对象</p><p><span class="math display">\[\forall x(Cat(x) \rightarrow Meows(x))\]</span></p><p>所有猫都会叫</p></li></ol><h4 id="语义网络表示">语义网络表示</h4><p>语义网络是谓词逻辑的替代方案，以图结构来表示知识</p><p>节点表示概念，边表示概念之间的语义关系</p><h4 id="框架表示">框架表示</h4><p>框架表示是一种结构化的知识表示方式</p><p>每个框架由多个槽和槽值组成，槽中包含该对象的特征、属性和相关信息</p><h4 id="生产规则">生产规则</h4><p>基于条件-动作来表示知识</p><p>每条规则都有前提（条件）和后果（动作）组成，当条件满足时，系统执行相应的动作</p><p>是专家系统的基础</p><h3 id="推理">推理</h3><p>从已有的知识或数据中推导出新的知识或结论的过程</p><h4 id="演绎推理">演绎推理</h4><p>从一般的规则出发，推到处特定的结论</p><p>只要前提是真的，演绎推理的结论必然为真</p><p>演绎推理的有效性取决于推理过程的正确性</p><h4 id="归纳推理">归纳推理</h4><p>从具体的实例中总结出一般性的结论</p><p>归纳推理得出的结论不一定是真的，而是具有概率性</p><p>归纳推理的强度在于结论是否适当考虑了前提的范围和局限性</p><p>强归纳论证更可信，因为它提供了一个合理且更为可能正确的推论</p><h3 id="专家系统">专家系统</h3><p>专家系统根据用户要求，使用推理规则从知识库中提取知识，进而提供像人类专家一样的决策来解决复杂问题</p><h4 id="构成">构成</h4><ul><li>知识库 存储从特定领域的不同专家出获得的知识的数据库</li><li>推理系统 主要处理单元，使用知识库中的知识来推导结论</li><li>用户界面</li></ul><h4 id="工作流程">工作流程</h4><p>以疾病诊断为例</p><ol type="1"><li>专家系统从专家处获得专业知识。例如，专门从事医学领域的人类专家提供有关该领域的原因、症状和其他知识的信息</li><li>知识库更新</li></ol><h4 id="推理方式">推理方式</h4><h5 id="正向链接">正向链接</h5><p>从已有的事实和规则开始，应用推理规则将结论添加到已知事实中</p><p>主要用于预测未来可能出现的结果</p><h5 id="反向链接">反向链接</h5><p>从目标开始，然后逆向进行，寻找支持该目标的事实和规则</p><h3 id="搜索策略">搜索策略</h3><p>搜索是指根据问题的实际情况寻找可利用的知识，从而勾走一条合适的推理路线，使问题得到解决的过程</p><p>搜索中需要解决的基本问题</p><ol type="1"><li>是否一定能找到一个解</li><li>找到的解是否为最佳解</li><li>搜索过程的时间与空间复杂性如何</li><li>搜索过程是否能终止运行或是否回陷入一个死循环</li></ol><h4 id="搜索策略-1">搜索策略</h4><p>常见的</p><ol type="1"><li>启发式搜索</li><li>无信息搜索</li><li>局部搜索</li><li>对抗性搜索</li></ol><h5 id="无信息搜索">无信息搜索</h5><p>一类通用的搜索算法</p><p>以暴力搜索的方式运行</p><p>也被称为盲目搜索</p><h6id="广度优先搜索breadth-first-search-bfs">广度优先搜索（Breadth-FirstSearch, BFS）</h6><p>使用队列进行管理遍历节点的顺序，每次从队列头部取出节点进行扩展，并将其子节点添加到队列尾部</p><h6 id="深度优先搜索depth-first-search-dfs">深度优先搜索（Depth-FirstSearch, DFS）</h6><p>使用栈进行管理遍历节点的顺序，每次从栈顶取出节点进行扩展，并将其子节点添加到栈顶</p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>专业课程</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路理论</title>
    <link href="/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%94%B5%E8%B7%AF/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"/>
    <url>/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%94%B5%E8%B7%AF/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="电路理论">电路理论</h1><h2 id="基本概念和基本规律">基本概念和基本规律</h2><h3 id="电路和电路模型">电路和电路模型</h3><h4 id="实际电路与电路模型">实际电路与电路模型</h4><p>电路：由电的器件相互联接所构成的电流的通路复杂的电路又称<strong>网络</strong></p><ul><li>实际电路在数学上难以精确描述</li><li>在电路理论中通过对实际电路进行建模来研究，称为<strong>电路（模型）</strong></li></ul><h5 id="实际电路的符号表示">实际电路的符号表示</h5><p>在电路理论中将电阻器、电容器、灯泡、晶体管、变压器等实际器件用理想的模型符号表示</p><p><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509161514892.png" /></p><h5 id="电路模型图">电路模型图</h5><p>将实际电路中各个部件用其模型符号表示而画出的图形，也简称为电路</p><h4 id="集中参数电路">集中参数电路</h4><p>集中参数元件：当实际电路的尺寸远小于其使用时电磁量的最高工作频率所对应的波长时，可以不必考虑电磁量的空间分布，相应的电路元件称为<strong>集中参数元件</strong></p><p>集中参数电路：由集中参数元件组成的电路集中参数电路可以看成电磁空间的一个点，电路变量是时间的函数</p><p>分布参数电路：电路变量是时间、空间的函数</p><p>我们在分析分布参数电路时，可以将其拆分为多个集中参数电路来分析</p><h5 id="满足集中化条件的电路的性质">满足集中化条件的电路的性质</h5><ol type="1"><li><span class="math inline">\(\forallt\)</span>，流入二端集中参数元件任一端的电流等于从另一端流出的电流，且该元件两个端点上的电位均为确定值（对选定的基准点或称参考点而言）</li><li><span class="math inline">\(\forallt\)</span>，流入多端集中参数元件任一端点的电流等于从其他端点流出电流之和，且其任一端点上的电位均为确定值（对选定的基准点而言）</li></ol><h3 id="电路变量">电路变量</h3><p>电路分析中最常用的电路变量为电流、电压及功率</p><h4 id="电流及其参考方向">电流及其参考方向</h4><h5 id="电流">电流</h5><p>电流即电流强度</p><p><span class="math display">\[i(t)=\frac{\mathrm{d}q}{\mathrm{d}t}\]</span></p><p>直流：若 <span class="math inline">\(i(t)\)</span>恒为常数，称为恒定（直流）电流，常用 <spanclass="math inline">\(I\)</span> 表示</p><ul><li>广义的直流指的是单向流动的电流</li></ul><p>单位：安培 <span class="math inline">\(A\)</span>，<spanclass="math inline">\(1A = 1C/s\)</span></p><h5 id="电流参考方向">电流参考方向</h5><p>实际方向：正电荷运动的方向</p><p>参考方向：假定为正电荷运动的方向</p><p>我们规定：若两者方向一致，电流为正，反之电流为负</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509181637685.png"alt="正电流" /><figcaption aria-hidden="true">正电流</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509181637170.png"alt="负电流" /><figcaption aria-hidden="true">负电流</figcaption></figure><h4 id="电压及其参考方向">电压及其参考方向</h4><p>电压是电路之中两点的电位差，用 <span class="math inline">\(u\)</span>表示</p><p><span class="math display">\[u(t)=\frac{\mathrm{d}w}{\mathrm{q}}\]</span></p><p>单位为伏特 <span class="math inline">\(V\)</span>，<spanclass="math inline">\(1V=1J/C\)</span></p><p>电压的实际方向为电位实际降低的方向电压的参考方向为电位假定降低的方向</p><p>关联参考方向：电流的流向是从电压的“+”极流向 “-” 极为关联参考方向</p><h4 id="功率和能量">功率和能量</h4><p>定义：电场力做功的速率，取关联参考方向，一段支路吸收的功率为</p><p><span class="math display">\[p = \frac{\mathrm{d}w}{\mathrm{d}t}=\frac{\mathrm{d}w}{\mathrm{d}q}\cdot\frac{\mathrm{d}q}{\mathrm{d}t}=u\cdot i\]</span></p><p>非关联参考方向时</p><p><span class="math display">\[p = -u\cdot i\]</span></p><p>功率是标量</p><ul><li><span class="math inline">\(p&gt;0\)</span>，支路吸收功率</li><li><span class="math inline">\(p&lt;0\)</span>，支路输出功率</li></ul><p>这里的吸收和输出是相对于电路中的正电荷而言的</p><h3 id="拓扑约束关系">拓扑约束关系</h3><h4 id="图论基础知识">图论基础知识</h4><h5 id="图">图</h5><ul><li>一组节点和一组支路的集合，且每条支路的两端终止在两个节点上网络图通常用符号G 记之</li><li>画图：将网络转化为图时，将支路用线段表示，支路间的连接用点表示</li></ul><h6 id="连通图">连通图</h6><p>在图 G中的任意两节点之间至少存在一条由支路构成的路径，则称该图为连通图，否则为非连通图</p><h6 id="有向图">有向图</h6><p>图中的每一条支路规定一个方向所得到的图</p><h6 id="子图">子图</h6><p>设有一图 <span class="math inline">\(G\)</span>，又有一图 <spanclass="math inline">\(G_i\)</span>，其每个节点都是 <spanclass="math inline">\(G\)</span> 中的节点，每条支路是 <spanclass="math inline">\(G\)</span> 中的支路，则称 <spanclass="math inline">\(G_i\)</span> 是 <spanclass="math inline">\(G\)</span> 的子图</p><h6 id="回路">回路</h6><p>回路是一条闭合的路经图 <span class="math inline">\(G\)</span> 的子图<span class="math inline">\(G_1\)</span> 是回路，则有</p><ol type="1"><li><span class="math inline">\(G_1\)</span> 是联通的</li><li><span class="math inline">\(G_1\)</span>中与每个节点关联的支路数都是 <span class="math inline">\(2\)</span></li></ol><h6 id="网孔">网孔</h6><p>网孔是图中不包含其他回路的最小回路</p><h6 id="树">树</h6><p>树是图的一个子图，满足</p><ol type="1"><li>包含图中所有节点</li><li>是联通的</li><li>不包含回路</li></ol><p>构成树的各支路称为树支，数量为 <spanclass="math inline">\(N-1\)</span>，其中 <spanclass="math inline">\(N\)</span> 为图中节点数</p><p>其余的支路为连支</p><p>连支的集合为余树或者补树</p><h6 id="基本回路">基本回路</h6><p>在图 <span class="math inline">\(G\)</span> 中，任选一棵树 <spanclass="math inline">\(T\)</span>，则每一条连枝与树 <spanclass="math inline">\(T\)</span>中的某些树支一起构成一个回路，这个回路称为<strong>基本回路</strong></p><p>基本回路数 <span class="math inline">\(=b-n+1\)</span>，其中 <spanclass="math inline">\(b\)</span> 为图中支路数，<spanclass="math inline">\(n\)</span> 为图中节点数</p><h6 id="平面图">平面图</h6><p><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509182234452.png" /></p><p>设一图 <spanclass="math inline">\(G\)</span>，若将其花在平面上，且各支路仅在节点处相交，则称该图为平面图</p><details closed><summary>看看 Gemimi 给出的解释？</summary><p><strong>生成树的概念</strong></p><p>我们将图想象为一个地图，地图上有多个村庄（节点）</p><p>现在，想象一下你要为这张城市地图规划一个紧急电话网络，你需要用最少的电话线连接所有的城市，并且不能形成任何的闭合环路（否则会造成信号干扰）这个只包含必要线路、连接了所有城市且没有环路的网络，就是这张图的一棵“生成树”</p><p><strong>什么是基本回路？</strong></p><p>理解了生成树之后，基本回路就很容易明白了</p><ol><li><strong>选择一棵生成树</strong>：对于一个图，我们先选定一棵生成树。这棵树连接了所有的顶点，但自身没有任何环路</li><li><strong>添加“冗余”的边</strong>：图中除了生成树包含的边之外，通常还会有一些其他的“冗余”边</li><li><strong>形成唯一的环路</strong>：当你从这些“冗余”边中任意选择一条，并把它添加回生成树中时，必然会形成一个且仅有一个闭合的环路</li></details><h6 id="割集和基本割集">割集和基本割集</h6><p><a href="https://www.cnblogs.com/orzlsw/p/18561798">相关资料</a></p><p>连通图 <span class="math inline">\(G\)</span>的割集是一组不包括节点的支路集合，其满足</p><ol type="1"><li>若移去该集的所有支路，则 G 成为两个独立的部分</li><li>若保留其中任一支路不去掉，剩下的图仍是连通的</li></ol><p>基本割集：</p><ul><li>对于任意连通图 <spanclass="math inline">\(G\)</span>，选定一个树，将仅包含一条树支的割集称为基本割集</li><li>基本割集数为 <span class="math inline">\(𝑛−1\)</span></li></ul><details><summary>看看 Gemimi 给出的解释？</summary><p><strong>什么是割集？</strong></p><p>想象一下，为了进行道路维护，你需要临时封闭一些道路，目的是把一个由村庄和道路组成的网络<b>分割成两个独立的区域</b>，让这两个区域的村民暂时无法互相往来</p><p><b>割集</b>就是能达到这个目的的一组道路这组道路需要满足两个条件：</p><ol><li><b>分割网络</b>：当你封闭了这组道路后，整个网络被分成了两个部分</li><li><b>最小性</b>：在这组封闭的道路里，任何一条道路重新开放，都会让这两个区域重新连接起来也就是说，你封闭的道路数量不多不少，恰好能完成分割任务</li></ol><p><b>通俗比喻：</b><br>假设你要把村庄分成“山南”和“山北”两个区域所有直接连接山南和山北的道路集合，就是一个割集移走这个集合里的所有道路，两个区域就彻底分开了但只要有一条路没被移走，两个区域之间就还能通行</p><hr><p><strong>什么是基本割集？</strong><p>要理解基本割集，我们首先需要一个“骨干网络”的概念，在图论里，这叫做<b>“生成树”(Spanning Tree)</b></p><ul><li><b>生成树</b>：你可以把它想象成连接所有村庄的<b>最核心、<a title="这个似乎是最小生成树的概念？编者注">最经济</a></b>的道路网络这个网络能确保每个村庄都能到达其他任何村庄，但又<b>没有任何多余的环路</b>那些不属于这个骨干网络的道路，我们可以称之为“乡间小道”（在图论里叫<b>弦</b>）</li></ul><p>现在，<b>基本割集</b>就是一种特殊的割集，它是<b>围绕骨干网络的一条核心道路</b>来定义的它的构成如下：</p><ul><li>从你的“骨干网络”（生成树）里，<b>任选一条核心道路</b></li><li>这个基本割集就由这条<b>核心道路</b>和所有能够<b>“跨接”</b>这条核心道路被切断后所形成的两个区域的<b>“乡间小道”</b>（弦）组成</li></ul><p><b>通俗比喻：</b></p><ol><li>你先规划出一个连接所有村庄的骨干路网（生成树），确保没有环路</li><li>现在，你选择骨干路网中的<b>一条路</b>（比如连接村A和村B的主干道）进行封闭</li><li>这一下，村庄网络被分成了两部分（一部分包含村A，另一部分包含村B）</li><li>除了你刚才封闭的那条主干道，可能还有一些“乡间小道”也连接着这两部分</li><li>那么，<b>刚才那条主干道</b> +<b>所有连接这两部分的乡间小道</b>，就共同组成了一个“基本割集”</li></ol><p>这个基本割集的特点是，它<b>有且仅有一条来自骨干网络的道路</b></p><hr><strong>两者总结与区别</strong><table border="1" style="width:100%; border-collapse: collapse;"><thead><tr><th style="padding: 8px; text-align: left; background-color: #f2f2f2;">特性</th><th style="padding: 8px; text-align: left; background-color: #f2f2f2;">割集 (Cut Set)</th><th style="padding: 8px; text-align: left; background-color: #f2f2f2;">基本割集 (Fundamental Cut Set)</th></tr></thead><tbody><tr><td style="padding: 8px;"><b>定义</b></td><td style="padding: 8px;">任何能将网络分成两部分，且自身是最小的道路集合</td><td style="padding: 8px;">一种特殊的割集，它与一个预先定义的“骨干网络”（生成树）相关</td></tr><tr><td style="padding: 8px;"><b>核心</b></td><td style="padding: 8px;">重点在于“<b>分割</b>”这个行为本身</td><td style="padding: 8px;">重点在于“<b>基于一条骨干道路</b>”的分割</td></tr><tr><td style="padding: 8px;"><b>数量</b></td><td style="padding: 8px;">一个网络中可以有很多个不同的割集</td><td style="padding: 8px;">数量是确定的，等于你“骨干网络”里道路的数量每一条骨干道路都对应一个唯一的基本割集</td></tr></tbody></table><p>总而言之，<b>割集</b>是一个更宽泛的概念，就像是说“所有能把村庄分开的封路方案”，而<b>基本割集</b>是一系列更具体、更有规律的“封路方案”，这些方案都是围绕着一个核心的骨干路网来制定的</p></details><p>基本割集是单树枝割集，也就是说给定了树的前提下，任何一个基本割集的组成都为一条树支和若干连枝，将树分为互不连通的两部分；确定了删除的树支后所得到的割集是一定的</p><p>基本割集能够保证所取剩下的两块区域都是联通的</p><h4 id="基尔霍夫定律">基尔霍夫定律</h4><h5 id="基尔霍夫电流定律kcl">基尔霍夫电流定律（KCL）</h5><p>对于集总电路的任一节点，在任一时刻流入该节点的电流之和等于流出该节点的电流之和</p><p><span class="math display">\[\sum i(t)=0\]</span></p><p>对电路的任一割集，KCL 也成立</p><p>对于电路的任意闭合面，KCL 也成立</p><h5 id="基尔霍夫电压定律kvl">基尔霍夫电压定律（KVL）</h5><p>对于集总电路的任一回路，在任一时刻，沿回路的各支路电压的代数和为<span class="math inline">\(0\)</span></p><p><span class="math display">\[\sum u(t)=0\]</span></p><h5 id="图论在基尔霍夫定律中的应用">图论在基尔霍夫定律中的应用</h5><p>对于节点数为 <span class="math inline">\(n\)</span>，支路数为 <spanclass="math inline">\(b\)</span> 的电路，有</p><ol type="1"><li>独立的 KCL 方程数为 <spanclass="math inline">\(n-1\)</span>，即为基本割集数</li><li>独立的 KVL 方程数为 <spanclass="math inline">\(b-n+1\)</span>，即为基本回路数</li><li>总的独立方程数为 <spanclass="math inline">\(b\)</span>，等于支路数</li></ol><h5 id="电路方程的独立性和完备性">电路方程的独立性和完备性</h5><h6 id="两类约束">两类约束</h6><ul><li><p>拓扑约束 取决于元件的相互连接方式</p><ul><li>节点电流受 KCL 约束</li><li>回路电压受 KVL 约束</li></ul></li><li><p>元件约束 取决于元件本身的特性 对于有 <spanclass="math inline">\(b\)</span> 条支路的电路，共有 <spanclass="math inline">\(2b\)</span> 个电压、电流变量</p><ul><li>VCR 可以得到 <span class="math inline">\(b\)</span> 个方程</li><li>KCL 和 KVL 可以得到 <span class="math inline">\(b\)</span>个方程</li></ul></li></ul><h4id="关联矩阵和基尔霍夫定律的矩阵形式">关联矩阵和基尔霍夫定律的矩阵形式</h4><h5 id="关联矩阵">关联矩阵</h5><p>描述电路节点对支路的关联关系的矩阵，为 一个 <spanclass="math inline">\(n \times b\)</span> 矩阵，记为 <spanclass="math inline">\(A_a\)</span></p><p>其中</p><p><span class="math display">\[a_{ik}=\left\{    \begin{aligned}        &amp;1,&amp;&amp; \text{节点} n_i \text{支路} b_k\text{关联，且电流流出节点} n_i \\        &amp;-1,&amp;&amp; \text{节点} n_i \text{支路} b_k\text{关联，且电流流入节点} n_i \\        &amp;0,&amp;&amp; \text{节点} n_i \text{支路} b_k \text{不关联}    \end{aligned}\right.\]</span></p><p>举例，下图的关联矩阵为</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509231617221.png"alt="一个电路举例" /><figcaption aria-hidden="true">一个电路举例</figcaption></figure><p><span class="math display">\[A_a=\begin{bmatrix}1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 \\-1 &amp; 0 &amp; -1 &amp; 0 &amp; -1\end{bmatrix}\]</span></p><p>可以看出，行对应的是节点，列对应的是支路</p><ul><li><span class="math inline">\(a_{11}=1\)</span>，支路 <spanclass="math inline">\(1\)</span> 流出节点 <spanclass="math inline">\(1\)</span></li><li><span class="math inline">\(a_{34}=-1\)</span>，支路 <spanclass="math inline">\(4\)</span> 流入节点 <spanclass="math inline">\(3\)</span></li><li><span class="math inline">\(a_{25}=0\)</span>，支路 <spanclass="math inline">\(5\)</span> 不关联节点 <spanclass="math inline">\(2\)</span></li></ul><h5 id="基尔霍夫定律的矩阵形式">基尔霍夫定律的矩阵形式</h5><h6 id="kcl-的矩阵形式">KCL 的矩阵形式</h6><p><span class="math display">\[A_ai_b=0\]</span></p><p>其中 <span class="math inline">\(i_b\)</span>为支路电流列向量，为一个 <span class="math inline">\(b \times 1\)</span>矩阵</p><p>矩阵 <span class="math inline">\(A_a\)</span> 的秩为 <spanclass="math inline">\(n-1\)</span>，即为基本割集数，所以我们将上述 KCL方程划掉一个，可以得到线性独立的 KCL 方程组，和线性独立的关联矩阵</p><p>我们计划掉任意一行后的矩阵为 <spanclass="math inline">\(A\)</span>，称为降阶关联矩阵</p><h6 id="kvl-的矩阵形式">KVL 的矩阵形式</h6><p>我们在上图中取节点 <span class="math inline">\(4\)</span>为参考节点，设 <span class="math inline">\(u_{n_1}\)</span>、<spanclass="math inline">\(u_{n_2}\)</span>、<spanclass="math inline">\(u_{n_3}\)</span> 为其他节点电位，<spanclass="math inline">\(u_1\)</span>、<spanclass="math inline">\(u_2\)</span>、<spanclass="math inline">\(u_3\)</span>、<spanclass="math inline">\(u_4\)</span>、<spanclass="math inline">\(u_5\)</span> 为各支路电压，则</p><p><span class="math display">\[\left\{    \begin{aligned}        &amp;u_1 = u_{n_1} - 0 \\        &amp;u_2 = u_{n_1} - u_{n_2} \\        &amp;u_3 = u_{n_2} - 0 \\        &amp;u_4 = u_{n_2} - u_{n_3} \\        &amp;u_5 = u_{n_3} - 0    \end{aligned}\right.\]</span></p><p>写成矩阵的形式</p><p><span class="math display">\[\begin{bmatrix}u_1 \\u_2 \\u_3 \\u_4 \\u_5\end{bmatrix}=\begin{bmatrix}1 &amp; 0 &amp; 0 \\1 &amp; -1 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; -1 \\0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}u_{n_1} \\u_{n_2} \\u_{n_3}\end{bmatrix}\]</span></p><p>即</p><p><span class="math display">\[u_b = A^Tu_n\]</span></p><p><span class="math inline">\(A^T\)</span> 为删除节点 <spanclass="math inline">\(4\)</span> 得到的降阶关联矩阵的转置</p><h4 id="特勒根定律">特勒根定律</h4><h5 id="形式一功率定理">形式一（功率定理）</h5><p>设集总电路有 <span class="math inline">\(b\)</span> 个元件，<spanclass="math inline">\(n\)</span> 个节点，并设 <spanclass="math inline">\(u_1\)</span>, <spanclass="math inline">\(u_2\)</span>,…, <spanclass="math inline">\(u_b\)</span> 和 <spanclass="math inline">\(i_1\)</span>, <spanclass="math inline">\(i_2\)</span>,…, <spanclass="math inline">\(i_b\)</span> 为满足 KCL 和 KVL的支路电压和电流，各元件的电压、电流为关联参考方向，则</p><p><span class="math display">\[\sum_{k=1}^b u_ki_k = 0\]</span></p><p>电路各元件吸收功率的代数和为 <spanclass="math inline">\(0\)</span>，即功率守恒</p><h5 id="形式二似功率定理">形式二（似功率定理）</h5><p>设两个结构完全相同的集总电路，它们有 <spanclass="math inline">\(b\)</span> 个元件，<spanclass="math inline">\(n\)</span> 个节点，并设 <spanclass="math inline">\(u_1\)</span>, <spanclass="math inline">\(u_2\)</span>,…, <spanclass="math inline">\(u_b\)</span> 和 <spanclass="math inline">\(i_1\)</span>, <spanclass="math inline">\(i_2\)</span>,…, <spanclass="math inline">\(i_b\)</span> 为第一个电路的支路电压和电流，<spanclass="math inline">\(\hat{u}_1\)</span>, <spanclass="math inline">\(\hat{u}_2\)</span>,…, <spanclass="math inline">\(\hat{u}_b\)</span> 和 <spanclass="math inline">\(\hat{i}_1\)</span>, <spanclass="math inline">\(\hat{i}_2\)</span>,…, <spanclass="math inline">\(\hat{i}_b\)</span>为第二个电路的支路电压和电流，各元件的电压、电流为关联参考方向，则</p><p><span class="math display">\[\begin{aligned}    &amp; \sum_{k=1}^b u_k(t) \hat{i}_k(t)  = 0 \\    &amp; \sum_{k=1}^b u_k(t) \hat{i}_k(t)  = 0 \\    &amp; \sum_{k=1}^b u_k(t_1) i_k(t_2)  = 0\end{aligned}\]</span></p><h3 id="元件约束关系">元件约束关系</h3><p>基本电路变量</p><ul><li>电压 <span class="math inline">\(u\)</span></li><li>电流 <span class="math inline">\(i\)</span></li><li>电荷 <span class="math inline">\(q\)</span></li><li>磁链（或者叫磁通量？） <spanclass="math inline">\(\psi\)</span></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509232012869.png"alt="基本电路变量之间的转化关系图" /><figcaption aria-hidden="true">基本电路变量之间的转化关系图</figcaption></figure><p>在四个基本变量中任意取两个互相转换可以得到六种关系</p><ul><li><span class="math inline">\(\displaystylei=\frac{\mathrm{d}q}{\mathrm{d}t}\)</span></li><li><span class="math inline">\(\displaystyleu=\frac{\mathrm{d}\psi}{\mathrm{d}t}\)</span></li><li><span class="math inline">\(\displaystyle u=iR\)</span></li><li><span class="math inline">\(\displaystyle q=C u\)</span></li><li><span class="math inline">\(\displaystyle \psi=Li\)</span></li><li><span class="math inline">\(\displaystyle \psi=qM\)</span></li></ul><p>其中直接关联电荷和磁链的第四类无源电路元件被称为忆阻元件</p><h4 id="电阻元件">电阻元件</h4><p>一个二端元件，若 <span class="math inline">\(\forallt\)</span>，其电压电流关系（Voltage Current Relation, VCR）可唯一地用<span class="math inline">\(u-i\)</span>平面上的一条曲线表示出来，该二端元件称为<strong>电阻元件</strong></p><p>由欧姆定律 <span class="math inline">\(u(t)=Ri(t)\)</span> 或者 <spanclass="math inline">\(i(t)=Gu(t)\)</span> 定义的电阻元件称为线性电阻</p><p>电阻 <span class="math inline">\(R\)</span> 的单位为欧姆 <spanclass="math inline">\(\Omega\)</span>，<spanclass="math inline">\(1\Omega = 1V/A\)</span></p><p>电导 <span class="math inline">\(G\)</span> 的单位为西门子 <spanclass="math inline">\(S\)</span>，<span class="math inline">\(1S =1\Omega^{-1}\)</span></p><p>对于非线性电阻元件，其 VCR 为非线性曲线</p><p><span class="math display">\[\left\{    \begin{aligned}        u(t) &amp;= f(i(t)) \\        i(t) &amp;= g(u(t))    \end{aligned}\right.\]</span></p><p>非线性电阻元件的电阻有<strong>静态电阻</strong>和<strong>动态电阻</strong>两种</p><p>我们可以将非线性电阻的 VCR 处理得到方程</p><p><span class="math display">\[h(u,i)=0\]</span></p><p>对其作 <span class="math inline">\(t\)</span> 的微分可以得到</p><p><span class="math display">\[\left\{    \begin{aligned}        R=\frac{u}{i}\\        R_d=\frac{\mathrm{d}u}{\mathrm{d}i}    \end{aligned}\right.\]</span></p><h4 id="独立电源">独立电源</h4><p>独立电源简称为电源，是电路能量的提供者。特点是端电压或电流不受其他电压或电流的影响</p><h5 id="电压源">电压源</h5><p>为二端元件，其两端电压保持一定的时间函数 <spanclass="math inline">\(u=u_s\)</span>，称为理想电压源，简称电压源</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509232042644.png"alt="电压源符号" /><figcaption aria-hidden="true">电压源符号</figcaption></figure><p>电压源不可以被看作是一个非线性电阻，其电压是定值但是电流是可以变化的，即<span class="math inline">\(i\)</span> 可以为任意值</p><p>电压源技术上是可以短路的，但是千万不要这样做</p><h5 id="电流源">电流源</h5><p>为二端元件，其两端电流保持一定的时间函数 <spanclass="math inline">\(i=i_s\)</span>，称为理想电流源，简称电流源</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509232043602.png"alt="电流源符号" /><figcaption aria-hidden="true">电流源符号</figcaption></figure><p>电流源是可以被看作是一个非线性电阻，其电流是定值但是电压是可以变化的，我们找到了一个<span class="math inline">\(u\)</span> 时也能确定一个 <spanclass="math inline">\(i\)</span></p><h5 id="几种典型的独立源信号波形">几种典型的独立源信号波形</h5><h6 id="单位越阶函数-epsilont">单位越阶函数 <spanclass="math inline">\(\epsilon(t)\)</span></h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281441930.png"alt="单位越阶函数" /><figcaption aria-hidden="true">单位越阶函数</figcaption></figure><p><span class="math display">\[\epsilon(t)=\left\{    \begin{aligned}        &amp;0,&amp;&amp; t&lt;0 \\        &amp;1,&amp;&amp; t&gt;0    \end{aligned}\right.\]</span></p><p><strong>延时单位越阶函数</strong></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281441692.png"alt="延时单位越阶函数" /><figcaption aria-hidden="true">延时单位越阶函数</figcaption></figure><p><span class="math display">\[\epsilon(t-t_0)=\left\{    \begin{aligned}        &amp;0,&amp;&amp; t&lt;t_0 \\        &amp;1,&amp;&amp; t&gt;t_0    \end{aligned}\right.\]</span></p><h6 id="单位冲激函数-deltat">单位冲激函数 <spanclass="math inline">\(\delta(t)\)</span></h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281449832.png"alt="狄拉克函数" /><figcaption aria-hidden="true">狄拉克函数</figcaption></figure><p><span class="math display">\[\delta(t)=\left\{    \begin{aligned}        &amp;\delta(t)=0\quad,t \neq 0 \\        &amp;\int_{-\infty}^{+\infty} \delta(t) \mathrm{d}t = 1    \end{aligned}\right.\]</span></p><h6 id="正弦波形">正弦波形</h6><p><span class="math display">\[f(t)=A_m \sin(\omega t + \varphi)\]</span></p><h4 id="受控源">受控源</h4><p>为了电路分析方便，我们构建了受控源元件，包含了两条分路，即控制分录和受控分路，受控分路的电压或电流由控制分路的电压或电流决定</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281639037.png"alt="ccvs 和 vcvs" /><figcaption aria-hidden="true">ccvs 和 vcvs</figcaption></figure><p>上图中的两个图例</p><ul><li>第一个图例中电阻的电压由电流控制 <spanclass="math inline">\(u=Ri\)</span></li><li>第二个图例中电阻的电压由另一个电阻的电压控制 <spanclass="math inline">\(u=\frac{R}{r}u_1\)</span></li></ul><p>根据控制量和被控量的不同，我们将控制源分为四种</p><ul><li>电压控制的电压源（Violtage Controlled Voltage Source, VCVS）</li><li>电压控制的电流源（Violtage Controlled Current Source, VCCS）</li><li>电流控制的电压源（Current Controlled Voltage Source, CCVS）</li><li>电流控制的电流源（Current Controlled Current Source, CCCS）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281648696.png"alt="四种控制源" /><figcaption aria-hidden="true">四种控制源</figcaption></figure><h4 id="运算放大器">运算放大器</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301603886.png"alt="符号" /><figcaption aria-hidden="true">符号</figcaption></figure><h5 id="符号">符号</h5><h6 id="反相输入端">反相输入端</h6><p>当输入 <span class="math inline">\(u_-\)</span>单独加于该端时，输入电压和输出电压反相</p><h6 id="同相输入端">同相输入端</h6><p>当输入 <span class="math inline">\(u_+\)</span>单独加于该端时，输入电压和输出电压同相</p><h6 id="开环增益放大倍数">开环增益（放大倍数）</h6><p>输出电压 <spanclass="math inline">\(u_0=Au_i=A(u_+-u_-)\)</span>，其中 <spanclass="math inline">\(A\)</span> 为开环增益，<spanclass="math inline">\(u_i\)</span> 为输入电压</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509282039348.png"alt="运算放大器的电路符号" /><figcaption aria-hidden="true">运算放大器的电路符号</figcaption></figure><h5 id="输入输出特征">输入输出特征</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301607505.png"alt="输入输出特性图" /><figcaption aria-hidden="true">输入输出特性图</figcaption></figure><p>运算放大器的输入输出特性图分为两个区域</p><ol type="1"><li><p>线性区</p><p><span class="math display">\[u_0 = Au_i=A(u_+-u_-)\]</span></p></li><li><p>饱和区(非线性区)</p><p><span class="math display">\[u_0 = \pm U_{0(sat)}\]</span></p></li></ol><h5 id="电路模型">电路模型</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301610913.png"alt="运算放大器电路模型" /><figcaption aria-hidden="true">运算放大器电路模型</figcaption></figure><p><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301611130.png" /></p><h5 id="理想运算放大器">理想运算放大器</h5><p>理想运算放大器满足以下条件</p><ol type="1"><li>开环增益 <span class="math inline">\(A \to \infty\)</span></li><li>输入电阻 <span class="math inline">\(R_i \to \infty\)</span></li><li>输出电阻 <span class="math inline">\(R_o = 0\)</span></li></ol><h5 id="输入输出特性">输入输出特性</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301612676.png"alt="理想运算放大器的输入输出特性图" /><figcaptionaria-hidden="true">理想运算放大器的输入输出特性图</figcaption></figure><h5 id="运算特性">运算特性</h5><ol type="1"><li><p>虚断路</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301616439.png"alt="虚断路" /><figcaption aria-hidden="true">虚断路</figcaption></figure><p>我们认为理想运算放大器的输入端电流为 <spanclass="math inline">\(0\)</span>，即 <span class="math inline">\(i_+ =i_-\approx 0\)</span></p></li><li><p>虚短路</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509301615439.png"alt="虚短路" /><figcaption aria-hidden="true">虚短路</figcaption></figure><p>我们认为理想运算放大器的两个输入端电压相等，即 <spanclass="math inline">\(u_+ = u_-\)</span></p></li></ol><h4 id="理想变压器">理想变压器</h4><p>理想变压器是实际变压器的理想化模型，是双口元件</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121351055.png"alt="理想变压器符号" /><figcaption aria-hidden="true">理想变压器符号</figcaption></figure><p>其电压电流关系为</p><p><span class="math display">\[\left\{    \begin{aligned}        &amp;u_1=nu_2\\        &amp;i_1=-\frac{1}{n}i_2    \end{aligned}\right.\]</span></p><ul><li><span class="math inline">\(n\)</span> 为变比，<spanclass="math inline">\(n=\frac{N_1}{N_2}\)</span></li></ul><p>当同名端颠倒时</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121359212.png"alt="同名端颠倒的理想变压器" /><figcaption aria-hidden="true">同名端颠倒的理想变压器</figcaption></figure><p><span class="math display">\[\left\{    \begin{aligned}        &amp;u_1=-nu_2\\        &amp;i_1=\frac{1}{n}i_2    \end{aligned}\right.\]</span></p><h5 id="等效模型">等效模型</h5><p>理想变压器可以用受控电源组成的模型来表示</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121415625.png"alt="理想变压器的等效模型" /><figcaption aria-hidden="true">理想变压器的等效模型</figcaption></figure><h5 id="功率">功率</h5><p>理想变压器时无源元件，它既不储存能量也不消耗能量</p><p><span class="math display">\[p=u_1i_1+u_2i_2=nu_2 \cdot \left(-\frac{1}{n}i_2\right)+u_2i_2=0\]</span></p><h5 id="阻抗变换性质">阻抗变换性质</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121422226.png"alt="阻抗变换图" /><figcaption aria-hidden="true">阻抗变换图</figcaption></figure><p>输出端有一电阻 <spanclass="math inline">\(R_L\)</span>，则输入端的等效电阻为</p><p><span class="math display">\[R_{in}=n^2R_L\]</span></p><p>证明：</p><p><span class="math display">\[\begin{aligned}    &amp;u_2&amp;&amp; =-R_Li_2\\    &amp;u_1&amp;&amp; =-nU_2\\        &amp;  &amp;&amp; =nR_Li_2\\        &amp;  &amp;&amp; =nR_L(ni_1)\\        &amp;  &amp;&amp; =n^2R_Li_1\end{aligned}\]</span></p><h4 id="负回转器">负回转器</h4><p>负回转器时一种双口元件，分为电流反向负回转器（INC）和电压反向负回转器（VNC）</p><h5 id="符号和外特性">符号和外特性</h5><h6 id="电流反向负回转器">电流反向负回转器</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121436901.png"alt="电流反向负回转器符号" /><figcaption aria-hidden="true">电流反向负回转器符号</figcaption></figure><p><span class="math display">\[\left\{    \begin{aligned}        &amp;i_1=i_2\\        &amp;u_1=u_2    \end{aligned}\right.\]</span></p><ul><li>输出电流方向与输入电流方向相反</li><li>输出电压极性与输入电压极性相同</li></ul><h6 id="电压反向负回转器">电压反向负回转器</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121438101.png"alt="电压反向负回转器符号" /><figcaption aria-hidden="true">电压反向负回转器符号</figcaption></figure><p><span class="math display">\[\left\{\begin{aligned}&amp;i_1=-i_2\\&amp;u_1=-u_2\end{aligned}\right.\]</span></p><ul><li>输出电流方向与输入电流方向相同</li><li>输出电压极性与输入电压极性相反</li></ul><h5 id="等效模型-1">等效模型</h5><p>我们可以分别使用 CCCS 和 VCVS 来表示 INC 和 VNC</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121454488.png"alt="INC 和 VNC 的等效模型" /><figcaption aria-hidden="true">INC 和 VNC 的等效模型</figcaption></figure><h5 id="负转换性">负转换性</h5><p>INC 在输出端中有一电阻 <spanclass="math inline">\(R_L\)</span>，则输入端的等效电阻为</p><p><span class="math display">\[R_{in}=-R_L\]</span></p><p>证明：</p><p><span class="math display">\[u_1=u_2=-i_2R_L=-i_1R_L\]</span></p><p>VNC 在输出端中有一电阻 <spanclass="math inline">\(R_L\)</span>，则输入端的等效电阻为</p><p><span class="math display">\[R_{in}=-R_L\]</span></p><p>证明：</p><p><span class="math display">\[u_1=-u_2=i_2R_L=-i_1R_L\]</span></p><h4 id="理想回转器">理想回转器</h4><p>理想回转器是一个双口元件，能够将一个端口的输入电压回转为另一个端口的输出电流</p><h5 id="符号和外特性-1">符号和外特性</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510121531031.png"alt="理想回转器电路符号" /><figcaption aria-hidden="true">理想回转器电路符号</figcaption></figure><p><span class="math display">\[\left\{    \begin{aligned}        &amp;u_1=-ri_2\\        &amp;u_2=ri_1    \end{aligned}\right.\]</span></p><p>或</p><p><span class="math display">\[\left\{    \begin{aligned}        &amp;i_1=gu_2\\        &amp;i_2=-gu_1    \end{aligned}\right.\]</span></p><ul><li><span class="math inline">\(r\)</span> 为回转比或回转器电阻</li><li><span class="math inline">\(g\)</span> 为回转器电导</li></ul><h4 id="功率-1">功率</h4><p>理想回转器是无源元件</p><p><span class="math display">\[p=u_1i_1+u_2i_2=-ri_2 \cdot gu_2+ri_1 \cdot (-gu_1)=0\]</span></p><h2 id="电路分析的基本方法">电路分析的基本方法</h2><p>根据电路所含的元件的性质将电路分类</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E7%94%B5%E8%B7%AF%E5%88%86%E7%B1%BB.png"alt="电路分类" /><figcaption aria-hidden="true">电路分类</figcaption></figure><h3 id="电路的等效变换">电路的等效变换</h3><h4 id="等效电路的概念">等效电路的概念</h4><p>如果端钮一一对应的 <span class="math inline">\(n\)</span> 端口电路<span class="math inline">\(N_1\)</span> 和 <spanclass="math inline">\(N_2\)</span>具有相同的端口特性，则两者相互等小，互称等效电路</p><p>等效电路具有以下的性质</p><ul><li>外特性相同将相同的两组输入电压或者电流分别接入两个电路，则两个电路的输出电压或者电流相同</li><li>内部不同 两个等效电路的内部结构可以完全不同</li></ul><h4 id="常见的等效电路">常见的等效电路</h4><h5 id="电阻串联">电阻串联</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131640951.png"alt="串联电阻" /><figcaption aria-hidden="true">串联电阻</figcaption></figure><p><span class="math display">\[R=R_1+R_2\]</span></p><h5 id="电阻并联">电阻并联</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131640923.png"alt="并联电阻" /><figcaption aria-hidden="true">并联电阻</figcaption></figure><p><span class="math display">\[G=G_1+G_2\]</span></p><p>或</p><p><span class="math display">\[\frac{1}{R}=\frac{1}{R_1}+\frac{1}{R_2}\]</span></p><h5 id="独立电源串联">独立电源串联</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131644307.png"alt="串联独立电压源" /><figcaption aria-hidden="true">串联独立电压源</figcaption></figure><p><span class="math display">\[u_s=u_{s_1}+u_{s_2}\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131651915.png"alt="串联独立电流源" /><figcaption aria-hidden="true">串联独立电流源</figcaption></figure><p><span class="math display">\[i&#39;_s=i_{s_1}=i_{s_2}\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131658545.png"alt="独立电压源与独立电流源串联" /><figcaption aria-hidden="true">独立电压源与独立电流源串联</figcaption></figure><ul><li><span class="math inline">\(u\)</span> 任意</li><li><span class="math inline">\(i&#39;_s=i_s\)</span></li></ul><h5 id="独立电源并联">独立电源并联</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131700677.png"alt="并联独立电压源" /><figcaption aria-hidden="true">并联独立电压源</figcaption></figure><p><span class="math display">\[u&#39;_s=u_s\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131701575.png"alt="并联独立电流源" /><figcaption aria-hidden="true">并联独立电流源</figcaption></figure><p><span class="math display">\[i_s=i_{s_1}+i_{s_2}\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510131702125.png"alt="独立电压源与独立电流源并联" /><figcaption aria-hidden="true">独立电压源与独立电流源并联</figcaption></figure><ul><li><span class="math inline">\(u&#39;_s=u_s\)</span></li><li><span class="math inline">\(i\)</span> 任意</li></ul>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>电路</tag>
      
      <tag>电路理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>能源化学</title>
    <link href="/2025/09/17/%E6%9C%AC%E7%A7%91/%E5%8C%96%E5%AD%A6/%E8%83%BD%E6%BA%90%E5%8C%96%E5%AD%A6/"/>
    <url>/2025/09/17/%E6%9C%AC%E7%A7%91/%E5%8C%96%E5%AD%A6/%E8%83%BD%E6%BA%90%E5%8C%96%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="能源化学">能源化学</h1><h2 id="能源结构化学">能源结构化学</h2><h3 id="原子的结构和排列">原子的结构和排列</h3><h4 id="原子半径与离子半径">原子半径与离子半径</h4><p>根据波动力学，电子在原子核周围运动，形成一个电磁场，作用范围大致可以看作是球形的</p><p>这个球的范围被认为是原子或者离子的体积，半径为原子半径或者离子半径，不同晶体的有效半径表述不同</p><ul><li>离子晶体：一堆相邻接触的阴、阳离子的中心距，即为阴阳离子半径之和</li><li>共价晶体：两个相邻键合原子的中心距，即为两个原子的共价半径之和</li><li>金属晶体：两个相邻原子中心距的一半，即为金属原子半径</li></ul><h4 id="球体紧密堆积原理">球体紧密堆积原理</h4><p>若晶体中的原子或离子的最外层电子构型为<strong>惰性气体构型</strong>或者<strong>18电子构型</strong>，则其电子云呈球形，无对成型</p><p>这样的质点在空间的堆积可以近似看作是刚性球体的堆积，服从紧密堆积原理</p><p>球体紧密堆积有两种方式</p><h5 id="六方最密堆积hexagonal-close-packedhcp">六方最密堆积（hexagonalclose-packed，HCP）</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200101666.png"alt="六方最密堆积的前视图" /><figcaption aria-hidden="true">六方最密堆积的前视图</figcaption></figure><p>每个原子的配位数都是 <spanclass="math inline">\(12\)</span>，空间利用率（Atomic Packing Factor,APF）为</p><p><span class="math display">\[\nabla = \frac{6\times\frac{4}{3}\pi r^3}{6\sqrt{2}r^3}\approx 0.74\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200105373.png"alt="六方密堆积的晶胞" /><figcaption aria-hidden="true">六方密堆积的晶胞</figcaption></figure><p>每个晶胞的原子数目为 <span class="math inline">\(6\)</span> 个</p><h5 id="面心立方最密堆积face-centered-cubic-fcc">面心立方最密堆积（FaceCentered Cubic, FCC）</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200114045.png"alt="面心立方最密堆积模型" /><figcaption aria-hidden="true">面心立方最密堆积模型</figcaption></figure><p>每个原子的配位数为 <spanclass="math inline">\(12\)</span>，堆积密度为 <spanclass="math inline">\(0.74\)</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509221624577.png"alt="面心立方晶胞" /><figcaption aria-hidden="true">面心立方晶胞</figcaption></figure><p>每个晶胞的原子数目为 <span class="math inline">\(4\)</span> 个</p><p>空间利用率为</p><p><span class="math display">\[\nabla = \frac{4\times\frac{4}{3}\pi r^3}{(2\sqrt{2}r)^3}\approx 0.74\]</span></p><h5 id="体心立方堆积body-centered-cubicbcc">体心立方堆积（Body CenteredCubic，BCC）</h5><p>立方体的中心原子与 <span class="math inline">\(8\)</span>个顶点原子相切，但是顶点原子互相不相切</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200117079.png"alt="体心立方堆积模型" /><figcaption aria-hidden="true">体心立方堆积模型</figcaption></figure><p>晶胞内有 <span class="math inline">\(2\)</span>个原子，中心的原子配位书为 <spanclass="math inline">\(8\)</span>，空间利用率为</p><p><span class="math display">\[\nabla=\frac{2\times\frac{4}{3}\pi r^3}{(\frac{4}{\sqrt{3}}r)^3}\approx0.68\]</span></p><h4 id="配位数与配位多面体">配位数与配位多面体</h4><p>配位多面体:是指在晶体结构中,与一个阳离子(或原子)成配位关系而相邻结合的各个阴离子(或原子),它们的<strong>中心连线所构成的多面体</strong></p><p>阳离子（或中心原子）多位于配位多面体的中心位置，阴离子（或配位原子）位于多面体的顶点位置</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509221759210.png"alt="常见的几种配位多面体的形式" /><figcaption aria-hidden="true">常见的几种配位多面体的形式</figcaption></figure><h4 id="鲍林规则">鲍林规则</h4><p>配位多面体的形成遵循鲍林规则</p><ol type="1"><li><p>围绕每一个阳离子,形成一个阴离子的配位多面体,阴阳离子的间距取决于它们的半径之和,阳离子的配位数则取决于半径之比 <imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509231113460.png" /></p></li><li><p>(静电价规则)在一个稳定的晶体结构中,从所有相邻接的阳离子到达一个配位阴离子的静电键的总强度,等于阴离子的电荷数从阳离子到每个配位阴离子的静电键强度 <spanclass="math inline">\(S\)</span> 可表示为</p><p><span class="math display">\[S=\frac{Z^+}{CN^+}\]</span></p><p>静电键总强度</p><p><span class="math display">\[\sum_i S_i=\sum_i \frac{Z_i^+}{CN_i^+}=Z^-\]</span></p><p>静电键理论可以用于分析离子晶体结果的稳定性，通过计算每个阴离子所得的经典强度的总和，若与其电价相等，则表明电价平衡，晶体结构稳定</p></li><li><p>（多面体连接规则）在配位结构中,两个阴离子多面体以<strong>共棱</strong>,特别是以<strong>共面</strong>方式存在时,离子晶体结构的稳定性便<strong>降低</strong>,对于电价高而配位数小的阳离子此效应尤为显著</p></li><li><p>（高价阳离子远离规则）在一个含有不同阳离子的晶体中,<strong>电价高</strong>而配位数<strong>小</strong>的阳离子,<strong>不趋向</strong>于相互共有配位多面体的要素</p></li><li><p>(节约规则)即在一个晶体结构中,本质不同的结构组元的种类,趋向于为<strong>数最少</strong>。本质不同的结构组元,是指在性质上有明显差别的结构方式</p></li></ol><h3 id="晶体的点阵和晶胞">晶体的点阵和晶胞</h3><h4 id="定义">定义</h4><h5 id="晶体crystals">晶体（Crystals）</h5><p>原子或离子或分子在三维空间有规律的周期性排列的、具有整齐外形的、以多面体出现的固体物质</p><h5 id="点阵lattice">点阵(lattice)</h5><p>一组无限的点。是指抽去了具体离子,原子或分子内容后的阵点,是被周期重复的最小单位,这样的最小单位称为结构基元</p><h5 id="晶胞unit-cell">晶胞（unit cell）</h5><p>点阵加上具体离子得到<strong>晶胞</strong>，晶胞是实际存在的实体，是晶体结构中的基本重复单位</p><h6 id="晶胞的基本要素">晶胞的基本要素</h6><ul><li>晶胞参数 晶胞的大小和形状<ul><li>三个边长：<span class="math inline">\(a,b,c\)</span></li><li>三个夹角：<spanclass="math inline">\(\alpha,\beta,\gamma\)</span></li></ul></li><li>坐标参数 晶胞内部各个原子的坐标位置，若从原点指向原子的向量空间可表示为 <spanclass="math inline">\(\vec{r}=x\vec{a}+y\vec{b}+z\vec{c}\)</span>，则原子的坐标参数为<span class="math inline">\((x,y,z)\)</span></li></ul><h4 id="七大晶系">七大晶系</h4><p>按照晶胞参数差异将晶体分为七大晶系</p><table><thead><tr><th style="text-align: center;">晶系</th><th style="text-align: center;">边长关系</th><th style="text-align: center;"><spanclass="math inline">\(\alpha\)</span></th><th style="text-align: center;"><spanclass="math inline">\(\beta\)</span></th><th style="text-align: center;"><spanclass="math inline">\(\gamma\)</span></th><th style="text-align: center;">图</th><th style="text-align: center;">代表性物质</th></tr></thead><tbody><tr><td style="text-align: center;">立方晶系</td><td style="text-align: center;"><spanclass="math inline">\(a=b=c\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509241109116.png"alt="立方晶系" /></td><td style="text-align: center;">黄铁矿</td></tr><tr><td style="text-align: center;">四方晶系</td><td style="text-align: center;"><span class="math inline">\(a=b\neqc\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509241117328.png"alt="四方晶系" /></td><td style="text-align: center;">锆石</td></tr><tr><td style="text-align: center;">六方晶系</td><td style="text-align: center;"><span class="math inline">\(a=b\neqc\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(120^\circ\)</span></td><td style="text-align: center;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509251400790.png"alt="六方晶系" /></td><td style="text-align: center;"><spanclass="math inline">\(\ce{Mg(OH)_2}\)</span></td></tr><tr><td style="text-align: center;">正交晶系</td><td style="text-align: center;"><span class="math inline">\(a\neq b\neqc\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509251405596.png"alt="正交晶系" /></td><td style="text-align: center;">钙钛矿</td></tr><tr><td style="text-align: center;">单斜晶系</td><td style="text-align: center;"><span class="math inline">\(a\neq b\neqc\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\beta\neq90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(90^\circ\)</span></td><td style="text-align: center;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509251406048.png"alt="单斜晶系" /></td><td style="text-align: center;">硫酸钡</td></tr><tr><td style="text-align: center;">三斜晶系</td><td style="text-align: center;"><span class="math inline">\(a\neq b\neqc\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\alpha\neq90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\beta\neq90^\circ\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\gamma\neq90^\circ\)</span></td><td style="text-align: center;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509251411124.png"alt="三斜晶系" /></td><td style="text-align: center;">滑石矿</td></tr></tbody></table><h5 id="种布拉菲点阵"><span class="math inline">\(14\)</span>种布拉菲点阵</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509251427044.png"alt="14种布拉菲点阵图" /><figcaption aria-hidden="true">14种布拉菲点阵图</figcaption></figure><h3 id="xrd">XRD</h3><h4 id="bragg-方程">Bragg 方程</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png"alt="X射线衍射" /><figcaption aria-hidden="true">X射线衍射</figcaption></figure><p>当光程差为波长的整数倍时，晶面的散射线将加强，此时满足</p><p><span class="math display">\[2d\sin\theta=n\lambda\]</span></p><p>这个公式暗含了一个条件：<spanclass="math inline">\(D&gt;\frac{\lambda}{2}\)</span></p><h4 id="xrd-光源">XRD 光源</h4><p>通过高能 X 射线辐射铜靶，产生的多个特征波长的荧光 X 射线，其中 k层电子被激发，外层电子填充时发射的波，称为 <spanclass="math inline">\(\ce{CuK}\)</span> 射线</p><ul><li><span class="math inline">\(\ce{CuK\alpha}\)</span>：<spanclass="math inline">\(1.54056\ Å\)</span></li></ul><h4 id="样品的制备">样品的制备</h4><ul><li>样品的颗粒度对 X 射线的衍射强度以及重现性有很大的影响一般样品的颗粒越大,则参与衍射的晶粒数就越少并还会产生初级消光效应使得强度的重现性较差</li><li>要求粉体样品的颗粒度大小在 <span class="math inline">\(0.1\sim 10\mum\)</span> 范围<ul><li>当吸收系数大的样品参加衍射的晶粒数减少也会使重现性变差</li><li>在选择参比物质时尽可能选择结晶完好晶粒小于 <spanclass="math inline">\(5\mu m\)</span>，吸收系数小的样品</li></ul></li><li>一般可以采用<strong>压片胶带粘</strong>以及<strong>石蜡分散</strong>的方法进行制样X射线的吸收与其质量密度有关，因此要求样品制备均匀，否则会严重影响定量结果的重现性</li></ul><h4 id="晶粒大小的测定原理">晶粒大小的测定原理</h4><p>使用 Scherrer 公式进行计算</p><p><span class="math display">\[D=\frac{0.89\lambda}{\beta\cos\theta}\]</span></p><p>其中</p><ul><li><span class="math inline">\(D\)</span>：晶粒度</li><li><span class="math inline">\(\lambda\)</span>：X 射线波长</li><li><spanclass="math inline">\(\beta\)</span>：衍射峰的半高宽，单位为弧度<ul><li><spanclass="math inline">\(\beta=\sqrt{\beta^2_{\text{total}}-\beta^2_0}\)</span></li></ul></li><li><span class="math inline">\(\theta\)</span>：衍射角</li></ul><h4 id="xps">XPS</h4><p>X 射线光电子能谱（X-ray Photoelectron Spectroscopy,XPS）是利用光电子能谱技术研究物质表面组成和化学状态的一种分析方法</p><p>利用 X射线激发材料表面的原子，使其内层电子逸出并且测量这些逸出电子的动能，从而计算出电子的结合能</p><h3 id="晶体的基本类型和特征">晶体的基本类型和特征</h3><p>固体物质按照原子或分子或离子在空间中的排列是否长程有序分为晶体和无定形两大类</p><ul><li>晶体：原子、离子、分子等微粒在空间按一定周期重复地排列构成的固体物质<ul><li>规则排序：在空间上“一定数量种类的微粒”每隔一定距离重复出现，即所谓晶体的周期性</li></ul></li><li>无定形固体：原子、离子、分子等微粒在空间中无规则排列或者仅仅短程有序，不能通过对称性相关联</li></ul><h4 id="晶体结构特征">晶体结构特征</h4><h5 id="自范性">自范性</h5><p>晶体能够自发形成多面体外形，并且满足欧拉定理</p><p><span class="math display">\[F+V=E+2\]</span></p><p>其中</p><ul><li><span class="math inline">\(F\)</span>：晶体的面数</li><li><span class="math inline">\(V\)</span>：晶体的顶点数</li><li><span class="math inline">\(E\)</span>：晶体的棱数</li></ul><p>因为晶体内部结构有对称性，所以晶体的理想外形也有特定的对称性</p><h5 id="各向异性">各向异性</h5><p>晶体中的某些物理或化学性质沿着不同的平面是不同的，这种现象被称为是晶体的<strong>各向异性</strong></p><h5 id="均匀性">均匀性</h5><p>一块晶体的内部的各个部分的宏观性质是相同的，比如具有相同的密度、化学组成等</p><h5 id="有确定的熔点">有确定的熔点</h5><p>晶体在加热时，在一定温度下突然熔化，这个温度称为晶体的熔点</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509262117643.png"alt="熔化示例" /><figcaption aria-hidden="true">熔化示例</figcaption></figure><h5 id="对称性">对称性</h5><p>理想晶体的外形与其内部的微观结构是紧密相关的，都具有特定的对称性，而且其对称性与性质的关系非常紧密</p><h5 id="晶体的-x-射线衍射">晶体的 X 射线衍射</h5><p>晶体的周期性结构，使它成为天然的三维光栅，其周期性 X光波长相当，能够对 X 光产生衍射</p><h4 id="晶体的分类">晶体的分类</h4><p>按照组成晶体的质点与质点间相互作用力的类型不同，将晶体分为四类</p><ul><li>离子晶体</li><li>分子晶体</li><li>原子晶体（共价晶体）</li><li>金属晶体</li></ul><table style="width:100%;"><thead><tr><th style="text-align: center;">晶体类型</th><th style="text-align: center;">晶格上节点</th><th style="text-align: center;">节点间作用力</th><th style="text-align: center;">代表性物质</th></tr></thead><tbody><tr><td style="text-align: center;">金属晶体</td><td style="text-align: center;">金属原子或金属正离子</td><td style="text-align: center;">金属键</td><td style="text-align: center;">Fe</td></tr><tr><td style="text-align: center;">离子晶体</td><td style="text-align: center;">阴阳离子</td><td style="text-align: center;">离子键</td><td style="text-align: center;">NaCl</td></tr><tr><td style="text-align: center;">分子晶体</td><td style="text-align: center;">分子</td><td style="text-align: center;">范德华力、氢键（分子间作用力）</td><td style="text-align: center;"><spanclass="math inline">\(\ce{I2}\)</span></td></tr><tr><td style="text-align: center;">原子晶体</td><td style="text-align: center;">原子</td><td style="text-align: center;">共价键</td><td style="text-align: center;"><spanclass="math inline">\(\ce{C}\)</span>（金刚石）</td></tr></tbody></table><h5 id="离子晶体">离子晶体</h5><p>常见的离子晶体有强碱、金属氧化物、部分盐等</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509262128874.png"alt="氯化钠晶胞" /><figcaption aria-hidden="true">氯化钠晶胞</figcaption></figure><h5 id="原子晶体">原子晶体</h5><p>两个或多个原子共用它们的外层电子，在理想状态下达到电子饱和的状态，由此组成的比较稳定和坚固的化学键称为<strong>共价键</strong></p><p>共价键有<strong>方向性</strong>和<strong>饱和性</strong>，原子的配位数由键的数目决定，一般配位数较低，键的方向性决定了晶体结构的空间构型</p><p>由于共价键的结合力比离子键大，所以共价型原子晶体都有较大的硬度和高的熔点，其导电性和导热性较差，但是石墨是个例外</p><h5 id="分子晶体">分子晶体</h5><p>分子晶体内组成晶格的质点是分子，质点间的作用力为分子间作用力，主要是范德华力和氢键</p><p>分子晶体一般熔点沸点较低，硬度较小，导电性较差，并且满足相似相溶原则</p><h5 id="金属晶体">金属晶体</h5><p>金属晶体中，自由电子不专属于某个金属离子而为整个金属晶体所共有</p><p>这些自由电子与全部金属离子相互作用，从而形成某种结合，这种作用称为金属键</p><p>金属件没有饱和性和方向性，因此金属一般有良好的导电性和导热性，并且具有延展性和可锻性</p><p>一般金属的熔点和沸点随着金属键的强度的增加而升高</p><h6 id="金属键的强度">金属键的强度</h6><p>金属键的强度可以用原子化热来度量</p><ul><li>原子化热指的是单位物质的量的金属由结晶态转变为气态自由原子所需要的能量，即拆散金属晶格所需的能量</li></ul><p>影响因素</p><ul><li>价电子数目 参与形成金属间的价电子数越多，则金属键越强</li><li>原子半径大小原子半径越大，原子核对价电子的吸引力越小，金属键越弱</li></ul><h5 id="john-teller-效应">John-Teller 效应</h5><details closed style="background-color: #f7f7f7; border: 1px solid #eaeaea; border-radius: 8px; padding: 16px; margin-bottom: 1em;"><summary>Gemini 谈 Jahn-Teller Effect</summary><div><pre><code class="hljs">&lt;h3&gt;杨-泰勒效应的核心思想&lt;/h3&gt;&lt;p&gt;简单来说，就是：&lt;b&gt;分子为了让自己更稳定，会主动“扭曲”自己的形状。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个效应解释了为什么某些分子的几何形状并不像理论上那么“完美对称”。&lt;/p&lt;hr&gt;&lt;h4&gt;一个简单的比喻：选座位&lt;/h4&gt;&lt;p&gt;想象一个分子里的电子要去“坐座位”，这些“座位”就是&lt;b&gt;电子轨道&lt;/b&gt;。&lt;/p&gt;&lt;ol&gt;  &lt;li&gt;    &lt;b&gt;遇到问题：&lt;/b&gt;&lt;br&gt;    现在，有两个或多个&lt;b&gt;一模一样舒服&lt;/b&gt;的空座位（这在化学上称为“轨道简并”），让一个电子随便选。对于整个分子来说，这种“选择困难”的状态其实是不稳定的。  &lt;/li&gt;  &lt;li&gt;    &lt;b&gt;分子的“小聪明”：&lt;/b&gt;&lt;br&gt;    为了解决这个问题，分子会自己&lt;b&gt;“变形”&lt;/b&gt;一下。比如，它会把其中一个座位变得&lt;b&gt;更舒服（能量更低）&lt;/b&gt;，同时让另一个座位变得不那么舒服（能量更高）。  &lt;/li&gt;  &lt;li&gt;    &lt;b&gt;完美解决：&lt;/b&gt;&lt;br&gt;    这样一来，电子就不用选择了，它会毫不犹豫地坐到那个&lt;b&gt;更舒服&lt;/b&gt;的座位上。因为电子找到了一个能量更低的位置，所以整个分子的总能量就降低了，变得&lt;b&gt;更稳定&lt;/b&gt;。  &lt;/li&gt;&lt;/ol&gt;&lt;hr&gt;&lt;h4&gt;总结&lt;/h4&gt;&lt;ul&gt;  &lt;li&gt;&lt;b&gt;触发条件：&lt;/b&gt;一个分子的电子排布不均匀，导致电子面临“选择困难”（轨道简并）。&lt;/li&gt;  &lt;li&gt;&lt;b&gt;行为：&lt;/b&gt;分子自发地改变自己的几何形状（发生畸变）。&lt;/li&gt;  &lt;li&gt;&lt;b&gt;目的：&lt;/b&gt;消除“选择困难”，让电子进入一个能量更低的位置，从而使整个体系变得更稳定。&lt;/li&gt;&lt;/ul&gt;</code></pre></div></details><h3 id="能带理论">能带理论</h3><p>四个量子数</p><ul><li><spanclass="math inline">\(n\)</span>：主量子数，描述电子层数，取值为正整数<span class="math inline">\(1,2,3,\cdots ,N\)</span></li><li><span class="math inline">\(m\)</span>:磁量子数，描述电子轨道的空间取向，取值为整数 <spanclass="math inline">\(0,\pm 1,\pm 2,\cdots,\pm (N-1)\)</span></li><li><spanclass="math inline">\(m_s\)</span>：自旋量子数，描述电子自旋方向，取值为<span class="math inline">\(+\frac{1}{2},-\frac{1}{2}\)</span></li><li><spanclass="math inline">\(l\)</span>：角量子数，描述电子轨道的形状，取值为<span class="math inline">\(0,1,2,\cdots,(N-1)\)</span></li></ul><p>能带的形成</p><ul><li>单个原子 电子只占据离散能级</li><li>大量原子原子的能级因为相互作用发生能级分裂，逐渐编程准连续的能带</li></ul><p>原来孤立的原子能级在晶体中会形成价带（ValenceBand）和导带（Conduction Band）</p><h4 id="导体半导体和绝缘体">导体、半导体和绝缘体</h4><ul><li><p>能带宽度 最低导带和最高价带之间的宽度</p></li><li><p>导体（Conducor）带隙比较窄，电子从价带移动到导带需要的能量比较少，导电性能良好</p></li><li><p>绝缘体（Insulator）带隙比较宽，电子从价带移动到导带需要的能量比较大，导电性能差一般来说带隙大于 <span class="math inline">\(3\ eV\)</span></p></li><li><p>半导体（Semiconductor）带隙适中，电子从价带移动到导带需要的能量适中，导电性能介于导体和绝缘体之间导电性能优于绝缘体，但是不如导体</p></li></ul><h5 id="本征半导体">本征半导体</h5><p>本征半导体（IntrinsicSemiconductor）：<strong>完全不含杂质</strong>且<strong>无晶格缺陷</strong>的纯净半导体</p><p>本征半导体的导电能力主要由材料的本征激发决定的纯净半导体</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509271638306.png"alt="本征激发" /><figcaption aria-hidden="true">本征激发</figcaption></figure><details closed style="background-color: #f7f7f7; border: 1px solid #eaeaea; border-radius: 8px; padding: 16px; margin-bottom: 1em;"><summary>Gemini 谈本征激发</summary><pre><code class="hljs">&lt;strong&gt;导电的原理：本征激发&lt;/strong&gt;    &lt;p&gt;当半导体获得能量（例如，通过加热或光照）时，会发生“本征激发”：&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;&lt;b&gt;自由电子的产生&lt;/b&gt;：一些束缚在共价键中的价电子会获得足够的能量，挣脱束缚，变成可以在晶格中自由移动的&lt;b&gt;自由电子&lt;/b&gt;。&lt;/li&gt;        &lt;li&gt;&lt;b&gt;空穴的产生&lt;/b&gt;：价电子离开后，在原来的共价键位置上会留下一个空位，这个空位被称为&lt;b&gt;空穴 (Hole)&lt;/b&gt;。空穴可以被邻近的电子填充，效果上等同于一个带正电的粒子在移动。&lt;/li&gt;        &lt;li&gt;&lt;b&gt;导电性&lt;/b&gt;：正是由于“本征激发”产生了可以自由移动的&lt;b&gt;自由电子&lt;/b&gt;和&lt;b&gt;空穴&lt;/b&gt;（这两种统称为“载流子”），本征半导体才具备了一定的导电能力。&lt;/li&gt;    &lt;/ul&gt;</code></pre></details><h5 id="p-型半导体和-n-型半导体">P 型半导体和 N 型半导体</h5><h6 id="p-型半导体">P 型半导体</h6><p>参杂三价杂质原子（如硼、铝、镓等）的半导体中会出现空穴，由于没有电子而变得非常不稳定，容易吸收电子并中和，从而形成P 型半导体</p><p>在 P型半导体中，位于共价键中的空穴只需要很少的外界能量就可以吸引价带中的其他电子来填充它</p><h6 id="n-型半导体">N 型半导体</h6><p>参杂五价杂质原子（如磷、砷、锑等）的半导体中会出现多余的电子，这些电子很容易脱离杂质原子而成为自由电子，从而形成N 型半导体</p><h6 id="p-n-结">P-N 结</h6><p>n 区和 p 区界面两侧的正负电荷薄层称为空间电荷区，即 P-N 结</p><p>扩散越强，空间电荷区越宽</p><h6 id="费米能级ef">费米能级（EF）</h6><p>在绝对零度（<spanclass="math inline">\(0K\)</span>）下，电子填充能带的最高能量水平</p><ul><li>金属 费米能级位于导带内</li><li>半导体和绝缘体 费米能级位于带隙中</li><li>本征半导体 无掺杂时，导电靠热激发</li><li>掺杂半导体 通过掺杂改变费米能级<ul><li>N 型半导体 费米能级靠近导带</li><li>P 型半导体 费米能级靠近价带</li></ul></li></ul><p>我们可以通过量子力学计算费米能级，通过密度泛函理论（DensityFunctional Theory, DFT）计算材料的能带理论</p><p>也可以通过实验测量费米能级，比如紫外-可见光吸收谱（UV-Vis）、光电子能谱（UPS/XPS）、角分辨光电子能谱（ARPES）等</p><h6 id="能带调控">能带调控</h6><p>通过设计或改造材料，使价带顶（VBM）和导带底（CBM）的能级位置、带隙大小发生改变，从而优化电学、光学或催化性能</p><p>调控能带的方法</p><ol type="1"><li>元素掺杂<ul><li>n 型掺杂：引入施主能级，使费米能级靠近导带</li><li>p 型掺杂：引入受主能级，使费米能级靠近价带改变了载流子的浓度，提高了导电性或调节带隙在硅基半导体器件、光催化材料中应用广泛</li></ul></li><li>尺寸效应与量子限域当材料尺寸缩小到纳米尺度时，电子运动被限制，能带变宽，带隙随粒径减小而增大（蓝移）量子点</li></ol><h2 id="能源化学热力学">能源化学热力学</h2><h3 id="化学平衡">化学平衡</h3><h4 id="gibbs-自由能">Gibbs 自由能</h4><p><span class="math display">\[\Delta G=\Delta H-T\Delta S\]</span></p><ul><li><span class="math inline">\(\Delta G\)</span>：吉布斯自由能变化</li><li><span class="math inline">\(\Delta H\)</span>：焓变</li><li><span class="math inline">\(\Delta S\)</span>：熵变</li></ul><p>在化学热力学中为<strong>判断过程进行的方向</strong>而引入的热力学函数在化学反应中吉布斯自由能的变化 <span class="math inline">\(\DeltaG\)</span> 可以用来判断反应的进行方向</p><ul><li>当 <span class="math inline">\(\Delta G&lt;0\)</span>时，反应自发，释放能量</li><li>当 <span class="math inline">\(\Delta G&gt;0\)</span>时，反应不自发，需吸收能量</li><li>当 <span class="math inline">\(\Delta G=0\)</span>时，反应达到平衡</li></ul><h4 id="热化学">热化学</h4><p>热化学目的在于计算物理和化学反应中的热效应</p><h4 id="化学反应进度">化学反应进度</h4><p><span class="math display">\[\ce{dD + eE -&gt; fF +gG}\]</span></p><p>化学反应进度 <span class="math inline">\(\xi\)</span>定义为反应物或生成物的量变化与其化学计量数之比，单位为 mol</p><p><span class="math display">\[\mathrm{d}\xi=\frac{-\mathrm{d}n_D}{d}=\frac{-\mathrm{d}n_E}{e}=\frac{\mathrm{d}n_F}{f}=\frac{\mathrm{d}n_G}{g}\]</span></p><h4 id="标准摩尔焓变">标准摩尔焓变</h4><p>标准态：<span class="math inline">\(1\ \text{atm}\)</span>压力下的纯净物质的稳定形态，用 <spanclass="math inline">\(\text{p}^{\theta}\)</span> 表示</p><ul><li>纯固体或纯液体：压力为 <span class="math inline">\(1\\text{atm}\)</span>，温度为 <spanclass="math inline">\(\text{T}\)</span> 下的状态</li><li>纯气体：压力为 <span class="math inline">\(1\\text{atm}\)</span>，温度为 <spanclass="math inline">\(\text{T}\)</span> 下的状态</li></ul><h4 id="hess-定律">Hess 定律</h4><p>反应的热效率只与始态和终态有关，与变化的途径无关</p><ul><li>这只对<strong>等容</strong>或<strong>等压</strong>过程才完全正确</li></ul><h4 id="标准摩尔生成焓">标准摩尔生成焓</h4><p>人为规定在标准压力下进行反应的温度时，由<strong>最稳定</strong>的<strong>单质</strong>合成标准压力<span class="math inline">\(\text{p}^\theta\)</span>下<strong>单位量</strong>物质 B 的反应焓变，称为物质 B的标准摩尔生成焓，记作 <span class="math inline">\(\Delta_f H_m^\theta(B)\ (B,\text{相态},T)\)</span></p><p>最稳定的单质的标准摩尔生成焓为零</p><h4 id="标准摩尔燃烧焓">标准摩尔燃烧焓</h4><p>在标准压力 <span class="math inline">\(\text{p}^\theta\)</span>，反应的温度 <span class="math inline">\(\text{T}\)</span>下，单位量物质 B 完全氧化生成指定产物时，单位量物质 B的反应焓变，称为物质 B 的标准摩尔燃烧焓，记作 <spanclass="math inline">\(\Delta_c H_m^\theta (B)\(B,\text{相态},T)\)</span></p><h4 id="kirchhoff-定律">Kirchhoff 定律</h4><p>在等压下，同一化学反应分别在两个不同的温度下进行，其反应焓变之差等于反应热容变的积分</p><p><span class="math display">\[\Delta _r H_m (T_2)-\Delta _r H_m (T_1)=\int_{T_1}^{T_2}\Delta _rC_{p,m}\mathrm{d}T\]</span></p><p>当热容差 $ C_p $ 在 $ T_1-T_2 $ 区间内可视为常数时，公式简化为：</p><p><span class="math display">\[\Delta H(T_2) = \Delta H(T_1) + \Delta C_p (T_2 - T_1)\]</span></p><ul><li><span class="math inline">\(\displaystyle \Delta C_p = \sum \nu _pC_{p,m}(\text{产物}) - \sum \nu _r C_{p,m}(\text{反应物})\)</span></li></ul><h3 id="化学反应平衡条件">化学反应平衡条件</h3><h4 id="化学平衡常数">化学平衡常数</h4><p>在<strong>等温等压、无非膨胀功</strong>的条件下，反应方向由 <spanclass="math inline">\((\Delta_r G_m)_{T,p}\)</span> 决定：</p><ul><li><span class="math inline">\((\Delta_r G_m)_{T,p} &lt; 0\)</span>：反应自发正向进行</li><li><span class="math inline">\((\Delta_r G_m)_{T,p} = 0\)</span>：反应达到平衡，达到反应的最大限度</li><li><span class="math inline">\((\Delta_r G_m)_{T,p} &gt; 0\)</span>：逆反应是自发的</li></ul><h3 id="多组分系统的化学势">多组分系统的化学势</h3><h4 id="多组分系统的热力学和化学势">多组分系统的热力学和化学势</h4><h5 id="偏摩尔量">偏摩尔量：</h5><p>对于一多组分均相体系 <spanclass="math inline">\(Z=Z(T,p,n_1,n_2,\ldots , n_k)\)</span></p><p><span class="math display">\[\mathrm{d}Z=\left(\frac{\partial Z}{\partial T}\right)_{P,n}\\mathrm{d}T + \left(\frac{\partial Z}{\partial p}\right)_{T,n}\\mathrm{d}p+\sum_{B=1}^k\left(\frac{\partial Z}{\partialn_B}\right)_{T,p,n_c(C\neq B)}\ \mathrm{d} n_B\]</span></p><p>令 <span class="math inline">\(\displaystyleZ_{B,M}=\left(\frac{\partial Z}{\partial n_B}\right)_{T,p,n_c(C\neqB)}\)</span>，则其表示在恒温恒压条件下体系组成不变时，加入 <spanclass="math inline">\(1\ \text{mol}\)</span> 物质 B 引发体系某一容量性质<span class="math inline">\(Z\)</span> 的改变</p><p>根据偏摩尔量的定义，我们可以得到偏摩尔吉布斯自由能</p><p><span class="math display">\[\left( \frac{\partial G}{\partial n_B} \right)_{T,p,n_c(C \neq B)} =\left( \frac{\partial H}{\partial n_B} \right)_{T,p,n_c(C \neq B)} - T\left( \frac{\partial S}{\partial n_B} \right)_{T,p,n_c(C \neq B)}\]</span></p><p>即</p><p><span class="math display">\[G_{B,m} = H_{B,m} - TS_{B,m}\]</span></p><h5 id="吉布斯-杜亥姆公式">吉布斯-杜亥姆公式</h5><p>对于一个多组分系统，其<strong>总的容量性质</strong>（如体积 <spanclass="math inline">\(V\)</span>、内能 <spanclass="math inline">\(U\)</span>、焓 <spanclass="math inline">\(H\)</span>、吉布斯自由能 <spanclass="math inline">\(G\)</span>）是系统中<strong>各个组分的偏摩尔量之和</strong></p><p>以系统的内能和焓为例</p><p><span class="math display">\[\begin{aligned}U=\sum_Bn_BU_{B,m}\\H=\sum_Bn_BH_{B,m}\end{aligned}\]</span></p><ul><li><span class="math inline">\(U_{B,m}\)</span> 和 <spanclass="math inline">\(H_{B,m}\)</span>分别为溶液中组分的偏摩尔内能和偏摩尔焓</li></ul><p>吉布斯-杜亥姆公式指明了不同组分间的关系</p><p><span class="math display">\[\begin{aligned}0 = \sum_{B} n_B \mathrm{d}V_B\\0 = \sum_{B} n_B \mathrm{d}X_B\end{aligned}\]</span></p><p>表明在恒温、恒压下，溶液中各组分的偏摩尔量（如偏摩尔体积 <spanclass="math inline">\(V_B\)</span> 或任意偏摩尔量 <spanclass="math inline">\(X_B\)</span>）的变化不是相互独立的。如果一个组分的偏摩尔量发生变化，其他组分的偏摩尔量也必须相应地变化，以保持总和关系为零</p><h4 id="化学势">化学势</h4><p><span class="math display">\[\mu_B=\left( \frac{\partial U}{\partial n_B} \right)_{S,V,n_c(C \neq B)}\]</span></p><p>化学势为保持体系熵、提及及其他组分物质的量不变的条件下，向体系中加入<span class="math inline">\(1\ \text{mol}\)</span> 组分 B时所引起的内能变化</p><p>揭示了化学势的本质为物质增加导致系统能量变化的趋势</p><p>并且通过定义可以得到化学势的等效表达</p><p><span class="math display">\[\mu_B = \left(\frac{\partial U}{\partial n_B}\right)_{S,V,n_c} =\left(\frac{\partial H}{\partial n_B}\right)_{S,p,n_c} =\left(\frac{\partial A}{\partial n_B}\right)_{T,V,n_c} =\left(\frac{\partial G}{\partial n_B}\right)_{T,p,n_c}\]</span></p><h5 id="多相系统中">多相系统中</h5><p>对于包含多个相（例如，固相、液相、气相，用 <spanclass="math inline">\(\alpha\)</span>表示）的系统，热力学基本方程需要对所有组分 B 在所有相 <spanclass="math inline">\(\alpha\)</span> 中进行求和</p><p><span class="math display">\[\begin{aligned}&amp;\mathrm{d}U=T\ \mathrm{d}S-p\ \mathrm{d}V\\&amp;\mathrm{d}H=T\ \mathrm{d}S+V\ \mathrm{d}p\\&amp;\mathrm{d}A=-S\ \mathrm{d}T-p\ \mathrm{d}V\\&amp;\mathrm{d}G=-S\ \mathrm{d}T+V\ \mathrm{d}p\end{aligned}+\sum_\alpha\sum_B\mu_B(\alpha)\ \mathrm{d}{n_B(\alpha)}\]</span></p><p>则多个相中的化学势为</p><p><span class="math display">\[\mu_B = \left(\frac{\partial G}{\partial n_B}\right)_{T,p,n_c} = G_{B,m}\quad (J \cdot mol^{-1})\]</span></p><p>恒温恒压下，组分 B 的化学势等于其偏吉布斯自由能</p><h3 id="相平衡">相平衡</h3><h4 id="相基本概念">相基本概念</h4><ul><li>系统中宏观上化学组成、物理和化学性质完全均匀的部分</li><li>相之间有明显的界面，界面上宏观性质改变巨大</li><li>相数：<span class="math inline">\(\Phi\)</span></li></ul><h2 id="能源化学动力学">能源化学动力学</h2><h3 id="化学">化学</h3><h3 id="动力学基础">动力学基础</h3><p>将时间作为变量之一，考察化学反应随时间的变化过程和其中的规律</p><p>任务</p><ol type="1"><li>研究各种因素，对反应的影响</li><li>降低副反应</li></ol><h4 id="键能与活化能">键能与活化能</h4><p>键能：化学键形成时放出的能量或断裂时吸收的能量；双原子分子的键能就是键的解离能</p><p>活化能：指化学反应中必须克服的能量壁垒</p><p>Arrenius 方程：描述了反应速率常数与温度之间的关系</p><p><span class="math display">\[k=Ae^{-\frac{E_a}{RT}}\]</span></p><h4 id="化学反应速率的表示方法">化学反应速率的表示方法</h4><h5 id="定义-1">定义</h5><p>SI 制中</p><p><span class="math display">\[v=\frac{1}{v_B}\frac{1}{V}\frac{\mathrm{d}n_B}{\mathrm{d}t}\]</span></p><h2 id="表界面化学">表界面化学</h2><h3 id="物理吸附和化学吸附">物理吸附和化学吸附</h3><p>物理吸附是由范德华力产生的，力较弱，对分子结构影响不大，可以类比为凝聚现象</p><p>化学吸附是由化学键产生的，涉及到电子的重拍、化学键的断裂或形成，对吸附质分子的结构影响较大，类似化学反应</p><h2 id="电化学">电化学</h2><p>电化学主要是研究电能和化学能之间的相互转化及其转化过程中有关规律的科学</p><p>Debye-Hückel 极限定律</p><h3 id="电介质溶液">电介质溶液</h3><h4 id="基本概念和电解定律">基本概念和电解定律</h4><h4 id="离子的电迁移率和迁移数">离子的电迁移率和迁移数</h4><h4 id="电介质溶液的电导">电介质溶液的电导</h4><h4id="电介质的平均活度和平均活动因子">电介质的平均活度和平均活动因子</h4><h3 id="可逆电池的电动势">可逆电池的电动势</h3><h3 id="电池极化">电池极化</h3><h3 id="电化学动力学">电化学动力学</h3>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>化学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>能源化学</tag>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理B笔记</title>
    <link href="/2025/09/15/%E6%9C%AC%E7%A7%91/%E7%94%B5%E8%B7%AF/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2025/09/15/%E6%9C%AC%E7%A7%91/%E7%94%B5%E8%B7%AF/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="自动控制原理-b">自动控制原理 B</h1><h2 id="导论">导论</h2><h3 id="概述">概述</h3><p>自动控制的意义</p><ul><li>提高了劳动生产率</li><li>提高控制的准确性</li><li>可用于某些人们不能直接参与工作的场合</li></ul><p>判断一个系统是否为自动控制系统的标准：控制过程脱离人的控制</p><p>但是，自动控制系统中仍然有人参与，并非脱离人的设置</p><h3 id="自动控制理论的发展">自动控制理论的发展</h3><h4 id="胚芽期1945-年以前">胚芽期（1945 年以前）</h4><ul><li>18 世纪以后，蒸汽机的使用提出了调速稳定等问题<ul><li>1765 年，俄国人波尔祖诺夫发明了锅炉水位调节器</li><li>1784 年，英国人瓦特发明了调速器，蒸汽机离心式调速器</li><li>1877 年，产生了古氏判据和劳斯稳定判据</li></ul></li><li>19 世纪前半叶，动力使用了发电机、电动机<ul><li>促进了水利、水电站的遥控和程控的发展以及电压、电流的自动调节技术的发展</li></ul></li><li>19 世纪末，20 世纪初，使用内燃机<ul><li>促进了飞机、汽车、船舶、机器制造业和石油工业的发展，产生了伺服控制和过程控制</li></ul></li><li>20 世纪初第二次世界大战，军事工业发展很快<ul><li>飞机、雷达、火炮上的伺服机构，总结了自动调节技术及反馈放大器技术，搭起了经典控制理论的架子，但还没有形成学科</li></ul></li></ul><h4 id="经典控制理论">经典控制理论</h4><ul><li>1945 年 美国人 Bold 网络分析与放大器的设计 奠定了控制理论的基础</li><li>50 年代 趋于成熟</li><li>研究对象 单输入、单输出系统</li><li>描述方法 传递函数</li><li>研究方法 频率法、根轨迹法</li><li>研究内容 系统稳定性的代数和几何判据以及校正网络等</li><li>举例<ul><li>调节电压改变电机的速度</li><li>调整方向盘改变汽车的运动轨迹</li></ul></li></ul><h4 id="现代控制理论">现代控制理论</h4><ul><li>空间技术的发展提出了许多复杂控制问题</li><li>用于导弹、人造卫星和宇宙飞船上</li><li>Kalmann 控制系统一般理论 奠定了现代控制理论的基础</li><li>研究对象<ul><li>线性、非线性、定常、时变系统</li><li>多输入、多输出</li></ul></li><li>描述方法<ul><li>向量空间（状态空间）</li></ul></li><li>研究方法<ul><li>状态空间法</li></ul></li></ul><h4 id="大系统理论">大系统理论</h4><ul><li>一种过程控制与信息处理相结合的动态系统工程理论</li><li>研究对象<ul><li>规模庞大、结构复杂、功能综合、目标多样、因素众多</li><li>多输入、多输出、多干扰、多变量的系统</li></ul></li><li>举例<ul><li>人体大系统</li><li>三峡水利枢纽</li></ul></li></ul><h4 id="智能控制理论">智能控制理论</h4><ul><li>研究对象 模糊性、不确定性、不完整性、偶然性的系统</li><li>基础 人工智能理论</li><li>指导思想依据人的思维方式和处理问题的技巧，解决哪些目前需要人的只能才能解决的问题</li></ul><h3 id="自动控制系统的分类">自动控制系统的分类</h3><h4 id="信号的传递路径">信号的传递路径</h4><h5 id="开环系统">开环系统</h5><p>作用信号由输入到输出单方向传递，系统的输出端与输入端不存在反馈回路</p><p>优点：</p><ol type="1"><li>结构简单，成本低廉，不存在稳定性问题</li><li>当输入信号和扰动能预先知道时，控制效果较好</li></ol><p>缺点：</p><ol type="1"><li>不具备自动修正能力</li><li>系统的元件参数变化以及未来的未知扰动对控制精度影响较大</li></ol><h5 id="闭环系统">闭环系统</h5><p>输出信号通过测量元件反馈到系统的输入端，通过比较、控制来减小系统误差</p><p>优点：</p><ol type="1"><li>具有自动修正被控制量出现偏离的能力</li><li>可修正元件参数变化以及外界扰动引起的误差</li><li>控制精度高</li></ol><p>缺点：</p><ul><li>被控量可能出现振荡，甚至发散</li></ul><h4 id="输入量的特点">输入量的特点</h4><h5 id="恒值控制系统">恒值控制系统</h5><p>也叫自动调节系统、自动镇定系统</p><ul><li>输入 恒定数值</li><li>任务 系统在任何扰动作用下，输出量以一定精度接近给定值</li></ul><h5 id="过程控制系统">过程控制系统</h5><p>也叫程序控制系统</p><ul><li>输入 已知函数</li><li>任务系统的控制过程按预定的程序进行，要求被控量能迅速准确地复现输入</li></ul><h5 id="随动系统">随动系统</h5><p>也叫伺服系统</p><ul><li>输入 未知函数</li><li>任务 控制系统的输出量<strong>跟随</strong>输入信号变化</li></ul><h4 id="信号传输的性质">信号传输的性质</h4><p>分为连续系统和离散系统</p><h4 id="元部件的特性">元部件的特性</h4><p>分为线性系统和非线性系统</p><h3 id="反馈控制系统的基本组成">反馈控制系统的基本组成</h3><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509152359458.png"alt="基本组成" /><figcaption aria-hidden="true">基本组成</figcaption></figure><p>主要有三个部分</p><ol type="1"><li>输入信号 系统控制目标的反映，是人的意志的体现</li><li>控制系统主要完成对有关信号的变换，处理，发出控制量，驱动执行机构完成控制功能</li><li>输出信号 系统的控制结果，反映了被控对象的运行状况</li></ol><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509160009862.png"alt="反馈系统组成部分" /><figcaption aria-hidden="true">反馈系统组成部分</figcaption></figure><p>对于其系统来说，有这些部分</p><ul><li>测量元件 用来测量被控量的实际值</li><li>比较元件 用来产生输入信号和主反馈信号的差值信号</li><li>放大元件 把误差信号放大并进行能量形式转换</li><li>执行元件 根据控制信号直接对控制对象进行操纵</li><li>被控对象 控制系统所要操纵的对象</li></ul><h3 id="对控制系统的基本要求">对控制系统的基本要求</h3><ol type="1"><li>稳定性<ul><li>保证控制系统正常工作的先决条件<ul><li>输入激励会使系统偏离平衡状态</li><li>激励消失后，经过一段过程，系统的状态恢复到平衡状态</li></ul></li><li>线性控制系统的稳定性由系统本身的结构与参数所决定的，与外部条件和初始状态无关</li></ul></li><li>稳态特性<ul><li>过渡过程结束后，系统的误差值，反映了系统的控制精度</li></ul></li><li>动态特性<ul><li>过渡过程 系统状态随时间变化的过程</li><li>产生原因 系统中储能元件的能量不可能突变</li><li>基本要求 时间短、平稳、振荡幅度小</li></ul></li></ol><h3 id="常用的典型测试信号">常用的典型测试信号</h3><p>我们在分析和设计系统时，常常需要一个对各种系统进行比较的基准，但是实际系统的输入信号具有不确定性，其函数形式难以使用解析法表示，所以我们用一些简单的测试信号对齐进行测试</p><p>系统对典型测试信号的相应与实际输入的相应之间应存在一定的关系，实际信号往往是多种典型测试信号的组合，典型测试信号是简单的时间函数</p><h4 id="脉冲信号pulse">脉冲信号（Pulse）</h4><ol type="1"><li><p>宽度（持续时间）为 <span class="math inline">\(h\)</span>的矩形脉冲信号</p><p><span class="math display">\[r(t)=\left\{    \begin{aligned}    &amp;\frac{1}{h},\quad 0 \leq t \leq h \\    &amp;0, \quad t&lt;0.t&gt;h  \end{aligned}\right.\]</span></p></li><li><p>单位冲激信号（单位脉冲信号），这是宽度趋于零的矩形脉冲信号</p><p><span class="math display">\[r(t)=\delta(t)=\left\{    \begin{aligned}    &amp;\infty, \quad t=0 \\    &amp;0, \quad t\neq 0    \end{aligned}\right.\]</span></p><p>其中</p><p><span class="math display">\[\int_{-\infty}^{\infty} \delta(t) \,\mathrm{d}t = 1\]</span></p><p>对单位冲激信号做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} \delta(t) e^{-s t} \,\mathrm{d}t=1\]</span></p></li></ol><h4 id="阶跃信号step">阶跃信号（Step）</h4><ol type="1"><li><p>标准阶跃信号</p><p><span class="math display">\[r(t)=R\cdot u(t)=\left\{    \begin{aligned}    &amp;R, \quad t \geq 0 \\    &amp;0, \quad t&lt;0    \end{aligned}\right.\]</span></p><p>其中 <span class="math inline">\(u(t)\)</span> 是单位阶跃信号，<spanclass="math inline">\(R\)</span> 是阶跃高度 这表明在 <spanclass="math inline">\(t=0\)</span> 时，阶跃信号从 0 突然跃变到 <spanclass="math inline">\(R\)</span>，并在 <spanclass="math inline">\(t&gt;0\)</span> 时保持不变</p></li><li><p>延时阶跃信号</p><p><span class="math display">\[r(t)=R\cdot u(t-\tau)=\left\{     \begin{aligned}     &amp;R, \quad t \geq \tau \\     &amp;0, \quad t&lt;\tau     \end{aligned}\right.\]</span></p><p>其中 <span class="math inline">\(\tau\)</span> 是延时时间</p></li></ol><p>对阶跃信号做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} R\cdot u(t) e^{-s t} \,\mathrm{d}t=\frac{R}{s}\]</span></p><p>如果对单位阶跃信号做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} u(t) e^{-s t} \,\mathrm{d}t=\frac{1}{s}\]</span></p><h3 id="斜坡信号ramp">斜坡信号（Ramp）</h3><p>也被称为速度信号</p><p><span class="math display">\[r(t)=\left\{    \begin{aligned}    &amp;R\cdot t, \quad t \geq 0 \\    &amp;0, \quad t&lt;0    \end{aligned}\right.\]</span></p><p>对其做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} R\cdot t e^{-s t} \,\mathrm{d}t=\frac{R}{s^{2}}\]</span></p><h3 id="抛物线信号parabolic">抛物线信号（Parabolic）</h3><p>也称匀加速信号</p><p><span class="math display">\[r(t)=\left\{    \begin{aligned}    &amp;\frac{1}{2}R\cdot t^2, \quad t \geq 0 \\    &amp;0, \quad t&lt;0    \end{aligned}\right.\]</span></p><p>对其做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} \frac{1}{2}R\cdot t^2 e^{-s t}\,\mathrm{d}t=\frac{R}{s^{3}}\]</span></p><h3 id="正弦信号">正弦信号</h3><p><span class="math display">\[r(t)=R\sin(\omega t+\varphi)\]</span></p><p>其中</p><ul><li><span class="math inline">\(R\)</span> 是振幅</li><li><span class="math inline">\(\omega\)</span> 是振荡角频率</li><li><span class="math inline">\(\varphi\)</span> 是相位移</li></ul><h3 id="谐波信号">谐波信号</h3><p><span class="math display">\[r(t)=R\cos(\omega t+\varphi)\]</span></p><h3 id="指数信号">指数信号</h3><p><span class="math display">\[r(t)=R e^{a t}\]</span></p><h2 id="控制系统的数学模型">控制系统的数学模型</h2><h3 id="概述-1">概述</h3><h4 id="数学模型的定义">数学模型的定义</h4><p>数学模型是定义系统行为的数学表达式，也是系统定量分析和研究的首要条件</p><h5 id="狭义定义">狭义定义</h5><p>是对实际物理系统后的数学抽象</p><h5 id="广义定义">广义定义</h5><p>揭示控制系统各变量内在联系及关系的解析式或图形表示</p><h5 id="分类">分类</h5><ul><li>静态模型<ul><li>揭示控制系统各变量内在联系及关系的解析式或图形表示</li><li>静态模型：在静态条件下，描述变量间关系的代数方程<ul><li>静态条件：变量各阶导数为零</li></ul></li></ul></li><li>动态模型：用微分方程描述变量在动态过程中的关系</li></ul><h4 id="表现形式">表现形式</h4><h5 id="数学表示">数学表示</h5><p>用于分析研究系统的动态特性</p><p>其基本形式有</p><ul><li>微分方程</li><li>代数方程</li><li>逻辑方程</li></ul><p>数学表示中的传递函数、频率特性等适用于单输入、单输出系统</p><p>状态空间描述：用于多变量系统及最优控制问题</p><h5 id="图形表示">图形表示</h5><p>用于分析研究系统内部的结构和动态特性</p><p>其基本形式有</p><ul><li>信号流图</li><li>方块图</li><li>根轨迹图</li><li>频率特性图</li></ul><p>等</p><p>还有在数字计算机上的程序综合</p><h5 id="建模原则">建模原则</h5><p>要分清主次、合理简化，从而建立适当的数学模型</p><p>要根据选定的系统分析方法建立起相关的数学模型</p><ul><li>时间域：微分方程</li><li>复数域：传递函数</li><li>频率域：频率特性</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509232158890.png"alt="三种数学模型" /><figcaption aria-hidden="true">三种数学模型</figcaption></figure><h5 id="复频域分析法">复频域分析法</h5><p>时域中列出微分方程得到时域的解</p><p>复频域中列出代数方程得到复频域的解</p><p>微分方程通过 Laplace 变换得到代数方程</p><p>代数方程通过 Laplace 逆变换得到微分方程</p><p>通过这个我们可以在复频域中分析时域问题，从而解决时域分析法存在的难点</p><h5 id="建模方法">建模方法</h5><h6 id="数学分析法">数学分析法</h6><p>我们在知道系统的结构和原理的情况下通过数学分析法建立数学模型</p><p>分析元件或者系统的物理化学规律，再通过微分方程求解、分析系统</p><h6 id="工程分析法">工程分析法</h6><p>当我们不知道系统的结构和原理时，我们可以通过工程分析法建立数学模型</p><p>对实际系统贾一定形式的输出信号，求取输出的相应</p><p>使用传递函数、频率特性对系统进行分析、求解</p><p>它比数学分析法更加简单、方便、直观</p><h3 id="微分方程">微分方程</h3><h4 id="建立方法">建立方法</h4><ol type="1"><li>明确输入量和输出量</li><li>应用物理规律列出变量的关系是</li><li>划分环节</li><li>写出每个环节的微分方程</li><li>简化微分方程至只含有输入量和输出量</li><li>将微分方程转换为标准形式</li></ol><h4 id="标准形式">标准形式</h4><p>对于一个线性定常系统，其输入 <spanclass="math inline">\(r(t)\)</span> 和输出 <spanclass="math inline">\(c(t)\)</span>之间的关系通常可以用一个高阶常系数线性微分方程来描述：</p><p><span class="math display">\[a_n\frac{\mathrm{d^nc(t)}}{\mathrm{d}t^{n-1}}+a_{n-1}\frac{\mathrm{d^{n-1}c(t)}}{\mathrm{d}t^{n-1}}+\cdots+a_1\frac{\mathrm{d}c(t)}{\mathrm{d}t}+a_0c(t)=b_m\frac{\mathrm{d^mr(t)}}{\mathrm{d}t^m}+b_{m-1}\frac{\mathrm{d^{m-1}r(t)}}{\mathrm{d}t^{m-1}}+\cdots+b_1\frac{\mathrm{d}r(t)}{\mathrm{d}t}+b_0r(t)\]</span></p><p>其中</p><ul><li><span class="math inline">\(c(t)\)</span> 是系统的输出量</li><li><span class="math inline">\(r(t)\)</span> 是系统的输入量</li></ul><p>一般来说 <span class="math inline">\(n\geqm\)</span>，因为系统中含有储能元件</p><h3 id="传递函数">传递函数</h3><h4 id="定义">定义</h4><p>线性定常系统在<strong>初始条件为零</strong>的情况下，输出量的 Laplace变换 <span class="math inline">\(C(s)\)</span> 和输入量的 Laplace 变换<span class="math inline">\(R(s)\)</span>之比，称为系统的<strong>传递函数</strong></p><p><span class="math display">\[G(s) = \frac{\mathcal{L}[c(t)]}{\mathcal{L}[r(t)]} = \frac{C(s)}{R(s)}\]</span></p><p>其中</p><ul><li><span class="math inline">\(G(s)\)</span> 是系统的传递函数</li><li><span class="math inline">\(C(s)=\mathcal{L}(c(t))\)</span>是系统输出量的 Laplace 变换</li><li><span class="math inline">\(R(s)=\mathcal{L}(r(t))\)</span>是系统输入量的 Laplace 变换</li></ul><h4 id="性质">性质</h4><ol type="1"><li><strong>模型描述</strong>：传递函数是系统在复数域中的动态数学模型</li><li><strong>固有特性</strong>：它反映了系统输入量和输出量之间的内在关系，其系数均为实数，仅由系统结构参数决定</li><li><strong>函数形式</strong>：传递函数是复变量 <spanclass="math inline">\(s\)</span> 的有理真分式函数，即分子的最高阶次<span class="math inline">\(m\)</span> 小于或等于分母的最高阶次 <spanclass="math inline">\(n\ (m\leq n)\)</span></li><li><strong>与单位脉冲响应的关系</strong>：系统的单位脉冲响应 <spanclass="math inline">\(g(t)\)</span> 的 Laplace 变换就是该系统的传递函数<span class="math inline">\(G(s)\)</span> ，即 <spanclass="math inline">\(G(s)=\mathcal{L}[g(t)]\)</span></li></ol><h4 id="表达形式">表达形式</h4><table><thead><tr><th style="text-align: left;">形式</th><th style="text-align: left;">表达式</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>微分方程</strong></td><td style="text-align: left;"><spanclass="math inline">\(\displaystyle\sum_{i=0}^{n}a_i\frac{\mathrm{d}^ic(t)}{\mathrm{d}t^i}=\sum_{j=0}^{m}b_j\frac{\mathrm{d}^jr(t)}{\mathrm{d}t^j}\)</span></td><td style="text-align: left;">时域模型</td></tr><tr><td style="text-align: left;"><strong>标准形式</strong></td><td style="text-align: left;"><span class="math inline">\(\displaystyleG(s)=\frac{C(s)}{R(s)}=\frac{b_ms^m+b_{m-1}s^{m-1}+\dots+b_0}{a_ns^n+a_{n-1}s^{n-1}+\dots+a_0}\)</span></td><td style="text-align: left;">多项式形式</td></tr><tr><td style="text-align: left;"><strong>时间常数形式</strong></td><td style="text-align: left;"><span class="math inline">\(\displaystyleG(s)=K\frac{(\tau&#39;_1s+1)(\tau&#39;_2s+1)\cdots}{(\mathcal{T}_1s+1)(\mathcal{T}_2s+1)\cdots}\)</span></td><td style="text-align: left;"><span class="math inline">\(K\)</span>为稳态增益</td></tr><tr><td style="text-align: left;"><strong>零极点形式</strong></td><td style="text-align: left;"><span class="math inline">\(\displaystyleG(s)=K_r\frac{(s+z_1)(s+z_2)\cdots(s+z_m)}{(s+p_1)(s+p_2)\cdots(s+p_n)}\)</span></td><td style="text-align: left;"><span class="math inline">\(z_i\)</span>为零点, <span class="math inline">\(p_j\)</span> 为极点, <spanclass="math inline">\(K_r\)</span> 为根轨迹增益</td></tr></tbody></table><h4 id="求取方法">求取方法</h4><h4 id="微分方程法">微分方程法</h4><ol type="1"><li>列出元件或者系统的微分方程</li><li>在零初始条件下对方程进行 Laplace 变换</li><li>计算 <span class="math inline">\(\frac{C(s)}{R(s)}\)</span>即为传递函数</li></ol><h4 id="频率特性法">频率特性法</h4><p>通过实验测定</p><h4 id="单位脉冲响应法">单位脉冲响应法</h4><p>测量系统的单位脉冲响应 <span class="math inline">\(g(t)\)</span>，然后对 <span class="math inline">\(g(t)\)</span> 做 Laplace变换，得到传递函数</p><p><span class="math display">\[G(s)=\frac{\mathcal{L}[c(t)]}{\mathcal{L}[r(t)]}=\frac{\mathcal{L}[g(t)]}{\mathcal{L}[\delta(t)]}=\mathcal{L}[g(t)]\]</span></p><h3 id="典型环节">典型环节</h3><p>典型环节总共有<strong>七种</strong></p><ul><li><strong>比例环节</strong></li><li><strong>微分环节</strong><ul><li><strong>典型微分环节</strong></li><li><strong>一阶微分环节</strong></li><li><strong>二阶微分环节</strong></li></ul></li><li><strong>积分环节</strong></li><li><strong>惯性环节</strong></li><li><strong>震荡环节</strong></li></ul><h4 id="比例环节">比例环节</h4><ul><li><strong>特点</strong>：输出量与输入量成正比，无延迟、无失真</li><li><strong>微分方程</strong>： <span class="math inline">\(c(t)=K\cdotr(t)\)</span></li><li><strong>传递函数</strong>： <spanclass="math inline">\(G(s)=K\)</span></li></ul><h4 id="微分环节">微分环节</h4><p><strong>特点</strong>：输出量与输入量的变化速度相关</p><h5 id="典型微分环节">典型微分环节</h5><ul><li><strong>特点</strong>： 输出量与输入量的变化速度成正比</li><li><strong>微分方程</strong>： <spanclass="math inline">\(\displaystylec(t)=K\frac{\mathrm{d}r(t)}{\mathrm{d}t}\)</span></li><li><strong>传递函数</strong>： <span class="math inline">\(G(s)=Ks\)</span></li></ul><h5 id="一阶微分环节">一阶微分环节</h5><ul><li><strong>特点</strong>：输出量与输入量的变化速度成正比，但有一定的延迟</li><li><strong>微分方程</strong>： <spanclass="math inline">\(\displaystylec(t)=T\frac{\mathrm{d}c(t)}{\mathrm{d}t}+r(t)\)</span></li><li><strong>传递函数</strong>： <spanclass="math inline">\(G(s)=\frac{1}{Ts+1}\)</span></li></ul><h5 id="二阶微分环节">二阶微分环节</h5><ul><li><strong>特点</strong>：输出量与输入量及其一、二届导数相关</li><li><strong>微分方程</strong>：<span class="math inline">\(\displaystylec(t)=T^2\frac{\mathrm{d}^2r(t)}{\mathrm{d}t^2}+2\xiT\frac{\mathrm{d}r(t)}{\mathrm{d}t}+r(t)\)</span></li><li><strong>传递函数</strong>： <spanclass="math inline">\(G(s)=T^2s^2+2\zeta Ts+1\)</span></li></ul><h4 id="积分环节">积分环节</h4><ul><li><strong>特点</strong>：输出量的变化速度与输入量成正比</li><li><strong>微分方程</strong>： <spanclass="math inline">\(\frac{\mathrm{d}c(t)}{\mathrm{d}t} = K\cdotr(t)\)</span></li><li><strong>传递函数</strong>： <span class="math inline">\(G(s)=\frac{K}{s}\)</span></li></ul><h4 id="惯性环节">惯性环节</h4><ul><li><strong>特点</strong>：对突变的输入，输出不能立即复现，而是按指数规律延迟变化含有一个独立的储能元件</li><li><strong>微分方程</strong>： <spanclass="math inline">\(T\frac{\mathrm{d}c(t)}{\mathrm{d}t}+c(t)=K\cdotr(t)\)</span></li><li><strong>传递函数</strong>： <spanclass="math inline">\(G(s)=\frac{K}{Ts+1}\)</span></li></ul><h4 id="振荡环节二阶">振荡环节（二阶）</h4><ul><li><strong>特点</strong>：当输入信号变化时，两个储能元件能量交换，使输出带有振荡性质</li><li><strong>微分方程</strong>： <spanclass="math inline">\(T^2\frac{\mathrm{d}^2c(t)}{\mathrm{d}t^2}+2\zetaT\frac{\mathrm{d}c(t)}{\mathrm{d}t}+c(t)=K\cdot r(t)\)</span></li><li><strong>传递函数</strong>： <spanclass="math inline">\(G(s)=\frac{K}{T^2s^2+2\zeta Ts +1}\)</span></li></ul><h3 id="方块图">方块图</h3><p>方块图（或结构图）是系统数学模型的图解形式，直观地描述了系统中各元件间的关系以及信号的传递过程</p><h4 id="基本组成">基本组成</h4><table><thead><tr><th style="text-align: left;">组件</th><th style="text-align: left;">图示</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>信号线</strong></td><td style="text-align: left;"><spanclass="math inline">\(\rightarrow\)</span></td><td style="text-align: left;">带箭头的直线，箭头表示信号的传递方向</td></tr><tr><td style="text-align: left;"><strong>方块（环节）</strong></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510151542576.png"alt="环节" /></td><tdstyle="text-align: left;">输入到输出<strong>单向传递</strong>的函数关系</td></tr><tr><td style="text-align: left;"><strong>比较点（求和点）</strong></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510151543603.png"alt="比较点" /></td><tdstyle="text-align: left;">对两个或多个信号进行加减运算，必须量纲相同</td></tr><tr><td style="text-align: left;"><strong>分支点（测量点）</strong></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510151543538.png"alt="分支点" /></td><td style="text-align: left;">表示信号从此处引出，引出后原信号不变</td></tr></tbody></table><h4 id="绘制方法">绘制方法</h4><ol type="1"><li>分解系统各环节</li><li>写出各环节的传递函数</li><li>绘制出各环节的方块图</li><li>根据信号的传递方向将各方块图依次连接起来</li></ol><h4 id="运算法则">运算法则</h4><table><thead><tr><th style="text-align: left;">运算类型</th><th style="text-align: left;">图示</th><th style="text-align: left;">公式</th><th>说明</th></tr></thead><tbody><tr><td style="text-align: left;"><strong>串联</strong></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510151549915.png"alt="串联" /></td><td style="text-align: left;"><span class="math inline">\(\displaystyleG(s)=\prod G_i(s)\)</span></td><td>各环节传递函数的乘积</td></tr><tr><td style="text-align: left;"><strong>并联</strong></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161421549.png"alt="并联" /></td><td style="text-align: left;"><span class="math inline">\(\displaystyleG(s)=\sum  \pm G_i(s)\)</span></td><td>各环节传递函数的和</td></tr><tr><td style="text-align: left;"><strong>反馈</strong></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161424708.png"alt="反馈" /></td><td style="text-align: left;"><span class="math inline">\(\displaystyleG(s)=\frac{G_1(s)}{1\pm G_1(s)G_2(s)}\)</span></td><td>负反馈分母为加，正反馈分母为减</td></tr></tbody></table><h4 id="方框图化简">方框图化简</h4><p>· 方框图变换的方法 ß</p><table><thead><tr><th style="text-align: left;">序号</th><th style="text-align: left;">变换方式</th><th style="text-align: left;">原方块图</th><th style="text-align: left;">等效方块图</th></tr></thead><tbody><tr><td style="text-align: left;">1</td><td style="text-align: left;">比较点变换</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161438378.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161439934.png" /></td></tr><tr><td style="text-align: left;">2</td><td style="text-align: left;">比较点分解</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161440044.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161440460.png" /></td></tr><tr><td style="text-align: left;">3</td><td style="text-align: left;">分支点前移</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161441782.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161441334.png" /></td></tr><tr><td style="text-align: left;">4</td><td style="text-align: left;">比较点后移</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161443445.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161444376.png" /></td></tr><tr><td style="text-align: left;">5</td><td style="text-align: left;">分支点前移</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161444192.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161445798.png" /></td></tr><tr><td style="text-align: left;">6</td><td style="text-align: left;">分支点后移</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161507629.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161619803.png" /></td></tr><tr><td style="text-align: left;">7</td><td style="text-align: left;">比较点与分支点交换</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161619870.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161620518.png" /></td></tr><tr><td style="text-align: left;">8</td><td style="text-align: left;">化为单位并联</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161626631.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161628965.png" /></td></tr><tr><td style="text-align: left;">9</td><td style="text-align: left;">化为单位反馈</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161628968.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161630089.png" /></td></tr><tr><td style="text-align: left;">10</td><td style="text-align: left;">分支点交换</td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161632905.png" /></td><td style="text-align: left;"><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161633706.png" /></td></tr></tbody></table><h3 id="信号流图">信号流图</h3><h4 id="基本组成-1">基本组成</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510161835215.png"alt="信号流图举例" /><figcaption aria-hidden="true">信号流图举例</figcaption></figure><ol type="1"><li><p><strong>节点 (Node)</strong></p><ul><li>代表系统的变量</li><li><strong>输入节点（源点）</strong>：只有输出支路的节点，代表系统的输入变量</li><li><strong>输出节点（阱点）</strong>：只有输入支路的节点，代表系统的输出变量</li><li><strong>混合节点</strong>：既有输入支路又有输出支路的节点</li></ul></li><li><p><strong>支路 (Branch)</strong></p><ul><li>连接两个节点的有向线段</li><li><strong>方向</strong>：支路上的箭头表示信号的流向</li><li><strong>增益（传输）</strong>：支路旁的代数式（传递函数）表示两个节点变量之间的函数关系信号流经该支路时，将被乘以该增益</li></ul></li></ol><h4 id="信号流图的基本概念">信号流图的基本概念</h4><ul><li><strong>通路(Path)</strong>：从一个节点到另一个节点，沿着支路箭头方向经过一系列连续支路所构成的路径，且路径上任何节点只能经过一次</li><li><strong>前向通路 (ForwardPath)</strong>：从<strong>输入节点</strong>到<strong>输出节点</strong>的一条<strong>开通路</strong></li><li><strong>回路 (Loop)</strong>：起点和终点在同一节点的闭合通路</li><li><strong>通路增益 (Path Gain)</strong>：通路上所有支路增益的乘积</li><li><strong>回路增益 (Loop Gain)</strong>：回路上所有支路增益的乘积</li><li><strong>互不接触回路 (Non-touchingLoops)</strong>：两个或多个回路之间没有任何公共节点</li></ul><h4 id="信号流图的绘制">信号流图的绘制</h4><ol type="1"><li><strong>确定变量</strong>：根据系统的微分方程或代数方程，确定所有的输入、输出和中间变量作为图的节点</li><li><strong>排列节点</strong>：按照信号的因果关系，将节点从左到右大致排列，输入节点在最左侧，输出节点在最右侧</li><li><strong>连接支路</strong>：根据方程中变量之间的关系，用带箭头的支路连接相应的节点，并在支路上标注增益</li><li><strong>整理图形</strong>：调整节点和支路布局，使图形清晰易读</li></ol><h4 id="梅逊公式">梅逊公式</h4><p>梅森公式是求解信号流图总增益（即系统传递函数）的通用方法，尤其适用于结构复杂的系统</p><p><span class="math display">\[P=\frac{1}{\Delta}\sum_{k=1}^{L}P_k\Delta_k\]</span></p><ul><li><p><spanclass="math inline">\(P\)</span>：系统的总增益（传递函数）</p></li><li><p><span class="math inline">\(P_k\)</span>：第 <spanclass="math inline">\(k\)</span> 条前向通路的增益</p></li><li><p><span class="math inline">\(L\)</span>：前向通路的总数</p></li><li><p><span class="math inline">\(\Delta\)</span>：系统的特征多项式</p><p><span class="math display">\[\Delta=1-\sum_m L_{m_1}+\sum_m L_{m_2}-\sum_m L_{m_3}+\cdots\]</span></p><ul><li><span class="math inline">\(L_{m_i}\)</span>：<spanclass="math inline">\(i\)</span> 个互不接触回路的增益乘积</li></ul></li><li><p><span class="math inline">\(\Delta_k\)</span>：与第 <spanclass="math inline">\(k\)</span>条前向通路不接触的回路的特征多项式</p></li></ul><h2 id="matlab-和-simulink">Matlab 和 Simulink</h2><h3 id="matlab-语言基础">Matlab 语言基础</h3><h4 id="变量">变量</h4><ul><li>变量名<ul><li>由字母、数字和下划线组成</li><li>以字母开头</li><li>区分大小写</li><li>不得与 Matlab 保留字相同</li></ul></li></ul><h4 id="语句">语句</h4><ul><li>赋值语句<ul><li><code>变量名=表达式</code></li></ul></li><li>函数调用语句<ul><li><code>[返回值列表]=函数名(参数列表)</code></li></ul></li><li>语句结尾<ul><li><code>...</code> ：续行符</li><li><code>;</code> ：抑制输出</li><li><code>,</code> ：不抑制输出</li></ul></li><li>注释语句<ul><li><code>%</code> ：单行注释</li><li><code>%&#123; %&#125;</code> ：多行注释</li></ul></li></ul><h4 id="基本数学计算">基本数学计算</h4><h5 id="矩阵输入">矩阵输入</h5><p>输入矩阵</p><p><span class="math display">\[A=\begin{bmatrix}1 &amp; 2 &amp; 3 \\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9\end{bmatrix}\]</span></p><p>直接输入</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A=[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>;<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>;<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>全零矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">% 3x3 全零矩阵</span><br>A=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">% 2x3 全零矩阵</span><br></code></pre></td></tr></table></figure><p>全一矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A=<span class="hljs-built_in">ones</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">% 3x3 全一矩阵</span><br>A=<span class="hljs-built_in">ones</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-comment">% 2x3 全一矩阵</span><br></code></pre></td></tr></table></figure><p>等</p><h6 id="矩阵运算">矩阵运算</h6><ul><li>元素<ul><li>矩阵第 i 行：<code>A(i,:)</code></li><li>矩阵第 j 列：<code>A(:,j)</code></li></ul></li><li>子矩阵<ul><li><code>A(i:m,j:n)</code></li></ul></li></ul><h2 id="控制系统的时域分析">控制系统的时域分析</h2><h3 id="稳定性分析">稳定性分析</h3><h4 id="稳定的定义">稳定的定义</h4><h5 id="系统的性能">系统的性能</h5><p>系统的输出为 <span class="math inline">\(\displaystylec(t)=c_s(t)+c_t(t)\)</span></p><ul><li>系统的动态特性 <span class="math inline">\(\displaystylec_t(t)\)</span><ul><li>为系统达到<strong>稳态</strong>所需的时间</li><li>包括了过渡期间输出偏离输入的程度</li></ul></li><li>系统的稳态特性 <span class="math inline">\(\displaystylec_s(t)\)</span><ul><li>输入信号只影响稳态部分</li><li>稳态误差：系统达到稳态后输入与输出的偏差</li></ul></li><li>系统的稳定性<ul><li>是系统正常运行的迁安题</li></ul></li></ul><h5 id="稳定的定义-1">稳定的定义</h5><p>如果一个线性定常系统在扰动作用消失后，能够恢复到原始的平衡状态，则称该系统是稳定的</p><p>即 <span class="math inline">\(\displaystyle \exists T\)</span>，当<span class="math inline">\(t&gt;T\)</span> 时，输出偏差 <spanclass="math inline">\(\displaystyle |\Deltac(t)|=|c(t)-c_0|\le\varepsilon\)</span></p><h4 id="稳定的充要条件">稳定的充要条件</h4><ul><li><p><strong>闭环</strong>传递函数</p><p><span class="math display">\[\Phi(s)=\frac{C(s)}{R(s)}=\frac{b_ms^m+b_{m-1}s^{m-1}+\dots+b_0}{a_ns^n+a_{n-1}s^{n-1}+\dots+a_0}=\frac{B(s)}{D(s)}\]</span></p><ul><li><span class="math inline">\(\displaystyle m\le n\)</span></li><li>令 <span class="math inline">\(\displaystyle D(s)=0\)</span>得到系统的特征方程，记其根为 <span class="math inline">\(\displaystylep_1,p_2,\dots,p_n\)</span>，并且互不相同</li></ul></li><li><p>系统的输出</p><p>输入信号为 <span class="math inline">\(\displaystyle\delta(t)\)</span></p><p><span class="math display">\[C(s)=\frac{B(s)}{D(s)}R(s)=\frac{B(s)}{D(s)}\mathcal{L}[\delta(t)]=\frac{B(s)}{D(s)}\]</span></p><p>将其展开，设特征根为 <span class="math inline">\(k\)</span>个实根，<span class="math inline">\(r\)</span> 对共轭复根，其中 <spanclass="math inline">\(k+2r=n\)</span>，则有</p><p><span class="math display">\[C(s)=\sum_{i=1}^{k}\frac{c_i}{s-p_i}+\sum_{j=1}^{r}\frac{\alpha_j s+\beta_j}{[s-(\sigma_j+j\omega_j)][s-p(\sigma_j-j\omega_j)]}\]</span></p><p>对其做 Laplace 逆变换，得到理想脉冲作用下的输出</p><p><span class="math display">\[c(t)=\sum_{i=1}^{k}c_ie^{p_it}+\sum_{j=1}^{r}e^{\sigma_j t}(\alpha_j\cos\omega_j t+\beta_j sin\omega_j t)\]</span></p><blockquote><p>注意，次形式仅适用于没有重根的情况，在有重根时部分系数带有 <spanclass="math inline">\(t\)</span> 的幂次</p></blockquote></li></ul><table><thead><tr><th style="text-align: left;">情况</th><th style="text-align: left;"><spanclass="math inline">\(p_i&lt;0\)</span>，<spanclass="math inline">\(\sigma_j&lt;0\)</span></th><th style="text-align: left;"><span class="math inline">\(p_i\le0\)</span>，<span class="math inline">\(\sigma_j\le 0\)</span> 且 <spanclass="math inline">\(p_i=0\)</span> 或 <spanclass="math inline">\(\sigma_j=0\)</span> 时重根</th><th style="text-align: left;"><spanclass="math inline">\(p_i&gt;0\)</span> 或 <spanclass="math inline">\(\sigma_j&gt;0\)</span>，或 <spanclass="math inline">\(p_i=0\)</span>，<spanclass="math inline">\(\sigma_j=0\)</span> 的根为复根</th></tr></thead><tbody><tr><td style="text-align: left;">系统输出</td><td style="text-align: left;"><span class="math inline">\(c(t)\to0\)</span></td><td style="text-align: left;"><span class="math inline">\(c(t)\)</span>有界</td><td style="text-align: left;"><span class="math inline">\(c(t)\)</span>无界</td></tr><tr><td style="text-align: left;">输出形式</td><td style="text-align: left;"><spanclass="math inline">\(r=0\)</span>，趋于单调衰减<br><spanclass="math inline">\(r\neq 0\)</span>，趋于振荡衰减</td><td style="text-align: left;"><spanclass="math inline">\(r=0\)</span>，趋于常数<br><spanclass="math inline">\(r\neq 0\)</span>，趋于振荡常数</td><td style="text-align: left;">趋于无穷大</td></tr><tr><td style="text-align: left;">根的位置</td><td style="text-align: left;"><spanclass="math inline">\(r=0\)</span>，位于实轴负半轴<br><spanclass="math inline">\(r\neq 0\)</span>，位于左半复平面开平面</td><td style="text-align: left;"><spanclass="math inline">\(r=0\)</span>，位于实轴非正半轴<br><spanclass="math inline">\(r\neq 0\)</span>，位于左半复平面闭平面</td><td style="text-align: left;"><spanclass="math inline">\(r=0\)</span>，位于实轴非负半轴<br><spanclass="math inline">\(r\neq 0\)</span>，位于右半复平面闭平面</td></tr></tbody></table><p>根据表可以得到线性系统稳定的充要条件</p><ul><li><strong>闭环系统</strong>的特征方程所有根均具有复实部也可以说，闭环系统的特征方程所有根均位于复平面的左半平面内</li></ul><p>稳定线性系统的输出性质</p><ul><li>稳定性仅取决于系统自身的固有特性，与外界条件无关</li><li>稳定系统的脉冲应随 <span class="math inline">\(t\to\infty\)</span>而衰减至零，不稳定系统则发散</li><li>稳定系统在增幅有界的输入信号下，输出增幅有界</li></ul><h4 id="稳定性的判别方法">稳定性的判别方法</h4><ul><li>直接求根<ul><li>直接解微分方程：适用于低阶系统</li><li>根轨迹法 通过绘制闭环极值点随开环某参数变化的轨迹判断闭环稳定性</li><li>利用计算机数值解或符号解</li></ul></li><li>求特征根的范围<ul><li>劳斯判据</li><li>Nyquist 判据和 Bode 图<ul><li>根据开环频率特性判断闭环稳定性</li><li>通过实验获取频率特性曲线，较为实用</li></ul></li></ul></li><li>李雅普诺夫判据 非线性的任意阶系统</li><li>波波夫法 非线性儒里叶型的时变系统</li><li>相平面法 多用于一二阶非线性系统</li></ul><p>主要研究劳斯判据</p><h5 id="劳斯判据">劳斯判据</h5><p>通过特征方程的系数来分析系统稳定性的一种代数判据</p><p>系统的特征方程为</p><p><span class="math display">\[a_ns^n+a_{n-1}s^{n-1}+\dots+a_1s+a_0=0\]</span></p><ul><li>所有根均分布在左半平面的<strong>必要条件</strong>方程的所有系数均为正（PPT 表述存在问题，应该是同正同负？）</li></ul><p>劳斯判据适用于实系数代数方程</p><h6 id="步骤">步骤</h6><ol type="1"><li><p>将特征方程的系数按照规则排成两行</p><ul><li>第一行 <span class="math inline">\(s^n\)</span>：<spanclass="math inline">\(a_n,a_{n-2},a_{n-4},\dots\)</span></li><li>第二行 <span class="math inline">\(s^{n-1}\)</span>：<spanclass="math inline">\(a_{n-1},a_{n-3},a_{n-5},\dots\)</span></li></ul></li><li><p>建立劳斯表</p><ul><li>从第三行开始，每个元素 <span class="math inline">\(b_i\)</span>按下式计算，设其上一行的行首元素为 <spanclass="math inline">\(c_n\)</span>，再上一行的行首元素为 <spanclass="math inline">\(d_n\)</span></li></ul><p><span class="math display">\[b_n =\frac{-\begin{vmatrix}d_n &amp; d_{i+1}\\c_n &amp;c_{i+1}\end{vmatrix}}{c_n}=\frac{c_n d_{i+1}-d_n c_{i+1}}{c_n}\]</span></p><ul><li>即前两行行首元素和 前两行 <span class="math inline">\(b_i\)</span>右侧元素组成的行列式的负值除以前一行行首元素</li><li>劳斯表应该有 <span class="math inline">\(n+1\)</span> 行，从 <spanclass="math inline">\(s^n\)</span> 行到 <spanclass="math inline">\(s^0\)</span> 行</li></ul></li><li><p>判别稳定性</p><ul><li>如果劳斯表第一列所有元素均为正，则系统稳定</li><li>如果劳斯表第一列存在负元素，则系统不稳定，并且实部为正的根的个数等于第一列元素符号变化的次数</li></ul></li></ol><h6 id="特殊情况">特殊情况</h6><p>这些情况会出现在建立劳斯表的过程中</p><ol type="1"><li>某行行首元素为 <spanclass="math inline">\(0\)</span>，并且其他元素不为零<ul><li>可以用一个极小的正数代替 <spanclass="math inline">\(0\)</span>，继续计算</li><li>计算完成后，观察第一列符号变化的次数，如果 <spanclass="math inline">\(0\)</span> 上面项系数符号和 <spanclass="math inline">\(0\)</span>下面项系数符号相反说明有一个符号变化</li></ul></li><li>某一行元素全部为 <span class="math inline">\(0\)</span><ul><li>可用全 <span class="math inline">\(0\)</span>行放的一行构造辅助方程</li><li>利用辅助方程对 <span class="math inline">\(s\)</span>求导后得到的方程系数代替全零行的元素</li><li>实际上，有了全 <span class="math inline">\(0\)</span>行就说明系统是临界稳定的</li></ul></li></ol><h3 id="稳态特征分析">稳态特征分析</h3><h4 id="稳态误差">稳态误差</h4><ul><li>通常被称为稳态性能</li><li>是反映系统的控制精度的一种度量</li><li>与系统的结构、<strong>输入信号的形式</strong>有很大的关系</li><li>不稳定的系统无稳态误差</li></ul><p>控制系统设计的任务是保证系统在稳定的前提下，尽量减小甚至消除稳态误差</p><p>任何一个稳定系统的误差信号 <span class="math inline">\(e(t)\)</span>都可以看作是两个部分的叠加+</p><p><span class="math display">\[e(t)=\mathcal{L}^{-1}[E(s)]=\mathcal{L}^{-1}{\Phi_e(s)R(s)}=e_{ts}(t)+e_{ss}(t)\]</span></p><ul><li>e_ts(t)：暂态分量<ul><li>是误差信号中随时间推移而逐渐衰减、最终消失的部分</li><li>反映了系统在响应初期的震荡、超调等过度过程</li><li>当 <span class="math inline">\(\displaystyle t\to\infty\)</span>时，<span class="math inline">\(e_{ts}(t)\to 0\)</span></li></ul></li><li>e_ss(t)：稳态分量<ul><li>是误差信号中在系统达到稳态后稳定保留的部分</li><li>反映了系统在长期运行中的控制精度</li><li>当 <span class="math inline">\(\displaystyle t\to\infty\)</span>时，<span class="math inline">\(e_{ss}(t)\)</span>保持恒定，这个值就是<strong>稳态误差</strong></li></ul></li></ul><h5 id="误差的两种定义">误差的两种定义</h5><ul><li>输入端定义 系统的输入信号与主反馈信号之差</li><li>输出端定义 系统输出量实际值与期望值之差</li></ul><h4 id="laplace-终值定理">Laplace 终值定理</h4><p>如果一个函数值 <span class="math inline">\(\displaystylee(t)\)</span> 当 <span class="math inline">\(\displaystylet\to\infty\)</span> 时存在一个有限的极限值，那么这个值可以通过其 Laplace变换 <span class="math inline">\(E(s)\)</span> 来计算</p><p><span class="math display">\[e_{ss}=\lim_{t\to\infty}e(t)=\lim_{s\to 0}sE(s)\]</span></p><p>当我们知道系统的传递函数和输入信号的 Laplace 变换时，可以通过计算<span class="math inline">\(sE(s)\)</span> 在 <spanclass="math inline">\(s\to 0\)</span> 时的极限来求取稳态误差，这比先对<span class="math inline">\(E(s)\)</span> 做逆变换再求极限要简单得多</p><p>在典型的反馈控制系统中，误差信号 <spanclass="math inline">\(E(s)\)</span> 与输入信号 <spanclass="math inline">\(R(s)\)</span> 之间和开环传递函数 <spanclass="math inline">\(G(s)H(s)\)</span> 之间的关系为</p><p><span class="math display">\[E(s)=、R(s)-C(s)=R(s)-\frac{G(s)}{1+G(s)H(s)}\cdot H(s)R(s)=\frac{1}{1+G(s)H(s)}R(s)\]</span></p><p>将其带入 Laplace 终值定理中，得到稳态误差的计算公式</p><p><span class="math display">\[e_{ss}=\lim_{s\to 0}sE(s)=\lim_{s\to 0}\frac{s}{1+G(s)H(s)}R(s)\]</span></p><h4 id="扰动下的稳态误差">扰动下的稳态误差</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E6%89%B0%E5%8A%A8%E8%BE%93%E5%85%A5%E6%96%B9%E6%A1%86%E5%9B%BE.png"alt="扰动输入方框图" /><figcaption aria-hidden="true">扰动输入方框图</figcaption></figure><p>这张方框图在研究扰动输入时等效为</p><p><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E6%89%B0%E5%8A%A8%E8%BE%93%E5%85%A5%E6%96%B9%E6%A1%86%E5%9B%BE%E7%AD%89%E6%95%88.drawio.png" /></p><p>其误差对扰动的传递函数为</p><p><span class="math display">\[\Phi_e(s)=\frac{E(s)}{N(s)}=\frac{-G_1(s)}{1+G_1(s)G_2(s)}\]</span></p><p>当误差输入 <span class="math inline">\(\displaystyleN(s)=\frac{1}{s}\)</span> 时，稳态误差为</p><p><span class="math display">\[e_{ss}=\lim_{s\to 0}sE(s)=\lim_{s\to0}\frac{-G_2(s)H(s)}{1+G_1(s)GH_2(s)H_(s)}\cdot\frac{1}{s}=\frac{-G_2(0)H(0)}{1+G_1(0)G_2(0)H(0)}\approx-\frac{1}{G_1(0)}\ (G_1(0)G_2(0)\gg 1)\]</span></p><h4 id="稳态误差与输入">稳态误差与输入</h4><ul><li>稳态误差<ul><li>输入有关</li><li>系统结构有关</li></ul></li></ul><p>三种典型输入信号</p><ul><li>单位阶跃信号<ul><li><span class="math inline">\(r(t)=1\)</span></li><li><span class="math inline">\(R(s)=\frac{1}{s}\)</span></li></ul></li><li>单位速度信号<ul><li><span class="math inline">\(r(t)=t\)</span></li><li><span class="math inline">\(R(s)=\frac{1}{s^2}\)</span></li></ul></li><li>单位加速度信号<ul><li><span class="math inline">\(r(t)=\frac{1}{2}t^2\)</span></li><li><span class="math inline">\(R(s)=\frac{1}{s^3}\)</span></li></ul></li></ul><h4 id="系统类型与稳态误差系数">系统类型与稳态误差系数</h4><p>开环传递函数（时间常数形式）</p><p><span class="math display">\[G(s)H(s)=\frac{K(\tau&#39;_1s+1)(\tau&#39;_2s+1)\cdots(\tau_ms+1)}{s^N(T_1s+1)(T_2s+1)\cdots(T_{n-M}s+1)}\]</span></p><ul><li>N：串联积分器的个数</li></ul><p>根据系统中积分器的个数 <spanclass="math inline">\(N\)</span>，将系统分为不同的类型</p><ul><li>N=0：零型系统</li><li>N=1：一型系统</li><li>N=2：二型系统</li></ul><p>性质</p><ul><li>根据已知的输入信号形式，可以判断是否存在稳态误差以及稳态误差的大小</li><li>系统阶数 <span class="math inline">\(m,n\)</span> 与系统类型 <spanclass="math inline">\(N\)</span> 无关，且不影响稳态误差的数值</li></ul><p><span class="math display">\[\lim_{s\to 0}G(s)H(s)=\lim_{s\to0}\frac{K(\tau&#39;_1s+1)(\tau&#39;_2s+1)\cdots(\tau_ms+1)}{s^N(T_1s+1)(T_2s+1)\cdots(T_{n-M}s+1)}=\lim_{s\to0}\frac{K}{s^N}\]</span></p><h4 id="单位阶跃信号作用下的稳态误差">单位阶跃信号作用下的稳态误差</h4><p><span class="math display">\[e_{ss}=\lim_{s\to 0}sE(s)=\lim_{s\to 0}\frac{s}{1+G(s)H(s)}\cdot\frac{1}{s}=\lim_{s\to0}\frac{1}{1+G(s)H(s)}=\frac{1}{1+K_p}=\begin{cases}\frac{1}{1+K},&amp;N=0\\0,&amp;N\ge1\end{cases}\]</span></p><p>稳态误差系数 <span class="math inline">\(\displaystyle K_p=\lim_{s\to0}G(s)H(s)\)</span>（位置误差系数）</p><ul><li>0 型系统：<span class="math inline">\(K_p=K\)</span><ul><li>被称为有差系统</li><li>误差大小与开环放大系数 <span class="math inline">\(K\)</span>有关</li><li>在稳定性允许的范围内，增大 <span class="math inline">\(K\)</span>可减小稳态误差</li></ul></li><li>1 型及以上系统：<span class="math inline">\(K_p=\infty\)</span></li></ul><h4 id="单位速度信号作用下的稳态误差">单位速度信号作用下的稳态误差</h4><p><span class="math display">\[e_{ss}=\lim_{s\to 0}sE(s)=\lim_{s\to 0}\frac{s}{1+G(s)H(s)}\cdot\frac{1}{s^2}=\lim_{s\to0}\frac{1}{s(1+G(s)H(s))}=\frac{1}{K_v}=\begin{cases}\infty,&amp;N=0\\\frac{1}{K},&amp;N=1\\0,&amp;N\ge2\end{cases}\]</span></p><p>稳态误差系数 <span class="math inline">\(\displaystyle K_v=\lim_{s\to0}s G(s)H(s)\)</span>（速度误差系数）</p><ul><li>0 型系统：<span class="math inline">\(K_v=0\)</span></li><li>1 型系统：<span class="math inline">\(K_v=K\)</span><ul><li>输出能跟踪输入速度信号的变化</li><li>稳态误差大小与开环放大系数 <span class="math inline">\(K\)</span>有关</li></ul></li><li>2 型及以上系统：<span class="math inline">\(K_v=\infty\)</span></li></ul><h4id="单位加速度信号作用下的稳态误差">单位加速度信号作用下的稳态误差</h4><p><span class="math display">\[e_{ss}=\lim_{s\to 0}sE(s)=\lim_{s\to 0}\frac{s}{1+G(s)H(s)}\cdot\frac{1}{s^3}=\lim_{s\to0}\frac{1}{s^2(1+G(s)H(s))}=\frac{1}{K_a}=\begin{cases}\infty,&amp;N=0\\\infty,&amp;N=1\\\frac{1}{K},&amp;N=2\\0,&amp;N\ge3\end{cases}\]</span></p><p>稳态误差系数 <span class="math inline">\(\displaystyle K_a=\lim_{s\to0}s^2 G(s)H(s)\)</span>（加速度误差系数）</p><ul><li>0 型系统：<span class="math inline">\(K_a=0\)</span></li><li>1 型系统：<span class="math inline">\(K_a=0\)</span></li><li>2 型系统：<span class="math inline">\(K_a=K\)</span><ul><li>输出能跟踪输入加速度信号的变化</li><li>稳态误差大小与开环放大系数 <span class="math inline">\(K\)</span>有关</li></ul></li><li>3 型及以上系统：<span class="math inline">\(K_a=\infty\)</span></li></ul><h4 id="总结">总结</h4><table><thead><tr><th style="text-align: left;">系统型号</th><th style="text-align: left;">误差 <spanclass="math inline">\(K_p\)</span></th><th style="text-align: left;">$K_v</th><th style="text-align: left;">系数 <spanclass="math inline">\(K_a\)</span></th><th style="text-align: left;">阶跃输入 <spanclass="math inline">\(r(t)=u(t)\)</span></th><th style="text-align: left;">速度输入 <spanclass="math inline">\(r(t)=t\)</span></th><th style="text-align: left;">加速度输入 <spanclass="math inline">\(r(t)=\frac{1}{2}t^2\)</span></th></tr></thead><tbody><tr><td style="text-align: left;">0 型</td><td style="text-align: left;"><spanclass="math inline">\(K\)</span></td><td style="text-align: left;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\frac{1}{1+K}\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: left;">1 型</td><td style="text-align: left;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: left;"><spanclass="math inline">\(K\)</span></td><td style="text-align: left;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\frac{1}{K}\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\infty\)</span></td></tr><tr><td style="text-align: left;">2 型</td><td style="text-align: left;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\infty\)</span></td><td style="text-align: left;"><spanclass="math inline">\(K\)</span></td><td style="text-align: left;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(0\)</span></td><td style="text-align: left;"><spanclass="math inline">\(\frac{1}{K}\)</span></td></tr></tbody></table><h4 id="减小稳态误差的方法">减小稳态误差的方法</h4><ul><li>提高开环增益 <span class="math inline">\(K\)</span><ul><li>增大 <span class="math inline">\(K\)</span>可减小稳态误差，但会影响系统稳定性</li></ul></li><li>提高开环传递函数中串联积分环节的个数 <spanclass="math inline">\(N\)</span><ul><li>增加积分环节可提高系统类型，从而减小稳态误差</li><li>但会影响系统的动态性能，可能引起系统振荡</li><li><span class="math inline">\(N\)</span> 一般不超过 <spanclass="math inline">\(2\)</span></li></ul></li><li>补偿法</li></ul><h3 id="动态特性分析">动态特性分析</h3><h4 id="概念">概念</h4><p>控制系统的输出为</p><p><span class="math display">\[c(t)=c_s(t)+c_t(t)\]</span></p><ul><li><span class="math inline">\(\displaystylec_s(t)\)</span>：稳态部分</li><li><span class="math inline">\(\displaystyle c_t(t)\)</span></li></ul><p>动态相应也叫瞬态响应</p><ul><li>对应系统从初始状态到接近稳定状态的相应<ul><li>通常使用零初始状态条件下的单位阶跃响应的动态特性衡量</li><li>输入只会影响稳态分量</li><li>系统分析的准确度取决于数学模型描述的真实程度</li><li>希望系统有很快的响应速度<ul><li>即在控制信号的作用下，系统的输出能很快地随控制信号变化</li></ul></li><li>与稳定性的关系<ul><li>动态响应对稳定系统才有意义</li><li>不稳定系统的动态响应是发散的</li></ul></li></ul></li></ul><h4 id="动态性能指标">动态性能指标</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511101440702.png"alt="动态性能指标合集" /><figcaption aria-hidden="true">动态性能指标合集</figcaption></figure><ul><li>延迟时间 <span class="math inline">\(t_d\)</span><ul><li>输出达到稳态值的 <span class="math inline">\(50\%\)</span>所需的时间</li></ul></li><li>上升时间 <span class="math inline">\(t_r\)</span><ul><li>有振荡系统输出从 <span class="math inline">\(0\)</span>到首次达到稳态值的时间</li><li>无振荡系统输出从 <span class="math inline">\(10\%\)</span> 到 <spanclass="math inline">\(90\%\)</span> 稳态值的时间</li></ul></li><li>峰值时间 <span class="math inline">\(t_p\)</span><ul><li>输出首次达到峰值所需的时间</li></ul></li><li>超调量 <span class="math inline">\(\sigma_p\)</span><ul><li><span class="math inline">\(\displaystyle\sigma_p=\frac{c(t_p)-c_\infty}{c_\infty}\times 100 \%\)</span></li></ul></li><li>调整时间 <span class="math inline">\(t_s\)</span><ul><li>输出进入并保持在稳态值的预定范围 <spanclass="math inline">\(\Delta\)</span> 内所需的时间</li></ul></li><li>误差范围 <span class="math inline">\(\Delta\)</span><ul><li>一般取稳态值的 <span class="math inline">\(\pm 2\%\)</span> 或 <spanclass="math inline">\(\pm 5\%\)</span></li></ul></li></ul><h4 id="一阶系统动态特性">一阶系统动态特性</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E4%B8%80%E9%98%B6%E7%B3%BB%E7%BB%9F.png"alt="一阶系统" /><figcaption aria-hidden="true">一阶系统</figcaption></figure><p>一阶系统闭环传递函数为</p><p><span class="math display">\[\frac{C(s)}{R(s)}=\frac{1}{1+Ts}\]</span></p><h5 id="单位阶跃响应">单位阶跃响应</h5><p><span class="math display">\[C(s)=\frac{1}{Ts+1}\cdot \frac{1}{s}=\frac{1}{s}-\frac{T}{Ts+1}\]</span></p><p>对其做 Laplace 逆变换，得到单位阶跃响应输出</p><p><span class="math display">\[c(t)=1-e^{-\frac{t}{T}}\]</span></p><ul><li>无振荡、按照指数规律单调上升</li><li>延迟时间 <span class="math inline">\(t_d=0.69T\)</span></li><li>上升时间 <span class="math inline">\(t_r=2.2T\)</span></li><li>调整时间<ul><li><span class="math inline">\(t_s=4T\)</span>（<spanclass="math inline">\(\Delta=\pm 2\%\)</span>）</li><li><span class="math inline">\(t_s=3T\)</span>（<spanclass="math inline">\(\Delta=\pm 5\%\)</span>）</li></ul></li><li>特征根<ul><li><span class="math inline">\(s=-\frac{1}{T}\)</span></li><li>为 <span class="math inline">\(\displaystyle-\frac{\mathrm{d}c(t)}{\mathrm{d}t}|_{t=0}\)</span>，可以通过实验得到</li></ul></li></ul><h5 id="单位脉冲响应">单位脉冲响应</h5><p><span class="math display">\[C(s)=\frac{1}{1+Ts}\cdot 1=\frac{1}{Ts+1}\]</span></p><p>对其做 Laplace 逆变换，得到单位脉冲响应输出</p><p><span class="math display">\[c(t)=\frac{1}{T}e^{-\frac{t}{T}}\]</span></p><h5 id="单位速度响应">单位速度响应</h5><p><span class="math display">\[C(s)=\frac{1}{1+Ts}\cdot\frac{1}{s^2}=\frac{1}{s^2}-\frac{T}{s}+\frac{T^2}{Ts+1}\]</span></p><p>对其做 Laplace 逆变换，得到单位速度响应输出</p><p><span class="math display">\[c(t)=t-T+Te^{-\frac{t}{T}}\]</span></p><ul><li>稳态分量 <span class="math inline">\(\displaystylec_s(t)=t-T\)</span></li><li>稳态误差 <span class="math inline">\(e_{ss}=T\)</span></li><li>瞬态分量 <span class="math inline">\(\displaystylec_t(t)=Te^{-\frac{t}{T}}\)</span></li></ul><h5 id="单位加速度响应">单位加速度响应</h5><p><span class="math display">\[C(s)=\frac{1}{1+Ts}\cdot\frac{1}{s^3}=\frac{1}{s^3}-\frac{T}{s^2}+\frac{T^2}{s}-\frac{T^3}{Ts+1}\]</span></p><p>对其做 Laplace 逆变换，得到单位加速度响应输出</p><p><span class="math display">\[c(t)=\frac{1}{2}t^2-Tt+T^2-T^2e^{-\frac{t}{T}}\]</span></p><h4 id="二阶系统动态特性">二阶系统动态特性</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E4%BA%8C%E9%98%B6%E7%B3%BB%E7%BB%9F.png"alt="二阶系统" /><figcaption aria-hidden="true">二阶系统</figcaption></figure><p>二阶系统闭环传递函数为</p><p><span class="math display">\[\Phi(S)=\frac{C(s)}{R(s)}=\frac{K}{Ts^2+s+K}=\frac{\frac{K}{T}}{s^2+\frac{1}{T}s+\frac{K}{T}}\]</span></p><p>记</p><ul><li>无阻尼（自然）振荡角频率 <span class="math inline">\(\displaystyle\omega_n=\sqrt{\frac{K}{T}}\)</span></li><li>阻尼比 <span class="math inline">\(\displaystyle\xi=\frac{1}{2\sqrt{K T}}\)</span></li></ul><p>传递函数可写为</p><p><span class="math display">\[\Phi(S)=\frac{\omega_n^2}{s^2+2\xi \omega_n s+\omega_n^2}\]</span></p><p>按照阻尼比 <span class="math inline">\(\xi\)</span>的不同，二阶系统可分为三种类型</p><ul><li>欠阻尼系统：<span class="math inline">\(0&lt;\xi&lt;1\)</span></li><li>临界阻尼系统：<span class="math inline">\(\xi=1\)</span></li><li>过阻尼系统：<span class="math inline">\(\xi&gt;1\)</span></li></ul><h5 id="二阶系统的特征方程">二阶系统的特征方程</h5><p><span class="math display">\[s^2+2\xi \omega_n s+\omega_n^2=0\]</span></p><ul><li><p>两个特征根</p><p><span class="math display">\[s_{1,2}=-\xi \omega_n \pm \omega_n \sqrt{\xi^2-1}\]</span></p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511101730974.png"alt="根的分布情况" /><figcaption aria-hidden="true">根的分布情况</figcaption></figure><h5 id="欠阻尼">欠阻尼</h5><p>有一对共轭复根</p><p><span class="math display">\[s_{1,2}=-\xi\omega_n\pm j\omega_n\sqrt{1-\xi^2}=-\sigma\pm j\omega_d\]</span></p><ul><li>衰减系数 <span class="math inline">\(\displaystyle \sigma=\xi\omega_n\)</span></li><li>阻尼振荡角频率 <span class="math inline">\(\displaystyle\omega_d=\omega_n \sqrt{1-\xi^2}\)</span></li><li>记 <span class="math inline">\(\cos\theta=\xi\)</span>，则 <spanclass="math inline">\(\sin\theta=\sqrt{1-\xi^2}\)</span>，<spanclass="math inline">\(\displaystyle\tan\theta=\frac{\sqrt{1-\xi^2}}{\xi}\)</span></li></ul><p>以阶跃响应为例</p><p><span class="math display">\[\begin{aligned}  C(s)&amp;=\frac{\omega_n^2}{s^2+2\xi \omega_ns+\omega_n^2}\cdot\frac{1}{s}\\      &amp;=\frac{1}{s}-\frac{s+\xi\omega_n}{(s+\xi\omega_n^2)+\omega_d^2}-\frac{\xi\omega_n}{(s+\xi\omega_n)^2+\omega_d^2}\end{aligned}\]</span></p><p>对其做 Laplace 逆变换，得到单位阶跃响应输出</p><p><span class="math display">\[c(t)=1-\frac{e^{-\xi \omega_n t}}{\sqrt{1-\xi^2}}\sin(\omega_d t+\theta)\]</span></p><p>为振荡衰减曲线，振荡频率为 <spanclass="math inline">\(\displaystyle\omega_d\)</span></p><p>包络线为</p><p><span class="math display">\[1 \pm \frac{1}{\sqrt{1-\xi^2}} e^{-\xi\omega_n t}\]</span></p><ul><li>时间常数 <span class="math inline">\(\xi\omega_n\)</span></li><li>衰减系数 <spanclass="math inline">\(\frac{1}{\xi\omega_n}\)</span></li></ul><h6 id="阻尼比系数-xi">阻尼比系数 <spanclass="math inline">\(\xi\)</span></h6><ul><li>阻尼比系数小<ul><li>震荡强</li><li>上升时间短</li><li>超调量大</li><li>调整时间长</li><li>稳态误差增加</li></ul></li><li>阻尼比系数大<ul><li>上升时间长</li></ul></li></ul><p>所以一般选取 <span class="math inline">\(0.5\le \xi \le0.8\)</span></p><p>最佳的阻尼比为 <span class="math inline">\(0.707\)</span></p><h6 id="峰值时间-t_p">峰值时间 <spanclass="math inline">\(t_p\)</span></h6><p><span class="math display">\[\frac{\mathrm{d}c(t)}{\mathrm{d}t}\vert_{t=t_p}=0\]</span></p><p>整理得到</p><p><span class="math display">\[\omega_dt_p=0,\pi,2\pi,3\pi,\dots\]</span></p><p>取第一个正根，得到</p><p><span class="math display">\[t_p=\frac{\pi}{\omega_d}=\frac{\pi}{\omega_n \sqrt{1-\xi^2}}\]</span></p><p>峰值时间 <span class="math inline">\(t_p\)</span> 与极点虚部 <spanclass="math inline">\(\omega_d\)</span> 成反比，并且当 <spanclass="math inline">\(\xi\)</span> 一定时，极点离实轴越远，<spanclass="math inline">\(t_p\)</span> 越小</p><h6 id="超调量-sigma_p">超调量 <spanclass="math inline">\(\sigma_p\)</span></h6><p><span class="math display">\[\sigma_p=c(t_p)-1=e^{-\frac{\xi \pi}{\sqrt{1-\xi^2}}}\times 100\%\]</span></p><p>超调量 <span class="math inline">\(\sigma_p\)</span> 仅与阻尼比 <spanclass="math inline">\(\xi\)</span> 有关</p><ul><li>阻尼比 <span class="math inline">\(\xi\)</span> 越大，超调量 <spanclass="math inline">\(\sigma_p\)</span> 越小</li><li>当 <span class="math inline">\(\xi\to 0\)</span> 时，<spanclass="math inline">\(\sigma_p\to 100\%\)</span></li><li>当 <span class="math inline">\(\xi\ge 0.69\)</span> 时，<spanclass="math inline">\(\sigma_p\le 5\%\)</span></li></ul><h6 id="上升时间-t_r">上升时间 <spanclass="math inline">\(t_r\)</span></h6><p><span class="math display">\[c(t_r)=1-\frac{e^{-\xi \omega_n t_r}}{\sqrt{1-\xi^2}}\sin(\omega_dt_r+\theta)=1\]</span></p><p><span class="math display">\[t_r=\frac{\pi-\theta}{\omega_d}=\frac{\pi-\arccos\xi}{\omega_n\sqrt{1-\xi^2}}\]</span></p><ul><li>当 <span class="math inline">\(\xi\)</span> 一定，<spanclass="math inline">\(\omega_n\)</span> 越大，<spanclass="math inline">\(t_r\)</span> 越小</li><li>当 <span class="math inline">\(\omega_n\)</span> 一定，<spanclass="math inline">\(\xi\)</span> 越大，<spanclass="math inline">\(t_r\)</span> 越大</li></ul><h6 id="调整时间-t_s">调整时间 <spanclass="math inline">\(t_s\)</span></h6><p>定义为从系统开始响应起，直到响应曲线 <spanclass="math inline">\(c(t)\)</span> 进入并永久保持在终值 <spanclass="math inline">\(1\)</span> 的一个小的误差带 <spanclass="math inline">\(\Delta\)</span> （例如 <spanclass="math inline">\(5\%\)</span> 或 <spanclass="math inline">\(3\%\)</span>）之内所需的最短时间</p><p>以包络线来近似研究调整时间问题</p><p><span class="math display">\[\left\vert 1-c(s)\right\vert \approx \frac{e^{-\xi\omega_nt_s}}{\sqrt{1-\xi^2}}=\Delta\]</span></p><p><span class="math display">\[t_s=-\frac{\ln(\Delta \sqrt{1-\xi^2})}{\xi \omega_n}\]</span></p><ul><li><span class="math inline">\(\Delta=5\%\)</span> 时，<spanclass="math inline">\(t_s\approx \frac{3}{\xi \omega_n}\)</span></li><li><span class="math inline">\(\Delta=2\%\)</span> 时，<spanclass="math inline">\(t_s\approx \frac{4}{\xi \omega_n}\)</span></li></ul><p>调整时间 <span class="math inline">\(t_s\)</span> 与极点实部 <spanclass="math inline">\(\sigma=\xi \omega_n\)</span> 成反比，并且当 <spanclass="math inline">\(\xi\)</span> 一定时，极点离虚轴越远，<spanclass="math inline">\(t_s\)</span> 越小</p><p>超调量 <span class="math inline">\(\sigma_p\)</span> 的值由 <spanclass="math inline">\(\xi\)</span> 决定，若 <spanclass="math inline">\(\xi\)</span> 不变，通过调整 <spanclass="math inline">\(\omega_n\)</span> 可以做到在不影响 <spanclass="math inline">\(\sigma_p\)</span> 的前提下，减小 <spanclass="math inline">\(t_s\)</span>，加快系统的响应速度</p><h6 id="总结-1">总结</h6><p>二阶系统单位阶跃响应</p><p><span class="math display">\[c(t)=1-\frac{e^{-\xi \omega_n t}}{\sqrt{1-\xi^2}}\sin(\omega_dt+\theta)s\]</span></p><ul><li><p>上升时间</p><p><span class="math display">\[t_r=\frac{\pi-\arccos\xi}{\omega_n \sqrt{1-\xi^2}}\]</span></p></li><li><p>峰值时间</p><p><span class="math display">\[t_p=\frac{\pi}{\omega_n \sqrt{1-\xi^2}}\]</span></p></li><li><p>超调量</p><p><span class="math display">\[\sigma_p=e^{-\frac{\xi \pi}{\sqrt{1-\xi^2}}}\times 100\%\]</span></p></li><li><p>调整时间</p><p><span class="math display">\[t_s=-\frac{\ln(\Delta \sqrt{1-\xi^2})}{\xi \omega_n}\]</span></p></li></ul><h5 id="临界阻尼">临界阻尼</h5><p>特征根为两个相等的实根</p><p><span class="math display">\[s_{1,2}=-\omega_n\]</span></p><p><span class="math display">\[C(s)=\frac{\omega_n^2}{(s+\omega_n)^2}\cdot\frac{1}{s}=\frac{1}{s}-\frac{1}{s+\omega_n}-\frac{\omega_n}{(s+\omega_n)^2}\]</span></p><p>对其做 Laplace 逆变换，得到单位阶跃响应输出</p><p><span class="math display">\[c(t)=1-(1+\omega_n t)e^{-\omega_n t}\]</span></p><h5 id="过阻尼">过阻尼</h5><p>特征根为两个不等的实根</p><p><span class="math display">\[s_{1,2}=-\xi \omega_n \pm \omega_n \sqrt{\xi^2-1}\]</span></p><p><span class="math display">\[c(s)=\frac{\omega_n^2}{s(s+\frac{1}{T_1})(s+\frac{1}{T_2})}\]</span></p><p><span class="math display">\[c(t)=1+\frac{1}{\frac{T_2}{T_1}-1}e^{-\frac{t}{T_1}}-\frac{1}{\frac{T_2}{T_1}-1}e^{-\frac{t}{T_2}}\]</span></p><p>单调增加的曲线，没有超调和振荡，调节时间较长，系统反应迟缓</p><h6 id="无阻尼">无阻尼</h6><p>特征根为两个共轭虚根</p><p><span class="math display">\[s_{1,2}=\pm j \omega_n\]</span></p><p><span class="math display">\[c(t)=1-\cos \omega_n t\]</span></p><p>为振荡频率为 <span class="math inline">\(\displaystyle\omega_n\)</span> 的等幅振荡曲线，不能达到稳态</p><h4 id="高阶系统的动态响应">高阶系统的动态响应</h4><p>高阶系统指的是三阶以上的系统</p><p>使用计算机仿真或者近似降阶为二阶系统来处理</p><p>控制系统的闭环传递函数为</p><p><span class="math display">\[\frac{C(s)}{R(s)}=\frac{b_ms^m+b_{m-1}s^{m-1}+\dots+b_1s+b_0}{a_ns^n+a_{n-1}s^{n-1}+\dots+a_1 s+a_0}\]</span></p><p>其阶跃响应为</p><p><span class="math display">\[C(s)=\frac{K\prod(s+z_i)}{\prod(s+p_j)\prod(s^2+2\xi_k\omega_{nk}s+\omega_{nk}^2)}\cdot \frac{1}{s}\]</span></p><p><span class="math display">\[\begin{aligned}  c(t)&amp;=a_0+\sum_{j=1}^q a_je^{-p_jt}+\sum_{i=1}^re^-\xi_k\omega_kt(B_k\cos\omega_kt\sqrt{1-\xi_k^2}+C_k\sin\omega_kt\sqrt{1-\xi_k^2})\\      &amp;=a_0+\sum_{J=1}^q a_je^{-p_jt}+\sum_{i=1}^rD_ke^{-\xi_k\omega_kt}\sin(\omega_kt\sqrt{1-\xi_k^2}+\varphi_k)\end{aligned}\]</span></p><ul><li><p><strong>主导极点</strong></p><ul><li>距离虚轴最近的极点，比其它极点到虚轴的距离小 5倍以上，且附近无零点</li><li>系统的动态响应将由主导极点决定</li><li>高阶系统的主导极点通常为一对共轭复极点</li></ul></li><li><p><strong>附加零点、极点</strong></p><ul><li>零点或极点距离虚轴的距离是主导极点的两倍以上</li><li>对动态响应的影响可以忽略不计</li></ul></li><li><p><strong>偶极子</strong></p><ul><li>同一位置或相距很近的闭环零极点<ul><li>它们之间的距离是它们到主导极点距离的 <spanclass="math inline">\(\frac{1}{10}\)</span> 或更小</li></ul></li><li>对系统的动态响应影响很小</li></ul></li><li><p><strong>响应曲线</strong></p><ul><li>由小振荡曲线、大振荡曲线、指数曲线叠加而成</li><li>形状取决于闭环零点：各分量幅值大小</li></ul></li><li><p><strong>动态响应</strong></p><ul><li>稳态分量的类型取决于输入函数的极点</li><li>动态分量取决于系统闭环传递函数的极点</li><li>类型取决于闭环极点：指数型、正弦振荡型</li></ul></li></ul><h2 id="根轨迹法">根轨迹法</h2><h3 id="根轨迹法的概念">根轨迹法的概念</h3><p>根轨迹法是通过绘制闭环极点随开环某参数变化的轨迹来判断闭环系统稳定性的一种图解方法，其参变量为系统增益<span class="math inline">\(K_1\)</span></p><p>描述的是当 <span class="math inline">\(K_1\)</span> 从 <spanclass="math inline">\(0\)</span> 变化到 <spanclass="math inline">\(\infty\)</span>时，闭环系统极点在复平面上的运动轨迹</p><ul><li>常规根轨迹：<span class="math inline">\(0\le K_1&lt;+\infty\)</span> 时的根轨迹，简称为根轨迹</li><li>补根轨迹（余根轨迹）：<spanclass="math inline">\(-\infty&lt;K_1&lt;0\)</span> 时的根轨迹</li><li>完全根轨迹（全根轨迹）：<spanclass="math inline">\(-\infty&lt;K_1&lt;+\infty\)</span> 时的根轨迹</li></ul><h3 id="根轨迹的幅相条件">根轨迹的幅相条件</h3><p>闭环系统的特征方程为</p><p><span class="math display">\[1+G(s)H(s)=0\]</span></p><p>其中</p><p><span class="math display">\[G(s)H(s)=\frac{K_1\prod_{i=1}^m (s+z_i)}{\prod_{j=1}^n (s+p_j)}\quad(n\ge m)\]</span></p><p>根轨迹上的点均满足幅角条件和幅值条件，满足幅角条件的点都在根轨迹上</p><ul><li>通过寻找满足幅角条件的所有 <span class="math inline">\(s\)</span>点，由这些点组成根轨迹</li><li>根据幅值条件计算出对应点的 <span class="math inline">\(K_1\)</span>值</li></ul><h4 id="幅角条件">幅角条件</h4><p><span class="math display">\[\angle G(s)H(s)=\sum_{i=1}^m\angle (s+z_i)-\sum_{j=1}^n \angle(s+p_j)=\pi\pm 2k\pi,\quad k=0,1,2,\dots\]</span></p><h4 id="幅值条件">幅值条件</h4><p><span class="math display">\[\vert G(s)H(s)\vert =\frac{K_1\prod_{i=1}^m \verts+z_i\vert}{\prod_{j=1}^n \vert s+p_j\vert}=1\]</span></p><h3 id="根轨迹图的绘制">根轨迹图的绘制</h3><p>主要有两种方法</p><ol type="1"><li>试探法<ol type="1"><li>找到尽量多的满足相角条件的点</li><li>连接成光滑曲线</li><li>用幅值条件计算根轨迹上点的 <span class="math inline">\(K_1\)</span>值</li></ol></li><li>规则法<ol type="1"><li>计算出 <span class="math inline">\(K_1=0\)</span>时的特征根（开环极点）和 <span class="math inline">\(K_1\to\infty\)</span> 时的特征根（开环零点或无穷远）</li><li>根据绘制法大致画出 <spanclass="math inline">\(0&lt;K_1&lt;\infty\)</span> 时的根轨迹草图</li><li>使用幅角条件修正重要部分</li></ol></li></ol><h4 id="根轨迹绘制的十条规则">根轨迹绘制的十条规则</h4><h5 id="根轨迹的起点和终点">根轨迹的起点和终点</h5><ul><li><span class="math inline">\(n\)</span> 个起点（<spanclass="math inline">\(K_1=0\)</span>）：开环极点</li><li><span class="math inline">\(n\)</span> 个终点（<spanclass="math inline">\(K_1\to \infty\)</span>）：开环零点<ul><li><span class="math inline">\(m\)</span> 个有限零点</li><li><span class="math inline">\(n-m\)</span> 个无穷远零点</li></ul></li></ul><p>当 <span class="math inline">\(K_1\)</span> 从 <spanclass="math inline">\(0\)</span> 增加到 <spanclass="math inline">\(\infty\)</span>时，根轨迹从开环极点出发，终止于开环零点</p><h5 id="根轨迹的分支数">根轨迹的分支数</h5><ul><li>一条完整的根轨迹为一条分支</li><li>根轨迹的分支数等于开环极点数 <spanclass="math inline">\(n\)</span></li></ul><h5 id="根轨迹对称性">根轨迹对称性</h5><ul><li>根轨迹对称于实轴</li></ul><h5 id="根轨迹的渐近线">根轨迹的渐近线</h5><p>渐近线有 <span class="math inline">\(n-m\)</span> 条</p><ul><li><p>渐近线与实轴交点（渐近点）</p><p><span class="math display">\[-\lambda=-\frac{\sum_{j=1}^n p_j-\sum_{i=1}^m z_i}{n-m}\]</span></p></li><li><p>渐近线与实轴的夹角</p><p><span class="math display">\[\theta_k=\frac{\pi\pm 2k\pi}{n-m},\quad k=0,1,2,\ldots\]</span></p></li></ul><h5 id="根轨迹在实轴上的分布">根轨迹在实轴上的分布</h5><p>实轴上凡是有根轨迹的线段，其右侧（包含右端）的开环零点、极点个数之和为奇数</p><h5 id="根轨迹的分离点">根轨迹的分离点</h5><p>分离点</p><ul><li>为特征方程的重根点</li><li>不一定在实轴上</li></ul><p>分离点满足</p><p><span class="math display">\[\frac{\mathrm{d}G_1(s)H_1(s)}{\mathrm{d}s}=0\]</span></p><p>其中</p><p><span class="math display">\[G_1(s)G_2(s)=\frac{G(s)H(s)}{K_1}\]</span></p><p>分离点处的分离的根轨迹切线斜率为</p><p><span class="math display">\[\frac{1}{N}(\pi+2k\pi),\quad k=0,1,2,\ldots ,N-1\]</span></p><p>几个经验法则</p><ol type="1"><li>如果实轴上开环极点间存在根轨迹，则存在分离点</li><li>如果实轴上开环零点间存在根轨迹，则存在会合点</li><li>如果实轴上开环极点与开环零点间存在根轨迹<ul><li>要么既存在分离点又存在会合点</li><li>要么二者都不存在</li></ul></li></ol><p>分离点的必要条件等价表达式</p><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d}s}[G_1(s)H_1(s)]=0\]</span></p><ul><li><span class="math inline">\(\displaystyle\frac{\mathrm{d}K_1}{\mathrm{d}s}=0\)</span></li><li><span class="math inline">\(\displaystyle\sum_{i=1}^{m}\frac{1}{s+z_i}=\sum_{i=1}^{n}\frac{1}{s+p_i}\)</span></li></ul><h5 id="根轨迹入射角和出射角">根轨迹入射角和出射角</h5><p>出射角（或入射角）：根轨迹离开复极点（或终止复零点）处切线的倾角</p><ul><li><p>若根轨迹一个分支离开复极点 <spanclass="math inline">\(-p_a\)</span> 的出射角为 <spanclass="math inline">\(\theta_a\)</span>，则</p><p><span class="math display">\[\theta_a=\pi-\left[\sum_{i=1,i\nea}^{n}\angle(-p_a+p_i)-\sum_{j=1}^{m}\angle(-p_a+z_j)\right]+2k\pi,\quadk=0,1,2,\ldots\]</span></p></li><li><p>若根轨迹一个分支终止于复零点 <spanclass="math inline">\(-z_b\)</span> 的入射角为 <spanclass="math inline">\(\phi_b\)</span>，则</p><p><span class="math display">\[\phi_b=\pi+\left[\sum_{i=1}^{n}\angle(-z_b+p_i)-\sum_{j=1,j\neb}^{m}\angle(-z_b+z_j)\right]+2k\pi,\quad k=0,1,2,\ldots\]</span></p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511221835529.png"alt="入射角例子" /><figcaption aria-hidden="true">入射角例子</figcaption></figure><p>其中</p><p><span class="math display">\[\theta_a=\pi+2k\pi+\varphi_1-(\theta_1+\theta_2+\theta_3)\]</span></p><h5 id="根轨迹与虚轴的焦点">根轨迹与虚轴的焦点</h5><p>根轨迹与虚轴交点纵坐标为</p><p><span class="math display">\[1+G(j\omega)H(j\omega)=0\]</span></p><p>的解 <span class="math inline">\(\omega\)</span></p><p>此时系统处于临界稳定状态</p><h5 id="根轨迹的走向">根轨迹的走向</h5><p>当 <span class="math inline">\(n-m\ge 2\)</span> 时，随着 <spanclass="math inline">\(K_1\)</span>的增加，一些根轨迹分支向左方移动，另一些根轨迹分支向右方移动</p><p><span class="math display">\[G(s)H(s)=\frac{K_1(s+z_1)\cdots(s+z_m)}{(s+p_1)\cdots(s+p_n)}=\frac{K_1(s^m+\sum_{i=1}^mz_is^{m-1}+\cdots\cdots+\prod_{i=1}^mz_m)}{s^n+\sum_{j=1}^np_js^{n-1}+\cdots\cdots+\prod_{j=1}^np_j}\]</span></p><p><span class="math display">\[1+G(s)H(s)=s^n+\sum_{j=1}^n p_js^{n-1}+\cdots+\prod_{j=1}^np_j+K_1s^m+K_1\sum_{i=1}^m z_is^{m-1}+\cdots+K_1\prod_{i=1}^mz_i\]</span></p><ul><li>当满足 <span class="math inline">\(m-n\ge 2\)</span> 时，上式中<span class="math inline">\(s^{n-1}\)</span>项没有同类项可以合并，通常将其称为极点的重心</li><li>当 <span class="math inline">\(K_1\)</span>保持不变时，极点的重心保持不变，为 <spanclass="math inline">\(\displaystyle -\sum_{j=1}^{n}\frac{p_i}{n}\)</span></li></ul><h5 id="根轨迹上-k_1-的计算">根轨迹上 <spanclass="math inline">\(K_1\)</span> 的计算</h5><p><span class="math display">\[K_1=\frac{\prod_{j=1}^n \vert s+p_j\vert}{\prod_{i=1}^m \verts+z_i\vert}=\frac{G_1(s_1)H_1(s_1)\text{极点至}s_1\text{向量长度的乘积}}{G_1(s_1)H_1(s_1)\text{零点至}s_1\text{向量长度的乘积}}\]</span></p><h5 id="总结-2">总结</h5><table><thead><tr><th style="text-align: left;">序</th><th style="text-align: left;">内容</th><th style="text-align: left;">规则</th></tr></thead><tbody><tr><td style="text-align: left;">1</td><td style="text-align: left;">起点<br>终点</td><tdstyle="text-align: left;">起始于开环极点<br>终止于开环零点（包括无限零点）</td></tr><tr><td style="text-align: left;">2</td><td style="text-align: left;">分支数</td><td style="text-align: left;">等于开环传递函数的极点数（ <spanclass="math inline">\(n \ge m\)</span> ）</td></tr><tr><td style="text-align: left;">3</td><td style="text-align: left;">对称性</td><td style="text-align: left;">对称于实轴</td></tr><tr><td style="text-align: left;">4</td><td style="text-align: left;">渐近线</td><td style="text-align: left;">相交于实轴上的同一点：<br></td></tr><tr><td style="text-align: left;">5</td><td style="text-align: left;">实轴上分布</td><tdstyle="text-align: left;">实轴上的根轨迹，其右边开环传递函数的零点、极点数之和必为奇数</td></tr><tr><td style="text-align: left;">6</td><td style="text-align: left;">分离点 /<br>会合点</td><td style="text-align: left;">实轴上的分离（会合）点（必要条件）<br><span class="math inline">\(\frac{\mathrm{d}[G_1(s)H_1(s)]}{\mathrm{d}s}= 0\)</span> 或 <spanclass="math inline">\(\frac{\mathrm{d}K_1}{\mathrm{d}s} =0\)</span></td></tr><tr><td style="text-align: left;">7</td><td style="text-align: left;">出射角<br>入射角</td><td style="text-align: left;">复极点处的出射角：<br> <spanclass="math inline">\(\theta_a = \pi \pm 2k\pi + \sum_{i=1}^m \angle(P_a- Z_i) - \sum_{j=1, j \neq a}^n \angle(P_a - P_j)\)</span><br>复零点处的入射角：<br> <span class="math inline">\(\varphi_b = \pi\pm 2k\pi + \sum_{j=1}^n \angle(Z_b - P_j) - \sum_{i=1, i \neq b}^m\angle(Z_b - Z_i)\)</span></td></tr><tr><td style="text-align: left;">8</td><td style="text-align: left;">虚轴交点</td><td style="text-align: left;"></td></tr><tr><td style="text-align: left;">9</td><td style="text-align: left;">走向</td><td style="text-align: left;">当 <span class="math inline">\(n - m \ge2\)</span> ， <span class="math inline">\(K_1 \to \infty\)</span>时，一些轨迹向右，则另一些将向左</td></tr><tr><td style="text-align: left;">10</td><td style="text-align: left;"><span class="math inline">\(K_1\)</span>计算</td><td style="text-align: left;">根轨迹上任一点处的 <spanclass="math inline">\(K_1\)</span> ：<br> <spanclass="math inline">\(\vert K_1 \vert = \frac{1}{\vert G_1(s_1)H_1(s_1)\vert} =\frac{G_1(s_1)H_1(s_1)\text{极点至}s_1\text{向量长度的乘积}}{G_1(s_1)H_1(s_1)\text{零点至}s_1\text{向量长度的乘积}}\)</span></td></tr></tbody></table><h3 id="系统性能分析">系统性能分析</h3><h4 id="根轨迹分析系统性能">根轨迹分析系统性能</h4><p>控制系统的性功能由闭环零点、极点位置决定</p><ul><li>定性分析<ul><li>稳定性分析</li></ul></li><li>定量分析<ul><li>暂态响应分析</li><li>定量计算性能指标</li></ul></li></ul><h4 id="稳定性分析-1">稳定性分析</h4><p>主要通过根轨迹图上点的分布来判断系统的稳定性</p><ul><li>稳定系统<ul><li>所有闭环极点均在复平面左半部</li></ul></li><li>临界稳定系统<ul><li>有闭环极点在虚轴上，其余闭环极点在复平面左半部</li></ul></li><li>不稳定系统<ul><li>有闭环极点在复平面右半部</li></ul></li></ul><h4 id="稳态性能分析">稳态性能分析</h4><p>一般来说，开环增益 <span class="math inline">\(K_1\)</span>越大，系统的稳态误差越小</p><p>但是随着 <span class="math inline">\(K_1\)</span>的增大，根轨迹向右移动，可能导致系统不稳定，并且阻尼比 <spanclass="math inline">\(\xi\)</span>变小，振荡变强，超调量增大，动态性能变差</p><h4 id="动态性能分析">动态性能分析</h4><p>通过根轨迹图可以分析系统的动态性能</p><ul><li><p>实部 <span class="math inline">\(\sigma\)</span> 决定收敛速度</p><ul><li>实部离虚轴越远，系统调节时间 <spanclass="math inline">\(t_s\)</span> 越短，响应越快</li></ul><p><span class="math display">\[t_s \approx \frac{4}{\vert\sigma\vert} \text{或} t_s \approx\frac{3}{\vert\sigma\vert}\]</span></p></li><li><p>虚部 <span class="math inline">\(\omega_d\)</span>决定振荡频率</p><ul><li>离实轴越远，振荡频率越高</li></ul></li><li><p>与负实轴夹角 <span class="math inline">\(\theta\)</span>决定阻尼比 <span class="math inline">\(\xi\)</span></p><ul><li>夹角越远离 <spanclass="math inline">\(\frac{\pi}{2}\)</span>，阻尼比越大，超调量越小</li></ul><p><span class="math display">\[\xi=\cos\theta\]</span></p></li></ul><h4 id="闭环零极点与系统性能">闭环零极点与系统性能</h4><h5 id="零极点的功能">零极点的功能</h5><ul><li>闭环极点分布<ul><li>决定动态响应类型<ul><li>极点为实数<ul><li>单调的指数响应，不振荡</li></ul></li><li>极点为复数<ul><li>振荡响应</li></ul></li><li>极点在右半平面<ul><li>系统不稳定</li></ul></li></ul></li></ul></li><li>闭环零点分布<ul><li>决定瞬态响应曲线的形态和指标</li></ul></li></ul><h5id="零极点对系统动态性能的影响及其化简">零极点对系统动态性能的影响及其化简</h5><ul><li>主导极点<ul><li>决定系统的动态性能</li><li>主导极点一般为一对共轭复极点</li><li>主导极点位置越靠近虚轴，系统响应越慢</li><li>过于远离虚轴的主导极点忽略不计（<spanclass="math inline">\(e^{-\sigma t}\)</span> 衰减过快）</li></ul></li><li>偶极子<ul><li>对系统动态性能影响较小，可忽略不计</li></ul></li></ul><h5 id="增加零极点的影响">增加零极点的影响</h5><ul><li>闭环实数零点<ul><li>减小系统阻尼比，超调量增大，峰值时间提前</li></ul></li><li>闭环实数极点<ul><li>较小系统超调量，峰值时间延后</li></ul></li><li>两个复极点<ul><li>暂态过程主要决定于离虚轴较近的极点</li></ul></li></ul><h5 id="复极点的几何意义">复极点的几何意义</h5><p>当闭环极点是共轭复数 <span class="math inline">\(s=-\sigma\pmj\omega_d\)</span> 时</p><ul><li>阻尼比 <spanclass="math inline">\(\xi=\frac{\sigma}{\sqrt{\sigma^2+\omega_d^2}}=\cos\theta\)</span></li><li>极点到原点的距离 <span class="math inline">\(\omega_n=\sqrt{\sigma^2+\omega_d^2}\)</span>，也是自然频率</li><li>若控制 <span class="math inline">\(\omega_n\)</span> 不变，改变<span class="math inline">\(\xi\)</span>，则极点在以原点为中心，<spanclass="math inline">\(\omega_n\)</span> 为半径的圆弧上移动</li><li>若控制 <span class="math inline">\(\xi\)</span> 不变，改变 <spanclass="math inline">\(\omega_n\)</span>，则极点在以原点为中心，倾角为<span class="math inline">\(\theta\)</span> 的直线上移动，随着 <spanclass="math inline">\(\omega_n\)</span>的增大，极点沿着矢量方向延伸，系统响应速度加快</li><li><span class="math inline">\(\sigma=\xi \omega_n\)</span>决定系统响应速度</li></ul><h2 id="控制系统的复域分析">控制系统的复域分析</h2><h2 id="控制系统的频域分析">控制系统的频域分析</h2><h2 id="控制系统的设计">控制系统的设计</h2>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>自动控制原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2025/09/11/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/09/11/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="个人博客搭建">个人博客搭建</h1><p>参考</p><ol type="1"><li><ahref="https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/">2024年，如何使用 github pages + Hexo + Next 搭建个人博客</a></li><li><a href="https://hexo.io/zh-cn/docs/">Hexo 文档</a></li><li><a href="https://blog.teru.fun/">teru 姐姐的笔记</a></li><li><a href="https://github.com/dcldyhb/dcldyhb.github.io">fluid主题</a></li><li><a href="https://zhuanlan.zhihu.com/p/405554589">Hexo 中支持 Mathjax–知乎</a></li></ol><p>使用 Github pages+Hexo 进行搭建</p><h2 id="第一步github-仓库准备">第一步：github 仓库准备</h2><p>新建立一个 Repo，名字为你的名字+github.io</p><h2 id="第二步本地化部署-hexo-环境">第二步，本地化部署 Hexo 环境</h2><ol type="1"><li><p>安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>在 MacOS 上，可能会出现权限问题，使用修改 npm全局安装目录的方式解决</p><ol type="1"><li><p>创建新的全局安装目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.npm-global<br></code></pre></td></tr></table></figure></li><li><p>配置 npm 使用新的目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&#x27;~/.npm-global&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>更新环境变量 打开 shell 配置文件，对于 zsh 是<code>~/.zshrc</code>，对于 bash 是 <code>~/.bash_profile</code> 或<code>~/.bashrc</code>，以用 vim 打开 <code>~/.zshrc</code> 为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>在文件末尾添加以下行，以将新的 npm 全局目录添加到环境变量<code>PATH</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/.npm-global/bin&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>保存并应用配置 保存文件，然后运行以下命令以使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc <span class="hljs-comment"># 或 source ~/.bash_profile</span><br></code></pre></td></tr></table></figure></li><li><p>验证安装 通过下面的命令来检查 PATH变量是否包含了你新添加的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>如果输出的内容里包含了 <code>/Users/yourname/.npm-global/bin</code>(或者 <code>$HOME/.npm-global/bin</code>)，就说明配置成功了。</p></li></ol></li><li><p>初始化 Hexo 框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入 blog 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure></li><li><p>运行 Hexo 本地服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure></li></ol><h2 id="发布">发布</h2><ol type="1"><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置站点文件</p><p>在博客目录下的 <code>_config.yml</code> 文件中，找到<code>deploy</code> 部分，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;your_username&gt;/&lt;your_username&gt;.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>找到 <code>url</code> 部分，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://&lt;your_username&gt;.github.io</span><br></code></pre></td></tr></table></figure></li><li><p>发布博客</p><ol type="1"><li><p>清理和生成静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br></code></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure></li></ol></li></ol><p>这样之后博客就搭建好了，访问<code>https://&lt;your_username&gt;.github.io</code>就可以看到博客了</p><h2 id="配置主题">配置主题</h2><p>这里以 <ahref="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>主题为例（看了<a href="https://teruteru.space/">teru姐姐的笔记</a>，这个主题真的很好看）</p><ol type="1"><li><p>进入 blog 文件夹</p></li><li><p>安装主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在在博客目录下创建  <code>_config.fluid.yml</code>，将主题的  <ahref="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>内容复制进去。</p></li><li><p>修改博客的 <code>_config.yml</code>，将 <code>theme</code>字段修改为 <code>fluid</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure></li></ol><p>接下来的步骤可以按照 <ahref="https://hexo.fluid-dev.com/docs/guide">Hexo Fluid 用户手册</a>进行配置</p><p>仅作个人记录</p><h3 id="全局配置">全局配置</h3><h4 id="博客标题">博客标题</h4><p>页面左上角的博客标题，默认使用<strong>站点配置</strong>中的<code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。</p><h4 id="几个常用的引擎用于替换-marked">几个常用的引擎（用于替换marked）</h4><ol type="1"><li>hexo-renderer-kramed</li><li>hexo-renderer-syzoj-renderer</li><li>hexo-renderer-pandoc</li></ol><h3 id="文章相关">文章相关</h3><h4 id="latex-支持"><span class="math inline">\(LaTeX\)</span> 支持</h4><ol type="1"><li><p>设置主题配置 在主题配置 <code>_config.fluid.yml</code>中有代码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时 提高加载速度</span><br>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when  the page does not contain math</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># Options: mathjax | katex</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><p>其中</p><ul><li><code>enable</code>：开启后，文章默认可用</li><li><code>specific</code>：开启后，只有在文章 Front-matter 里指定<code>math: true</code>才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</li><li><code>engine</code>：引擎，MathJax 或 KaTeX<ul><li>MathJax 支持更全面的 <span class="math inline">\(LaTeX\)</span>语法，但渲染速度较慢</li><li>KaTeX 更为轻量，渲染速度快，但不支持所有 <spanclass="math inline">\(LaTeX\)</span> 语法</li></ul></li></ul></li><li><p>更换 Markdown 渲染器 Hexo 默认使用 hexo-renderer-marked 作为Markdown 渲染器，但 marked 对 <span class="math inline">\(LaTeX\)</span>的支持很烂，更换为其他渲染器</p><p>我们需要先卸载 marked</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br></code></pre></td></tr></table></figure><p>接下来我以更加全面的 MathJax 为例，安装hexo-renderer-pandoc（不要忘了主题配置中选择引擎为 MathjJax）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></li><li><p>下载 pandoc</p><p>按照官网 <a href="https://pandoc.org/installing.html">Pandoc</a>说的做就行了</p></li><li><p>配置 mathjax 和 pandoc 在站点配置中加入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">pandoc:</span><br>  <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;--mathjax&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>宏包支持 （我还不会）</p></li></ol><p>这样就可以使用 MathJax 来渲染 <spanclass="math inline">\(LaTeX\)</span> 公式了</p>]]></content>
    
    
    <categories>
      
      <category>Web 开发</category>
      
      <category>建站</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Git</tag>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2025/08/12/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/Git%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/08/12/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/Git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="git-笔记">Git 笔记</h1><p>本文参照了 <ahref="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的 Git教程</a> 和 <ahref="https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/">CS自学指南</a> 的内容</p><p>（学了好多才发现最好用的是 <ahref="https://desktop.github.com/">GitHub Desktop</a> …）</p><h2 id="git-的安装和简单的配置">Git 的安装和简单的配置</h2><h3 id="安装-git">安装 Git</h3><h4 id="windows-系统">Windows 系统</h4><p>在 Windows 系统上安装 Git 有两种方法：</p><ol type="1"><li><p>在 <a href="https://git-scm.com/">Git 官网</a> 上直接下载 <ahref="https://git-scm.com/downloads/win">Git 安装包</a>之后按照安装向导进行安装；</p></li><li><p>使用包管理器，</p><p>先下载一个包管理器，这里使用 <a href="https://scoop.sh/">scoop</a>作为示例，这里参考了 <ahref="https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Scoop/#scoop_1">CS自学指南</a>.</p><p>打开 power shell，执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 设置 PowerShell 执行策略</span><br><span class="hljs-built_in">Set-ExecutionPolicy</span> <span class="hljs-literal">-ExecutionPolicy</span> RemoteSigned <span class="hljs-literal">-Scope</span> CurrentUser<br><span class="hljs-comment"># 下载安装脚本</span><br><span class="hljs-built_in">irm</span> get.scoop.sh <span class="hljs-literal">-outfile</span> <span class="hljs-string">&#x27;install.ps1&#x27;</span><br><span class="hljs-comment"># 执行安装, --ScoopDir 参数指定 Scoop 安装路径</span><br>.\install.ps1 <span class="hljs-literal">-ScoopDir</span> <span class="hljs-string">&#x27;C:\Scoop&#x27;</span><br></code></pre></td></tr></table></figure><p>然后继续输入以下指令安装 Git：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">coop install git<br></code></pre></td></tr></table></figure></li></ol><p>安装完成后可以在终端中输入以下指令查看 Git 版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-literal">-v</span><br></code></pre></td></tr></table></figure><h4 id="在-macos-上安装-git">在 macOS 上安装 Git</h4><p>在 macOS 上安装 Git 有两种方法：</p><ol type="1"><li><p>使用 <a href="https://brew.sh/">Homebrew</a>包管理器，打开终端，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure></li><li><p>使用 XCode， 内置 了 Git 工具 运行 XCode，选择菜单 “Xcode” -&gt;“Preferences” -&gt; “Downloads”，然后选择一个 Command Line Tools版本，系统会提示你安装命令行工具，点击 “Instal” 安装即可.</p></li></ol><hr /><p>使用包管理器安装 Git 是最简单的方式，推荐使用这种方式.</p><p>同时使用包管理器更新 Git 也非常方便.</p><ul><li><code>scoop update git</code> (Windows)</li><li><code>brew upgrade git</code> (macOS)</li></ul><h3 id="配置-git">配置 Git</h3><p>安装完成之后对 Git 进行一些基本的配置</p><p>在命令行中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>Your Name</code>替换为你的名字，<code>email@example.com</code> 替换为你的邮箱地址.</p><p><code>--global</code>参数表明这台机器上的所有仓库都会使用这个配置，如果你想为某个特定的仓库设置不同的名字和邮箱，可以进入该仓库目录，去掉<code>--global</code> 参数，重新执行上述命令即可.</p><p>配置完之后可以使用以下命令查看配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure><h2 id="创建版本库">创建版本库</h2><p>版本库也叫做仓库(repository)，是用于存储文件的地方，里面每个文件的变动Git 都能记录.</p><p><code>cd</code>到你<strong>需要创建版本库的目录下</strong>，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 <code>.git</code> 的隐藏目录，里面存储了Git 需要的所有信息.</p><p>若此时使用 <code>ls</code>命令查看当前的目录,看不到任何新建的文件夹，因为 <code>.git</code>是一个隐藏目录.</p><h3 id="向版本库中添加文件">向版本库中添加文件</h3><p>首先创建一个 <code>Readme.md</code> 文件,内容为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Git 学习</span><br><br>Git is a version control system.<br><br>Git is free software.<br></code></pre></td></tr></table></figure><p>这个文件一定要在刚才创建的版本库的目录或子目录下</p><ol type="1"><li><p>在终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add Readme.md<br></code></pre></td></tr></table></figure><p>这里输入的是路径而不是文件名，可以选择相对路径或者绝对路径.</p><p>如果没有输出任何内容，说明添加成功了.</p></li><li><p>提交这些文件到版本库中，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Add Readme.md&quot;</span><br></code></pre></td></tr></table></figure><p><code>-m</code>参数后面跟的是提交信息，描述了这次提交的内容,有助于其他人或者未来的自己理解这次提交的目的.</p><p>一些工具可以使用 ai 生成提交信息,如 Github Desktop,这个也是十分好用的Git 的图形化客户端.</p></li></ol><h2 id="版本管理">版本管理</h2><ul><li>使用 <code>git status</code>命令可以查看当前版本库的状态，显示哪些文件被修改了，哪些文件被添加了，哪些文件还没有被提交等信息.</li><li>使用 <code>git diff</code>命令可以查看文件的具体修改内容，显示哪些行被添加了，哪些行被删除了等信息.</li></ul><h3 id="版本回退">版本回退</h3><ul><li>使用 <code>git log</code>命令可以查看版本库的提交历史，显示每次提交的哈希值，作者，日期，提交信息等信息.</li></ul><p>以这个笔记的版本库为例，显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">commit 493bb5004ef68c281f0fbf7f22e60e9111c94a86 (HEAD -&gt; main, origin/main, origin/HEAD)<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:41:08 2025 +0800<br><br>    Update .gitignore and workspace layout settings<br><br>    Added duplicate entries <span class="hljs-keyword">for</span> .obsidian and workspace.json <span class="hljs-keyword">in</span> .gitignore. Modified workspace.json to <span class="hljs-built_in">set</span> the left pane as collapsed by default.<br><br>commit d63e6e188c19e1f13fbf38ec735125e7c22d5484<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:39:11 2025 +0800<br><br>    updated Git notes<br><br>commit 172fb0bb0c001e1451eab09d8abb04814c755d0d<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Fri Aug 15 01:06:28 2025 +0800<br><br>    Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure><p>在 powee shell 中</p><ul><li>使用 <kbd>j</kbd> 和 <kbd>k</kbd> 键可以上下移动查看提交记录.</li><li>使用 <kbd>q</kbd> 键可以退出日志查看.</li></ul><p>该命令会从最近到最远显示提交的记录，在这里我列出了最近的三个提交记录.</p><p>最近的一次是<code>UUpdate .gitignore and workspace layout settings</code>，上一次是<code>update Git notes</code>，再上一次是<code>Update .gitignore and workspace settings</code>.</p><p>加上 <code>--pretty=oneline</code>参数可以让输出显示为一行，方便查看.</p><p>形如 <code>493bb5004ef68c281f0fbf7f22e60e9111c94a86</code>的是每次提交的版本号，git会为每次提交生成一个唯一的哈希值，这个哈希值可以用来标识这次提交.</p><p>git 使用 <code>HEAD</code> 来标识当前版本库的最新提交，这里是<code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>，上一个版本是<code>HEAD^</code>，也就是<code>d63e6e188c19e1f13fbf38ec735125e7c22d5484</code>，再上一个版本是<code>HEAD^^</code>，也就是<code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>.</p><p>我们使用 <code>git reset</code> 命令来回退到上一个版本.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><p><code>--hard</code>参数表明回到上个版本的已提交状态，<code>--soft</code>参数表明回到上个版本的未提交状态，<code>--mixed</code>参数表明回到上个版本的已暂存状态.</p><p>我们同样可以使用该命令返回更晚的版本，只要记得版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 493bb5004ef68c281f0fbf7f22e60e9111c94a86<br></code></pre></td></tr></table></figure><p>这里的版本号不需要是完整的哈希值，只需要前几位就可以了，Git会自动匹配到唯一的版本.</p><p>git 的版本回退很快，因为 Git 内部有一个指向当前版本的<code>HEAD</code> 指针，回退只需要修改这个指针的指向即可.</p><p>如果找不到可以使用 <code>git reflog</code>命令查看所有的提交记录，包括已经被回退的版本.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">172fb0b HEAD@&#123;1&#125;: reset: moving to HEAD^^<br>493bb50 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;2&#125;: commit: Update .gitignore and workspace layout settings<br>d63e6e1 HEAD@&#123;3&#125;: commit: updated Git notes<br>172fb0b HEAD@&#123;4&#125;: commit: Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure><p>这里发现 Update .gitignore and workspace layout settings 的版本号是<code>493bb50</code>，可以使用 <code>git reset --hard 493bb50</code>命令回到这个版本.</p><h3 id="工作区和暂存区">工作区和暂存区</h3><h4 id="名词解释">名词解释</h4><ul><li><strong>工作区（Working Directory）：</strong> 电脑中的目录</li><li><strong>版本库（Repository）：</strong> 工作区中的 <code>.git</code>目录，默认为隐藏 存储有所有的版本信息，其中最重要的就是称为<code>stage</code> （或 <code>index</code>）的暂存区，还有 Git为我们自动创建的第一个分支 <code>master</code> 分支，以及指向当前分支的<code>HEAD</code> 指针.</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Git</tag>
      
      <tag>版本控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML笔记</title>
    <link href="/2025/07/15/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/HTML%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/07/15/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/HTML%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="html-笔记">HTML 笔记</h1><h2 id="元素">元素</h2><ol type="1"><li>开始标签 （Opening tag）：<code>&lt;p&gt;</code></li><li>结束标签 （Closing tag）：<code>&lt;/p&gt;</code></li><li>内容（Content）：元素的内容，可以是输入的文本本身</li><li>元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素<ul><li>元素可以有属性，包含的是不想在真正的内容中出现的和元素有关的额外信息，有值的属性应该包含<ol type="1"><li>属性与元素名称（或上一个属性，如果元素有超过一个属性的话）之间的一个空格。</li><li>属性名，后接一个等号</li><li>一对引号包围的属性值</li></ol></li></ul></li></ol><h3 id="嵌套元素">嵌套元素</h3><p>元素可以嵌套在其他元素中。嵌套的元素必须正确地嵌套在开始标签和结束标签之间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My cat is <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> cute.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="空元素">空元素</h3><p>空元素没有内容，只有开始标签，没有结束标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/firefox-icon.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;My test image&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="案例分析">案例分析</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My test page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/firefox-icon.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;My test image&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明，告诉浏览器这是一个HTML5 文档，现在用于保证文档能够正常读取</li><li><code>&lt;html&gt;&lt;/html&gt;</code>：HTML元素，包含了整个文档的内容，有时也被称为根元素</li><li><code>&lt;head&gt;&lt;/head&gt;</code>：head 元素，该元素作为想在HTML页面中包含但不想向用户显示的内容的容器。包括想在搜索结果中显示的关键字和页面描述、用于设置页面样式的CSS、字符集声明等等。</li><li><code>&lt;meta charset="utf-8"&gt;</code>：该元素指明文档使用 UTF-8字符编码，UTF-8包括世界绝大多数书写语言的字符。它基本上可以处理任何文本内容。以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。</li><li><code>&lt;meta name="viewport" content="width=device-width"&gt;</code>：视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器以比视口更宽的宽度渲染内容，导致内容缩小。</li><li><code>&lt;title&gt;&lt;/title&gt;</code>：<title>元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</li><li><code>&lt;body&gt;&lt;/body&gt;</code>：<body>元素。该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web 开发</category>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Web</tag>
      
      <tag>笔记</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毛概</title>
    <link href="/2025/06/11/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/"/>
    <url>/2025/06/11/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/</url>
    
    <content type="html"><![CDATA[<h1 id="毛概">毛概</h1><h2id="毛概是什么马克思主义中国化时代化的历史进程和理论结果">毛概是什么：马克思主义中国化时代化的历史进程和理论结果</h2><ul><li>什么是马克思主义中国化时代化：<ul><li>运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。</li><li>总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。</li><li>用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义</li></ul></li><li>1938党的六届六中全会上，《论新阶段》的报告，标志着“马克思主义的中国化”这一命题的正式提出</li><li>中共七大，刘少奇从理论上做出阐述</li><li>内涵：马克思主义中国化时代化，就是立足<em>中国国情</em>和<em>时代特点</em>，坚持把马克思主义基本原理同中国<em>具体实际</em>相结合、同中华优秀<em>传统文化</em>相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</li></ul><h2 id="马克思主义中国化的理论成果">马克思主义中国化的理论成果</h2><ul><li>毛泽东思想</li><li>中国特色社会主义理论体系</li></ul><h2id="马克思主义中国化理论成果的精髓实事求是">马克思主义中国化理论成果的精髓：实事求是</h2><h2 id="理论">理论</h2><h3 id="新民主主义革命理论">新民主主义革命理论</h3><ul><li>认清中国国情是解决中国革命问题的<em>基本前提</em></li><li>认清中国社会的性质，乃是认清一切革命问题的<em>基本的根据</em></li></ul><h4 id="何以形成">何以形成</h4><ul><li>国情依据：近代中国是一个半殖民地半封建性质的社会<ul><li>帝国主义列强进行政治，经济，文化的侵略，中国长期处于帝国主义国家的统治或半统治之下，没有完整的主权与国家的统一</li><li>前述侵略使得自给自足的封建经济基础解体，但封建制度的根基：地主阶级对农民的剥削仍然存在，而且同买办资本和高利贷资本的剥削结合在了一起。</li><li>主要矛盾：<strong>帝国主义和中华民族的矛盾</strong>（主要），封建主义和人民大众的矛盾</li><li>根本任务：推翻帝国主义，封建主义和官僚资本主义的统治，争取民族独立和人民解放</li></ul></li><li>时代背景<ul><li>1917 年十月革命，建立了第一个无产阶级专政的政权</li><li>五四运动，中国无产阶级作为独立的政治力量成为革命的领导力量，马克思列宁主义逐步成为中国革命的指导思想，进入新民主主义革命阶段</li></ul></li><li>实践基础<ul><li>旧民主主义革命的失败<ul><li>旧式的农民战争</li><li>不触动封建根基的自强运动和改良主义</li><li>照搬西方资本主义的方案</li></ul></li><li>包含对上述失败教训的深刻总结</li></ul></li></ul><h4 id="基本内容">基本内容</h4><ul><li>提出<ul><li>1939《中国革命和中国共产党》，第一次提出“新民主主义的革命”的概念</li><li>1948《在晋绥干部会议上的讲话》完整总结和概括了新民主主义革命总路线的内容</li></ul></li><li>总路线：<strong>无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命</strong><ul><li>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，也是新民主主义革命区别于旧民主主义革命的根本标志<ul><li>与先进的生产方式相联系，没有私人占有的生产资料，富有组织纪律性</li><li>受“三座大山”的压迫</li><li>集中分布在少数大城市和大企业，利于组织团结</li><li>成员与农民间有天然的联系</li></ul></li><li>革命的对象：分清敌友，是革命的<em>首要问题</em><ul><li>帝国主义（中国革命的首要对象）<ul><li>近代中国贫困落后和一切灾难祸害的总根源</li><li>推翻帝国主义的压迫是中国走向独立和富强的前提</li></ul></li><li>封建主义<ul><li>帝国主义统治中国和封建军阀实行专制统治的社会基础，是中国经济现代化和政治民主化的主要障碍</li></ul></li><li>官僚资本主义<ul><li>对劳动人民 /民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展。</li></ul></li></ul></li><li>革命的任务<ul><li>民族革命：对外推翻帝国主义的压迫</li><li>民主革命：对内推翻封建地主阶级和官僚资产阶级的压迫</li><li>相互区别，相互联系</li></ul></li><li>革命的动力<ul><li>无产阶级：中国革命<em>最基本的动力</em>，中国革命的领导力量</li><li>农民：中国革命的主力军，农民问题是中国革命的<em>基本问题</em>，<strong>新民主主义革命实质上就是党领导下的农民革命，中国革命战争实质上就是党领导下的农民战争</strong></li><li>城市小资产阶级：无产阶级的可靠同盟者（广大知识分子，小商人，手工业者和自由职业者）</li><li>民族资产阶级：带有两面性的阶级，一方面受压迫，一方面政治经济上又有联系，表现出明显的动摇性</li></ul></li></ul></li><li>纲领（总路线的展开）<ul><li>政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，<em>各革命阶级联合专政</em>（国体）的新民主主义的共和国。（不同于欧美，也不同于苏联）<ul><li>革命的根本问题是政权问题</li><li>政体：民主集中制的人民代表大会制度</li></ul></li><li>经济纲领：“两没收，一保护”<ul><li>没收封建地主阶级的土地归农民所有（进行土地革命，耕者有其田，扫除封建的剥削关系，解放农村生产力）</li><li>没收官僚资本归新民主主义国家所有（建立具有社会主义性质的国营经济，使它居于领导地位，为建立新民主主义的国家政权实现向社会主义过渡奠定坚实的基础）</li><li>保护民族工商业（保护，推动民族资本主义经济的发展，使它在发展现代技术，发展社会生产力，满足人民生活需要方面发挥作用，但不能让它操纵国计民生）</li></ul></li><li>文化纲领<ul><li><strong>“民族的”</strong>：<ul><li>内容上：反对帝国主义压迫，主张中华民族的尊严和独立</li><li>形式上：具有鲜明的民族风格，民族形式和民族特色</li></ul></li><li><strong>“科学的”</strong>：<ul><li>反对封建迷信，主张实事求是，客观真理，理论和实践的一致性</li><li>历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信</li></ul></li><li><strong>“大众的”</strong>：<ul><li>文化工作者要用革命文化教育和武装人民大众</li><li>以人民群众的实践作为创作的源泉</li><li>为人民大众服务</li></ul></li></ul></li></ul></li><li>道路：<strong>农村包围城市，武装夺取政权</strong><ul><li>成功原因<ul><li>近代中国的社会性质，社会政治经济发展极端不平衡</li><li>广大农村深受反动统治阶级的多重压迫和剥削，革命愿望强烈</li><li>革命形势的变动</li><li>正式红军的存在</li><li>党的领导</li></ul></li><li>土地革命：是中国革命的基本内容</li><li>农村革命根据地建设：是中国革命的战略阵地，进行武装斗争和土地革命的依托</li><li>武装斗争：中国革命的主要形式，是上述两者的有力保证</li></ul></li><li>基本经验：三大法宝：统一战线，武装斗争，党的建设<ul><li>统一战线和武装斗争：针对敌人，是武器<ul><li>统一战线：采取区别对待的方针，发展进步势力，争取中间势力，孤立顽固势力</li></ul></li><li>党的建设：针对党自身，是掌握武器的人<ul><li>思想建设放在首位</li><li>三大优良作风：理论联系实际，密切联系群众，批评与自我批评相结合</li></ul></li></ul></li></ul><h4 id="意义">意义</h4><ul><li>理论：极大地丰富了马克思主义的理论宝库，是马克思主义中国化时代化的重要理论成果，是对中国革命实际问题做出的分析和研究，是中国共产党集体智慧的结晶</li><li>实践：在新民主主义革命理论的指导下，党团结带领人民完成了新民主主义革命，实现了民族独立和人民解放</li><li>世界：极大改变了世界的政治格局，鼓舞了全世界人民争取解放，反对帝国主义斗争的信心，增强了世界人民争取和平的力量</li></ul><h3 id="社会主义改造理论">社会主义改造理论</h3><h4 id="过渡的依据">过渡的依据</h4><ul><li>新民主主义社会是一个过渡性的社会<ul><li>中华人民共和国成立 <span class="math inline">\(\to\)</span>社会主义改造基本完成是我国从新民主主义到社会主义的过渡时期，性质是新民主主义社会</li><li>不是独立的社会形态，而是过渡性社会形态，由经济结构和社会主要矛盾决定</li><li>经济结构<ul><li>社会主义性质的国营经济</li><li>半社会主义性质的合作社经济（个体 <spanclass="math inline">\(\to\)</span> 国营）</li><li>农民和手工业者的个体经济</li><li>私人资本主义经济</li><li>国家资本主义经济（私人 <span class="math inline">\(\to\)</span>国营）</li></ul></li><li>阶级构成<ul><li>社会主义 <span class="math inline">\(\leftrightarrow\)</span>工人阶级</li><li>个体经济 <span class="math inline">\(\leftrightarrow\)</span>农民阶级和其他小资产阶级</li><li>资本主义经济 <span class="math inline">\(\leftrightarrow\)</span>民族资产阶级</li></ul></li><li>主要矛盾<ul><li>社会主义 <span class="math inline">\(\leftrightarrow\)</span>资本主义</li><li>工人阶级 <span class="math inline">\(\leftrightarrow\)</span>资产阶级</li></ul></li></ul></li><li>理论依据<ul><li>马克思 / 恩格斯：科学社会主义理论<ul><li>无产阶级利用自己的政治统治一步一步夺取资产阶级的全部资本，把一切生产工具集中在国家也即成为统治阶级的无产阶级手里，并尽可能增加生产力的宗量</li></ul></li><li>中国共产党人的理论：党的七届二中全会</li></ul></li><li>现实依据<ul><li>经济：1949-1952，已经拥有了相对强大和迅速发展的社会主义国营经济，国家掌握了重要工矿企业，铁路，银行等国民经济的命脉，体现了国营经济相比其他成分的优越性。</li><li>政治：新中国是工人阶级领导的以工农联盟为基础的人民民主专政的国家，马克思主义在思想文化领域处于指导地位，中国共产党执政并得到人民群众的广泛拥护</li><li>国际形势：经过二战，资本主义国家也很不景气，尽管帝国主义国家对我国实施了军事上侵略威胁，经济上严密封锁，政治上孤立遏制等策略，但社会主义国家正充满向上发展的活力</li></ul></li></ul><h4 id="如何过渡">如何过渡</h4><ul><li>总路线与总任务（1953.6）<ul><li>在一个相当长的时间内，逐步实现国家的社会主义工业化，并初步实现国家对农业、手工业和资本主义工商业的社会主义改造。</li><li>实质：把生产资料的资本主义私有制改变成生产资料的社会主义公有制</li></ul></li><li>核心内容：“一化三改”<ul><li>社会主义工业化</li><li>对个体农业、手工业和资本主义工商业进行社会主义改造。<ul><li>对农业的社会主义改造首先进行<ul><li>积极领导，稳步前进的方针，循序渐进的步骤</li><li>互助组（社会主义萌芽） <span class="math inline">\(\to\)</span>初级农业生产合作社（半社会主义性质） <spanclass="math inline">\(\to\)</span>高级农业生产合作社（完全社会主义性质）<ul><li>互助组：解决生产上的困难，自愿基础上建立，分为临时与常年</li><li>初级农业生产合作社：在互助组的基础上自愿组织，以土地入股，其他生产资料作价入社，实施统一经营，进行集体劳动，以按劳分配和土地入股分红相结合</li><li>高级农业生产合作社：由初级社发展而成，规模更大，生产资料归集体所有，取消了土地报酬，实行按劳分配</li></ul></li></ul></li><li>手工业的社会主义改造<ul><li>积极领导，稳步前进</li><li>通过合作化道路，把个体手工业经济改造为社会主义的集体所有制<ul><li>个体手工业经济：建立在生产资料私有制和个体劳动基础上</li></ul></li><li>手工业供销小组（社会主义萌芽） <spanclass="math inline">\(\to\)</span> 供销合作社（半社会主义性质） <spanclass="math inline">\(\to\)</span> 生产合作社（社会主义性质）<ul><li>手工业供销小组：独立手工业者 / 家庭手工业者由国营商业 /供销合作社供给原料和包销产品 / 推销成品，通过加工订货方式组织起来</li><li>手工业供销合作社：随着供销业务的逐步扩大，手工业供销小组发展为合作社。</li><li>手工业生产合作社：社会主义性质的集体经济组织，生产资料归集体所有，在计划指导下，根据市场需要灵活安排，集中/ 分散生产，流动服务，独立核算，自负盈亏。</li></ul></li><li>采取说服教育，典型示范和国家帮助的方法</li></ul></li><li>资本主义工商业的社会主义改造<ul><li>和平赎买：国家有偿将私营企业变为国营企业（让企业家在一定年限内从企业经营所得中获取一部分利润）</li><li>从低级到高级的过渡形式<ul><li>具有社会主义因素的企业，实行初级形式的国家资本主义</li><li>半社会主义性质的企业，实行个别企业的公私合营</li><li>社会主义国营性质的企业，实现全行业的公私合营</li></ul></li><li>采取“包下来”的政策，把资本主义工商业者改造为自食其力的社会主义劳动者</li></ul></li></ul></li></ul></li><li>历史经验<ul><li>坚持社会主义工业化建设和社会主义改造同时并举</li><li>采取积极引导和逐步过渡的方式</li><li>用和平方法进行改造</li></ul></li></ul><h4 id="意义-1">意义</h4><ul><li>社会主义基本经济制度确立的标志：1956 年底，三大改造完成</li><li>社会主义基本制度确立的表现<ul><li>经济：社会主义公有制成为经济基础<ul><li>数千年的阶级剥削制度结束，社会主义制度确立</li></ul></li><li>政治：1954 年《宪法》<ul><li>根本政治制度：人民代表大会制度</li><li>基本政治制度：中国共产党领导的多党合作和政治协商制度</li><li>标志着中国从新民主主义国家转变为社会主义国家</li></ul></li><li>社会关系<ul><li>工人阶级成为国家的领导阶级</li><li>亿万农民和其他个体劳动者成为社会主义的集体劳动者</li></ul></li></ul></li><li>重大意义<ul><li>中国历史上最深刻最伟大的变革<ul><li>广大农民真正成为国家的主人</li><li>奠定我国社会主义工业化的初步基础</li></ul></li><li>为当代中国一切发展奠定了制度基础，社会生产力的发展，初步显示了社会主义的优越性</li><li>世界社会主义发展史上一个历史性的伟大胜利</li><li>丰富和发展社会主义理论</li></ul></li><li>经验<ul><li>实现伟大复兴，必须建立符合我国实际的先进生产制度</li></ul></li></ul><h3id="社会主义建设道路初步探索的理论成果">社会主义建设道路初步探索的理论成果</h3><h4 id="理论成果">理论成果</h4><ul><li>调动一切积极因素为社会主义事业服务（《论十大关系》探索中国特色社会主义建设道路的基本方针）<ul><li>回答了如何建设和巩固社会主义的问题</li><li>有利于最大限度团结全国各族人民，为建设社会主义现代化国家而奋斗</li></ul></li><li>正确认识和处理社会主义社会矛盾的思想<ul><li>此时无产阶级同资产阶级之间的矛盾已基本解决，但仍面临着其他的矛盾</li><li>社会主义社会的基本矛盾<ul><li>生产力 <span class="math inline">\(\leftrightarrow\)</span>生产关系</li><li>经济基础 <span class="math inline">\(\leftrightarrow\)</span>上层建筑</li><li>与资本主义社会不同，两者的基本矛盾具有根本不同的性质与情况</li><li>“又相适应，又相矛盾”</li><li>非对抗性的矛盾</li></ul></li><li>社会主义社会的主要矛盾<ul><li>人民对于经济文化迅速发展的需要</li><li>当前经济文化不能满足人民需要的状况</li><li>主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质和文化需要</li></ul></li><li>两类不同性质的矛盾<ul><li>敌我矛盾<ul><li>对抗性矛盾，分清敌我</li><li>处理方法：专政</li></ul></li><li>人民内部矛盾<ul><li>非对抗性矛盾，分清是非</li><li>处理方法：民主</li><li>处理方针：<ul><li>政治思想领域 <span class="math inline">\(\leftrightarrow\)</span>“团结-批评-团结”</li><li>物质利益、分配 <span class="math inline">\(\leftrightarrow\)</span>“统筹兼顾，适当安排”</li><li>人民群众和政府机关 <spanclass="math inline">\(\leftrightarrow\)</span>坚持民主集中制，克服政府机关的官僚主义，同时加强对群众的教育</li><li>科学文化领域 <span class="math inline">\(\leftrightarrow\)</span>“百花齐放，百家争鸣”</li><li>共产党和民主党派 <spanclass="math inline">\(\leftrightarrow\)</span>在坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”</li><li>民族矛盾 <span class="math inline">\(\leftrightarrow\)</span>民族平等，团结互助</li></ul></li></ul></li></ul></li><li>意义：<ul><li>团结全国各族文明发展我们的经济，文化，巩固新制度，建设新国家</li></ul></li></ul></li><li>走中国工业化道路的思想<ul><li>为什么要<ul><li>实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件</li><li>中华人民共和国的成立，为我国实现工业化提供了根本的政治前提</li></ul></li><li>背景<ul><li>国内：工业基础薄弱</li><li>国际：受苏联工业化模式影响，比例失调</li></ul></li><li>总方针：<ul><li>以农业为基础，以工业为主导</li><li>以农、轻、重为序发展国民经济</li></ul></li><li>“两条腿走路”工业化发展思路<ul><li>重工业和轻工业同时并举</li><li>中央工业和地方工业同时并举</li><li>沿海工业和内地工业同时并举</li><li>大型企业和中小型企业同时并举</li></ul></li><li>“两步走”发展战略<ul><li>目标：把中国建设成为一个具有现代农业，现代工业，现代国防，现代国防技术的强国</li><li>战略步骤<ul><li>建成一个独立的比较完整的工业体系和国民经济体系</li><li>全面实现工业，农业，国防和科学技术现代化，使中国走在世界前列</li></ul></li></ul></li><li>要怎么做<ul><li>正确的经济建设方针<ul><li>党的八大：既反保守，又反冒进，坚持在综合平衡中稳步前进</li></ul></li><li>调整和完善所有制结构</li><li>探索适合我国情况的经济体制和运行机制</li></ul></li></ul></li><li>其他<ul><li>四个现代化：现代化的工业，现代化的农业，现代化的交通运输业和现代化的国防</li></ul></li></ul><h4 id="经验教训">经验教训</h4><ul><li>意义<ul><li>巩固和发展了我国的社会主义制度</li><li>为开创中国特色社会主义提供了宝贵经验，理论准备和物质基础</li><li>丰富了科学社会主义的理论和实践</li></ul></li><li>经验教训，“六个必须”<ul><li>把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路</li><li>正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力</li><li>从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成</li><li>发展社会主义民主，健全社会主义法治</li><li>坚持党的民主集中制和集体领导制度，加强执政党建设</li><li>坚持对外开放，借鉴和吸收人类文明成果建设社会主义</li></ul></li></ul><h2 id="历程">历程</h2><h3 id="毛泽东的思想历程-毛泽东思想的形成发展过程">毛泽东的思想历程 /毛泽东思想的形成发展过程</h3><ul><li>19 世纪末 20 世纪初，战争与革命成为时代的主题</li><li>科学含义<ul><li>马列主义在中国的运用和发展</li><li>被实践证明了的关于中国革命建设的正确理论原则和经验总结</li><li>中国共产党集体智慧的结晶</li></ul></li><li>中国革命战胜敌人的三大法宝：统一战线，武装斗争，党的建设</li><li>主要内容与活的灵魂：==实事求是，群众路线，独立自主==<ul><li>实事求是<ul><li>从实际出发，把握客观规律</li><li>清醒认识和正确把握我国基本国情</li><li>推进实践基础上的理论创新</li></ul></li><li>群众路线<ul><li>将“人民群众是历史的创造者”（<em>本质</em>）的原理用在党的活动中</li><li>怎么做<ul><li>坚持人民是推动历史发展的根本力量</li><li>坚持全心全意为人民服务的根本宗旨</li><li>保持党同人民群众的血肉联系</li></ul></li></ul></li><li>独立自主（针对“左”倾教条主义倾向提出的）<ul><li>中华民族的优良传统</li><li>立党立国的重要原则</li><li>外交一以贯之的</li></ul></li></ul></li><li>形成和发展<ul><li>形成时期：<ul><li>第一次国内革命战争<ul><li>《中国社会各阶级的分析》/《湖南农民运动考察报告》</li><li>深刻分析中国社会各阶级在革命中的地位和作用</li><li>提出了新民主主义革命的基本思想</li></ul></li><li>土地革命战争初期<ul><li>《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》</li><li>农村包围城市，武装夺取政权，中国革命道路理论</li><li>毛泽东思想初步形成</li></ul></li></ul></li><li>成熟时期<ul><li>土地革命战争后期，抗日战争时期<ul><li>《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》</li><li>实现了马克思主义与中国革命实际相结合的历史性飞跃</li><li>毛泽东思想趋于成熟</li></ul></li><li>遵义会议，系统分析了党内左和右的思想根源</li><li>确立指导思想：1945 年 4-6 月召开的党的七大将毛泽东思想写入党章</li></ul></li><li>继续发展<ul><li>解放战争时期<ul><li>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》</li><li>人民民主专政理论</li></ul></li><li>新中国成立后<ul><li>《论十大关系》《关于正确处理人民内部矛盾的问题》</li><li>社会主义改造理论、建设理论</li></ul></li><li>毛泽东思想进一步丰富和发展</li></ul></li></ul></li><li>历史地位<ul><li>马克思主义中国化时代化的第一个重大理论成果</li><li>中国革命和建设的科学指南</li><li>中国共产党和中国人民宝贵的精神财富</li></ul></li><li>科学评价<ul><li>完整准确理解和掌握毛泽东思想的科学体系</li><li>坚持辩证唯物主义和历史唯物主义的原则和方法</li><li>在实践中坚持和发展毛泽东思想</li></ul></li><li>辨析：毛泽东思想 <span class="math inline">\(\neq\)</span>毛泽东个人的思想<ul><li>被实践证明了的正确的理论原则和经验总结</li><li>中国共产党集体智慧的结晶</li><li>主要是“毛泽东同志的思想”，其他领导人也对毛泽东思想的形成和发展做出了重要贡献</li></ul></li></ul><h3 id="邓小平理论">邓小平理论</h3><ul><li><em>中国特色社会主义理论体系的开篇之作</em></li></ul><h4 id="邓小平理论的形成">邓小平理论的形成</h4><ul><li>时代背景：和平与发展<ul><li>和平：东西问题</li><li>发展：南北问题</li><li><strong>发展是核心问题</strong></li></ul></li><li>历史依据：社会主义建设的经验教训<ul><li>社会主义建设实践中的正确主张在改革开放后得到真正贯彻</li><li>社会主义建设经历的曲折和失误促使党和人民进行深刻反思</li></ul></li><li>现实依据：改革开放和现代化建设的实践</li><li>形成过程<ul><li>“文革”结束后，邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持领导开展真理标准问题的打讨论，推进各方面的拨乱反正</li><li>1978，党的十一届三中全会确定了解放思想，实事求是的思想路线，停止“以阶级斗争为纲”的错误，将全党工作的重点转移到社会主义现代化建设上来，做出改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。</li><li>1982，党的“十二大”提出“中国特色社会主义”，并成为党的全部理论和实践创新的主题</li><li>1984，《中共中央关于经济体制改革的决定》——社会主义经济是在公有制基础上的有计划的商品经济</li><li>1987，党的十三大，系统论述了我国社会主义初级阶段理论，明确概括和全面阐发了党“一个中心，两个基本点”的基本路线，对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成</li><li>1992，南方谈话，重申深化改革、加速发展的必要性和重要性，从理论上解答了当时困扰和束缚人们思想的一系列重大问题，邓小平理论走向成熟；党的十四大强调中国特色社会主义理论第一次比较系统地初步回答了中国这样的社会经济文化比较落后的国家如何建设社会主义，如何巩固和发展社会主义的一系列基本问题，继承和发展了马克思主义</li><li>1997，十五大正式提出“邓小平理论”这一概念，确立为党的指导思想并写入党章</li><li>1999，宪法修正案正式将邓小平理论载入宪法</li></ul></li></ul><h4 id="理论问题">理论问题</h4><ul><li>首要、基本的理论问题：在中国这样一个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义</li><li>社会主义本质<ul><li>解放生产力</li><li>发展生产力（社会主义的根本任务是发展生产力）</li><li>消灭剥削</li><li>消除两极分化</li><li>达到共同富裕</li></ul></li><li>包括了生产力和生产关系的问题</li></ul><h4 id="精髓">精髓</h4><ul><li><strong>解放思想，实事求是</strong></li></ul><h4 id="主要内容">主要内容</h4><ul><li>社会主义初级阶段（建设中国特色社会主义的总依据）理论<ul><li>一切从社会主义初级阶段的实际出发，将社会主义初级阶段作为事关全局的基本国情加以把握</li><li>含义<ul><li>我国社会已经是社会主义社会（社会性质）</li><li>我国的社会主义社会还处于初级阶段（发展程度）</li></ul></li><li>社会主义初级阶段具有长期性</li><li>基本特征<ul><li>以农业人口占多数的手工劳动为基础的农业国，逐步变为非农产业人口占多数的现代化的工业国的阶段</li><li>自然经济半自然经济占很大比重，变为商品经济高度发达的阶段</li><li>通过改革和探索建立和发展充满活力的社会主义经济、政治，文化体制的阶段</li><li>全民奋起，艰苦创业，实现中华民族伟大复兴的阶段</li></ul></li></ul></li><li>党在社会主义初级阶段的基本路线<ul><li><strong>领导和团结全国各族人民</strong>（<em>领导力量和依靠力量</em>），以<strong>经济建设为中心（根本任务），坚持四项基本原则（社会主义道路，人民民主专政，党的领导，马列毛思想）解放和发展生产力的政治保证），坚持改革开放（发展动力与外部条件）</strong>（<em>基本途径</em>），<strong>自力更生，艰苦创业</strong>（<em>实现目标的根本立足点</em>），为把我国建设成为<strong>富强（经济），民主（政治），文明（思想）的社会主义现代化国家</strong>（<em>奋斗目标</em>）而奋斗</li><li>“一个中心（经济建设），两个基本点（四项基本原则（立国之本），改革开放（强国之路））”</li></ul></li><li>社会主义的根本任务是发展生产力，党和国家的工作重点是经济建设<ul><li>发展生产力离不开科学技术</li><li>改革是动力，发展是目的，稳定是前提</li></ul></li><li>分“三步走”基本实现现代化![[Pasted image20240612214124.png|300]]</li><li>社会主义改革开放理论与市场经济理论<ul><li>社会主义市场经济：在社会主义制度条件下，让市场在资源配置中起决定作用<ul><li>所有制结构：公有制为主体，多种所有制经济共同发展</li><li>宏观调控：市场在国家宏观调控下对资源配置起到决定性作用</li><li>分配制度：按劳分配为主体，多种分配形式并存</li></ul></li></ul></li><li>“两手抓，两手都要硬”（物质文明和精神文明）（建设和法治）（改革开放和惩治腐败）</li><li>“一国两制”与祖国统一</li><li>中国特色社会主义外交和国际战略<ul><li>基本目标：维护我国的独立和主权，促进世界的和平与发展</li><li>冷静观察，稳住阵脚，沉着应付</li></ul></li><li>党的建设<ul><li>重视马克思主义理论学习</li><li>加强组织建设</li><li>加强领导班子建设</li><li>打好党风建设</li><li>重视制度建设</li></ul></li><li>“三个有利于”：<ul><li>是否有利于发展社会主义社会的生产力</li><li>是否有利于增强社会主义国家的综合国力</li><li>是否有利于提高人民的生活水平</li></ul></li></ul><h4 id="重要意义">重要意义</h4><ul><li>马克思列宁主义，毛泽东思想的继承和发展</li><li>中国特色社会主义理论体系的开篇之作</li><li>改革开放和社会主义现代化建设的科学指南</li></ul><h3id="三个代表重要思想形成背景与具体内容">“三个代表”重要思想形成背景与具体内容</h3><h4 id="背景与形成过程">背景与形成过程</h4><ul><li>社会历史条件<ul><li>国际背景：发生并经历重大变化，基于冷战结束后国际局势的科学判断<ul><li>国际共运遭受重大挫折</li><li>处于两种社会制度对立，斗争的最前沿</li></ul></li><li>历史条件（国内背景）：党的历史方位和党员队伍发生了深刻变化，基于科学判断党的历史方位和总结历史经验<ul><li>领导人民为夺取全国政权而奋斗 <spanclass="math inline">\(\to\)</span> 领导人民掌握全国政权并长期执政</li><li>受到外部封锁和实行计划经济条件下领导国家建设 <spanclass="math inline">\(\to\)</span>对外开放和发展社会主义市场经济条件下领导国家建设</li><li>党员队伍进入整体性交接的关键时刻<ul><li>提高党的领导水平和执政水平</li><li>提高拒腐防变和抵御风险的能力</li><li>要求党从新的实际出发，以改革的精神加强和改进党的建设，使党在世界形势深刻变化的历史进程中始终走在时代前列</li></ul></li></ul></li><li>实践基础：在建设中国特色社会主义伟大实践的基础上形成的</li></ul></li><li>“三个代表”重要思想发展过程<ul><li>酝酿<ul><li>1989.6 / 8提出大力加强党的建设，惩治腐败的要求，发布《关于加强党的建设的通知》</li><li>1991.7，中国共产党成立 70周年大会上深刻论述了进一步加强党的建设的问题</li><li>1992.10，党的十四大系统论述了加强党的建设和改善党的领导的问题</li></ul></li><li>形成<ul><li>1994，十四届四中全会通过了《关于加强党的建设几个重大问题的决定》</li><li>1997，党的十五大，高度概括了新时期党的建设新的伟大工程的总目标</li><li>2000.2，在广东考察，首次对“三个代表”进行了比较全面的阐述</li><li>2000.6，在全国党校工作会议上指出，“三个代表”重要思想回答和解决的事“建设什么样的党，怎样建设党”的问题</li></ul></li><li>深度发展<ul><li>2000.10，就“改进党的作风”发表重要讲话</li><li>2001.7，庆祝中国共产党成立 80周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容</li><li>2002.11，党的十六大确立为指导思想，写入党章</li></ul></li></ul></li></ul><h4 id="核心观点">核心观点</h4><ul><li>中国共产党始终代表中国先进生产力的发展要求</li><li>中国共产党始终代表中国先进文化的前进方向</li><li>中国共产党始终代表中国最广大人民的根本利益</li></ul><h4 id="主要内容-1">主要内容</h4><ul><li>发展是党执政兴国的第一要务</li><li>建立社会主义市场经济体制<ul><li>毫不动摇巩固发展公有制经济</li><li>毫不动摇鼓励、支持、引导非公有制经济</li><li>本质要求：发挥市场机制的作用和国家宏观调控</li></ul></li><li>全面建设小康社会<ul><li>两个百年奋斗目标</li></ul></li><li>建设社会主义政治文明</li><li>实施“引进来”和“走出去”的对外开放战略</li><li>推进党的建设新的伟大工程</li></ul><h4 id="历史地位">历史地位</h4><ul><li>中国特色社会主义理论体系的丰富发展</li><li>加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</li></ul><h3id="科学发展观的形成过程与具体内容">科学发展观的形成过程与具体内容</h3><h4 id="形成条件">形成条件</h4><ul><li>国际背景：<ul><li>深刻分析国际形势</li><li>顺应世界发展趋势</li><li>借鉴国外发展经验</li></ul></li><li>历史条件<ul><li>深刻把握我国国情和新的阶段性特征</li></ul></li><li>实践基础<ul><li>总结改革开放尤其是十六大以来实践经验的基础</li></ul></li></ul><h4 id="形成过程">形成过程</h4><ul><li>逐步形成：抗击非典疫情和探索未完善社会主义市场经济体制<ul><li>2003.7，总结非典经验：全面发展，协调发展，可持续发展</li><li>2003.10，科学发展观</li></ul></li><li>充实丰富：加强和改善宏观调控的时间<ul><li>十四届六中全会，树立和落实科学发展观作为提高党的执政能力的重要内容</li><li>十一五规划的建议 / 纲要：以科学发展观统领经济社会发展全局</li></ul></li><li>走向成熟</li><li>发展完善：十七大后，不断发展完善<ul><li>2008.12，在中央经济工作会议上强调，科学发展观第一要义是发展</li><li>十七届五中全会强调，坚持发展是硬道理的本质要求，就是坚持科学发展</li><li>2012，确立为指导思想</li></ul></li></ul><h4 id="内涵">内涵</h4><ul><li>推动经济社会<strong>发展</strong>是科学发展观的<em>第一要义</em>（为什么）</li><li><strong>以人为本</strong>是科学发展观的<em>核心立场</em>（为了谁和依靠谁）</li><li><strong>全面协调可持续</strong>是科学发展观的<em>基本要求</em>（实现什么样的发展）</li><li><strong>统筹兼顾</strong>是科学发展观的<em>根本方法</em>（怎么发展）</li></ul><h4 id="精神实质">精神实质</h4><ul><li>解放思想，实事求是，与时俱进，求真务实</li></ul><h4 id="内容">内容</h4><ul><li>转变经济发展方式<ul><li>持续健康发展</li><li>创新驱动发展战略</li><li>经济结构战略性调整</li><li>促进区域协调发展战略</li><li>城乡发展一体化</li></ul></li><li>发展社会主义民主政治<ul><li>社会主义核心价值体系</li><li>社会主义核心价值观</li></ul></li><li>推进社会主义文化强国建设</li><li>构建社会主义和谐社会</li><li>推进生态文明建设</li><li>全面提高党的建设科学化水平</li></ul><h4 id="历史地位-1">历史地位</h4><ul><li>中国特色社会主义理论体系在新世纪新阶段的接续发展</li><li>全面建设小康社会，加快推进社会主义现代化的根本指针</li></ul>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>公共课程</category>
      
      <category>毛泽东思想与中国特色社会主义理论体系概论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>毛概</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理2笔记</title>
    <link href="/2025/04/10/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/04/10/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="大学物理-2-笔记">大学物理 2 笔记</h1><h2 id="真空中的静电场">真空中的静电场</h2><h3 id="电学基本概念">电学基本概念</h3><h4 id="电荷">电荷</h4><ul><li>代表物质间发生电离相互作用的物质的一种属性</li><li>一般用 <span class="math inline">\(q\)</span> 表示</li></ul><p>电荷的单位为 库伦 <span class="math inline">\(C\)</span>，<spanclass="math inline">\(1C = 1A\cdot s\)</span></p><h5 id="电荷的基本性质">电荷的基本性质</h5><h6 id="电荷的正负性">电荷的正负性</h6><ul><li>电荷有正负两种性质</li><li>同种电荷相互排斥，异种电荷相互吸引</li></ul><h5 id="电荷的量子化">电荷的量子化</h5><p>任何带电体的电量都是电子电量的整数倍</p><p><span class="math display">\[q = N\cdot e\quad (N=0,\pm 1,\pm 2,\ldots)\]</span></p><p>其中 <span class="math inline">\(e = 1.602\times 10^{-19}C\)</span>为电子的电量</p><h6 id="电荷量子化的实验验证">电荷量子化的实验验证</h6><p>密立根的油滴实验</p><h5 id="电荷的守恒性">电荷的守恒性</h5><p>在一个和外界没有电荷交换的系统内，正负电荷的代数和在任意物理过程中保持不变</p><p><span class="math display">\[\sum Q_i =\text{const.}\]</span></p><p>可以通过法拉第冰桶实验证明</p><h5 id="电荷运动的不变性">电荷运动的不变性</h5><p>电荷电量与运动状态无关，具有相对论不变性</p><h4 id="点电荷">点电荷</h4><p>点电荷是一种可以忽略大小的带电体</p><p>带电体之间发生电路相互作用，如果它们之间的距离远远大于带电体本身的尺寸，那么带电体的尺寸和形状可以忽略不计，而将带电体看作是点电荷</p><h4 id="电荷之间的作用力">电荷之间的作用力</h4><p>库伦定律：在真空之中，两个静止点电荷之间的相互作用力大小，与它们的电量的乘积成正比，与它们之间距离的平方成反比；作用力的方向沿着它们的联线，同号电荷相斥，异号电荷相吸</p><p><span class="math display">\[\vec{F} =\frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\vec{e_r}\]</span></p><p>我们可以令</p><p><span class="math display">\[k=\frac{1}{4\pi\varepsilon_0}=8.9875\times 10^9 N\cdot m^2/C^2\approx9.0\times 10^9N\cdot m^2/C^2\]</span></p><p>其中 <span class="math inline">\(\varepsilon_0 = 8.854\times10^{-12}C^2/(N\cdot m^2)\)</span> 为真空介电常数</p><h4 id="多个电荷间的作用力">多个电荷间的作用力</h4><p>遵循电力叠加原理</p><p>离散的点电荷</p><p><span class="math display">\[\vec{F}=\sum_i\vec{F_i}=\frac{1}{4\pi\varepsilon_0}\sum_i\frac{qq_i}{r_i^2}\vec{e_{r_i}}\]</span></p><h3 id="电场与电场强度">电场与电场强度</h3><h4 id="电场">电场</h4><p>是电荷周围存在的一种物理场</p><h4 id="电场强度">电场强度</h4><p><span class="math display">\[\vec{E}=\frac{\vec{F}}{q}=\frac{1}{4\pi\varepsilon_0}\frac{q_i}{r^2}\vec{e_r}\]</span></p><p>单位为 <span class="math inline">\(N/C\)</span> 或 <spanclass="math inline">\(V/m\)</span></p><p>方向为正电荷在该点所受力的方向</p><h4 id="电场强度的计算">电场强度的计算</h4><h5 id="点电荷的场强">点电荷的场强</h5><p><span class="math display">\[\vec{E}=\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}\vec{e_r}\]</span></p><h5 id="多个点电荷的场强">多个点电荷的场强</h5><p><span class="math display">\[\vec{E}=\sum_i\vec{E_i}=\frac{1}{4\pi\varepsilon_0}\sum_i\frac{q_i}{r_i^2}\vec{e_{r_i}}\]</span></p><h5 id="连续分布电荷的场强">连续分布电荷的场强</h5><p><span class="math display">\[\vec{E}=\frac{1}{4\pi\varepsilon_0}\int\frac{\mathrm{d}q}{r^2}\vec{e_r}\]</span></p><p>我们可以将 <span class="math inline">\(\mathrm{d}q\)</span>表示为</p><ol type="1"><li>线电荷分布：<spanclass="math inline">\(\mathrm{d}q=\lambda\mathrm{d}l\)</span></li><li>面电荷分布：<spanclass="math inline">\(\mathrm{d}q=\sigma\mathrm{d}s\)</span></li><li>体电荷分布：<spanclass="math inline">\(\mathrm{d}q=\rho\mathrm{d}v\)</span></li></ol><h5 id="几种模型的场强">几种模型的场强</h5><h6id="真空中有均匀带电直线电荷线密度为-lambda线外有一点-p离开直线的垂直距离为-ap-点和直线两端连线的夹角分别为-theta_1-和-theta_2求-p-点的场强">真空中有均匀带电直线，电荷线密度为<span class="math inline">\(\lambda\)</span>线外有一点P，离开直线的垂直距离为 <span class="math inline">\(a\)</span>，P点和直线两端连线的夹角分别为 <spanclass="math inline">\(\theta_1\)</span> 和 <spanclass="math inline">\(\theta_2\)</span>求 P 点的场强</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180810166.png"alt="有限长带电直导线" /><figcaption aria-hidden="true">有限长带电直导线</figcaption></figure><ul><li><span class="math inline">\(\displaystyleE_x=\frac{\lambda}{4\pi\varepsilon_0a}(\sin\theta_2-\sin\theta_1)\)</span></li><li><span class="math inline">\(\displaystyleE_y=\frac{\lambda}{4\pi\varepsilon_0a}(\cos\theta_1-\cos\theta_2)\)</span></li></ul><p>当导线无限长时</p><ul><li><span class="math inline">\(\displaystyle E_x=0\)</span></li><li><span class="math inline">\(\displaystyleE_y=\frac{\lambda}{2\pi\varepsilon_0a}\)</span></li></ul><h6id="电荷-q-均匀地分布在半径为-r-圆心角为-theta-的一段圆弧上计算圆弧圆心位置的场强">电荷<span class="math inline">\(q\)</span> 均匀地分布在半径为 <spanclass="math inline">\(R\)</span> ，圆心角为 <spanclass="math inline">\(\theta\)</span>的一段圆弧上，计算圆弧圆心位置的场强</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180832207.png"alt="带电圆弧" /><figcaption aria-hidden="true">带电圆弧</figcaption></figure><ul><li><span class="math inline">\(\displaystyle E_x=0\)</span></li><li><span class="math inline">\(\displaystyleE_y=-\frac{q}{2\pi\varepsilon_0R^2}\frac{\sin(\theta/2)}{\theta}\)</span></li></ul><h6id="电荷-q-均匀地分布在一半径为-r-的圆环上计算在圆环的轴线上任一给定点-p-的场强">电荷<span class="math inline">\(q\)</span> 均匀地分布在一半径为 <spanclass="math inline">\(r\)</span> 的圆环上计算在圆环的轴线上任一给定点 P的场强</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180835005.png"alt="带电圆环" /><figcaption aria-hidden="true">带电圆环</figcaption></figure><ul><li><span class="math inline">\(\displaystyleE_x=\frac{1}{4\pi\varepsilon_0}\frac{qx}{(x^2+r^2)^{3/2}}\)</span></li></ul><h6id="均匀带电圆板半径为-r电荷面密度为-sigma求轴线上任一点-p-的电场强度">均匀带电圆板，半径为<span class="math inline">\(R\)</span>，电荷面密度为 <spanclass="math inline">\(\sigma\)</span>求轴线上任一点 P 的电场强度</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180836392.png"alt="带电圆板" /><figcaption aria-hidden="true">带电圆板</figcaption></figure><p><span class="math display">\[E=\frac{\sigma}{2\varepsilon_0}\left[1-\frac{x}{\sqrt{x^2+R^2}}\right]\]</span></p><p>特别的，当 <span class="math inline">\(\displaystyleR\to\infty\)</span> 时，<span class="math inline">\(\displaystyleE=\frac{\sigma}{2\varepsilon_0}\)</span></p><h3 id="高斯定理">高斯定理</h3><h4 id="电场线">电场线</h4><p>电场线是描述电场分布情况的曲线</p><ul><li>电场线的切线方向与该点的电场强度方向相同</li><li>电场线的疏密程度表示该处电场强度的大小</li></ul><h4 id="电通量">电通量</h4><p>电通量 <span class="math inline">\(\Phi\)</span>是电场通过某一面积的电场线的总数</p><p>电通量是标量</p><p>单位为 <span class="math inline">\(N\cdot m^2/C\)</span> 或 <spanclass="math inline">\(V\cdot m\)</span></p><p><span class="math display">\[\Phi=\int_SE\cos\theta\mathrm{d}S = \int_S\vec{E}\cdot\mathrm{d}\vec{S}\]</span></p><p>通过闭合曲面的电通量</p><p><span class="math display">\[\Phi=\oint_S\vec{E}\cdot\mathrm{d}\vec{S}\]</span></p><h4 id="高斯定理-1">高斯定理</h4><p>如果在真空中场源是若干个点电荷，则穿过任一闭合曲面的总电通量等于该闭合曲面包围的电荷电量的代数和（净电荷）的<span class="math inline">\(\frac{1}{\varepsilon_0}\)</span> 倍</p><p><span class="math display">\[\Phi_e=\oint_S\vec{E}\cdot\mathrm{d}\vec{S}=\frac{\sum_{i=1}^nq_{i内}}{\varepsilon_0}\]</span></p><h3 id="环流定理和电势">环流定理和电势</h3><h4 id="场强环流定理">场强环流定理</h4><p>单位实验电荷沿着闭合路径移动回出发点时，电场力做功为 <spanclass="math inline">\(0\)</span></p><p><span class="math display">\[\oint_{abcd}\vec{E}\cdot\mathrm{d}\vec{l}=\int_{abc}\vec{E}\cdot\mathrm{d}\vec{l}+\int_{cda}\vec{E}\cdot\mathrm{d}\vec{l}=0\]</span></p><p>即</p><p><span class="math display">\[\oint\vec{E}\cdot\mathrm{d}\vec{l}=0\]</span></p><p>在<strong>静电场</strong>中场强沿着闭合环路的第一类线积分等于零</p><h4 id="电势能和电势">电势能和电势</h4><h5 id="电势能">电势能</h5><p>静电场是保守场，所以可以引入电势能的概念</p><p><span class="math display">\[W_a-W_b=A_{ab}=\int_b^a\vec{F}\cdot\mathrm{d}\vec{l}=q\int_b^a\vec{E}\cdot\mathrm{d}\vec{l}\]</span></p><p>我们通常取无限远处为电势能零点</p><p>则试验电荷 <span class="math inline">\(q_0\)</span> 在 a点处的电势能为</p><p><span class="math display">\[W_a=A_{a\infty}=q_0\int_\infty^a\vec{E}\cdot\mathrm{d}\vec{l}\]</span></p><p>也就是说试验电荷 <span class="math inline">\(q_0\)</span> 在 a点的电势能等于它从无限远处移到 a 点时电场力所做的功</p><h5 id="电势">电势</h5><p><span class="math display">\[\varphi_a=\frac{W_a}{q_0}=\int_\infty^a\vec{E}\cdot\mathrm{d}\vec{l}\]</span></p><p>电势的单位为伏特 <span class="math inline">\(V\)</span>，<spanclass="math inline">\(1V=1J/C\)</span></p><h5 id="电势差">电势差</h5><p>a 点和 b 点之间电势的差值 <spanclass="math inline">\(U_a-U_b\)</span> 称为电势差</p><p>也被称为<strong>电压</strong></p><h5 id="几种常见的模型电势">几种常见的模型电势</h5><h6 id="点电荷的电势">点电荷的电势</h6><p><span class="math display">\[\varphi=\frac{1}{4\pi\varepsilon_0}\frac{q}{r}\]</span></p><h6 id="带电圆环轴线上一点的电势">带电圆环轴线上一点的电势</h6><p>均匀带电细圆环,总电量为 <span class="math inline">\(q\)</span>,半径为<span class="math inline">\(R\)</span>,求圆环轴线上任一点的电势</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281337024.png"alt="带电圆环" /><figcaption aria-hidden="true">带电圆环</figcaption></figure><p>由前文可知带电圆环上任意一点的电场强度为</p><p><span class="math display">\[E=\frac{qx}{4\pi\varepsilon_0(x^2+R^2)^{3/2}}\]</span></p><p>则</p><p><span class="math display">\[\varphi=\int_\infty^xE\mathrm{d}x=\frac{q}{4\pi\varepsilon_0(x^2+R^2)^\frac{1}{2}}\]</span></p><h6 id="均匀带电球体的电势">均匀带电球体的电势</h6><p>均匀带电球体,总电量为 <span class="math inline">\(q\)</span>,半径为<span class="math inline">\(R\)</span>,求球外和球内任一点的电势</p><p><span class="math display">\[V=\left\{  \begin{aligned}    &amp;\frac{1}{4\pi\varepsilon_0}\cdot\frac{q}{r}&amp;&amp; (r\geR)\\    &amp;\frac{1}{4\pi\varepsilon_0}\cdot\frac{q(3R^2-r^2)}{2R^3}&amp;&amp;(r&lt;R)  \end{aligned}\right.\]</span></p><h6 id="带电球壳的电势">带电球壳的电势</h6><p><span class="math display">\[V=\left\{  \begin{aligned}    &amp;\frac{1}{4\pi\varepsilon_0}\cdot\frac{q}{r}&amp;&amp; (r\geR)\\    &amp;\frac{1}{4\pi\varepsilon_0}\cdot\frac{q}{R}&amp;&amp; (r&lt;R)  \end{aligned}\right.\]</span></p><h4 id="电偶极子">电偶极子</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281410764.png"alt="电偶极子" /><figcaption aria-hidden="true">电偶极子</figcaption></figure><ul><li>电量 <span class="math inline">\(q\)</span> 的正负两点电荷</li><li>电偶极矩 <span class="math inline">\(\vec{p}=q\vec{l}\)</span></li></ul><h5 id="电偶极子场中的电势">电偶极子场中的电势</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281411344.png"alt="电偶极子场中一点电荷" /><figcaption aria-hidden="true">电偶极子场中一点电荷</figcaption></figure><p><span class="math display">\[\begin{aligned}  &amp;V_+=\frac{1}{4\pi\varepsilon_0}\cdot\frac{q}{r_+}\\  &amp;V_-=\frac{1}{4\pi\varepsilon_0}\cdot\frac{-q}{r_-}\\  &amp;V=V_++V_-=\frac{1}{4\pi\varepsilon_0}\left(\frac{q}{r_+}-\frac{q}{r_-}\right)\\\end{aligned}\]</span></p><p>因为 <span class="math inline">\(l\ll r\)</span>，<spanclass="math inline">\(r_--r_+\approx l\cos{\theta}\)</span>，<spanclass="math inline">\(r_+r_-\approx r^2\)</span>，所以</p><p><span class="math display">\[V=\frac{1}{4\pi\varepsilon_0}\cdot\frac{ql\cos{\theta}}{r^2}=\frac{1}{4\pi\varepsilon_0}\cdot\frac{p\cos\theta}{r^2}\]</span></p><h5 id="电偶极子场中的场强">电偶极子场中的场强</h5><p><span class="math display">\[\begin{aligned}  &amp;E_r=-\frac{\partial V}{\partialr}=\frac{1}{2\pi\varepsilon_0}\cdot\frac{p\cos\theta}{r^3}\\  &amp;E_\theta=-\frac{1}{r}\frac{\partialV}{\partial\theta}=\frac{1}{4\pi\varepsilon_0}\cdot\frac{p\sin\theta}{r^3}\\  &amp;\vec{E}=E_r\vec{e_r}+E_\theta\vec{e_\theta}\end{aligned}\]</span></p><h4 id="均匀外电场中的电偶极子">均匀外电场中的电偶极子</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509281420775.png"alt="均匀外电场中的电偶极子" /><figcaption aria-hidden="true">均匀外电场中的电偶极子</figcaption></figure><ul><li>电场力 <span class="math inline">\(\displaystyle\vec{F}=q\vec{E}-q\vec{E}=0\)</span></li><li>力矩 <span class="math inline">\(\displaystyle\vec{M}=\vec{p}\times\vec{E}\)</span></li><li>电势能 <span class="math inline">\(\displaystyleW=-\vec{p}\cdot\vec{E}=-pE\cos\theta\)</span></li></ul><h2 id="静电场与物质的相互作用">静电场与物质的相互作用</h2><h3 id="静电场中的导体">静电场中的导体</h3><h4 id="导体的静电感应和静电平衡">导体的静电感应和静电平衡</h4><p>金属导体可看作是组成具有空间周期性的晶格的大量的带正电的原子实和大量的价电子</p><p>无外电场时，价电子在晶格的周期性正电背景场中近乎自由地运动，常称之为自由电子</p><p>原子实近似静止</p><p>当导体收到外电场作用时，内部的电子沿着外电场作反向的定向运动</p><h5 id="静电感应">静电感应</h5><p>在外电场的作用下，导体内自由电子有宏观移动，导体表面出现宏观电荷分布的现象</p><h5 id="静电平衡">静电平衡</h5><p>感应电荷在导体内部产生一个与外电场方向相反的电场，随着电子的不断移动，这个电场强度不断增大，直至和外界电场强度抵消，和电场为<spanclass="math inline">\(0\)</span>，此时导体内的自由电子不再有定向移动，导体达到静电平衡状态</p><h4 id="导体静电平衡时的性质">导体静电平衡时的性质</h4><h5 id="导体内部场强处处为-0">导体内部场强处处为 <spanclass="math inline">\(0\)</span></h5><p><span class="math display">\[\vec{E}=\vec{E_\text{内}}+\vec{E_\text{外}}=0\]</span></p><h5id="导体电势处处相同整个导体为等势体">导体电势处处相同，整个导体为等势体</h5><p>导体内部电势差处处为 <span class="math inline">\(0\)</span></p><p><span class="math display">\[U_b-U_a=\int_a^b\vec{E}\cdot\mathrm{d}\vec{l}=0\]</span></p><h4 id="静电平衡时导体上电荷的分布">静电平衡时导体上电荷的分布</h4><h5 id="实心导体">实心导体</h5><p>电荷只分布在导体表面，内部没有电荷</p><p>证明：</p><p>在导体内部任意取一高斯面</p><p><span class="math display">\[q=\varepsilon_0\oint_S\vec{E}\cdot\mathrm{d}\vec{S}=0\]</span></p><h5 id="空腔导体">空腔导体</h5><h6 id="腔内无电荷">腔内无电荷</h6><p>电荷只分布在外表面</p><h6 id="腔内有电荷">腔内有电荷</h6><p>在内表面和外表面均有电荷分布，内表面的电荷分布只与腔内电荷有关，外表面的电荷分布只与导体外部电荷有关</p><h4 id="静电屏蔽">静电屏蔽</h4><p>在导体内部，场强处处为 <spanclass="math inline">\(0\)</span>，所以导体内部的空间不受外界电场的影响</p><h4 id="尖端放电">尖端放电</h4><p>在导体表面的场强与该点的面电荷密度成正比，方向垂直与表面</p><p><span class="math display">\[\oint_S\vec{E}\cdot\mathrm{d}\vec{S}=\frac{q}{\varepsilon_0}=\frac{\sigmaS}{\varepsilon_0}\]</span></p><p>通过实验研究得到导体电荷的定性分布，即表面处面电荷密度 <spanclass="math inline">\(\sigma\)</span> 与该点的曲率半径 <spanclass="math inline">\(R\)</span>成反比，并且当表面为凹进时，电荷密度更小</p><p>对于具有尖端的带电体，因为尖端的曲率很大，分布的面电荷密度也大，所以它周围的电场很强，当场强超过空气击穿场强时，就会发生空气被电离的放电现象，称为尖端放电</p><h3 id="静电场中的电介质">静电场中的电介质</h3><p>按照导电能力的不同，对固体如下分类</p><ol type="1"><li>导体 内部存在大量自由电子</li><li>绝缘体（电介质）所有电子均在各自所属的原子内部运动，内部几乎没有自由电荷</li><li>半导体 少量可自由移动的电荷</li></ol><h4 id="电介质的分类和极化">电介质的分类和极化</h4><h5 id="电介质的电结构">电介质的电结构</h5><ol type="1"><li>电子被原子核紧紧束缚</li><li>在静电场中电介质中性分子的正负电荷仅产生围观相对运动</li><li>在静电场与电戒指相互作用时，电介质分子简化为电偶极子</li></ol><p>我们将分子中的全部正电荷等效为一个总的正电荷，全部负电荷等效为一个总的负电荷，那么中性分子简化为电偶极子</p><p>以 <span class="math inline">\(q\)</span>表示电偶极子中正负电荷的电量，<spanclass="math inline">\(\vec{l}\)</span>表示正负电荷之间的距离，则分子的等效电偶极矩为</p><p><span class="math display">\[\vec{p}=q\vec{l}\]</span></p><p>下面介绍两个概念</p><ul><li>有极分子 正电荷中心与负电荷中心不重合的分子</li><li>无极分子 正电荷中心与负电荷中心重合的分子</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510102054423.png"alt="两种极化" /><figcaption aria-hidden="true">两种极化</figcaption></figure><h4 id="电极化强度矢量">电极化强度矢量</h4><p>有外加电场时，宏观体积内的电介质分子的电偶极矩的矢量和可以不为零，为了定量描述电介质的极化程度，引入与体积无关的极化强度矢量</p><p><span class="math display">\[\vec{P}=\frac{\sum_{\Delta V}\vec{p_i}}{\Delta V}\quad(\text{单位为}C/m^2)\]</span></p><p>实验证明：对于各向同性的介质，当外电场不太强时，介质内任意点的电极化强度与该点的<strong>总电场强度</strong>成正比</p><p><span class="math display">\[\vec{P}=\chi_e\varepsilon_0\vec{E}\]</span></p><ul><li>其中 <span class="math inline">\(\chi_e\)</span>被称为介质的<strong>电极化率</strong>当介质为各向同性的均匀介质时，极化率为一常数</li><li><span class="math inline">\(\vec{E}\)</span>为介质内的<strong>总电场强度</strong></li></ul><h4 id="极化电荷分布">极化电荷分布</h4><p>极化电荷在某个面上的面密度</p><p><span class="math display">\[\sigma&#39;=\vec{P}\cdot\vec{e_n}\]</span></p><ul><li><span class="math inline">\(\vec{P}\)</span> 为极化强度</li><li><span class="math inline">\(\vec{e_n}\)</span>为面外法线方向的单位矢量</li></ul><p>不同介质交界面处的极化电荷面密度</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510102112502.png"alt="两介质交界面" /><figcaption aria-hidden="true">两介质交界面</figcaption></figure><p><span class="math display">\[\sigma&#39;=\vec{P}_1\cdot\vec{e}_{n_1}+\vec{P}_2\cdot\vec{e}_{n_2}=(\vec{P}_1-\vec{P}_2)\cdot\vec{e}_{n_1}\]</span></p><h4 id="高斯闭合曲面内的极化电荷">高斯闭合曲面内的极化电荷</h4><p>在极化介质中取一闭合曲面 <spanclass="math inline">\(S\)</span>，其内的净剩的极化电荷总量为</p><p><span class="math display">\[\begin{aligned}  \sum_{S\text{内}} q&#39;&amp;=\oiint_S\sigma&#39;\mathrm{d}S\\                      &amp;=\oiint_S\vec{P}\cdot\mathrm{d}\vec{S}\\                      &amp;=\iiint_V(\nabla\cdot\vec{P})\mathrm{d}v\\                      &amp;= -\iiint_V\rho&#39;\mathrm{d}v\end{aligned}\]</span></p><p>得到结论：极化电荷的体密度</p><p><span class="math display">\[\rho&#39;=-\nabla\cdot\vec{P}\]</span></p><h4 id="电介质中静电场的基本规律">电介质中静电场的基本规律</h4><h5 id="介质中的高斯定理">介质中的高斯定理</h5><p>在电介质中高斯定律仍然成立</p><p><span class="math display">\[\oiint\vec{E}\cdot\mathrm{d}\vec{S}=\frac{1}{\varepsilon_0}\left(\sumq_0+\sum q&#39;\right)\]</span></p><ul><li><span class="math inline">\(\sum q_0\)</span>为闭合曲面内的自由电荷总量</li><li><span class="math inline">\(\sum q&#39;\)</span>为闭合曲面内的极化电荷总量</li></ul><p>处理得到</p><p><span class="math display">\[\oiint_s\left(\varepsilon_0\vec{E}+\vec{P}\right)\cdot\mathrm{d}\vec{S}=\sumq_0\]</span></p><p>我们定义电位移矢量</p><p><span class="math display">\[\vec{D}=\varepsilon_0\vec{E}+\vec{P}\]</span></p><p>则</p><p><span class="math display">\[\oiint_S\vec{D}\cdot\mathrm{d}\vec{S}=\sum q_0\]</span></p><h3 id="电容器及电容">电容器及电容</h3><h4 id="孤立导体的电容">孤立导体的电容</h4><p>孤立导体的电势与带电量有关，且成正比‘</p><p>我们定义</p><p><span class="math display">\[C=\frac{q}{V}\]</span></p><p>为该导体的电容，单位为法拉 <spanclass="math inline">\(F\)</span>，<spanclass="math inline">\(1F=1C/V\)</span></p><h4 id="电容器的电容">电容器的电容</h4><p>两导体组 A 和 B 之间的电容器</p><p><span class="math display">\[C=\frac{Q}{\Delta V_{AB}}\]</span></p><h4 id="几种常见电容器及其电容">几种常见电容器及其电容</h4><h5 id="平行板电容器">平行板电容器</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510141026835.png"alt="平行板电容器" /><figcaption aria-hidden="true">平行板电容器</figcaption></figure><p><span class="math display">\[C=\varepsilon_0\frac{S}{d}\]</span></p><h5 id="球形电容器">球形电容器</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510141042608.png"alt="球形电容器" /><figcaption aria-hidden="true">球形电容器</figcaption></figure><p><span class="math display">\[C=4\pi\varepsilon_0\frac{R_AR_B}{R_B-R_A}\]</span></p><h5 id="圆柱形电容器">圆柱形电容器</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510141043726.png"alt="圆柱形电容器" /><figcaption aria-hidden="true">圆柱形电容器</figcaption></figure><p><span class="math display">\[C=\frac{2\pi\varepsilon_0l}{\ln(\frac{R_2}{R_1})}\]</span></p><h4 id="电容器的联接">电容器的联接</h4><h5 id="电容器的并联">电容器的并联</h5><p><span class="math display">\[\left\{  \begin{aligned}    &amp;u_1=u_2=u\\    &amp;q_1+q_2=q  \end{aligned}\right.\]</span></p><p><span class="math display">\[C=C_1+C_2\]</span></p><h5 id="电容器的串联">电容器的串联</h5><p><span class="math display">\[\left\{  \begin{aligned}    &amp;q_1=q_2=q\\    &amp;u_1+u_2=u  \end{aligned}\right.\]</span></p><p><span class="math display">\[\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}\]</span></p><h3 id="静电场中的能量">静电场中的能量</h3><h4 id="带电体系的经典能">带电体系的经典能</h4><p>系统从状态 <span class="math inline">\(a\)</span>无限分裂到彼此相距无限远的状态中静电场力作的功，叫作系统在状态 <spanclass="math inline">\(a\)</span> 时的静电势能，简称静电能</p><h4 id="点电荷之间的相互作用能">点电荷之间的相互作用能</h4><p>对于两个点电荷 <span class="math inline">\(q_1\)</span> 和 <spanclass="math inline">\(q_2\)</span>，它们之间的相互作用能为</p><p><span class="math display">\[W=\frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r_{12}}\]</span></p><p>若带电体连续分布</p><p><span class="math display">\[W=\frac{1}{2}\int_QU\,\mathrm{d}q\]</span></p><h4 id="电容器的静电能">电容器的静电能</h4><p><span class="math display">\[W_e=\frac{1}{2}CU^2=\frac{1}{2}QU=\frac{1}{2}\frac{Q^2}{C}\]</span></p><h4 id="静电场能及电场能量密度">静电场能及电场能量密度</h4><p>以平行板电容器为例</p><p><span class="math display">\[W_e=\frac{1}{2}QU=\frac{1}{2}\varepsilon E^2 Sd=\frac{1}{2}DEV\]</span></p><p>则其电场能量密度为</p><p><span class="math display">\[w_e=\frac{\mathrm{d}W_e}{\mathrm{d}V}=\frac{1}{2}DE\]</span></p><p>在一般情况下</p><p>在无穷大空间中，电位移矢量 <spanclass="math inline">\(\vec{D}\)</span> ，电场强度 <spanclass="math inline">\(\vec{E}\)</span>，当电势为 <spanclass="math inline">\(U\)</span> 时，自由电荷密度增加 <spanclass="math inline">\(\delta \rho\)</span></p><p>其总能量增加</p><p><span class="math display">\[\begin{aligned}  \delta W_e &amp;=\iiint_VU\delta\rho\,\mathrm{d}V\\             &amp;=\iiint_VU\nabla\cdot\delta\vec{D}\,\mathrm{d}V\\             &amp;=\iiint_V\left[\nabla\cdot(U\delta\vec{D})-\delta\vec{D}\cdot\nablaU\right]\,\mathrm{d}V\\             &amp;=\iiint_V\nabla\cdot(U\delta\vec{D})\,\mathrm{d}V-\iiint_V\delta\vec{D}\cdot\nablaU\,\mathrm{d}V\\             &amp;=\oiint(U\delta\vec{D})\cdot\,\mathrm{d}\vec{S}+\iiint_V\vec{E}\cdot\delta\vec{D}\,\mathrm{d}V\end{aligned}\]</span></p><p>因为在无穷远处 <spanclass="math inline">\(\vec{D}=0\)</span>，所以</p><p><span class="math display">\[\begin{aligned}  W_e=\int\delta W_e&amp;=\iiint_V\int_0^E\vec{E}\cdot\delta\vec{D}\,\mathrm{d}V\\             &amp;=\iiint_V\frac{1}{2}\varepsilon E^2\,\mathrm{d}V\end{aligned}\]</span></p><p>则电场能密度为</p><p><span class="math display">\[w_e=\frac{1}{2}\varepsilon E^2=\frac{1}{2}DE\]</span></p><h2 id="真空中的磁场">真空中的磁场</h2><h3 id="电流与电源">电流与电源</h3><h4 id="电流稳恒电场与电源">电流、稳恒电场与电源</h4><h5 id="电流">电流</h5><p>电子的定向移动形成电流</p><p>定向运动的宏观电荷可以看成等效电流</p><p>比如绕自身对称轴旋转的均匀带电圆环、圆盘、球面、球体等</p><h5 id="稳恒电流的形成">稳恒电流的形成</h5><p>仅有静电场不可能在导体回路中形成稳恒电流电荷移动时需要克服阻力做功，但是由于静电场是保守场，电荷在回路中移动一周所做的功为零，无法满足克服阻力做功这一条件</p><p>稳恒电流实现的前提</p><ol type="1"><li>导体内存在不随时间变化的恒定电场</li><li>必须是包含导体在内的闭合回路</li><li>需要非静电力做功，使得自由电子从高电势回到低电势处，以维持稳恒电流</li></ol><h4 id="电源">电源</h4><p>能够提供非静电力的装置被称为电源</p><p>在电源外部，电源提供静电场，使得正电荷从电势高处流向电势低处</p><p>在电源内部，静电场力和非静电力都存在，并且非静电力克服静电场力做功，使得正电荷从电势低处流向电势高处</p><h5 id="电动势">电动势</h5><p>用于表征电源将非静电能转换为电能的能力</p><p>电动势 <span class="math inline">\(\varepsilon\)</span>等于将单位正电荷从电源负极沿内电路移到正极过程中非静电力做的功</p><p><span class="math display">\[\varepsilon=\frac{1}{q}\int_-^+q\vec{E_k}\cdot\mathrm{d}\vec{l}=\int_-^+\vec{E_k}\cdot\mathrm{d}\vec{l}\]</span></p><p>电动势为标量，正方向为自负极经电源内部指向正极</p><h4 id="稳恒电场">稳恒电场</h4><p>由非静止，但是空间分布保持恒定的电荷产生的电场</p><h4 id="电流强度和电流密度矢量">电流强度和电流密度矢量</h4><h5 id="电流强度">电流强度</h5><p>电流强度位单位时间内通过导体某一横截面的电荷量</p><p><span class="math display">\[I=\lim_{\Delta t \to 0}\frac{\Delta q}{\Deltat}=\frac{\mathrm{d}q}{\mathrm{d}t}\]</span></p><p>方向为正电荷流动的方向，单位为安培 <spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(1A=1C/s\)</span></p><p>如果电流强度与时间无关，则称为稳恒电流</p><h5 id="电流密度">电流密度</h5><p>电流密度大小等于垂直于电场方向的单位截面流过的电流强度</p><p><span class="math display">\[\vec{J}=\frac{\mathrm{d}I}{\mathrm{d}S}\vec{e_n}\]</span></p><p>单位为 <span class="math inline">\(A/m^2\)</span></p><p>通过电流密度可以计算电流强度</p><p><span class="math display">\[I=\int_S\vec{J}\cdot\,\mathrm{d}\vec{s}\]</span></p><p>电流强度的决定式</p><p><span class="math display">\[\vec{j}=q_e\vec{v_e}\]</span></p><ul><li><span class="math inline">\(q_e\)</span> 为电荷的体密度<ul><li><span class="math inline">\(q&gt;0\)</span> 时，<spanclass="math inline">\(\vec{j}\)</span> 与 <spanclass="math inline">\(\vec{v_e}\)</span> 同向</li><li><span class="math inline">\(q&lt;0\)</span> 时，<spanclass="math inline">\(\vec{j}\)</span> 与 <spanclass="math inline">\(\vec{v_e}\)</span> 反向</li></ul></li><li><span class="math inline">\(\vec{v_e}\)</span>为电荷的平均漂移速度</li></ul><h5 id="欧姆定律的微分形式">欧姆定律的微分形式</h5><p>对于柱形材料</p><p><span class="math display">\[R=\rho\frac{l}{S}\]</span></p><ul><li><span class="math inline">\(\rho\)</span> 为材料的电阻率，<spanclass="math inline">\(\frac{1}{\rho}=\gamma\)</span> 为材料的电导率</li></ul><p>则由欧姆定律可以得出</p><p><span class="math display">\[\vec{j}=\gamma\vec{E}\]</span></p><p>由计算可以得到</p><p><span class="math display">\[\gamma=\frac{nq^2\tau}{2m}\]</span></p><ul><li><span class="math inline">\(\tau\)</span> 为电子的平均自由时间</li></ul><h5 id="电路上两点的电势差">电路上两点的电势差</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202510151418894.png"alt="一段含塬电路" /><figcaption aria-hidden="true">一段含塬电路</figcaption></figure><p><span class="math display">\[U_{ab}=V_a-V_b=-IR+\varepsilon\]</span></p><h3 id="磁场的磁感应强度">磁场的磁感应强度</h3><h4 id="基本磁现象">基本磁现象</h4><ol type="1"><li><strong>磁性与磁极</strong>：物质具有吸引铁、钴、镍等物质的性质，称为<strong>磁性</strong>磁体上磁性最强的区域称为<strong>磁极</strong>，分为N 极（北极）和 S极（南极）磁极间的相互作用规律是：<em>同性相斥，异性相吸</em></li><li><strong>磁极的不可分割性</strong>：磁体的两个磁极总是成对出现，无法将N 极与 S极单独分离开这是磁现象与电现象（电荷可独立存在）的一个基本区别</li><li><strong>电流的磁效应</strong>：丹麦物理学家奥斯特在 1820年发现，载流导线可以使其附近的磁针发生偏转，这表明<strong>电流能够产生磁场</strong></li><li><strong>磁现象的电本质</strong>：从经典物理的观点来看，一切磁现象都起源于<strong>电荷的运动</strong>物质的磁性源于其内部分子、原子等微观结构中电荷的运动</li></ol><h4 id="磁场的描述">磁场的描述</h4><p><strong>磁感应强度</strong>（Magnetic Induction Intensity）<spanclass="math inline">\(\vec{B}\)</span>表示传递磁相互作用的特殊物质为了定量描述磁场的强弱和方向</p><ul><li><strong>方向</strong>：磁场中该点处小磁针静止时<strong>N极</strong>所指的方向</li><li><strong>大小</strong>：通过运动电荷在磁场中所受的力来定义</li></ul><p>实验表明，一个电荷量为 <span class="math inline">\(q\)</span>的粒子以速度 <span class="math inline">\(\vec{v}\)</span>在磁场中运动时，所受的磁场力 <spanclass="math inline">\(\vec{F}\)</span> 具有以下特点：</p><ul><li><span class="math inline">\(\vec{F}\perp\vec{v}\)</span> 且 <spanclass="math inline">\(\vec{F}\perp\vec{B}\)</span></li><li><span class="math inline">\(|\vec{F}|\proptoqv\sin\theta\)</span></li></ul><p>描述运动电荷在磁场中所受作用力的基本公式<strong>洛伦兹力公式</strong></p><p><span class="math display">\[\vec{F} = q(\vec{v} \times \vec{B})\]</span></p><p>磁感应强度 <span class="math inline">\(B\)</span>的大小可以由上式定义为：</p><p><span class="math display">\[B = \frac{F}{qv\sin\theta}\]</span></p><ul><li>单位为 <span class="math inline">\(\text{T}\)</span>，<spanclass="math inline">\(1\, \text{T}=1\,\text{N/(A·m)}\)</span></li></ul><h3 id="毕奥萨伐尔定律-biot-savart-law">毕奥—萨伐尔定律 (Biot-SavartLaw)</h3><p>在真空中的一小段载流导线 <spanclass="math inline">\(\mathrm{d}l\)</span> 上的电流为 <spanclass="math inline">\(I\)</span>，该段导线到空间某点 P 的距离为 <spanclass="math inline">\(r\)</span>，<spanclass="math inline">\(\mathrm{d}l\)</span> 与 <spanclass="math inline">\(\vec{r}\)</span> 之间的夹角为 <spanclass="math inline">\(\theta\)</span>，则该段导线在 P 点产生的磁感应强度<span class="math inline">\(\mathrm{d}\vec{B}\)</span> 的大小为</p><p><span class="math display">\[\mathrm{d}\vec{B}=k\frac{I\mathrm{d}\vec{l}\times\vec{r}}{r^3}\]</span></p><ul><li>SI 制中，<spanclass="math inline">\(k=\frac{\mu_0}{4\pi}\)</span>，<spanclass="math inline">\(\mu_0\)</span> 为真空磁导率，<spanclass="math inline">\(\mu_0=4\pi\times10^{-7}\,\text{T·m/A}\)</span></li></ul><h3 id="磁场的基本规律">磁场的基本规律</h3><h4 id="磁感应强度线与磁通量">磁感应强度线与磁通量</h4><ol type="1"><li><p><strong>磁感应强度线</strong> 用于形象化描述磁场分布的曲线</p><ul><li>曲线上任意一点的<strong>切线方向</strong>表示该点磁感应强度的方向</li><li>线的<strong>疏密程度</strong>表示磁感应强度的大小</li></ul></li><li><p><strong>磁通量</strong> 穿过某一曲面的磁感应强度线的总数，用<span class="math inline">\(\Phi_m\)</span> 表示通过一个面元 <spanclass="math inline">\(\mathrm{d}\vec{S}\)</span> 的磁通量为 <spanclass="math inline">\(\mathrm{d}\Phi_m=\vec{B}\cdot\mathrm{d}\vec{S}\)</span> 通过任意曲面 <spanclass="math inline">\(S\)</span> 的总磁通量为：</p><p><span class="math display">\[\Phi_m = \int_S \vec{B} \cdot \,\mathrm{d}\vec{S}\]</span></p><ul><li>单位为 <span class="math inline">\(\text{Wb}\)</span>，<spanclass="math inline">\(1\, \text{Wb}=1\,\text{T·m}^2\)</span></li></ul></li></ol><h4 id="磁高斯定律">磁高斯定律</h4><p>对于一电流系统，在真空中取任一闭合曲面 <spanclass="math inline">\(S\)</span>，则通过该闭合曲面的总磁通量为零</p><p><span class="math display">\[\oint_S \vec{B} \cdot \mathrm{d}\vec{S} = 0\]</span></p><p>这说明磁场为无源场</p><h4 id="安培环路定律">安培环路定律</h4><p>在真空中，磁场沿任一闭合路径的环路积分等于该闭合路径所围面积内的总电流的<span class="math inline">\(\mu_0\)</span> 倍</p><p><span class="math display">\[\sum_i \oint \vec{B_i} \cdot \mathrm{d}\vec{l} = \mu_0 \sum_{\text{内}}I_i\]</span></p><h3 id="磁场对载流导线的作用">磁场对载流导线的作用</h3><h4 id="安培力">安培力</h4><p>在磁场中的一个载流子受到的洛伦兹力为</p><p><span class="math display">\[\vec{F} = q(\vec{v} \times \vec{B})\]</span></p><p>一个电流源可以看作是由大量电荷组成的系统</p><p><span class="math display">\[\mathrm{d}I=nq\vec{v}S\mathrm{d}l\]</span></p><p>则其受到的力为</p><p><span class="math display">\[\mathrm{d}\vec{F} = nq\vec{v}S\mathrm{d}l \times \vec{B} =I\mathrm{d}\vec{l} \times \vec{B}\]</span></p><p>导线中的电子会与晶格相互作用，宏观上表现为导线受到磁场力，称为安培力</p><p><span class="math display">\[\vec{F} = \int_L I\mathrm{d}\vec{l} \times \vec{B}\]</span></p><blockquote><p>通过计算可以知道匀强磁场中一段不规则形状的导线所受的安培力等于连接导线两端的直线所受的安培力</p></blockquote><h4 id="载流线圈在磁场中受到的力矩">载流线圈在磁场中受到的力矩</h4><h5 id="矩形线圈">矩形线圈</h5><p>匀强磁场中，矩形线圈匝数为 <spanclass="math inline">\(N\)</span>，面积为 <spanclass="math inline">\(S\)</span>，电流为 <spanclass="math inline">\(I\)</span>，磁感应强度为 <spanclass="math inline">\(\vec{B}\)</span>，法线与 <spanclass="math inline">\(\vec{B}\)</span> 夹角为 <spanclass="math inline">\(\theta\)</span>，则线圈受到的力矩大小为</p><p><span class="math display">\[M = NIBS\sin\theta\]</span></p><h5 id="任意形状线圈">任意形状线圈</h5><p>在匀强磁场中任意形状平面载流线圈受到的合外力为</p><p><span class="math display">\[\vec{F}=\oint_l (I\mathrm{d}\vec{l} \times \vec{B}) = 0\]</span></p><p>我们可以将线圈看作是由多个小矩形线圈组成</p><p><span class="math display">\[\vec{M} = \oint_l (I\mathrm{d}\vec{l} \times \vec{B}) = IN\vec{B} \times\vec{S}\]</span></p><h4 id="磁力做功">磁力做功</h4><h5 id="运动载流导线">运动载流导线</h5><p>为了方便，我们考虑磁场与导线垂直的情况</p><p><span class="math display">\[F=BIL\]</span></p><p>安培力做功为</p><p><span class="math display">\[A=F\Delta x=BI\Delta xL=BI\Delta S=I\Delta\Phi\]</span></p><h5 id="旋转载流线圈">旋转载流线圈</h5><p><span class="math display">\[A=\int M\,\mathrm{d}\theta=INB\int\sin\theta\,\mathrm{d}\theta=-INB\Delta(\cos\theta)=I\Delta\Phi\]</span></p><p>电流与外磁场呈右手螺旋关系时磁通量取正，反之取负</p><h5 id="非均匀磁场">非均匀磁场</h5><p><span class="math display">\[\mathrm{d}A=I\mathrm{d}\Phi\]</span></p><h5 id="磁矩在均匀外磁场中的势能">磁矩在均匀外磁场中的势能</h5><p>在均匀磁场中，一个磁矩为 <span class="math inline">\(\vec{m}\)</span>的载流线圈具有势能，其大小取决于线圈相对于磁场的取向</p><p><span class="math display">\[U = -\vec{m} \cdot \vec{B}\]</span></p><ul><li>当 <span class="math inline">\(\vec{m}\)</span> 与 <spanclass="math inline">\(\vec{B}\)</span>方向一致时，势能最小，系统最稳定</li><li>当 <span class="math inline">\(\vec{m}\)</span> 与 <spanclass="math inline">\(\vec{B}\)</span>方向相反时，势能最大，系统最不稳定</li></ul><h3 id="带电粒子的运动">带电粒子的运动</h3><h4 id="运动带电粒子的磁场">运动带电粒子的磁场</h4><p>由 Biot-Savart 定律可知，运动带电粒子在空间某点 P产生的磁感应强度为</p><p><span class="math display">\[\vec{B}=\frac{\mu_0}{4\pi}\frac{q\vec{v}\cdot\vec{r}}{r^3}\]</span></p><ul><li>当粒子的速度远远小于光速时成立</li></ul><h4 id="带电粒子在匀强磁场中的运动">带电粒子在匀强磁场中的运动</h4><h5 id="速度平行于磁场">速度平行于磁场</h5><p>当带电粒子以速度 <span class="math inline">\(\vec{v}\)</span>平行于匀强磁场 <span class="math inline">\(\vec{B}\)</span>方向进入磁场时，洛伦兹力为零，粒子将做<strong>匀速直线运动</strong></p><h5 id="速度垂直于磁场">速度垂直于磁场</h5><p>做匀速圆周运动</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;F=qvB=\frac{mv^2}{r}\\    &amp;a_n=\frac{v^2}{r}=\frac{qvB}{m}\\    &amp;r=\frac{mv}{qB}\\    &amp;T=\frac{2\pi r}{v}=\frac{2\pi m}{qB}  \end{aligned}\right.\]</span></p><h5 id="速度与磁场成任意夹角">速度与磁场成任意夹角</h5><p>设夹角为 <span class="math inline">\(\theta\)</span>，则</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;v_\parallel=v\cos\theta\\    &amp;v_\perp=v\sin\theta  \end{aligned}\right.\]</span></p><p>粒子做螺旋运动</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;r=\frac{mv\sin\theta}{qB}\\    &amp;T=\frac{2\pi m}{qB}\\    &amp;h=v\cos\theta T=\frac{2\pi mv\cos\theta}{qB}  \end{aligned}\right.\]</span></p><ul><li><span class="math inline">\(h\)</span> 为螺旋线圈的间距</li></ul><h4 id="霍尔效应">霍尔效应</h4><p>当载流导体置于垂直于电流方向的匀强磁场中时，导体内的自由电子在洛伦兹力作用下发生偏转，在导体的侧面形成电势差，这种现象称为霍尔效应</p><p>随着时间的推移，电子在侧面形成的电场力与洛伦兹力相平衡</p><p><span class="math display">\[qE_H=qv_dB\]</span></p><p><span class="math display">\[E_H=v_dB\]</span></p><p>如果使用电流 <span class="math inline">\(i\)</span> 来表示</p><p><span class="math display">\[E_H=\frac{iB}{nqS}\]</span></p><h2 id="磁场与物质的相互作用">磁场与物质的相互作用</h2><h3 id="磁介质对磁场的影响">磁介质对磁场的影响</h3><p><strong>磁介质定义</strong></p><p>处于磁场中能与磁场发生相互作用的物质被称为磁介质</p><ul><li>与磁场发生呢相互作用强的磁介质为铁磁物质</li><li>与磁场发生相互作用弱的物质分为顺磁质和抗磁质</li></ul><h3 id="分子电流和分子磁矩">分子电流和分子磁矩</h3><p>在一个原子或分子中，电子的轨道运动和自旋运动可用一个等效的环电流来表征，称为<strong>分子电流</strong>，相应的磁矩称为<strong>分子磁矩</strong><span class="math inline">\(\vec{\mu}_m\)</span></p><ol type="1"><li><strong>抗磁质分子：</strong> 分子<strong>没有固有</strong>的磁矩，<span class="math inline">\(\vec{\mu}_m = 0\)</span>无外磁场时，不显宏观磁性</li><li><strong>顺磁质分子：</strong> 分子<strong>有固有</strong>的磁矩，<span class="math inline">\(\vec{\mu}_m \ne 0\)</span>无外磁场时，由于热运动，分子磁矩取向杂乱无章，总磁矩为零， <spanclass="math inline">\(\sum \vec{\mu}_m = 0\)</span>，不显宏观磁性</li></ol><h3 id="顺磁质的转向磁化">顺磁质的转向磁化</h3><p>顺磁质的固有磁矩 <span class="math inline">\(\mu\neq0\)</span>，但分子的热运动导致分子的磁矩取向各不相同，从而 <spanclass="math inline">\(\displaystyle \sum \mu \neq0\)</span>，整个介质不显磁性</p><p>当存在外磁场时，分子受到力矩的作用</p><p><span class="math display">\[\vec{M}=\vec{\mu_m}\times\vec{B}\]</span></p><p>这个力矩使得分子磁矩转向外磁场的方向，导致顺磁质显现出宏观磁性，这种现象称为<strong>顺磁质的转向磁化</strong>，顺磁化的结果是使得介质内部的磁场增强</p><h3 id="抗磁质的感应磁化">抗磁质的感应磁化</h3><p>抗磁质没有固有磁矩 <spanclass="math inline">\(\mu=0\)</span>，所以整个介质不显磁性</p><p>在外磁场中抗磁质分子会产生附加磁矩，与外磁场反向，这种现象称为<strong>抗磁质的感应磁化</strong>，抗磁化的结果是使得介质内部的磁场减弱</p><h3 id="电子的抗磁性">电子的抗磁性</h3><p>电子以 <span class="math inline">\(v,r\)</span>绕原子核转动时，产生的分子电流大小为 <spanclass="math inline">\(I=\frac{ev}{2\pi r}\)</span>，其磁矩大小为</p><p><span class="math display">\[\mu_l=IS=\frac{ev}{2\pi r}\cdot\pi r^2=\frac{evr}{2}\]</span></p><p>电子的旋转有角动量</p><p><span class="math display">\[\vert L \vert=mr v\]</span></p><p>则旋转角动量和旋转磁矩有关系</p><p><span class="math display">\[|\mu_l|=\frac{e}{2m}|L|\]</span></p><p>其角动量变化量为</p><p><span class="math display">\[\mathrm{d}\vec{L}=\vec{M}\mathrm{d}t=\vec{\mu_l}\times\vec{B}\mathrm{d}t=-\frac{e}{2m}\vec{L}\times\vec{B}\mathrm{d}t\]</span></p><ul><li><span class="math inline">\(\displaystyle-\frac{e}{2m}\vec{L}=\vec{\mu}_{\text{orb}}\)</span> 为电子的磁矩</li></ul><p>从而电子角动量变化量与角动量垂直，电子的角动量方向趋向于与磁场方向相反，从而电子的磁矩方向也趋向于与磁场方向相反，表现出抗磁性</p><p>我们称类似电子这样的运动为进动</p><p>磁介质在外磁场中发生的上述微观过程，如转向磁化、感应磁化、电子的抗磁性等，会导致介质内或介质表面出现宏观电流，称为磁化电流，这种现象称为磁化</p><h4 id="超导体的迈斯纳效应">超导体的迈斯纳效应</h4><p>处于超导态的物体，外加磁场无法穿透其内部，即内部的磁感应强度 <spanclass="math inline">\(\vec{B}=0\)</span></p><p>超导体表面感生了一个无损耗的抗磁超导电流，其产生的磁场恰好抵消了超导体内部的磁场</p><h3 id="磁化强度和磁化电流">磁化强度和磁化电流</h3><h4 id="磁化强度">磁化强度</h4><p>引入宏观物理量来描述介质磁化的程度</p><p><span class="math display">\[\vec{M}=\frac{\sum_{i}\vec{mu}_i}{\Delta V}\]</span></p><ul><li>单位为 <span class="math inline">\(A/m\)</span></li><li>在顺磁质中 <span class="math inline">\(\vec{M}\)</span> 与 <spanclass="math inline">\(\vec{B}\)</span> 同向</li><li>在抗磁质中 <span class="math inline">\(\vec{M}\)</span> 与 <spanclass="math inline">\(\vec{B}\)</span> 反向</li></ul><h4 id="磁化电流">磁化电流</h4><p>磁介质中大量<strong>微观</strong>的分子电流在外磁场作用下，发生规律性排列或变化后，在宏观上表现出的等效电流效应</p><p>表面磁化电流线密度</p><p><span class="math display">\[\vec{\alpha}=\vec{M}\times\vec{e}_n\]</span></p><h3 id="介质中的磁场和磁场强度">介质中的磁场和磁场强度</h3><h4 id="介质中的磁高斯定理">介质中的磁高斯定理</h4><p>介质中的磁场可分为两部分</p><p><span class="math display">\[\vec{B}=\vec{B}_0+\vec{B}&#39;\]</span></p><ul><li><span class="math inline">\(\vec{B}_0\)</span> 为外磁场</li><li><span class="math inline">\(\vec{B}&#39;\)</span>为磁化电流产生的磁场</li></ul><p>磁场线为闭合曲线则</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\oint_S \vec{B}_0 \cdot \mathrm{d}\vec{S} = 0\\      &amp;\oint_S \vec{B}&#39; \cdot \mathrm{d}\vec{S}&#39; = 0   \end{aligned}\right.\]</span></p><p>则介质中的磁高斯定理为</p><p><span class="math display">\[\oint_S \vec{B} \cdot \mathrm{d}\vec{S} = \oint_S (\vec{B}_0 +\vec{B}&#39;) \cdot \mathrm{d}\vec{S} = 0\]</span></p><h4 id="介质中的安培环路定律">介质中的安培环路定律</h4><p><span class="math display">\[\oint_L \vec{B} \cdot \mathrm{d}\vec{l} = \mu_0 \left(\sum I + \sumI&#39; \right)= \mu_0 \left(\sum I + \oint_L \vec{M} \cdot\mathrm{d}\vec{l} \right)\]</span></p><p>我们定义磁场强度 <span class="math inline">\(\vec{H}\)</span> 为</p><p><span class="math display">\[\vec{H} = \frac{1}{\mu_0} \vec{B} - \vec{M}\]</span></p><p>则介质中的安培环路定律为</p><p><span class="math display">\[\oint_L \vec{H} \cdot \mathrm{d}\vec{l} = \sum I\]</span></p><p>记</p><p><span class="math display">\[\vec{M}=\chi_m \vec{H}\]</span></p><ul><li><span class="math inline">\(\chi_m\)</span> 为介质的磁化率<ul><li>顺磁质 <span class="math inline">\(\chi_m &gt; 0\)</span></li><li>抗磁质 <span class="math inline">\(\chi_m &lt; 0\)</span></li></ul></li></ul><p><span class="math display">\[\mu_r=1+\chi_m\]</span></p><p>则</p><p><span class="math display">\[\vec{B}=\mu_0(1+\chi_m)\vec{H}=\mu_0\mu_r\vec{H}\]</span></p><ul><li><span class="math inline">\(\mu_r\)</span> 为介质的相对磁导率<ul><li>顺磁质 <span class="math inline">\(\mu_r &gt; 1\)</span></li><li>抗磁质 <span class="math inline">\(\mu_r &lt; 1\)</span></li></ul></li></ul><h3 id="铁磁质">铁磁质</h3><h4 id="磁化曲线">磁化曲线</h4><p>铁磁质的磁化强度 <span class="math inline">\(\vec{M}\)</span>与磁场强度 <span class="math inline">\(\vec{H}\)</span>之间的关系并不是简单的线性关系，而是表现出明显的非线性特征</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511130836291.png"alt="磁化曲线" /><figcaption aria-hidden="true">磁化曲线</figcaption></figure><ul><li>起始阶段：当 <span class="math inline">\(H\)</span> 较小时，<spanclass="math inline">\(B\)</span> 随 <spanclass="math inline">\(H\)</span> 缓慢增加</li><li>急剧增长阶段：随着 <span class="math inline">\(H\)</span>的进一步增大，<span class="math inline">\(B\)</span> 会迅速增长</li><li>饱和阶段：当 <span class="math inline">\(H\)</span>增加到一定值后，<span class="math inline">\(B\)</span>的增长变得非常缓慢，最终达到一个饱和值，即饱和磁感应强度 <spanclass="math inline">\(B_s\)</span></li></ul><h4 id="磁滞回线">磁滞回线</h4><p>当铁磁质达到磁饱和状态后，如果逐渐减小外磁场强度 <spanclass="math inline">\(H\)</span>，其磁感应强度 <spanclass="math inline">\(B\)</span>的变化并不会沿着起始磁化曲线返回，而是表现出滞后现象，这一现象称为<strong>磁滞</strong></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511130837003.png"alt="磁滞回线" /><figcaption aria-hidden="true">磁滞回线</figcaption></figure><ul><li>剩磁 (<span class="math inline">\(B_r\)</span>)：当外磁场 <spanclass="math inline">\(H\)</span>减小到零时，铁磁质中仍然保留的磁感应强度</li><li>矫顽力 (<spanclass="math inline">\(H_c\)</span>)：为使剩磁完全消失，需要施加的反向磁场强度矫顽力的大小反映了铁磁材料保持其磁化状态的能力</li></ul><h4 id="铁磁性的起因磁畴">铁磁性的起因——磁畴</h4><p>根据现代理论，铁磁性的产生源于其特殊的微观结构</p><ul><li>交换耦合作用铁磁质中相邻原子的电子之间存在很强的“交换耦合作用”这种作用使得在没有外磁场时，电子自旋磁矩也能在微小区域内自发地平行排列，形成达到饱和磁化状态的微小区域</li><li>磁畴 这些自发磁化达到饱和状态的微小区域被称为磁畴</li><li>未磁化状态在没有外磁场的宏观铁磁质中，各个磁畴的磁化方向是杂乱无章的，因此整体对外不显示磁性当施加外磁场时，磁畴会重新取向或发生边界移动，从而使材料被磁化</li></ul><h4 id="临界温度居里点">临界温度（居里点）</h4><ul><li>居里点 每种铁磁质都有一个特定的临界温度，称为居里点当温度升高到居里点以上时，由于剧烈的热运动破坏了磁畴的有序排列，铁磁质的高磁导率、磁滞、磁致伸缩等特性会全部消失，转变为顺磁性</li><li>不同铁磁质的居里点<ul><li>铁：<span class="math inline">\(1040 K\)</span></li><li>钴：<span class="math inline">\(1390 K\)</span></li><li>镍：<span class="math inline">\(630 K\)</span></li></ul></li></ul><h4 id="磁质的分类及其应用">磁质的分类及其应用</h4><p>根据磁滞回线的形状和特性，铁磁质材料主要分为三类：</p><ol type="1"><li><p>软磁材料</p><ul><li>特点<ul><li>矫顽力 <span class="math inline">\(H_c\)</span> 小，剩磁 <spanclass="math inline">\(B_r\)</span> 小，磁导率 <spanclass="math inline">\(\mu\)</span> 大，易磁化也易退磁</li><li>磁滞回线<strong>窄而长</strong>，磁滞损耗小</li></ul></li><li>材料<ul><li>纯铁、硅钢、坡莫合金（Fe-Ni 合金）、铁氧体等</li></ul></li><li>应用<ul><li>主要用于电磁能的转换，如变压器、电机、继电器以及各种高频电磁元件的磁芯和磁棒</li></ul></li></ul></li><li><p>硬磁材料</p><ul><li>特点<ul><li>矫顽力 <span class="math inline">\(H_c\)</span> 大（<spanclass="math inline">\(&gt;10^2 A/m\)</span>），剩磁 <spanclass="math inline">\(B_r\)</span> 大</li><li>磁滞回线宽而肥，磁滞损耗大</li></ul></li><li>材料<ul><li>钨钢、碳钢、铝镍钴合金等</li></ul></li><li>应用<ul><li>主要用于制作永久磁铁，如磁电式电表、耳机、永磁扬声器中的永磁体</li></ul></li></ul></li><li><p>矩磁材料</p><ul><li>特点<ul><li>磁滞回线呈矩形状</li></ul></li><li>材料<ul><li>锰镁铁氧体、锂锰铁氧体等</li></ul></li><li>应用<ul><li>主要用作计算机中的：其两种相反的饱和磁化状态可以稳定地代表二进制中的“0”和“1”</li></ul></li></ul></li></ol><h2 id="电磁感应">电磁感应</h2><h3 id="电磁感应现象">电磁感应现象</h3><p>电磁感应现象是指当穿过闭合导体回路的磁通量发生变化时，回路中就会产生电流的现象</p><ul><li>感应电流：在电磁感应现象中产生的电流</li><li>感应电动势：引起感应电流的电动势感应电动势是电磁感应现象的本质，即使回路不闭合，只要磁通量发生变化，感应电动势依然存在</li></ul><h3 id="楞次定律">楞次定律</h3><p>感应电流的方向总是使得它自身产生的磁场来反抗（或阻碍）引起感应电流的磁通量的变化</p><p>判断步骤如下：</p><ol type="1"><li>确定原磁场方向和磁通量的变化：判断穿过回路的原磁场 <spanclass="math inline">\(\vec{B}\)</span> 的方向，并明确其磁通量 <spanclass="math inline">\(\Phi_m\)</span> 是增加还是减少</li><li>确定感应磁场方向：<ul><li>若原磁通量增加，感应电流的磁场 <spanclass="math inline">\(\vec{B}\text{感}\)</span> 方向与原磁场 <spanclass="math inline">\(\vec{B}\)</span> 方向相反</li><li>若原磁通量减少，感应电流的磁场 <spanclass="math inline">\(\vec{B}\text{感}\)</span> 方向与原磁场 <spanclass="math inline">\(\vec{B}\)</span> 方向相同</li></ul></li><li>确定感应电流方向：根据感应磁场的方向，利用右手定则（安培定则）判断出感应电流<span class="math inline">\(I\text{感}\)</span> 的方向</li></ol><p>楞次定律是能量守恒定律在电磁感应现象中的体现</p><h3 id="法拉第电磁感应定律">法拉第电磁感应定律</h3><p>定量地描述了感应电动势的大小</p><p><span class="math display">\[\varepsilon = -\frac{\mathrm{d}\Phi_m}{dt}\]</span></p><ul><li><span class="math inline">\(\varepsilon\)</span>是感应电动势，单位为伏特 (<spanclass="math inline">\(\text{V}\)</span>)</li><li><span class="math inline">\(\Phi_m\)</span>是穿过回路的磁通量，单位为韦伯 (<spanclass="math inline">\(\text{Wb}\)</span>)</li></ul><p>对于一个有 <span class="math inline">\(N\)</span>匝的线圈，由于各匝是串联的，总的感应电动势为各匝之和</p><p><span class="math display">\[\varepsilon = -N\frac{\mathrm{d}\Phi_m}{\mathrm{d}t} =-\frac{\mathrm{d}(N\Phi_m)}{\mathrm{d}t} =-\frac{\mathrm{d}\Psi}{\mathrm{d}t}\]</span></p><ul><li><span class="math inline">\(\Psi = N\Phi_m\)</span>称为线圈的总磁通量，单位为韦伯</li></ul><h3 id="动生电动势">动生电动势</h3><p>当导体在磁场中运动时，导体内的自由电荷（载流子）会受到洛伦兹力 <spanclass="math inline">\(\vec{F} = q(\vec{v} \times \vec{B})\)</span>的作用。这个力会驱动电荷向导体的某一端移动，从而在导体两端形成电势差，这就是动生电动势</p><p><span class="math display">\[\vec{E}_k = \frac{\vec{F}}{q} = \vec{v} \times \vec{B}\]</span></p><p>对于一段在磁场中运动的导体（非闭合回路），其两端产生的动生电动势为：</p><p><span class="math display">\[\varepsilon = \int_a^b (\vec{v} \times \vec{B}) \c\mathrm{d}ot\mathrm{d}\vec{l}\]</span></p><p>对于闭合回路，整个回路的动生电动势为：</p><p><span class="math display">\[\varepsilon = \oint_l (\vec{v} \times \vec{B}) \cdot \mathrm{d}\vec{l}\]</span></p><p>在稳恒磁场中，这可以等效地写成磁通量对时间的变化率，其中磁通量的变化是由于回路面积变化引起的</p><p><span class="math display">\[\varepsilon = -\frac{\mathrm{d}\Phi_m}{\mathrm{d}t}\]</span></p><h3 id="感生电动势">感生电动势</h3><p><span class="math display">\[\oint_l \vec{E}_i \cdot \ \mathrm{d}\vec{l} = -\iint_S\frac{\partial\vec{B}}{\partial t} \cdot \ \mathrm{d}\vec{S}\]</span></p><h4 id="涡电流与趋肤效应">涡电流与趋肤效应</h4><ul><li>涡电流 (EddyCurrent)：当大块导体处于变化的磁场中，或在磁场中运动时，导体内会产生闭合的、像水涡一样的感应电流，称为涡电流<ul><li>应用：电磁炉、金属探测器、电磁阻尼</li><li>减小方法：使用相互绝缘的硅钢片叠成的铁芯</li></ul></li><li>趋肤效应 (SkinEffect)：高频交变电流在导体中流动时，电流会集中在导体的表面薄层，导致导体的有效截面积减小，电阻增大</li></ul><h3 id="自感与互感">自感与互感</h3><h4 id="自感">自感</h4><p>导体中电流自身发生变化时，引起自身磁通量变化，从而在导体中产生感应电动势的现象</p><p><span class="math display">\[\Phi_m=\iint_S \vec{B} \cdot \mathrm{d}\vec{S}\]</span></p><p>当电流 <span class="math inline">\(I\)</span> 发生变化时，磁场强度<span class="math inline">\(\vec{B}\)</span> 也发生变化，从而磁通量<span class="math inline">\(\Phi_m\)</span> 也发生变化</p><p>可以记</p><p><span class="math display">\[\Phi_m=L I\]</span></p><ul><li><span class="math inline">\(L\)</span> 为自感系数，单位为亨利 (<spanclass="math inline">\(\text{H}\)</span>)</li></ul><p>则自感电动势为</p><p><span class="math display">\[\varepsilon_L=- \frac{\mathrm{d}\Psi}{\mathrm{d}t}=-L\frac{\mathrm{d}I}{\mathrm{d}t}-I\frac{\mathrm{d}L}{\mathrm{d}t}\]</span></p><p>当 <span class="math inline">\(L\)</span> 不随时间变化时</p><p><span class="math display">\[\varepsilon_L=-L\frac{\mathrm{d}I}{\mathrm{d}t}\]</span></p><h4 id="互感">互感</h4><p>指当一个电路中的电流发生变化时，它产生的变化磁场在邻近的另一个电路中引起感应电动势</p><p>两个线圈间的互感系数是对称的： <span class="math inline">\(M_{12} =M_{21} = M\)</span></p><p><span class="math display">\[\varepsilon_{21} = -M\frac{\mathrm{d}I_1}{\mathrm{d}t},\quad\varepsilon_{12} = -M\frac{\mathrm{d}I_2}{\mathrm{d}t}\]</span></p><h3 id="磁场能量">磁场能量</h3><h4 id="自感磁能">自感磁能</h4><p>电流为 <span class="math inline">\(I_0\)</span>的线圈中储存的磁能为</p><p><span class="math display">\[W_m=\frac{1}{2}LI_0^2\]</span></p><h4 id="互感磁能">互感磁能</h4><p>对于两个存在互感的线圈，系统总的磁场能量为</p><p><span class="math display">\[W_m = \frac{1}{2}L_1 I_1^2 + \frac{1}{2}L_2 I_2^2 \pm M I_1 I_2\]</span></p><ul><li>当两个线圈的电流方向使得它们的磁场相互增强时，取正号</li><li>当两个线圈的电流方向使得它们的磁场相互抵消时，取负号</li></ul><h4 id="磁场能量密度">磁场能量密度</h4><p><span class="math display">\[w_m = \frac{1}{2}\vec{B} \cdot \vec{H} = \frac{1}{2\mu}B^2\]</span></p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>物理</tag>
      
      <tag>电磁学</tag>
      
      <tag>光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理1笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%861%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%861%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="大学物理学-1-笔记">大学物理学 1 笔记</h1><h2 id="质点运动学">质点运动学</h2><h3 id="时间空间概念">时间、空间概念</h3><h3 id="质点">质点</h3><h4 id="牛顿的时空观">牛顿的时空观</h4><ul><li><p><strong>时间</strong><br />均匀流动的带子，与事件本身无关，事件是带子上的标记.</p></li><li><p><strong>空间</strong><br />好比建筑物，人的存在与否不影响它的存在.</p><p>时间、空间与事物及过程完全割裂，这就是“绝对时空观”.</p></li></ul><h4 id="研究对象的理想化">研究对象的理想化</h4><ol type="1"><li>把抽象的物质具体化，看得见，摸得着.</li><li>把研究的物质质点化.<br />(点：具有该物体相同的质量)<ul><li>物体的大小、形状可以忽略时</li><li>物体运动中，物体的各部分运动相同</li></ul></li></ol><h3 id="运动的绝对性和相对性">运动的绝对性和相对性</h3><h3 id="参考系">参考系</h3><h3 id="质点的位置坐标和位置矢量">质点的位置坐标和位置矢量</h3><h4 id="直角坐标系">直角坐标系</h4><p>质点位置<span class="math inline">\(P(x,y,z)\)</span> 位置矢量<spanclass="math inline">\(\vec{r}=\vec{oP}\)</span></p><h4 id="位移">位移</h4><h4 id="速度">速度</h4><ol type="1"><li>平均速度：<span class="math inline">\(\overline{\vec{v}}=\dfrac{\Delta \vec{r}}{\Delta t}\)</span></li><li>瞬时速度：<spanclass="math inline">\(\vec{v}=\dfrac{\mathrm{d}\vec{r}}{\mathrm{d}t}\)</span></li></ol><h4 id="直角坐标系中的速度加速度">直角坐标系中的速度、加速度</h4><h4 id="自然坐标系速度表示法">自然坐标系速度表示法</h4><h4 id="极坐标速度表示法">极坐标速度表示法</h4><h4 id="圆周运动">圆周运动</h4><h3 id="伽利略变换">伽利略变换</h3><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250225111725.png"alt="坐标系" /><figcaption aria-hidden="true">坐标系</figcaption></figure><p><span class="math inline">\(S&#39;\)</span> 相对于 <spanclass="math inline">\(S\)</span> 运动，速度为 <spanclass="math inline">\(u\)</span> ，则有</p><p><span class="math display">\[\begin{aligned}&amp;\vec{r} = \vec{r&#39;} + \vec{R},\quad dt=dt&#39;\\&amp;\frac{\mathrm{d}\vec{r}}{\mathrm{d}t} =\frac{\mathrm{d}\vec{r&#39;}}{\mathrm{d}t&#39;} +\frac{\mathrm{d}\vec{R}}{\mathrm{d}t&#39;}, \quad \vec{v} =\vec{u}+\vec{v&#39;}\\&amp;\frac{\mathrm{d}^2\vec{r}}{\mathrm{d}t^2} =\frac{\mathrm{d}^2\vec{r&#39;}}{\mathrm{d}t&#39;^2} +\frac{\mathrm{d}^2\vec{R}}{\mathrm{d}t^2}, \quad \vec{a} = \vec{a}_0 +\vec{a&#39;}\end{aligned}\]</span></p><h2 id="质点运动学-1">质点运动学</h2><h3 id="牛顿运动定律">牛顿运动定律</h3><h4 id="牛顿第一定律">牛顿第一定律</h4><h4 id="牛顿第二定律">牛顿第二定律</h4><h4 id="牛顿第三定律">牛顿第三定律</h4><h3 id="相互作用力">相互作用力</h3><h4 id="万有引力的计算">万有引力的计算</h4><h5 id="引力质量">引力质量</h5><h5 id="惯性质量和引力质量的联系">惯性质量和引力质量的联系</h5><h4 id="弹性力">弹性力</h4><h4 id="摩擦力">摩擦力</h4><h4 id="流体阻力">流体阻力</h4><h3 id="非惯性系惯性力">非惯性系、惯性力</h3><h4 id="惯性参考系">惯性参考系</h4><h4 id="惯性离心力">惯性离心力</h4><h3 id="惯性力与自然界的运动">惯性力与自然界的运动</h3><h4 id="太阳和地球引力失重">太阳和地球引力失重</h4><h4 id="潮汐力和潮汐">潮汐力和潮汐</h4><h3 id="科氏加速度和科氏力">科氏加速度和科氏力</h3><h4 id="科里奥利力的来源">科里奥利力的来源</h4><h3 id="质心和质心运动定律">质心和质心运动定律</h3><h4 id="质心">质心</h4><h4 id="质心坐标系">质心坐标系</h4><h2 id="功与能">功与能</h2><h3 id="功动能定理">功、动能定理</h3><h4 id="功的基本概念">功的基本概念</h4><h4 id="内力的功">内力的功</h4><h2 id="狭义相对论">狭义相对论</h2><h3 id="狭义相对论时空观">狭义相对论时空观</h3><h4 id="狭义相对性原理">狭义相对性原理</h4><p>物理学定律与惯性系的选择无关,所有惯性系是等价的</p><p><span class="math display">\[\left\{\begin{array}{ll}  &amp;S  &amp;&amp;m_1\vec{v_1} + m_2\vec{v_2} = m_1\vec{v_10} +m_2\vec{v_20}\\  &amp;S&#39; &amp;&amp;m&#39;_1\vec{v&#39;_1} + m&#39;_2\vec{v&#39;_2}= m&#39;_1\vec{v&#39;_10} + m&#39;_2\vec{v&#39;_20}\end{array}\right.\]</span></p><h4 id="光速不变原理">光速不变原理</h4><p>光速在任何惯性系中都是不变的,即光速是绝对的,与光源和观察者的运动状态无关由 Maxwell 方程可以推出</p><h4 id="洛伦兹变换">洛伦兹变换</h4><p>设$ <span class="math inline">\(S&#39;\)</span> 系相对于 <spanclass="math inline">\(S\)</span> 系以速度 <spanclass="math inline">\(u\)</span> 沿 <spanclass="math inline">\(x\)</span> 轴正方向运动，两坐标轴原点 <spanclass="math inline">\(o\)</span> 与 <spanclass="math inline">\(o&#39;\)</span> 在 <spanclass="math inline">\(t=t&#39;=0\)</span> 时重合，则有</p><ul><li>正变换</li></ul><p><span class="math display">\[\begin{cases}  x&#39; = \frac{x-ut}{\sqrt{1-\frac{u^2}{c^2}}}\\  y = y&#39;\\  z = z&#39;\\  t&#39; = \frac{t-\frac{ux}{c^2}}{\sqrt{1-\frac{u^2}{c^2}}}\end{cases}\]</span></p><ul><li>逆变换</li></ul><p><span class="math display">\[\begin{cases}  x = \frac{x&#39;+ut&#39;}{\sqrt{1-\frac{u^2}{c^2}}}\\  y&#39; = y\\  z&#39; = z\\  t = \frac{t&#39;+\frac{ux&#39;}{c^2}}{\sqrt{1-\frac{u^2}{c^2}}}\end{cases}\]</span></p><p>若令 <span class="math inline">\(\gamma =\frac{1}{\sqrt{1-\frac{u^2}{c^2}}} &gt;1\)</span>，则有</p><ul><li>正变换</li></ul><p><span class="math display">\[\begin{cases}  x&#39; = \gamma(x-ut)\\  y&#39; = y\\  z&#39; = z\\  t&#39; = \gamma(t-\frac{ux}{c^2})\end{cases}\]</span></p><ul><li>逆变换</li></ul><p><span class="math display">\[\begin{cases}  x = \gamma(x&#39;+ut&#39;)\\  y = y&#39;\\  z = z&#39;\\  t = \gamma(t&#39;+\frac{ux&#39;}{c^2})\end{cases}\]</span></p><h3 id="狭义相对论的时空效应">狭义相对论的时空效应</h3><p>设在 <span class="math inline">\(S&#39;\)</span>系中，质点的时空坐标为 <span class="math inline">\((x&#39;,t&#39;)\)</span>，在 <span class="math inline">\(S\)</span>系中，质点的坐标为 <span class="math inline">\((x, t)\)</span>，系 <spanclass="math inline">\(S&#39;\)</span> 相对于系 <spanclass="math inline">\(S\)</span> 以速度 <spanclass="math inline">\(u\)</span> 沿 <spanclass="math inline">\(x\)</span> 轴正方向运动</p><p><span class="math display">\[\begin{cases}  \Delta x = \gamma \left(\Delta x -u\Delta t\right)\\  \Delta x&#39; = \gamma \left(\Delta x&#39; +u\Delta t&#39;\right)\\\end{cases}\]</span></p><p><span class="math display">\[\begin{cases}  \Delta t = \gamma \left(\Delta t -\frac{u\Delta x}{c^2}\right)\\  \Delta t&#39; = \gamma \left(\Delta t&#39; +\frac{u\Deltax&#39;}{c^2}\right)\\\end{cases}\]</span></p><p>明确这两组公式中的变量哪些是 <span class="math inline">\(0\)</span>，哪些是已知量是解题的关键</p><h4 id="时间膨胀">时间膨胀</h4><p>物体在 <span class="math inline">\(S&#39;\)</span> 系中静止，则有</p><p><span class="math display">\[\Delta t = \gamma \Delta t&#39;\]</span></p><p>在 <span class="math inline">\(S&#39;\)</span>系中同时不同地发生的两件事，<span class="math inline">\(S\)</span>系中不同时发生，时间间隔为 <span class="math inline">\(\Delta t = \gamma\frac{u \Delta x&#39;}{c^2}\)</span></p><h4 id="长度收缩">长度收缩</h4><p>设在 <span class="math inline">\(S&#39;\)</span>系中静止的物体的本征长度为 <spanclass="math inline">\(L&#39;\)</span>，在 <spanclass="math inline">\(S\)</span> 系中测得的长度 <spanclass="math inline">\(L\)</span> 为</p><p><span class="math display">\[L = \frac{L&#39;}{\gamma} = L&#39; \sqrt{1-\frac{u^2}{c^2}}\]</span></p><blockquote><p><strong>注意：</strong></p><p>在 <span class="math inline">\(S\)</span> 系测量则需要在 <spanclass="math inline">\(S\)</span> 系中同时确认两个点的空间坐标，<spanclass="math inline">\(\Delta t = 0\)</span></p></blockquote><h3 id="洛伦兹速度变换">洛伦兹速度变换</h3><ul><li>正变换</li></ul><p><span class="math display">\[\begin{cases}  v_x&#39; = \frac{v_x - u}{1-\frac{uv_x}{c^2}}\\  v_y&#39; = \frac{v_y}{\gamma(1-\frac{uv_x}{c^2})} =\frac{v_y\sqrt{1-\frac{u^2}{c^2}}}{\left(1-\frac{uv_x}{c^2}\right)}\\  v_z&#39; = \frac{v_z}{\gamma(1-\frac{uv_x}{c^2})} =\frac{v_z\sqrt{1-\frac{u^2}{c^2}}}{\left(1-\frac{uv_x}{c^2}\right)}\end{cases}\]</span></p><ul><li>逆变换</li></ul><p><span class="math display">\[\begin{cases}  v_x = \frac{v_x&#39; + u}{1+\frac{uv_x&#39;}{c^2}}\\  v_y = \frac{v_y&#39;}{\gamma(1+\frac{uv_x&#39;}{c^2})} =\frac{v_y&#39;\sqrt{1-\frac{u^2}{c^2}}}{\left(1+\frac{uv_x&#39;}{c^2}\right)}\\  v_z = \frac{v_z&#39;}{\gamma(1+\frac{uv_x&#39;}{c^2})} =\frac{v_z&#39;\sqrt{1-\frac{u^2}{c^2}}}{\left(1+\frac{uv_x&#39;}{c^2}\right)}\end{cases}\]</span></p><h3 id="相对论中的质量和动量">相对论中的质量和动量</h3><p>由实验研究表明，物体的质量随着速率增大而增大，记 <spanclass="math inline">\(m_0\)</span>为物体在静止时的质量，称为静质量，<span class="math inline">\(m\)</span>为物体在运动时的质量，称为动质量，则有</p><p><span class="math display">\[m = \frac{m_0}{\sqrt{1-\frac{v^2}{c^2}}}\]</span></p><p>其动量为</p><p><span class="math display">\[\vec{p} = m\vec{v} = \frac{m_0\vec{v}}{\sqrt{1-\frac{v^2}{c^2}}}\]</span></p><h3 id="相对论中的力学基本方程">相对论中的力学基本方程</h3><p><span class="math display">\[\begin{aligned}  &amp;\vec{p} = m\vec{u} =\frac{m_0\vec{u}}{\sqrt{1-\frac{u^2}{c^2}}}\\  &amp;\vec{p} = \vec{u} \mathrm{d}m + m\mathrm{d}\vec{u}\\  &amp;\vec{F}  = \frac{\mathrm{d}}{\mathrm{d}t}\left(\frac{m_0\vec{u}}{\sqrt{1-\frac{u^2}{c^2}}}\right)\end{aligned}\]</span></p><h3 id="相对论中的能量">相对论中的能量</h3><p><span class="math display">\[\begin{cases}  E_k = mc^2 - m_0c^2&amp;\text{动能}\\  E_0 = m_0c^2&amp;\text{静能}\\  E = mc^2 = E_0 +E_k&amp;\text{总能量}\end{cases}\]</span></p><p>质能关系</p><p><span class="math display">\[\Delta E = \Delta m c^2\]</span></p><p>能量与动量之间的关系</p><p><span class="math display">\[p = \frac{E}{c}\]</span></p><h2 id="振动力学">振动力学</h2><h3 id="简谐振动动力学">简谐振动动力学</h3><p>简谐运动定义：凡质点的运动遵从余弦（或正弦）规律时，其运动形式为简谐振动</p><p>其运动方程为</p><p><span class="math display">\[x(t) = A \cos(\omega t + \varphi)\]</span></p><p>简谐运动的动力学方程为</p><p><span class="math display">\[\frac{\mathrm{d}^2x}{\mathrm{d}t^2} + \omega^2 x = 0\]</span></p><p>其中 <span class="math inline">\(\omega =\sqrt{\frac{k}{m}}\)</span>，<span class="math inline">\(k\)</span>为弹性系数，<span class="math inline">\(m\)</span> 为物体的质量</p><h3 id="简谐振动运动的物理量">简谐振动运动的物理量</h3><h4 id="周期频率和角频率">周期、频率和角频率</h4><ul><li><strong>角频率：</strong> <span class="math inline">\(\omega=\sqrt{\frac{k}{m}} = \frac{2\pi}{T} = 2\pi \nu\)</span></li><li><strong>周期：</strong> <span class="math inline">\(T =\frac{1}{\nu} = \frac{2\pi}{\omega} =2\pi\sqrt{\frac{m}{k}}\)</span></li></ul><p>在 <span class="math inline">\(x =A \cos(\omega t + \varphi)\)</span>中，<span class="math inline">\(A\)</span> 为振幅，<spanclass="math inline">\(\varphi\)</span> 为初相位</p><ul><li><span class="math inline">\(v = \frac{\mathrm{d}x}{\mathrm{d}t} =-A\omega \sin(\omega t + \varphi)\)</span></li><li><span class="math inline">\(v_0 = -A\omega\sin\varphi\)</span></li><li><span class="math inline">\(E = E_k + E_p = \frac{1}{2}mv^2 +\frac{1}{2}kx^2 = \frac{1}{2}kA^2\)</span></li><li><span class="math inline">\(A = \sqrt{x_0^2+\frac{v_0^2}{\omega^2}}= \sqrt{\frac{2E}{m\omega^2}}\)</span></li></ul><h4 id="相位">相位</h4><p><span class="math display">\[x = A\cos(\omega t + \varphi)\]</span></p><ul><li><span class="math inline">\(\left(\omega t+\varphi\right)\)</span>是 <span class="math inline">\(t\)</span> 时刻的相位</li><li><span class="math inline">\(\varphi\)</span> 是 <spanclass="math inline">\(t=0\)</span> 时刻的相位</li><li><strong>相位差：</strong> <span class="math inline">\(\Delta \varphi=\left(\omega_2t+  \varphi_2\right)-\left(\omega_1t=\varphi_1\right)\)</span><ul><li>相位差为 <span class="math inline">\(\pm2k\pi(k = 0 , 1 ,\ldots)\)</span> 时，两个简谐振动的相位相同</li><li>相位差为 <span class="math inline">\(\pm(2k+1)\pi(k = 0 , 1 ,\ldots)\)</span> 时，两个简谐振动的相位相反</li><li>若 <span class="math inline">\(\Delta\varphi = \varphi_-\varphi_1&gt;0\)</span>，则 <span class="math inline">\(x_2\)</span> 比<span class="math inline">\(x_1\)</span> 较早到正最大，称 <spanclass="math inline">\(x_2\)</span> 比 <spanclass="math inline">\(x_1\)</span> 超前，或称 <spanclass="math inline">\(x_1\)</span> 比 <spanclass="math inline">\(x_2\)</span> 滞后<ul><li>超前和落后以小于 <span class="math inline">\(\pi\)</span>的相位角来判断</li></ul></li></ul></li></ul><h4 id="振动状态和振动能量">振动状态和振动能量</h4><h5 id="振动速度">振动速度</h5><p><span class="math display">\[\begin{aligned}  v = \frac{\mathrm{d}x}{\mathrm{d}t} &amp;= -A\omega \sin(\omega t +\varphi)\\  &amp;= -v_m \cos(\omega t + \varphi + \frac{\pi}{2})\\\end{aligned}\]</span></p><p>其中 <span class="math inline">\(v_m = A\omega\)</span>称为速度振幅</p><h5 id="振动加速度">振动加速度</h5><p><span class="math display">\[\begin{aligned}  a = \frac{\mathrm{d}^2x}{\mathrm{d}t^2} &amp;= -A\omega^2 \cos(\omegat + \varphi)\\  &amp;= -a_m \sin(\omega t + \varphi + \frac{\pi}{2})\\\end{aligned}\]</span></p><p>其中 <span class="math inline">\(a_m =A\omega^2\)</span>称为加速度振幅</p><h5 id="振动系统的能量">振动系统的能量</h5><ul><li>振子动能</li></ul><p><span class="math display">\[E_k = \frac{1}{2}mv^2 = \frac{1}{2}mA^2\omega^2\sin^2(\omega t +\varphi)\]</span></p><ul><li>振子势能</li></ul><p><span class="math display">\[E_p = \frac{1}{2}kx^2 = \frac{1}{2}kA^2\cos^2(\omega t + \varphi)\]</span></p><ul><li>振子总能量</li></ul><p><span class="math display">\[E = E_k + E_p = \frac{1}{2}kA^2\]</span></p><h4 id="旋转振幅矢量">旋转振幅矢量</h4><p>旋转矢量 <span class="math inline">\(\vec{A}\)</span> 在 <spanclass="math inline">\(x\)</span> 轴上的投影点的运动规律为</p><p><span class="math display">\[x = A \cos(\omega t + \varphi)\]</span></p><h2 id="平衡态">平衡态</h2><h3 id="基本概念">基本概念</h3><ol type="1"><li>热力学系统<ul><li><strong>孤立系统：</strong> 与外界无能量和质量交换</li><li><strong>封闭系统：</strong> 与外界有能量无质量交换</li><li><strong>开放系统：</strong> 与外界由能量和质量交换</li><li><strong>外界：</strong> 处于系统之外的物体或物体组</li></ul></li><li>系统状态的描述<ul><li><strong>宏观参量：</strong> 可以直接测量的量，如压强 <spanclass="math inline">\(p\)</span>、温度 <spanclass="math inline">\(T\)</span>等由宏观参量描述的系统状态称为宏观状态</li><li><strong>微观量：</strong>描述系统内微观粒子的物理量，一般无法直接测量，如分子的质量 <spanclass="math inline">\(m\)</span>、直径 <spanclass="math inline">\(d\)</span>、位置、速度 <spanclass="math inline">\(v\)</span>、动量 <spanclass="math inline">\(p\)</span>、能量 <spanclass="math inline">\(\epsilon\)</span> 等。</li></ul></li><li>平衡态<ul><li>孤立系统达到的不随时间变化的状态称为热力学平衡态或平衡态</li><li>内部能量和质量没有宏观流动，达到同一温度的定态叫平衡态</li></ul></li><li>定态<ul><li>宏观性质不随时间变化的稳定状态称为定态</li></ul></li><li><strong>动态平衡：</strong><strong>不受外界影响</strong>的条件下系统的宏观性质不随时间变化，此系统处在热力学平衡态</li><li>涨落：<ul><li>系统的宏观性质在平衡态下有微小的波动称为涨落</li><li>涨落是系统内微观粒子运动的结果</li></ul></li></ol><h3 id="热力学第一定律">热力学第一定律</h3><h4 id="温度">温度</h4><p>达到热平衡的系统具有共同的内部属性：温度</p><h4 id="热力学第零定律">热力学第零定律</h4><p>两个系统同时与第三个系统热平衡时，这两个物体之间也必达到热平衡</p><p>处于热平衡的多个系统具有相同的温度</p><h4 id="理想气体温标和状态方程">理想气体温标和状态方程</h4><h5 id="理想气体">理想气体</h5><ul><li>波义耳定律<ul><li>温度不变时没压强和体积的乘积是一个常数</li></ul></li><li>理想气体<ul><li>严格遵守波义耳定律的气体为理想气体</li></ul></li></ul><h5 id="热力学温标">热力学温标</h5><p>理论上存在一个与测温质、测温属性无关的温标：热力学温标</p><p>根据物理定律，温度为 <span class="math inline">\(0^\circ C\)</span>是，每下降 <span class="math inline">\(1^\circ C\)</span>，体积减少<span class="math inline">\(\frac{1}{273}\)</span>，则当处于 <spanclass="math inline">\(-273.15^\circ C\)</span> 时，体积为 <spanclass="math inline">\(0\)</span>，即 <spanclass="math inline">\(0K\)</span>，称为绝对零度</p><p>摄氏温度 <span class="math inline">\(t\)</span> 与绝对温度 <spanclass="math inline">\(T\)</span> 的关系</p><p><span class="math display">\[T = t + 273.15\]</span></p><h5 id="理想气体状态方程">理想气体状态方程</h5><p><span class="math display">\[PV = nRT = \frac{m}{M}RT\]</span></p><p>其中 <span class="math inline">\(R=8.314J/(mol \cdotK)\)</span>，<span class="math inline">\(n\)</span> 为物质的量，<spanclass="math inline">\(P\)</span> 为压强，<spanclass="math inline">\(V\)</span> 为体积，<spanclass="math inline">\(T\)</span> 为绝对温度</p><h4 id="气体压强和温度的统计意义">气体压强和温度的统计意义</h4><h5 id="气体的特征">气体的特征</h5><ol type="1"><li>无一定形状、体积，能充满整个容器空间</li><li>气体分子间距远大于分子的线度L&gt;&gt;d，分子间引力很小，故气体具有高压缩性、高热膨胀率及高扩散性</li><li>气体分子以高速向四方自由运动，具有高动能</li><li>气体分子无规则热运动，频繁碰撞必产生压力</li></ol><h5 id="理想气体分子运动模型">理想气体分子运动模型</h5><ol type="1"><li>大小不计</li><li>弹性碰撞</li><li>除碰撞外其他相互作用不计</li><li>不记重力</li></ol><p>两条统计假设</p><ol type="1"><li></li></ol><p><span class="math display">\[n_\text{单位体积的分子数} = \frac{\Delta N}{\Delta V}=\frac{\mathrm{d}N}{\mathrm{d}V}=\frac{N_\text{总分子数}}{V_\text{总容积}}\]</span></p><ol start="2" type="1"><li></li></ol><p><span class="math display">\[\vec{u}_{x\text{平均速度}} \left(\sum_i^N \frac{u_{ix}}{N}\right) =\bar{u}_{y\text{平均速度}} =\bar{u}_{z\text{平均速度}} =0\]</span></p><h5 id="理想气体压强公式">理想气体压强公式</h5><p><span class="math display">\[\begin{aligned}  p = \frac{1}{3}\sum_imn_iu_i^2 = \frac{1}{3}nm\bar{u}^2\end{aligned}\]</span></p><h5 id="溫度的统计意义">溫度的统计意义</h5><p>气体的平均动能</p><p><span class="math display">\[\bar{\varepsilon}_t = \frac{1}{2}m\bar{u}^2 =\frac{3}{2}kT\]</span></p><p>对于系统而言，表示分子热运动的激烈程度</p><h3 id="麦克斯韦速率分布">麦克斯韦速率分布</h3><ul><li>标量形式</li></ul><p><span class="math display">\[f(v)= 4\pi v^2 \left(\frac{m}{2\pi kT}\right)^{\frac{3}{2}}e^{-\frac{mv^2}{2kT}}\]</span></p><ul><li>矢量形式</li></ul><p><span class="math display">\[f(\vec{v})= \left(\frac{m}{2\pi kT}\right)^{\frac{3}{2}}e^{-\frac{m\vert \vec{v}\vert ^2}{2kT}}\]</span></p><p>其在三个方向上的分量为</p><p><span class="math display">\[\begin{cases}  f(v_x) = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}}e^{-\frac{m}{2kT}v_x^2}\\  f(v_y) = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}}e^{-\frac{m}{2kT}v_y^2}\\  f(v_z) = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}}e^{-\frac{m}{2kT}v_z^2}\end{cases}\]</span></p><p>可以推出</p><p><span class="math display">\[\begin{cases}  \frac{\mathrm{d}N_x}{N} = f(v_x)\mathrm{d}v_x = \left(\frac{m}{2\pikT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_x^2}\mathrm{d}v_x\\  \frac{\mathrm{d}N_y}{N} = f(v_y)\mathrm{d}v_y = \left(\frac{m}{2\pikT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_y^2}\mathrm{d}v_y\\  \frac{\mathrm{d}N_z}{N} = f(v_z)\mathrm{d}v_z = \left(\frac{m}{2\pikT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_z^2}\mathrm{d}v_z\end{cases}\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221129410.png"alt="Mexwell V" /><figcaption aria-hidden="true">Mexwell V</figcaption></figure><h3 id="麦克斯韦速率分布应用">麦克斯韦速率分布应用</h3><h4 id="最可几速率">最可几速率</h4><p><span class="math display">\[\begin{aligned}  &amp;\frac{\mathrm{d}f(v)}{\mathrm{d}v} = 0\\  \Rightarrow &amp;v_p=\sqrt{\frac{2kT}{m}} = \sqrt{\frac{2RT}{M}}\end{aligned}\]</span></p><h4 id="平均速率">平均速率</h4><p><span class="math display">\[\bar{v} = \int_0^{\infty} v f(v) \mathrm{d}v = \sqrt{\frac{8kT}{\pi m}}= \sqrt{\frac{8RT}{\pi M}}\]</span></p><h4 id="均方根速率">均方根速率</h4><p><span class="math display">\[\sqrt{\bar{v}^2} = \sqrt{\int_0^{\infty} v^2 f(v) \mathrm{d}v} =\sqrt{\frac{3kT}{m}} = \sqrt{\frac{3RT}{M}}\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221314126.png"alt="MaxwellDistributionApplication" /><figcaptionaria-hidden="true">MaxwellDistributionApplication</figcaption></figure><h4 id="一些应用">一些应用</h4><p>设箱体的分子密度为 <spanclass="math inline">\(n\)</span>，求单位时间内单位面积碰撞到墙体的分子数</p><p><span class="math display">\[\begin{aligned}  N&amp;=n\bar{v}S\\  &amp;=nS\int_0^\infty f(v_x)v_x\,\mathrm{d}v_x\\  &amp;=\boxed{\frac{1}{4}nS\bar{v}}\end{aligned}\]</span></p><h4 id="玻尔兹曼分布">玻尔兹曼分布</h4><p><span class="math display">\[\mathrm{d} N = n_0e^{-\frac{\varepsilon_p}{k_BT}}\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><p><span class="math display">\[n_i = n_0 e^{-\frac{E_i}{kT}}\]</span></p><h6id="空气中气体分子在重力场中的密度分布">空气中气体分子在重力场中的密度分布</h6><h4 id="能量均分定理">能量均分定理</h4><h5 id="分子的自由度">分子的自由度</h5><table><thead><tr><th style="text-align: center;">分子原子数</th><th style="text-align: center;">总自由度</th></tr></thead><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">多</td><td style="text-align: center;">6</td></tr></tbody></table><p>对于多原子分子，其内能为</p><p><span class="math display">\[U = \frac{f}{2}NkT = \frac{f}{2} PV\]</span></p><p>其中 <span class="math inline">\(f\)</span> 为分子的自由度，<spanclass="math inline">\(N\)</span> 为分子数</p><h2 id="热力学第一定律-1">热力学第一定律</h2><p><span class="math display">\[Q = \Delta E + W\]</span></p><h3 id="比热容">比热容</h3><h4 id="等容过程">等容过程</h4><p><span class="math display">\[\begin{align}  \Delta V &amp; = 0\\  A &amp; = 0\\  \Delta Q &amp;= \Delta E\\  C_V &amp;= \frac{\Delta Q}{\Delta T} = \frac{\mathrm{d}E}{\mathrm{d}T}= \frac{i}{2}R\end{align}\]</span></p><p><span class="math display">\[\Delta E = \frac{i}{2}R\Delta T = \frac{i}{2}V\Delta P\]</span></p><h4 id="等温过程">等温过程</h4><p><span class="math display">\[\begin{aligned}  \Delta T &amp; = 0\\  \Delta E &amp; = 0\\  \Delta Q &amp; = W \\  \mathrm{d}Q &amp;= \mathrm{d}A \\  &amp;= P\mathrm{d}V \\  &amp;= nRT \frac{1}{V}\,\mathrm{d}V\end{aligned}\]</span></p><p>则 <span class="math inline">\(Q = nRT\ln\frac{V_2}{V_1}\)</span></p><h4 id="等压过程">等压过程</h4><p><span class="math display">\[\begin{aligned}  \mathrm{d}Q_P &amp;= \mathrm{d}E + P\mathrm{d}V\\  Q_P &amp;= \Delta E + P\Delta V\\  &amp;= \frac{i}{2} nR\Delta T + nR\Delta V\\  &amp;= \frac{i+2}{2} nR\Delta T\\\end{aligned}\]</span></p><p><span class="math display">\[C_P = \frac{\Delta Q}{\Delta T} = \frac{i+2}{2}R = C_V +R\]</span></p><p>热容比</p><p><span class="math display">\[\gamma = \frac{C_P}{C_V} = 1+\frac{R}{C_P} = \frac{i+2}{i}\]</span></p><h4 id="绝热过程">绝热过程</h4><p>绝热过程是指系统与外界没有热量交换的过程</p><p>准静态绝热过程方程</p><p><span class="math display">\[PV^\gamma = \text{const}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>物理</tag>
      
      <tag>力学</tag>
      
      <tag>热力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 2 笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B02%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B02%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="高等数学-2-笔记">高等数学 2 笔记</h1><h2 id="重积分">重积分</h2><h3 id="重积分的概念和性质">重积分的概念和性质</h3><h4 id="二重积分的概念">二重积分的概念</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(D\)</span> 是平面上的有界闭区域，<spanclass="math inline">\(f(x,y)\)</span> 为 <spanclass="math inline">\(D\)</span> 上的有界函数，<spanclass="math inline">\(I\)</span> 为实数.若对 <spanclass="math inline">\(D\)</span> 的任意分割 <spanclass="math inline">\(\Delta D_1 , \Delta D_2 , \cdots , \DeltaD_n\)</span> ，任取 <span class="math inline">\((\xi_i ,\eta_i)\in\Delta D_i(i=1,\ldots,n)\)</span>，作和 <spanclass="math inline">\(\displaystyle\sum_{i=1}^nf(\xi_i,\eta_i)\Delta\sigma_i\)</span> （<span class="math inline">\(\Delta \sigma_i\)</span>为 <span class="math inline">\(D_i\)</span> 的面积），总有</p><p><span class="math display">\[\lim_{\lambda\to 0}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta \sigma_i = I\]</span></p><p>其中 <span class="math inline">\(\displaystyle\lambda = \max_{1\leqi\leq d} \{d_i\}\)</span>，<span class="math inline">\(d_i\)</span>是小区域 <span class="math inline">\(\Delta D_i\)</span>的直径，则称函数 <span class="math inline">\(f(x,y)\)</span> 在 <spanclass="math inline">\(D\)</span> 上<strong>可积</strong>，记为 <spanclass="math inline">\(f\in R(D)\)</span>；极限值 <spanclass="math inline">\(I\)</span> 称为 <spanclass="math inline">\(f(x,y)\)</span> 在 <spanclass="math inline">\(D\)</span> 上的<strong>二重积分</strong>，记作</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma.\]</span></p><ul><li><p><span class="math inline">\(\displaystyle \iint\)</span>积分号</p></li><li><p><span class="math inline">\(D\)</span> 积分区域</p></li><li><p><span class="math inline">\(f(x,y)\)</span> 被积函数</p></li><li><p><span class="math inline">\(\mathrm{d}\sigma\)</span>面积元素（微元）</p></li><li><p>二重积分的几何意义</p><ul><li>当被积函数大于 <span class="math inline">\(0\)</span>时，二重积分是柱体体积</li><li>当被积函数小于 <span class="math inline">\(0\)</span>时，二重积分是柱体体积的负值</li><li>一般的，为曲顶柱体体积的代数和</li></ul></li><li><p>可积的充分条件</p><ul><li><strong>定理：</strong> 若函数 <spanclass="math inline">\(f(x,y)\)</span> 在区域 <spanclass="math inline">\(D\)</span> 上连续，则 <spanclass="math inline">\(f(x,y)\in D\)</span>.</li></ul></li><li><p><span class="math inline">\(f(x,y)\)</span> 在 <spanclass="math inline">\(D\)</span> 上的可积性及积分值与其在 <spanclass="math inline">\(D\)</span>内<strong>有限条光滑曲线</strong>上的定义无关</p></li></ul><h3 id="二重积分的性质">二重积分的性质</h3><ol type="1"><li><p><spanclass="math inline">\(\displaystyle\iint_D\,\mathrm{d}\sigma = \iint_D1\,\mathrm{d}\sigma = A_D \quad\left(\text{D的面积}\right)\)</span>.</p></li><li><p><strong>线性性：</strong> 设 <span class="math inline">\(f,g\inR(D)\)</span>，<span class="math inline">\(\alpha ,\beta\)</span>，是任意常数，则 <span class="math inline">\(\alpha f+\beta g \in R(D)\)</span>，且</p><p><span class="math display">\[\iint_D (\alpha f +\beta g)\,\mathrm{d}\sigma = \alpha \iint_Df\,\mathrm{d}\sigma + \beta \iint_D g\,\mathrm{d}\sigma\]</span></p></li><li><p><strong>区域可加性：</strong> 若 <span class="math inline">\(f\inR(D)\)</span> 且积分区域 <span class="math inline">\(D\)</span>分为内部不相交的子区域 <span class="math inline">\(D_1 ,D_2\)</span>，则</p><p><span class="math display">\[\iint_D f(x,y) \,\mathrm{d}\sigma = \iint_{D_1} f(x,y)\,\mathrm{d}\sigma+ \iint_{D_2} f(x,y)\,\mathrm{d}\sigma\]</span></p></li><li><p><strong>保序性：</strong> 若 <span class="math inline">\(f,g\inR(D)\)</span>，且当 <span class="math inline">\((x,y)\in D\)</span>时，<span class="math inline">\(f(x,y)\leq g(x,y)\)</span>，则</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma \leq \iint_D g(x,y)\,\mathrm{d}\sigma\]</span></p><ul><li><strong>推论 1：</strong> 若 <span class="math inline">\(f\inR(D)\)</span> ,则 <span class="math inline">\(\vert f(x,y) \vert \inR(D)\)</span>，且</li></ul><p><span class="math display">\[\left\vert \iint_D f(x,y)\,\mathrm{d}\sigma \right\vert \leq \iint_D\vert f(x,y) \vert \,\mathrm{d}\sigma\]</span></p><ul><li><strong>推论 2：</strong> 若 <span class="math inline">\(f\inR(D)\)</span>，且当 <span class="math inline">\((x,y)\in D\)</span> 时，<span class="math inline">\(m\leq f(x,y) \leq M\)</span>，则</li></ul><p><span class="math display">\[mA_D \leq \iint_D f(x,y)\,\mathrm{d}\sigma \leq MA_D\]</span></p><ul><li><strong>推论 3：</strong> 若 <span class="math inline">\(f\inR(D)\)</span>，且当 <span class="math inline">\((x,y)\in D\)</span>时，<span class="math inline">\(f(x,y) \geq 0\)</span>，则</li></ul><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma \geq 0\]</span></p></li><li><p><strong>积分中值定理：</strong> 若 <spanclass="math inline">\(f(x,y)\in C(D)\)</span> ，<spanclass="math inline">\(g(x,y)\in R(D)\)</span>，且 <spanclass="math inline">\(g\)</span> 在 <spanclass="math inline">\(D\)</span> 上不变号，则 <spanclass="math inline">\(\exists \xi , \eta \in D\)</span>，使得</p><p><span class="math display">\[\iint_D f(x,y)g(x,y)\,\mathrm{d}\sigma = f(\xi ,\eta )\iint_Dg(x,y)\,\mathrm{d}\sigma\]</span></p><ul><li><strong>推论：</strong> 若 <span class="math inline">\(f(x,y)\inC(D)\)</span>，则存在 <span class="math inline">\((\xi , \eta )\inD\)</span>，使得</li></ul><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = f(\xi ,\eta )A_D\]</span></p><p>称 <span class="math inline">\(f(\xi,\eta) = \frac{\iint_Df\,\mathrm{d}\sigma}{A_D}\)</span> 为函数 <spanclass="math inline">\(f(x,y)\)</span> 在有界闭区域 <spanclass="math inline">\(D\)</span> 上的<strong>平均值</strong></p></li></ol><h3 id="二重积分的计算">二重积分的计算</h3><h4 id="直角坐标系下的计算">直角坐标系下的计算</h4><p>当二重积分存在时，可利用平行于坐标轴的直线来划分积分区域 <spanclass="math inline">\(D\)</span>，此时，面积元素</p><p><span class="math display">\[\mathrm{d}\sigma = \mathrm{d}x\mathrm{d}y\]</span></p><p>故二重积分在直角坐标系下可表示为</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \iint_Df(x,y)\,\mathrm{d}x\mathrm{d}y\]</span></p><h5 id="x-型正则区域"><span class="math inline">\(x\)</span>型正则区域</h5><p><span class="math display">\[D = \left\{(x,y)\bigg| \varphi_1(x)\leq y\leq \varphi_2(x),a\leq x\leqb\right\}\]</span></p><p>化为先 <span class="math inline">\(y\)</span> 后 <spanclass="math inline">\(x\)</span> 的二次积分</p><p><span class="math display">\[\begin{aligned}    \iint_D f(x,y)\,\mathrm{d}x\mathrm{d}y &amp;=\int_a^b\left[\int_{\varphi_1(x)}^{\varphi_2(x)}f(x,y)\,\mathrm{d}y\right]\mathrm{d}x \\    &amp;\equiv \int_a^b f(x,y)\,\mathrm{d}x\mathrm{d}y\end{aligned}\]</span></p><h5 id="y-型正则区域"><span class="math inline">\(y\)</span>型正则区域</h5><p><span class="math display">\[D = \left\{(x,y)\bigg| \varphi_1(y)\leq x\leq \varphi_2(y),c\leq y\leqd\right\}\]</span></p><p>化为先 <span class="math inline">\(x\)</span> 后 <spanclass="math inline">\(y\)</span> 的二次积分</p><p><span class="math display">\[\begin{aligned}    \iint_D f(x,y)\,\mathrm{d}x\mathrm{d}y &amp;=\int_c^d\left[\int_{\varphi_1(y)}^{\varphi_2(y)}f(x,y)\,\mathrm{d}x\right]\mathrm{d}y \\    &amp;\equiv \int_c^d f(x,y)\,\mathrm{d}x\mathrm{d}y\end{aligned}\]</span></p><h5 id="一般区域的二重积分">一般区域的二重积分</h5><p>分割成若干个正则子区域，利用积分区域可加性，分别在子区域上积分后求和</p><blockquote><p>直角坐标计算二重积分的步骤</p><ol type="1"><li><strong>画出积分区域</strong> <span class="math inline">\(D\)</span>的草图，并<strong>确定类型</strong></li><li>按照所确定的类型<strong>表示区域</strong> <spanclass="math inline">\(D\)</span></li><li><strong>化二重积分为二次积分</strong>（注意上下限）</li><li><strong>计算</strong>二重积分</li></ol></blockquote><h4 id="极坐标系下的计算">极坐标系下的计算</h4><p>当积分区域的边界曲线或被积函数用极坐标表示较为简单时，可用极坐标来计算二重积分.</p><p>面积元素 <span class="math inline">\(\Delta \sigma\)</span>在极坐标下为</p><p><span class="math display">\[\boxed{\Delta\sigma= r\mathrm{d}r\mathrm{d}\theta}\]</span></p><p>从直角坐标到极坐标时的二重积分变换公式为</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \iint_Df(r\cos\theta,r\sin\theta)r\,\mathrm{d}r\mathrm{d}\theta\]</span></p><p><span class="math display">\[\left\{\left(r,\theta\right)\left \vert r_1(\theta)\leq r \leqr_2(\theta) , \alpha \leq \theta \leq \beta \right.\right\}\]</span></p><p>则</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \int_\alpha^\beta\,\mathrm{d}\theta\int_{r_1(\theta)}^{r_2(\theta)}f(r\cos\theta,r\sin\theta)r\,\mathrm{d}r\]</span></p><h4 id="二重积分的变量代换">二重积分的变量代换</h4><p><strong>定理：</strong></p><p>设变换 <span class="math inline">\(\displaystyle T:\begin{cases}x=x(u,v)\\y=y(u,v)\end{cases}\)</span>有连续偏导数，且满足 <span class="math inline">\(\displaystyle J =\frac{\partial (x,y)}{\partial (u,v)}\coloneqq \begin{vmatrix}x_u,x_v\newline y_u,y_v\end{vmatrix} \left(\text{Jacobi 行列式}\right)\neq0\)</span>，而 <span class="math inline">\(f(x,y)\inC(D)\)</span>，则</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \iint_{D^*}f(x(u,v),y(u,v))\left\vert J \right\vert \,\mathrm{d}u\mathrm{d}v\]</span></p><ul><li><p>在定理条件下，变换 <span class="math inline">\(T\)</span>一定存在逆变换 <spanclass="math inline">\(T^{-1}:\begin{cases}u=u(x,y)\\v=v(x,y)\end{cases}\)</span>，且<span class="math inline">\(\frac{\partial (u,v)}{\partial (x,y)}\cdot\frac{\partial (x,y)}{\partial (u,v)} = 1\)</span></p><p>有时，借助此式求 <span class="math inline">\(J\)</span>较为简单</p></li><li><p>当 Jacobi 行列式仅在区域 <span class="math inline">\(D^*\)</span>内个别点上或个别曲线上为 <span class="math inline">\(0\)</span>时，定理结论仍成立</p></li><li><p>在广义极坐标 <spanclass="math inline">\(\begin{cases}x=ar\cos\theta\\y=br\sin\theta\end{cases}\)</span>下，<span class="math inline">\(J = abr\)</span></p></li></ul><h3 id="三重积分">三重积分</h3><h4 id="三重积分的定义">三重积分的定义</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(\Omega\)</span> 是 <spanclass="math inline">\(\mathbb{R}^3\)</span> 中的有界闭区域，三元函数<span class="math inline">\(f(x,y,z)\)</span> 在 <spanclass="math inline">\(\Omega\)</span> 上有界，<spanclass="math inline">\(I\)</span> 为实数. 若将 <spanclass="math inline">\(\Omega\)</span> 任意分割成 <spanclass="math inline">\(n\)</span> 个小区域 <spanclass="math inline">\(\Delta\Omega_1,\Delta\Omega_2,\ldots,\Delta\Omega_n\)</span>，任取 <spanclass="math inline">\(\left(\varepsilon_i,\eta_i,\xi_i\right)\in\Delta\Omega_i\left(i=1,2,\ldotp,n\right)\)</span>，作和 <spanclass="math inline">\(\displaystyle\sum_{i=1}^nf\left(\varepsilon_i,\eta_i,\xi_i\right)\Delta V_i\)</span>，（<span class="math inline">\(\DeltaV_i\)</span> 是 <span class="math inline">\(\Delta\Omega_i\)</span>的体积），总有</p><p><span class="math display">\[\lim_{\lambda\to 0}\sum_{i=1}^nf\left(\varepsilon_i,\eta_i,\xi_i\right)\Delta V_i = I\]</span></p><p>其中 <span class="math inline">\(\lambda = \max_{1\leq i\leqn}\{d_i\}\)</span>，<span class="math inline">\(d_i\)</span> 是 <spanclass="math inline">\(\Delta\Omega_i\)</span> 的直径，则称函数 <spanclass="math inline">\(f(x,y,z)\)</span> 在 <spanclass="math inline">\(\Omega\)</span> 上<strong>可积</strong>，记为<span class="math inline">\(f\in R(\Omega)\)</span>； <spanclass="math inline">\(I\)</span> 称为 <spanclass="math inline">\(f(x,y,z)\)</span> 在 <spanclass="math inline">\(\Omega\)</span>上的<strong>三重积分</strong>，记作</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V\]</span></p><p>其中 <span class="math inline">\(V_\Omega\)</span> 是区域 <spanclass="math inline">\(\Omega\)</span> 的体积</p><ul><li>若 <span class="math inline">\(f(x,y,z)\)</span>表示占有三维空间区域 <span class="math inline">\(\Omega\)</span>的物体的体密度函数，则 <spanclass="math inline">\(\displaystyle\iiint_\Omegaf(x,y,z)\,\mathrm{d}V\)</span> 给出了物体的<strong>质量</strong></li><li>类似二重积分，三重积分具有线性性，区域可加性，保序性以及推论和积分中值定理，并且有<span class="math inline">\(\displaystyle\iiint_\Omega \,\mathrm{d}V =V_\Omega\)</span></li></ul><h4 id="直角坐标系下的计算-1">直角坐标系下的计算</h4><p>直角坐标系下，由于 <spanclass="math inline">\(\mathrm{d}V=\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span>，故</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_\Omegaf(x,y,z)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><h5 id="柱线法坐标面投影法">柱线法（坐标面投影法）</h5><p>设 <span class="math inline">\(\Omega\)</span> 是以曲面 <spanclass="math inline">\(z=z_1(x,y)\)</span> 为底，曲面 <spanclass="math inline">\(x=x_2(x,y)\)</span>，而侧面是母线平行于 <spanclass="math inline">\(z\)</span> 轴的柱体所围成的区域</p><p>设 <span class="math inline">\(\Omega\)</span> 在 <spanclass="math inline">\(xOy\)</span> 面上的投影区域为 <spanclass="math inline">\(D_1\)</span> ，则 <spanclass="math inline">\(\Omega\)</span> 可表示为</p><p><span class="math display">\[\Omega = \left\{(x,y,z)\bigg| (x,y)\in D_1 , z_1(x,y)\leq z\leqz_2(x,y)(x,y)\in D\right\}\]</span></p><p>则物体总质量为</p><p><span class="math display">\[\iint_D\left(\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)\,\mathrm{d}z\right)\,\mathrm{d}x\mathrm{d}y\]</span></p><p>故有</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iint_{D_1}\,\mathrm{d}x\mathrm{d}y\int_{z_1(x,y)}^{z_2(x,y)} f(x,y,z)\,\mathrm{d}z\]</span></p><h5 id="截面法坐标轴投影法">截面法（坐标轴投影法）</h5><p>设区域 <span class="math inline">\(\Omega\)</span> 在 <spanclass="math inline">\(z\)</span> 轴上的投影区间为 <spanclass="math inline">\([h_1,h_2]\)</span>，即 <spanclass="math inline">\(\Omega\)</span> 介于平面 <spanclass="math inline">\(z=h_1\)</span> 和 <spanclass="math inline">\(z=h_2\)</span> 之间，过 <spanclass="math inline">\(z\)</span> 处且垂直于 <spanclass="math inline">\(z\)</span> 轴的平面截 <spanclass="math inline">\(\Omega\)</span> 得截面区域 <spanclass="math inline">\(D_z\)</span>，则 <spanclass="math inline">\(\Omega\)</span> 可表示为</p><p><span class="math display">\[\Omega = \left\{(x,y,z)\bigg| h_1\leq z\leq h_2 , (x,y)\in D_z\right\}\]</span></p><p>物体总质量为</p><p><span class="math display">\[\int_{h_1}^{h_2}\left(\iint_{D_z}f(x,y,z)\,\mathrm{d}x\mathrm{d}y\right) \,\mathrm{d}z\]</span></p><p>故有</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V =\int_{h_1}^{h_2}\,\mathrm{d}z\iint_{D_z}f(x,y,z)\,\mathrm{d}x\mathrm{d}y\]</span></p><h4 id="三重积分的变量代换">三重积分的变量代换</h4><p><strong>定理：</strong></p><p>设变换 <spanclass="math inline">\(T:\begin{cases}x=x(u,v,w)\\y=y(u,v,w)\\z=z(u,v,w)\end{cases}\)</span>有连续偏导数，且满足 <span class="math inline">\(J=\frac{\partial(x,y,z)}{\partial (u,v,w)}\neq 0\)</span>，而 <spanclass="math inline">\(f(x,y,z)\in C(\Omega)\)</span>，则</p><p><span class="math display">\[  \iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_{\Omega^*}f(x(u,v,w),y(u,v,w),z(u,v,w))\left\vert J \right\vert\,\mathrm{d}u\mathrm{d}v\mathrm{d}w\]</span></p><h5 id="柱面坐标系下的计算">柱面坐标系下的计算</h5><p>柱面坐标系，实际上就是将 <span class="math inline">\(x,y\)</span>坐标转换为极坐标</p><p><span class="math display">\[\begin{cases}x = r\cos\theta\\y = r\sin\theta\\z = z\end{cases}\]</span></p><p>其 Jacobi 行列式为</p><p><span class="math display">\[J = \frac{\partial (x,y,z)}{\partial (r,\theta,z)} = \begin{vmatrix}\cos\theta &amp; -r\sin\theta &amp; 0\\\sin\theta &amp; r\cos\theta &amp; 0\\0 &amp; 0 &amp; 1\end{vmatrix} = r\]</span></p><p>则柱面积分积分公式为</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_{\Omega^*}f(r\cos\theta,r\sin\theta,z)r\,\mathrm{d}r\mathrm{d}\theta\mathrm{d}z\]</span></p><h5 id="球面坐标系下的计算">球面坐标系下的计算</h5><p>球面坐标系，实际上就是将 <span class="math inline">\(x,y,z\)</span>坐标转换为球坐标</p><p><span class="math display">\[\begin{cases}x = \rho\sin\varphi\cos\theta\\y = \rho\sin\varphi\sin\theta\\z = \rho\cos\varphi\end{cases}\]</span></p><p>其 Jacobi 行列式为</p><p><span class="math display">\[J = \frac{\partial (x,y,z)}{\partial (\rho,\varphi,\theta)} =\begin{vmatrix}\sin\varphi\cos\theta &amp; \rho\cos\varphi\cos\theta &amp;-\rho\sin\varphi\sin\theta\\\sin\varphi\sin\theta &amp; \rho\cos\varphi\sin\theta &amp;\rho\sin\varphi\cos\theta\\\cos\varphi &amp; -\rho\sin\varphi &amp; 0\end{vmatrix} = \rho^2\sin\varphi\]</span></p><p>则球面积分积分公式为</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_{\Omega^*}f(\rho\sin\varphi\cos\theta,\rho\sin\varphi\sin\theta,\rho\cos\varphi)\rho^2\sin\varphi\,\mathrm{d}\rho\mathrm{d}\varphi\mathrm{d}\theta\]</span></p><h3 id="重积分的应用">重积分的应用</h3><h4 id="重积分的几何应用">重积分的几何应用</h4><h5 id="平面图形的面积">平面图形的面积</h5><p><span class="math display">\[A(D) = \iint_D \,\mathrm{d}\sigma = \iint_D \,\mathrm{d}x\mathrm{d}y\]</span></p><h5 id="立体的体积">立体的体积</h5><p><span class="math display">\[V(\Omega) = \iiint_\Omega \,\mathrm{d}V = \iiint_\Omega\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><h5 id="曲面的面积">曲面的面积</h5><p>设空间曲面 <span class="math inline">\(S:z=f(x,y),(x,y)\inD\)</span>.</p><p>则曲面 <span class="math inline">\(S\)</span> 的面积为</p><p><span class="math display">\[A(S) = \iint_D \sqrt{1+z_x^2+z_y^2}\,\mathrm{d}x\mathrm{d}y\]</span></p><h4 id="重积分的物理应用">重积分的物理应用</h4><h6 id="质心">质心</h6><p>体密度为 <span class="math inline">\(\rho(x, y)\)</span>的物体占据空间 <spanclass="math inline">\(\Omega\)</span>，其质心坐标为</p><p><span class="math display">\[\begin{cases}  \displaystyle\bar{x} = \frac{\iiint_\Omegax\rho(x,y,z)\,\mathrm{d}V}{\iiint_\Omega\mu(x,y,z)\,\mathrm{d}V} \\  \displaystyle\bar{y} = \frac{\iiint_\Omegay\rho(x,y,z)\,\mathrm{d}V}{\iiint_\Omega\mu(x,y,z)\,\mathrm{d}V}\\  \displaystyle\bar{z} = \frac{\iiint_\Omegaz\rho(x,y,z)\,\mathrm{d}V}{\iiint_\Omega\mu(x,y,z)\,\mathrm{d}V}\end{cases}\]</span></p><h5 id="转动惯量">转动惯量</h5><p>设物体的密度为 <spanclass="math inline">\(\rho(x,y,z)\)</span>，则物体分别关于 <spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(y\)</span>，<span class="math inline">\(z\)</span>轴的转动惯量为</p><p><span class="math display">\[\begin{cases}  I_x = \iiint_\Omega \rho(x,y,z)(y^2+z^2)\,\mathrm{d}V\\  I_y = \iiint_\Omega \rho(x,y,z)(x^2+z^2)\,\mathrm{d}V\\  I_z = \iiint_\Omega \rho(x,y,z)(x^2+y^2)\,\mathrm{d}V\end{cases}\]</span></p><h5 id="引力">引力</h5><p><span class="math display">\[\begin{aligned}  &amp;\mathrm{d}\vec{F} = G\frac{m_0\mathrm{d}m}{r^3}\vec{r}\\  =&amp;G\frac{m_0\rho(x,y,z)\mathrm{d}V}{r^3}\cdot\left(x-x_0,y-y_0,z-z_0\right)\\  =&amp;\left(\mathrm{d}F_x,\mathrm{d}F_y,\mathrm{d}F_z\right)\end{aligned}\]</span></p><h2 id="曲线积分和曲面积分">曲线积分和曲面积分</h2><h3 id="第一类曲线积分和曲面积分">第一类曲线积分和曲面积分</h3><h4 id="第一类曲线积分的概念">第一类曲线积分的概念</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(C\)</span> 是 <spanclass="math inline">\(xOy\)</span> 面上的一条光滑曲线弧，函数 <spanclass="math inline">\(f(x,y)\)</span> 是定义在 <spanclass="math inline">\(C\)</span> 上的有界函数，在 <spanclass="math inline">\(C\)</span> 上任意插入分点 <spanclass="math inline">\(A =A_0,A_1,\ldots,A_{n-1},A_n=B\)</span>，将其分成 <spanclass="math inline">\(n\)</span> 个小弧段，记第 <spanclass="math inline">\(i\)</span> 个小弧段的弧长为 <spanclass="math inline">\(\Delta s_i\)</span>，在第 <spanclass="math inline">\(i\)</span> 个小段上任取点 <spanclass="math inline">\((\epsilon_i,\eta_i)\)</span>，和式 <spanclass="math inline">\(\displaystyle\sum_{i=1}^{+\infty}f(\epsilon_i,\eta_i)\Deltas_i\)</span>，当 <spanclass="math inline">\(\displaystyle\lambda=\max_{1\leq i\leq n}\{\Deltas_i\}\to 0\)</span> 时，有确定的极限值 <spanclass="math inline">\(I\)</span>，即</p><p><span class="math display">\[\lim_{\lambda\to 0}\sum_{i=1}^nf(\epsilon_i,\eta_i)\Delta s_i = I\]</span></p><p>则称函数 <span class="math inline">\(f(x,y)\)</span> 在曲线 <spanclass="math inline">\(C\)</span> 上<strong>可积</strong>，并将此极限值<span class="math inline">\(I\)</span> 称为函数 <spanclass="math inline">\(f(x,y)\)</span> 在曲线 <spanclass="math inline">\(C\)</span>上的<strong>第一类曲线积分</strong>，记作 <spanclass="math inline">\(\displaystyle\int_Cf(x,y)\,\mathrm{d}s\)</span>，即</p><p><span class="math display">\[I = \int_C f(x,y)\,\mathrm{d}s = \lim_{\lambda\to0}\sum_{i=1}^nf(\epsilon_i,\eta_i)\Delta s_i\]</span></p><ul><li>第一类曲线积分的几何含义为柱面的面积</li><li><span class="math inline">\(\displaystyle\int_C\,\mathrm{d}s =\displaystyle\int_c1\,\mathrm{d}s=s_C\)</span></li><li>若 <span class="math inline">\(C\)</span> 是封闭曲线，即 <spanclass="math inline">\(C\)</span> 的二端点重合，则记第一类曲线积分为<spanclass="math inline">\(\displaystyle\oint_Cf(x,y)\,\mathrm{d}s\)</span></li></ul><h4 id="第一类曲线积分的性质">第一类曲线积分的性质</h4><h5 id="与曲线方向无关">与曲线方向无关</h5><p>若曲线 <span class="math inline">\(C\)</span> 的端点为 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，<spanclass="math inline">\(f(x,y)\)</span> 在曲线 <spanclass="math inline">\(C\)</span> 上可积，则</p><p><span class="math display">\[\int_{\widehat{AB}} f(x,y)\,\mathrm{d}s=\oint_{\widehat{BA}}f(x,y)\,\mathrm{d}s\]</span></p><h5 id="线性性">线性性</h5><p>若 <span class="math inline">\(f,g\)</span> 在曲线 <spanclass="math inline">\(C\)</span> 上可积，<spanclass="math inline">\(\alpha , \beta\)</span> 是任意常数，则 <spanclass="math inline">\(\alpha f + \beta g\)</span> 在曲线 <spanclass="math inline">\(C\)</span> 上可积，且</p><p><span class="math display">\[\int_C (\alpha f + \beta g)\,\mathrm{d}s = \alpha \int_Cf(x,y)\,\mathrm{d}s + \beta \int_C g(x,y)\,\mathrm{d}s\]</span></p><h5 id="路径可加性">路径可加性</h5><p>若曲线 <span class="math inline">\(C\)</span> 由两段光滑曲线 <spanclass="math inline">\(C_1\)</span> 和 <spanclass="math inline">\(C_2\)</span> 首尾连接而成，则 <spanclass="math inline">\(f(x,y)\)</span> 在曲线 <spanclass="math inline">\(C\)</span> 上可积，等价于 <spanclass="math inline">\(f(x,y)\)</span> 在曲线 <spanclass="math inline">\(C_1\)</span> 和 <spanclass="math inline">\(C_2\)</span> 上均可积，且</p><p><span class="math display">\[\int_C f(x,y)\,\mathrm{d}s = \int_{C_1} f(x,y)\,\mathrm{d}s + \int_{C_2}f(x,y)\,\mathrm{d}s\]</span></p><h5 id="中值定理">中值定理</h5><p>设函数 <span class="math inline">\(f\)</span> 在光滑曲线 <spanclass="math inline">\(C\)</span> 上连续，则 <spanclass="math inline">\(\exists (\epsilon,\eta)\in C\)</span>，使得</p><p><span class="math display">\[\int_C f(x,y)\,\mathrm{d}s = f(\epsilon,\eta)\cdot s_C\]</span></p><p>其中 <span class="math inline">\(s_C\)</span> 是曲线段 <spanclass="math inline">\(C\)</span> 的长度</p><h4 id="第一类曲线积分的计算">第一类曲线积分的计算</h4><p>设函数 <span class="math inline">\(f(x,y)\)</span> 在光滑曲线 <spanclass="math inline">\(C\)</span> 上连续，<spanclass="math inline">\(C\)</span> 的参数方程为 <spanclass="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>，<spanclass="math inline">\(t\in [a,b]\)</span>，满足 <spanclass="math inline">\(x&#39;(t)\)</span>，<spanclass="math inline">\(y&#39;(t)\)</span> 连续，且 <spanclass="math inline">\(x&#39;(t)^2 + y&#39;(t)^2 \neq 0\)</span>，则</p><p><span class="math display">\[\int_C f(x,y)\,\mathrm{d}s = \int_\alpha^\betaf(x(t),y(t))\sqrt{x&#39;(t)^2 + y&#39;(t)^2}\,\mathrm{d}t\]</span></p><ul><li>右端积分限应 <span class="math inline">\(\alpha &lt;\beta\)</span></li><li>当曲线 <span class="math inline">\(C\)</span> 形式为 <spanclass="math inline">\(y=y(x)\)</span>，<span class="math inline">\(x\in[a,b]\)</span> 时，则 <spanclass="math inline">\(\displaystyle\int_Cf(x,y)\,\mathrm{d}s=\int_a^bf(x,y(x))\sqrt{1+y&#39;^2(x)}\,\mathrm{d}x\)</span></li><li>当曲线 <span class="math inline">\(C\)</span> 为极坐标 <spanclass="math inline">\(r=r(\theta)\)</span>，<spanclass="math inline">\(\theta\in [\alpha,\beta]\)</span> 时，则 <spanclass="math inline">\(\displaystyle\int_Cf(x,y)\,\mathrm{d}s =\int_\alpha^\betaf(r(\theta)\cos\theta,r(\theta)\sin\theta)\sqrt{r(\theta)^2+r&#39;^2(\theta)}\,\mathrm{d}\theta\)</span></li></ul><h3 id="第二类曲线积分与曲面积分">第二类曲线积分与曲面积分</h3><h4 id="第二类曲线积分的概念">第二类曲线积分的概念</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(C\)</span> 为平面光滑定向曲线(<spanclass="math inline">\(A\rightarrow B\)</span>)，且向量值函数 <spanclass="math inline">\(\vec{F}(x,y) =R(x,y)\vec{i}+Q(x,y)\vec{j}\)</span> 在 <spanclass="math inline">\(C\)</span> 上有界，<spanclass="math inline">\(\vec{e}_\tau\)</span> 为 <spanclass="math inline">\(C\)</span> 上点 <spanclass="math inline">\((x,y)\)</span> 处于定向一致的单位切向量，若</p><p><span class="math display">\[\int_C \vec{F}(x,y) \cdot \vec{e}_\tau \,\mathrm{d}s\]</span></p><p>存在，则称为<strong>向量值函数 <spanclass="math inline">\(\vec{F}\)</span> 在定向曲线 <spanclass="math inline">\(C\)</span>上的曲线积分或第二类曲线积分</strong></p><p>若 <span class="math inline">\(\vec{e}_\tau(x,y) =(\cos\alpha,\cos\beta)\)</span>，则</p><p><span class="math display">\[\begin{aligned}  \int_C \vec{F}(x,y) \cdot \vec{e}_\tau \,\mathrm{d}s &amp;= \int_CP(x,y)\cos\alpha + Q(x,y)\cos\beta \,\mathrm{d}s \\  &amp;= \int_C P(x,y)\cos\alpha \,\mathrm{d}s + \int_C Q(x,y)\cos\beta\,\mathrm{d}s \\  &amp;= \int_C P(x,y)\,\mathrm{d}x +  Q(x,y)\,\mathrm{d}y\end{aligned}\]</span></p><p>这是对坐标的曲线积分</p><p>记 <span class="math inline">\(\vec{r} = (x,y)\)</span>，则 <spanclass="math inline">\(\mathrm{d}\vec{e} = \vec{e}_\tau\,\mathrm{d}s\)</span> 称为<strong>定向弧微分</strong></p><p>从而有向量形式的第一类曲线积分</p><p><span class="math display">\[\int_C \vec{F}(x,y) \cdot \mathrm{d}\vec{e} = \int_C \vec{F}\cdot\mathrm{d}\vec{r}\]</span></p><h5 id="第二类曲线积分的性质">第二类曲线积分的性质</h5><p>第二类曲线积分与<strong>曲线方向有关</strong>，即</p><p><span class="math display">\[\int_{\widehat{AB}} \vec{F}(x,y) \cdot \mathrm{d}\vec{r} =-\oint_{\widehat{BA}} \vec{F}(x,y) \cdot \mathrm{d}\vec{r}\]</span></p><p>此外线性性与对定向积分路径的可加性等仍然成立</p><h5 id="第二类曲线积分的计算">第二类曲线积分的计算</h5><p>若曲线 <span class="math inline">\(C\)</span> 为 <spanclass="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>，<spanclass="math inline">\(t:\alpha\rightarrow \beta\)</span></p><p>起点 <span class="math inline">\(A\)</span> 对应 <spanclass="math inline">\(\alpha\)</span>，终点 <spanclass="math inline">\(B\)</span> 对应 <spanclass="math inline">\(\beta\)</span></p><p>考察 <span class="math inline">\(\displaystyle\int_C P\,\mathrm{d}x +Q\,\mathrm{d}y = \int_C \vec{F}\cdot\vec{e}_\tau\,\mathrm{d}s\)</span>，沿曲线 <span class="math inline">\(C\)</span> 有<span class="math inline">\(\vec{F} =\left(P\left(x(t),y(t)\right),Q\left(x(t),y(t)\right)\right)\)</span>，则</p><p><span class="math display">\[\int_C P\,\mathrm{d}x + Q\,\mathrm{d}y = \int_\alpha^\betaP\left(x(t),y(t)\right)\,\mathrm{d}x(t) +Q\left(x(t),y(t)\right)\,\mathrm{d}y(t)\]</span></p><h4 id="第二类曲面积分的概念">第二类曲面积分的概念</h4><h5 id="双侧曲面">双侧曲面</h5><p><strong>定义：</strong></p><p>若点 <span class="math inline">\(P\)</span> 沿曲面 <spanclass="math inline">\(S\)</span>上任何不越过曲面边界的连续闭曲线移动后回到起始位置时，法向量 <spanclass="math inline">\(\vec{n}\)</span> 保持原来的指向，则称 <spanclass="math inline">\(S\)</span> 为<strong>双侧曲面</strong></p><p>典型的，Mobius 面不是双侧曲面</p><p>选定双侧曲面 <span class="math inline">\(S\)</span>一侧为正向，称为<strong>正侧</strong>，记为 <spanclass="math inline">\(S^+\)</span> ，其相反测记作 <spanclass="math inline">\(S^-\)</span></p><h5 id="双侧曲面定侧">双侧曲面定侧</h5><p>若 <span class="math inline">\(S:z=z(x,y)\)</span>，<spanclass="math inline">\((x,y)\in D_{xy}\)</span>，<spanclass="math inline">\(\vec{n}_0=\left(\cos\alpha,\cos\beta,\cos\gamma\right)=\pm\frac{\left(-z_x,-z_y,1\right)}{\sqrt{1+z_x^2+z_y^2}}\)</span></p><p>若选取 <spanclass="math inline">\(\vec{n}_0=\left(\cos\alpha,\cos\beta,\cos\gamma\right)=\frac{\left(-z_x,-z_y,1\right)}{\sqrt{1+z_x^2+z_y^2}}\)</span>，则说明<span class="math inline">\(\cos\gamma &gt;0\)</span>，选取了曲面的上侧</p><p>一般的</p><p><span class="math display">\[\begin{cases}  \cos\alpha &gt;0 \Leftrightarrow \text{前侧}，\cos\alpha &lt; 0\Leftrightarrow \text{后侧}\\  \cos\beta &gt;0 \Leftrightarrow \text{右侧}，\cos\beta &lt; 0\Leftrightarrow \text{左侧}\\  \cos\gamma &gt;0 \Leftrightarrow \text{上侧}，\cos\gamma &lt; 0\Leftrightarrow \text{下侧}\end{cases}\]</span></p><p>习惯上选取曲面片的上侧为 <spanclass="math inline">\(S^+\)</span>；对于封闭曲面，选取外侧为 <spanclass="math inline">\(S^+\)</span></p><p>对于向量值函数 <span class="math inline">\(\vec{F} =(P,Q,R)\)</span></p><p><span class="math display">\[\int_C \vec{F}\cdot\,\mathrm{d}S = \int_c P\,\mathrm{d}x\mathrm{d}y +Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x\]</span></p><h5 id="第二类曲面积分的性质">第二类曲面积分的性质</h5><p>第二类曲面积分与在曲面的哪一侧积分有关</p><p><span class="math display">\[\iint_{S^+}P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z +R\,\mathrm{d}z\mathrm{d}x = -\iint_{S^-}P\,\mathrm{d}x\mathrm{d}y +Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x\]</span></p><p>此外第二类曲面积分也具有线性性和可加性等性质</p><h4 id="第二类曲面积分的计算">第二类曲面积分的计算</h4><h5 id="合一投影法">合一投影法</h5><p><span class="math display">\[\iint_{S^+}P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z +R\,\mathrm{d}z\mathrm{d}x = \iint_{D_{xy}}\left(-Pz_x-Qz_y+R\right)\,\mathrm{d}x\mathrm{d}y\]</span></p><h5 id="分面投影法">分面投影法</h5><p>分 <spanclass="math inline">\(P\,\mathrm{d}x\mathrm{d}y\)</span>，<spanclass="math inline">\(Q\,\mathrm{d}y\mathrm{d}z\)</span>，<spanclass="math inline">\(R\,\mathrm{d}z\mathrm{d}x\)</span>三个部分进行积分</p><p>常在部分曲面垂直坐标轴时进行</p><h5 id="公式法">公式法</h5><p>常用于参数方程确定的曲面</p><p>设 <span class="math inline">\(S:\vec{r} =\left(x(u,v),y(u,v),z(u,v)\right)\)</span>，其中 <spanclass="math inline">\((u,v)\in D_{xy}\)</span>，则</p><p><span class="math display">\[\iint_{S^+}\vec{F}\cdot\,\mathrm{d}\vec{S} =\iint_{D_{uv}}\vec{F}\cdot\left(\vec{r}_u\times\vec{r_v}\right)\,\mathrm{d}u\mathrm{d}v\]</span></p><h3 id="green-公式及其应用">Green 公式及其应用</h3><h4 id="green-公式">Green 公式</h4><h5 id="连通区域及其边界方向">连通区域及其边界方向</h5><p>设 <span class="math inline">\(D\)</span> 为平面区域, 若 <spanclass="math inline">\(D\)</span> 内的任意一条闭曲线所围的区域都落在<span class="math inline">\(D\)</span> 内, 则称 <spanclass="math inline">\(D\)</span> 是单连通的, 否则称 <spanclass="math inline">\(D\)</span> 为复连通的</p><p>当点沿区域边界朝一个方向前进时, 区域总在它的左侧,则将此方向规定为边界曲线 <span class="math inline">\(C\)</span>的正向,记为 <span class="math inline">\(C^+\)</span>, 与 <spanclass="math inline">\(C^+\)</span> 相反方向为 <spanclass="math inline">\(C^−\)</span></p><h5 id="green-公式-1">Green 公式</h5><p><strong>定理：</strong></p><p>设有界闭区域 <span class="math inline">\(D\)</span> 由分段光滑曲线<span class="math inline">\(C\)</span> 围成，函数 <spanclass="math inline">\(P(x, y)\)</span>, <span class="math inline">\(Q(x,y)\)</span> 在 <span class="math inline">\(D\)</span>上有一阶连续偏导数, 则</p><p><span class="math display">\[\oint_{C^+} P\,\mathrm{d}x + Q\,\mathrm{d}y = \iint_D\left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partialy}\right)\,\mathrm{d}x\mathrm{d}y\]</span></p><ul><li>对于复连通区域 <span class="math inline">\(D\)</span>，Green公式仍然成立，但需将 <span class="math inline">\(C\)</span>分成若干个单连通区域 <spanclass="math inline">\(D_i\)</span>，并对每个区域应用 Green 公式</li><li>公式也可以记为 <span class="math inline">\(\displaystyle\oint_{C^+}P\,\mathrm{d}x + Q\,\mathrm{d}y = \iint_D\begin{vmatrix}\frac{\partial}{\partial x}&amp;\frac{\partial}{\partialy}\newline P&amp;Q\end{vmatrix}\,\mathrm{d}x\mathrm{d}y\)</span></li></ul><h5 id="green-公式的向量形式">Green 公式的向量形式</h5><p><span class="math display">\[\oint_{C^+} \vec{F}\cdot\,\mathrm{d}\vec{r} = \iint_D\nabla\times\vec{F}\,\mathrm{d}x\mathrm{d}y\]</span></p><h4 id="曲线积分与路径无关的条件">曲线积分与路径无关的条件</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(P(x,y)\)</span>，<spanclass="math inline">\(Q(x,y)\)</span> 在区域 <spanclass="math inline">\(D\)</span> 内连续，若对 <spanclass="math inline">\(D\)</span> 内任意两点 <spanclass="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>以及 <span class="math inline">\(D\)</span> 内连接 <spanclass="math inline">\(A,B\)</span> 的任意二分段光滑曲线 <spanclass="math inline">\(C_1\)</span>，<spanclass="math inline">\(C_2\)</span>，均有</p><p><span class="math display">\[\int_{C_1} P\,\mathrm{d}x +Q\,\mathrm{d}y = \int_{C_2} P\,\mathrm{d}x+Q\,\mathrm{d}y\]</span></p><p>则称曲线积分 <span class="math inline">\(\displaystyle\int_CP\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 在 <spanclass="math inline">\(D\)</span> 内<strong>与路径无关</strong></p><p><strong>定理：</strong></p><p>设函数 <span class="math inline">\(P\)</span>，<spanclass="math inline">\(Q\)</span> 在<strong>单连通</strong>区域 <spanclass="math inline">\(D\)</span> 上有连续偏导数，则下述四命题等价</p><ol type="1"><li>在 <span class="math inline">\(D\)</span> 内的任一条分段光滑闭曲线<span class="math inline">\(C\)</span> 上，有 <spanclass="math inline">\(\displaystyle \int_C P\,\mathrm{d}x+Q\,\mathrm{d}y = 0\)</span></li><li>曲线积分 <span class="math inline">\(\displaystyle \int_CP\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 在 <spanclass="math inline">\(D\)</span> 内与路径无关</li><li>存在 <span class="math inline">\(D\)</span> 上的可微函数 <spanclass="math inline">\(u(x,y)\)</span> 使得 <spanclass="math inline">\(\displaystyle \mathrm{d}u = P\,\mathrm{d}x+Q\,\mathrm{d}y\)</span>，此时称 <spanclass="math inline">\(u(x,y)\)</span> 为 <spanclass="math inline">\(\displaystyle P\,\mathrm{d}x+Q\,\mathrm{d}y\)</span> 的一个<strong>原函数</strong></li><li><span class="math inline">\(\displaystyle \frac{\partial Q}{\partialx} = \frac{\partial P}{\partial y}\)</span> 在 <spanclass="math inline">\(D\)</span> 内恒成立</li></ol><h4 id="全微分求积与全微分方程">全微分求积与全微分方程</h4><p>设函数 <span class="math inline">\(P\)</span>，<spanclass="math inline">\(Q\)</span> 在单连通区域 <spanclass="math inline">\(D\)</span> 上有连续偏导数，且 <spanclass="math inline">\(\displaystyle \frac{\partial Q}{\partial x} =\frac{\partial P}{\partial y}\)</span> ，则 <spanclass="math inline">\(\displaystyle P\,\mathrm{d}x+Q\,\mathrm{d}y\)</span> 为某函数 <span class="math inline">\(u\)</span>的全微分，且取定 <span class="math inline">\((x_0,y_0)\in D\)</span></p><p><span class="math display">\[u(x,y) = u(x_0,y_0) + \int_{(x_0,y_0)}^{(x,y)} P\,\mathrm{d}x+Q\,\mathrm{d}y,\quad (x,y)\in D\]</span></p><p>从而全体函数为 <span class="math inline">\(u(x,y) + C\)</span></p><p>称求 <span class="math inline">\(P\,\mathrm{d}x+Q\,\mathrm{d}y\)</span> 的原函数的过程为<strong>全微分求积</strong></p><p>若 <span class="math inline">\(P\,\mathrm{d}x+Q\,\mathrm{d}y\)</span> 是某二元函数的全微分，称方程</p><p><span class="math display">\[P(x,y)\,\mathrm{d}x +Q(x,y)\,\mathrm{d}y = 0\]</span></p><p>为<strong>全微分方程</strong></p><p>求出一个原函数 <spanclass="math inline">\(u(x,y)\)</span>，则方程的通解为 <spanclass="math inline">\(u(x,y) = C\)</span>，其中 <spanclass="math inline">\(C\)</span> 是任意常数</p><h3 id="gauss-公式和-strokes-公式">Gauss 公式和 Strokes 公式</h3><h4 id="gauss-公式">Gauss 公式</h4><p><strong>定理：</strong></p><p>设函数 <span class="math inline">\(P(x,y,z)\)</span>，<spanclass="math inline">\(Q(x,y,z)\)</span>，<spanclass="math inline">\(R(x,y,z)\)</span> 在空间有界闭区域 <spanclass="math inline">\(\Omega\)</span> 上有连续偏导数，<spanclass="math inline">\(\Omega\)</span> 的边界时光滑或分片光滑的闭曲面<span class="math inline">\(\Sigma\)</span>，则</p><p><span class="math display">\[\oiint_{\Sigma^+} P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z+ R\,\mathrm{d}z\mathrm{d}x = \iiint_\Omega \left(\frac{\partialP}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partialR}{\partial z}\right)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><ul><li>令 <span class="math inline">\(P=\frac{x}{3}\)</span>，<spanclass="math inline">\(Q=\frac{y}{3}\)</span>，<spanclass="math inline">\(R=\frac{z}{3}\)</span>，则可导出 <spanclass="math inline">\(\displaystyle V_\Omega =\frac{1}{3}\oiint_{\Sigma^+} x\,\mathrm{d}y\mathrm{d}z +y\,\mathrm{d}z\mathrm{d}x +z\,\mathrm{d}x\mathrm{d}y\)</span>，即体积公式</li><li>使用 Gauss 公式时，注意 <spanclass="math inline">\(\Sigma^+\)</span> 的方向应与 <spanclass="math inline">\(\Omega\)</span> 的外侧一致</li></ul><h5 id="向量形式的-gauss-公式">向量形式的 Gauss 公式</h5><p><span class="math display">\[\oiint_{\Sigma^+} \vec{F}\cdot\,\mathrm{d}\vec{S} = \iiint_\Omega\nabla\cdot\vec{F}\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><h4 id="通量和散度">通量和散度</h4><h5 id="通量">通量</h5><p>若给定向量场</p><p><span class="math display">\[\vec{F} = \left(P(x,y,z),Q(x,y,z),R(x,y,z)\right)\]</span></p><p>则称曲面积分</p><p><span class="math display">\[\Phi = \oiint_{\Sigma^+} \vec{F}\cdot\,\mathrm{d}\vec{S} =\oiint_{\Sigma^+} P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z+ R\,\mathrm{d}z\mathrm{d}x\]</span></p><p>为向量场 <span class="math inline">\(\vec{F}\)</span> 在通过定侧曲面<span class="math inline">\(\Sigma^+\)</span>的<strong>通量</strong></p><h5 id="散度">散度</h5><p>称</p><p><span class="math display">\[\mathrm{div}\vec{F} = \nabla\cdot\vec{F}=\frac{\partial P}{\partial x} +\frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}\]</span></p><p>为向量场 <span class="math inline">\(\vec{F}\)</span>的<strong>散度</strong></p><p>则 Gauss 公式可写为</p><p><span class="math display">\[\Phi =\oiint_{\Sigma^+} \vec{F}\cdot\,\mathrm{d}\vec{S} = \iiint_\Omega\mathrm{div}\vec{F}\,\mathrm{d}V\]</span></p><h2 id="级数">级数</h2><h3 id="数项级数">数项级数</h3><h4 id="数项级数的概念">数项级数的概念</h4><p><strong>定义：</strong></p><p>给定数列 <span class="math inline">\(\{a_n\}\)</span> ，和式</p><p><span class="math display">\[\sum_{n=1}^{\infty} a_n = a_1 + a_2 + \cdots + a_n + \cdots\]</span></p><p>称为 <strong>（无穷）极数</strong> ，<spanclass="math inline">\(a_n\)</span>称为级数的<strong>通项</strong>（或<strong>一般项</strong>）</p><ul><li><span class="math inline">\(\displaystyle S_n = \sum_{k=1}^na_k\)</span> 称为级数 <span class="math inline">\(\displaystyle\sum_{n=1} a_n\)</span> 的前 <span class="math inline">\(n\)</span>项<strong>部分和</strong></li><li><span class="math inline">\(\displaystyle\sum_{k=n+1}^\inftya_k\)</span> 称为级数 <span class="math inline">\(\displaystyle\sum_{n=1} a_n\)</span> 的<strong>余项级数</strong></li></ul><p><strong>定义：</strong></p><ul><li>若级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\inftya_n\)</span> 的部分和数列 <span class="math inline">\(\{S_n\}\)</span>收敛，且 <span class="math inline">\(\displaystyle \lim_{n\to\infty}S_n= S\)</span>，则称级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> <strong>收敛</strong>，<spanclass="math inline">\(S\)</span> 称为级数 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>的<strong>和</strong>，记作 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n = S\)</span></li><li>若部分和数列 <span class="math inline">\(\{S_n\}\)</span>发散，则称级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> <strong>发散</strong></li></ul><blockquote><p>常用结论：</p><p><strong>等比数列</strong> <span class="math inline">\(\displaystyle\sum_{n=1}^\infty aq^{n-1}\begin{cases}\text{收敛于}\frac{a}{1-q} &amp;,\vert q \vert &lt; 1\newline \text{发散} &amp; ,\vert q \vert \geq1\end{cases}\)</span></p></blockquote><h4 id="数项级数的基本性质">数项级数的基本性质</h4><h5 id="基本性质">基本性质</h5><ol type="1"><li>若常数 <span class="math inline">\(\alpha \neq 0\)</span>，则级数<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>与级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty\alpha a_n\)</span> 有相同敛散性</li><li><strong>线性性：</strong> 若级数 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n =S\)</span>，<span class="math inline">\(\displaystyle \sum_{n=1}^\inftyb_n = T\)</span>，则 <span class="math inline">\(\forall \alpha ,\beta\in \mathbb{R}\)</span>，有 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty (\alpha a_n +\beta b_n) = \alpha S + \beta T\)</span></li><li><strong>可加性：</strong>将级数增加、删减或改换<strong>有限项</strong>，不改变级数的<strong>敛散性</strong></li><li><strong>结合律：</strong> 若级数收敛于 <spanclass="math inline">\(S\)</span>，则将相邻若干项添加括号所成新级数仍收敛于<span class="math inline">\(S\)</span><ul><li>其本质是部分和数列收敛于 <spanclass="math inline">\(S\)</span>，则子列均收敛于 <spanclass="math inline">\(S\)</span></li><li>加括号后级数收敛 <span class="math inline">\(\nRightarrow\)</span>原级数收敛</li><li>加括号后级数发散 <span class="math inline">\(\Rightarrow\)</span>原级数发散</li></ul></li></ol><h5 id="级数收敛的必要条件">级数收敛的必要条件</h5><p><strong>定理：</strong></p><p>若 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 收敛，则 <span class="math inline">\(\displaystyle\lim_{n\to\infty} a_n = 0\)</span></p><ul><li>若 <span class="math inline">\(\displaystyle \lim_{n\to\infty} a_n\neq 0 \nRightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span>发散</li><li>若 <span class="math inline">\(\displaystyle \lim_{n\to\infty} a_n =0 \nRightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span>收敛，比如调和级数</li></ul><h3 id="正项级数敛散性">正项级数敛散性</h3><h4 id="正项级数">正项级数</h4><p><strong>定义：</strong></p><p>若级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 满足 <span class="math inline">\(a_n &gt;0 \quad\left(n\in\mathbb{N}^+\right)\)</span>，则称此级数为<strong>正项级数</strong></p><p><strong>定理：（收敛原理）</strong></p><p>正项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 收敛 <span class="math inline">\(\Leftrightarrow\)</span>是其部分和数列 <span class="math inline">\(\{S_n\}\)</span> 有上界，即<span class="math inline">\(\exists M\in\mathbb{R},\forall n \in\mathbb{N}^+:S_n \leq M\)</span></p><blockquote><p><span class="math inline">\(p\)</span> 级数</p><p><span class="math inline">\(\displaystyle \sum_{n=1}^\infty\frac{1}{n^p} \begin{cases}\text{收敛} &amp; ,p&gt;1\newline \text{发散}&amp; ,p\leq 1\end{cases}\)</span></p></blockquote><h4 id="正项级数敛散性判别法">正项级数敛散性判别法</h4><h5 id="比较判别法">比较判别法</h5><p><strong>定理：</strong></p><p>设正项级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span>，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 满足<span class="math inline">\(a_n \leq b_n \quad (\forall n \in\mathbb{N}^+)\)</span> ，则 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty b_n\)</span> 收敛 <spanclass="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\inftya_n\)</span> 收敛，<span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> 发散 <spanclass="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\inftyb_n\)</span> 发散</p><ul><li>条件 <span class="math inline">\(\forall n \in \mathbb{N}^+，a_n\leq b_n\)</span> 可改为 <span class="math inline">\(\exists N,C&gt;0  ,\forall n\in \mathbb{N}^+，\forall n \geq N，a_n \leqCb_n\)</span></li><li>使用该判别法时需要有参照级数，常选<strong>等比级数</strong>或<strong><span class="math inline">\(p\)</span> 级数</strong>作参照</li></ul><h5 id="比较判别法极限形式">比较判别法（极限形式）</h5><p><strong>定理：</strong></p><p>正项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span>，<span class="math inline">\(\displaystyle\sum_{n=1}^\infty b_n\)</span> 满足 <spanclass="math inline">\(\displaystyle \lim_{n\to\infty} \frac{a_n}{b_n} =l\)</span></p><ul><li>当 <span class="math inline">\(0 &lt;l&lt;+\infty\)</span> 时，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 与<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span>同敛散</li><li>当 <span class="math inline">\(l=0\)</span> 时，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 收敛<span class="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\inftya_n\)</span> 收敛</li><li>当 <span class="math inline">\(l=+\infty\)</span> 时，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 发散<span class="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\inftya_n\)</span> 发散</li></ul><blockquote><p>通常使用 <span class="math inline">\(b_n = \frac{1}{n^p}\)</span>作为参照物，因为我们此时在分析无穷小 <spanclass="math inline">\(a_n\)</span> 的阶</p></blockquote><h5 id="比值判别法dalembert-判别法">比值判别法（d’Alembert 判别法）</h5><p><strong>定理：</strong></p><p>若<strong>正项级数</strong> <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> 满足 <spanclass="math inline">\(\displaystyle \lim_{n\to\infty}\frac{a_{n+1}}{a_n} = l\)</span>，则</p><ul><li>当 <span class="math inline">\(0\leq l&lt;1\)</span> 时，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>收敛</li><li>当 <span class="math inline">\(l&gt;1\)</span> 时，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>发散</li><li>当 <span class="math inline">\(l=1\)</span> 时，判别法失效</li></ul><blockquote><p>Stirling 公式： <span class="math inline">\(n! \sim\left(\frac{n}{e}\right)^n \sqrt{2n\pi} \quad (n\to\infty)\)</span></p></blockquote><blockquote><p>当 <span class="math inline">\(a_n\)</span> 是一些乘积构成或含 <spanclass="math inline">\(n!\)</span> 时，可以考虑比值法</p></blockquote><h5 id="根值判别法cauchy-判别法">根值判别法（Cauchy 判别法）</h5><p><strong>定理：</strong></p><p>若正项级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> 满足 <spanclass="math inline">\(\displaystyle \lim_{n\to\infty} \sqrt[n]{a_n} =l\)</span>，则</p><ol type="1"><li>当 <span class="math inline">\(0\leq l&lt;1\)</span> 时，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>收敛</li><li>当 <span class="math inline">\(1 &lt; l \leq +\infty\)</span>时，<span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 发散</li><li>当 <span class="math inline">\(l=1\)</span> 时，判别法失效</li></ol><blockquote><p>当 <span class="math inline">\(a_n\)</span> 中含有 <spanclass="math inline">\(n\)</span> 次方时，可以考虑使用根值法</p></blockquote><blockquote><p>比值法和根值法实际上可看作是在将级数与等比级数作比较，均智能判断收敛速度不满与等比级数的级数.当所求级数存在时，可称级数为<strong>拟等比级数</strong></p></blockquote><blockquote><p>根值法优于比值法</p><ul><li><spanclass="math inline">\(\displaystyle\lim_{n\to\infty}\frac{a_{n+1}}{a_n}=  l \Rightarrow \displaystyle \sqrt[n]{a_n} = l\)</span></li><li><span class="math inline">\(\displaystyle \sqrt[n]{a_n} =l\nRightarrow \displaystyle\lim_{n\to\infty}\frac{a_{n+1}}{a_n}=  l\)</span></li></ul></blockquote><h5 id="积分判别法">积分判别法</h5><p><strong>定理：</strong></p><p>设 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 为<strong>正项级数</strong>，若非负函数 <spanclass="math inline">\(f(X)\)</span> 在 <spanclass="math inline">\([1,+\infty)\)</span>上<strong>单调递减</strong>，且 <span class="math inline">\(a_n =f(n)\quad \left(\forall n \in \mathbb{N}^+\right)\)</span>，则级数 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>与反常积分 <span class="math inline">\(\displaystyle \int_1^{+\infty}f(x)\,\mathrm{d}x\)</span> 有相同的敛散性</p><ul><li>条件 <span class="math inline">\(\left[1,+\infty\right)\)</span>可改为 <spanclass="math inline">\(\left[a,+\infty\right)，(a&gt;1)\)</span></li></ul><h3 id="任意项级数的敛散性">任意项级数的敛散性</h3><p><strong>任意项级数</strong></p><p>正负项分布是任意的级数</p><h4 id="交错级数敛散性的判别法">交错级数敛散性的判别法</h4><h5 id="交错级数">交错级数</h5><p><strong>定义：</strong></p><p>各项正负相间的级数称为<strong>交错级数</strong>，其形式为</p><p><span class="math display">\[\pm\sum_{n=1}^\infty {-1}^{n-1}a_n \quad \left(\text{其中}a_n &gt;0\right)\]</span></p><h5 id="leibniz-判别法">Leibniz 判别法</h5><p><strong>定理：</strong></p><p>若交错级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty (-1)^{n-1}a_n \,\left(a_n&gt;0\right)\)</span>满足:</p><ol type="1"><li><span class="math inline">\(a_{n+1} \leq a_n \quad \left(n = 1 ,2,\ldots\right)\)</span></li><li><span class="math inline">\(\displaystyle\lim_{n\to\infty}a_n=0\)</span></li></ol><p>则级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty(-1)^{n-1}a_n\)</span> 收敛，且其余项级数满足</p><p><span class="math display">\[\left\vert \sum_{k=n+1}^\infty a_k \right\vert \leq a_{n+1}\]</span></p><blockquote><p>我们称满足定理条件的级数为 <strong>leibniz 型级数</strong></p></blockquote><h4 id="abel-判别法和-dirichlet-判别法">Abel 判别法和 Dirichlet判别法</h4><p><strong>定理：（Abel 判别法）</strong></p><p>若 <span class="math inline">\(\{a_n\}\)</span> 单调且有界，<spanclass="math inline">\(\displaystyle\sum_{n=1}^\infty b_n\)</span>收敛，则 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_nb_n\)</span> 收敛</p><p><strong>定理：（Dirichlet 判别法）</strong></p><p>若 <span class="math inline">\(\{a_n\}\)</span> 单调趋于 <spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span>的部分和数列有界，则 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_nb_n\)</span> 收敛</p><h4 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 为任意项级数</p><ol type="1"><li>若级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty\vert a_n \vert\)</span> 收敛，则称级数 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>为<strong>绝对收敛</strong></li><li>若 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty \verta_n \vert\)</span> 发散，而 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> 收敛，但 ，则称 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span><strong>条件收敛</strong></li></ol><p><strong>定理：</strong></p><p>若 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_n\)</span> 绝对收敛，则 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> 收敛</p><blockquote><p><strong>常用结论：</strong></p><p><span class="math display">\[\displaystyle \sum_{n=1}^\infty\frac{(-1)^{n}}{n^p}\begin{cases}\text{绝对收敛} &amp; ,p&gt;1\\\text{条件收敛} &amp; , 0 &lt; p\leq 1 \end{cases}\]</span></p></blockquote><p><strong>定理：（绝对收敛与条件收敛的本质）</strong></p><ol type="1"><li>绝对收敛的级数，可以改变任意项的顺序，其收敛性与和均不变（即满足加法交换律）</li><li>条件收敛的级数，总可以适当改变项的顺序，使其按照任意预定的方式收敛或者发散</li></ol><h3 id="函数项级数">函数项级数</h3><p><strong>定义：</strong></p><p>设函数列 <span class="math inline">\(\{u_n{x}\}(n=1,2,\ldots)\)</span> 在数集 <span class="math inline">\(X\)</span>上有定义，则称形式和</p><p><span class="math display">\[\sum_{n=1}^\infty u_n(x)= u_1(x) + u_2(x) + \cdots + u_n(x) + \cdots\]</span></p><p>为<strong>函数项级数</strong>，其中 <spanclass="math inline">\(u_n(x)\)</span> 称为<strong>通项</strong></p><p><strong>定义：</strong></p><p>若数项级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty u_n(x_0)\)</span> 收敛，则 <spanclass="math inline">\(x_0\)</span> 为函数项级数 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span>的一个<strong>收敛点</strong>，否则称为<strong>发散点</strong>，全体收敛点所组成的集合<span class="math inline">\(I\)</span> 称为<strong>收敛域</strong></p><p><strong>定义</strong></p><p>记 <span class="math inline">\(\displaystyle S_n(x)=\sum_{k=1}^\infty u_k(x)\)</span>,为 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span>的前 <span class="math inline">\(n\)</span>项<strong>部分和(函数)</strong>，记 <spanclass="math inline">\(\displaystyle r_n(x) = \sum_{k=n+1}^\inftyu_k(x)\)</span> 为<strong>余和</strong></p><p><strong>定义：</strong></p><p>对于收敛域 <span class="math inline">\(I\)</span> 中的任意一点 <spanclass="math inline">\(x\)</span>，记 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span>的和为 <span class="math inline">\(S(x)\)</span>，称此函数 <spanclass="math inline">\(S(x)\)</span> 为 <spanclass="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span>的<strong>和函数</strong></p><p>显然，<span class="math inline">\(\forall x\in I\)</span>，<spanclass="math inline">\(\displaystyle \lim_{n\to +\infty}S_n(x)=S(x)\)</span>，<span class="math inline">\(\displaystyle \lim_{n\to+\infty}r_n(x)=0\)</span></p><h3 id="幂级数">幂级数</h3><h4 id="幂级数及其收敛半径">幂级数及其收敛半径</h4><p>在函数项级数中，最简单及最重要的级数形如</p><p><span class="math display">\[\sum_{n=0}^\infty a_n(x-x_0)^n = a_0 +a_1x + a_2(x-x_0)^2 + \ldots +a_n(x-x_0)^n + \ldots\]</span></p><p>称为<strong>幂级数</strong>，其中常数项 <spanclass="math inline">\(a_0,a_1,\ldots,a_n,\ldots\)</span>称为幂级数的<strong>系数</strong></p><p>幂级数更加一半的形式为 <span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_n(x-x_0)^n\)</span></p><h5 id="abel-定理"><strong>Abel 定理</strong></h5><ol type="1"><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_n(x-x_0)^n\)</span> 在 <span class="math inline">\(x=x_0(x\neq0)\)</span> 收敛，则当 <span class="math inline">\(\vert x \vert&lt;\vert x_0\vert\)</span>，时，幂级数 <spanclass="math inline">\(\displaystyle \sum_{n=0}^\inftya_n(x-x_0)^n\)</span> 绝对收敛</li><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 在 <span class="math inline">\(x=x_1\)</span> 发散，则当<span class="math inline">\(\vert x \vert &gt;\vert x_1\vert\)</span>时，幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 发散</li></ol><h6 id="推论幂级数收敛域的情况">推论（幂级数收敛域的情况）</h6><p>幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_n(x-x_0)^n\)</span> 的收敛域 <span class="math inline">\(I\)</span>仅有以下几种情况：</p><ol type="1"><li>仅在 <span class="math inline">\(x=0\)</span> 的情况收敛（<spanclass="math inline">\(R=0\)</span>）</li><li>在区间 <span class="math inline">\((-R,R)(R&gt;0)\)</span>内绝对收敛，在 <span class="math inline">\((-\infty,-R)\bigcup(R,+\infty)\)</span> 发散</li><li>在区间 <span class="math inline">\((-R,R)\)</span> 内绝对收敛（<spanclass="math inline">\(R=+\infty\)</span>）</li></ol><h3 id="幂级数收敛半径的求法">幂级数收敛半径的求法</h3><h4 id="系数模比值法">系数模比值法</h4><p><strong>定理：</strong></p><p>对幂级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_nx^n\)</span>，若 <span class="math inline">\(\displaystyle\lim_{n\to+\infty}\left\vert\frac{a_{n+1}}{a_n}\right\vert =\rho\)</span>，则收敛半径 <span class="math inline">\(\displaystyleR=\begin{cases}&amp;0,&amp;&amp;\rho=+\infty\newline &amp;\frac{1}{\rho},&amp;&amp; 0&lt;\rho&lt;+\infty\newline &amp;+\infty,&amp;&amp;\rho=0\end{cases}\)</span></p><h4 id="系数模根值法">系数模根值法</h4><p><strong>定理：</strong></p><p>对幂级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\inftya_nx^n\)</span>，若 <span class="math inline">\(\displaystyle\lim_{n\to+\infty}\sqrt[n]{\left\vert a_n\right\vert} =\rho\)</span>，则收敛半径 <span class="math inline">\(\displaystyleR=\begin{cases}&amp;0,&amp;&amp;\rho=+\infty\newline &amp;\frac{1}{\rho},&amp;&amp; 0&lt;\rho&lt;+\infty\newline &amp;+\infty,&amp;&amp;\rho=0\end{cases}\)</span></p><h3 id="幂级数的性质">幂级数的性质</h3><ol type="1"><li>设幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 和 <span class="math inline">\(\displaystyle\sum_{n=0}^\infty b_nx^n\)</span> 的收敛半径分别为 <spanclass="math inline">\(R_1\)</span> 和 <spanclass="math inline">\(R_2\)</span>，则 <spanclass="math inline">\(\displaystyle \sum_{n=0}^\infty(a_n+b_n)x^n\)</span> 的收敛半径为 <spanclass="math inline">\(R=\min\{R_1,R_2\}\)</span></li><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 的收敛半径 <spanclass="math inline">\(R&gt;0\)</span>，在收敛区间 <spanclass="math inline">\((-R,R)\)</span> 内的和函数为 <spanclass="math inline">\(S(n)\)</span>，则 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\((-R,R)\)</span> 上连续；若 <spanclass="math inline">\(\displaystyle\sum_{n=0}^\infty a_nx^n\)</span> 在<span class="math inline">\(x=R\)</span> 或 <spanclass="math inline">\(x=-R\)</span> 收敛，则和函数 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\(x=R\)</span> 左连续或 <spanclass="math inline">\(x=-R\)</span> 处右连续，即 <spanclass="math inline">\(\displaystyle \lim_{x\toR^-}S(x)=S(R)=\sum_{n=0}^\infty a_nR^n\)</span></li><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 的收敛半径 <spanclass="math inline">\(R&gt;0\)</span>，在收敛区间 <spanclass="math inline">\((-R,R)\)</span> 内的和函数为 <spanclass="math inline">\(S(n)\)</span>，则 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\((-R,R)\)</span>上可导，且有<strong>逐项求导公式</strong></li></ol><p><span class="math display">\[  \begin{aligned}  S&#39;(x) = &amp;\left(\sum_{n=0}^\infty a_nx^n\right)&#39;\\    = &amp;\sum_{n=0}^\infty \left(a_nx^n\right)&#39;\\    = &amp;\sum_{n=0}^\infty na_nx^{n-1}\\  \end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftyna_nx^{n-1}\)</span> 的收敛半径仍为 <spanclass="math inline">\(R\)</span></p><ol start="4" type="1"><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 的收敛半径 <spanclass="math inline">\(R&gt;0\)</span>，在收敛区间 <spanclass="math inline">\((-R,R)\)</span> 内的和函数为 <spanclass="math inline">\(S(n)\)</span>，则 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\((-R,R)\)</span>上可导，且有<strong>逐项求积公式</strong></li></ol><p><span class="math display">\[  \begin{aligned}  \int_0^xS(t)\,\mathrm{d}t = &amp;\int_0^x\left(\sum_{n=0}^\inftya_nt^n\right)\,\mathrm{d}t\\    = &amp;\sum_{n=0}^\infty \int_0^x a_nt^n\,\mathrm{d}t\\    = &amp;\sum_{n=0}^\infty \frac{a_n}{n+1}x^{n+1}\\  \end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nt^n\)</span> 的收敛半径仍为 <spanclass="math inline">\(R\)</span></p><h4 id="幂级数的分析性质">幂级数的分析性质</h4><p><strong>性质：</strong></p><p>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 的收敛半径为 <spanclass="math inline">\(R&gt;0\)</span>，在收敛区间 <spanclass="math inline">\((-R,R)\)</span> 上连续；若 <spanclass="math inline">\(\displaystyle\sum_{n=0}^\infty a_nx^n\)</span> 在<span class="math inline">\(x=R\)</span> 或 <spanclass="math inline">\(x=-R\)</span> 收敛，则和函数 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\(x=R\)</span> 左连续或 <spanclass="math inline">\(x=-R\)</span> 处右连续，即</p><p><span class="math display">\[\displaystyle \lim_{x\to R^-}S(x)=S(R)=\sum_{n=0}^\infty a_nR^n\]</span></p><p><strong>性质：</strong></p><p>若幂函数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 的收敛半径为 <spanclass="math inline">\(R&gt;0\)</span>，在收敛区间 <spanclass="math inline">\((-R,R)\)</span> 上的和函数为 <spanclass="math inline">\(S(n)\)</span>，则 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\((-R,R)\)</span>上可导，且有<strong>逐项求导公式</strong></p><p><span class="math display">\[\begin{aligned}S&#39;(x) = &amp;\left(\sum_{n=0}^\infty a_nx^n\right)&#39;\\  = &amp;\sum_{n=0}^\infty \left(a_nx^n\right)&#39;\\  = &amp;\sum_{n=0}^\infty na_nx^{n-1}\\\end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftyna_nx^{n-1}\)</span> 的收敛半径仍为 <spanclass="math inline">\(R\)</span></p><p><strong>性质：</strong></p><p>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nx^n\)</span> 的收敛半径为 <spanclass="math inline">\(R&gt;0\)</span>，在收敛区间 <spanclass="math inline">\((-R,R)\)</span> 上的和函数为 <spanclass="math inline">\(S(n)\)</span>，则 <spanclass="math inline">\(S(n)\)</span> 在 <spanclass="math inline">\((-R,R)\)</span>上可导，且有<strong>逐项求积公式</strong></p><p><span class="math display">\[\begin{aligned}\int_0^xS(t)\,\mathrm{d}t = &amp;\int_0^x\left(\sum_{n=0}^\inftya_nt^n\right)\,\mathrm{d}t\\  = &amp;\sum_{n=0}^\infty \int_0^x a_nt^n\,\mathrm{d}t\\  = &amp;\sum_{n=0}^\infty \frac{a_n}{n+1}x^{n+1}\\\end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\inftya_nt^n\)</span> 的收敛半径仍为 <spanclass="math inline">\(R\)</span></p><blockquote><ol type="1"><li>幂函数逐项求导，逐项积分后，收敛半径不变，但是收敛域可能改变</li><li>幂函数在收敛区间内具有任意阶导数</li></ol></blockquote><h4 id="taylor-级数">Taylor 级数</h4><p><strong>定义：</strong></p><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x_0\)</span> 的某领域内有任意阶导数，称幂级数</p><p><span class="math display">\[\sum_{n=0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</span></p><p>为 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x_0\)</span> 处的 <strong>Taylor</strong>级数，记为</p><p><span class="math display">\[f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</span></p><p><span class="math inline">\(x_0=0\)</span> 是，称为 <strong>Maclaurin级数</strong></p><p><strong>定理（唯一性）</strong></p><p>若 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x_0\)</span> 可展开为幂级数，则展开式唯一，且恰为Taylor 级数</p><p><strong>定理</strong></p><p>设 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\(x_0\)</span> 的某领域 <spanclass="math inline">\(I\)</span> 内任意阶可导，则在 <spanclass="math inline">\(I\)</span> 内</p><p><span class="math display">\[f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\Leftrightarrow \lim_{n\to\infty}R_n(x) =0\]</span></p><h4 id="常用的初等函数的幂级数展开式">常用的初等函数的幂级数展开式</h4><ol type="1"><li><span class="math inline">\(\displaystyle e^x = \sum_{n=0}^\infty\frac{x^n}{n!} \quad (x\in\mathbb{R})\)</span></li><li><span class="math inline">\(\displaystyle \sin x = \sum_{n=0}^\infty\frac{(-1)^nx^{2n+1}}{(2n+1)!} \quad (x\in\mathbb{R})\)</span></li><li><span class="math inline">\(\displaystyle \cos x = \sum_{n=0}^\infty\frac{(-1)^nx^{2n}}{(2n)!} \quad (x\in\mathbb{R})\)</span></li><li><span class="math inline">\(\displaystyle \ln(1+x) =\sum_{n=1}^\infty \frac{(-1)^{n-1}x^n}{n} \quad (\left\vert x\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle (1+x)^\alpha =\sum_{n=0}^\infty \frac{\alpha(\alpha-1)\cdots(\alpha-n+1)}{n!}x^n \quad(\left\vert x\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle \frac{1}{1-x} =\sum_{n=0}^\infty x^n \quad (\left\vert x\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle \frac{1}{1+x} =\sum_{n=0}^\infty (-1)^nx^n \quad (\left\vertx\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle \arctan{x} =\sum_{n=0}^\infty \frac{(-1)^n x^{2n+1}}{2n+1} \quad (\left\vertx\right\vert\leq 1)\)</span></li></ol><h4 id="正弦级数和余弦级数">正弦级数和余弦级数</h4><p>若周期为 <span class="math inline">\(2\pi\)</span> 的函数 <spanclass="math inline">\(f(x)\)</span> 是奇函数时，其 Fourier 系数 <spanclass="math inline">\(a_n=0\)</span>，从而</p><p><span class="math display">\[f(x) \sim \sum_{n=1}^{+\infty}b_n\sin(nx)\quad\text{正弦级数}\]</span></p><p>其中 <span class="math inline">\(\displaystyle b_n=\frac{2}{\pi}\int_0^\pi f(x)\sin(nx) \,\mathrm{d}x\)</span></p><p>若周期为 <span class="math inline">\(2\pi\)</span> 的函数 <spanclass="math inline">\(f(x)\)</span> 是偶函数，其 Fourier 系数 <spanclass="math inline">\(b_n=0\)</span>，从而</p><p><span class="math display">\[f(x) \sim\frac{a_0}{2}+\sum_{n=0}^{+\infty}a_n\cos(nx)\quad\text{余弦级数}\]</span></p><p>其中 <span class="math inline">\(\displaystyle a_n=\frac{1}{\pi}\int_0^\pi f(x)\cos(nx) \,\mathrm{d}x\)</span></p><p>若函数 <span class="math inline">\(f(x)\)</span> 定义在 <spanclass="math inline">\([0,\pi]\)</span> 上，可作奇延拓</p><p><span class="math display">\[F(x)=\begin{cases}  f(x), &amp; 0&lt; x&lt; \pi\\  -f(-x), &amp; -\pi &lt; x &lt; 0\\  0, &amp; x=0,\pm\pi\\\end{cases}\]</span></p><p>使得 <span class="math inline">\(F(x)\)</span> 为 <spanclass="math inline">\([-\pi,\pi]\)</span> 上的奇函数</p><p>也可作偶延拓</p><p><span class="math display">\[G(x)=\begin{cases}  f(x), &amp; 0&lt; x&lt; \pi\\  f(-x), &amp; -\pi &lt; x &lt; 0\\  0, &amp; x=0,\pm\pi\\\end{cases}\]</span></p><p>使得函数 <span class="math inline">\(G(x)\)</span> 为 <spanclass="math inline">\([-\pi,\pi]\)</span> 上的偶函数</p><p>对于一定义在 <span class="math inline">\([0,\pi]\)</span> 上的函数<spanclass="math inline">\(f(x)\)</span>，可以对其先做奇延拓或者偶延拓，再将其展开为正弦级数或者余弦级数</p><h4 id="周期为-2l-的-fourier-级数">周期为 <spanclass="math inline">\(2l\)</span> 的 Fourier 级数</h4><p>设函数 <span class="math inline">\(f(x)\)</span> 在区间 <spanclass="math inline">\([-l,l]\)</span> 上可积，作代换 <spanclass="math inline">\(x =\frac{l}{\pi}t\)</span>，使得 <spanclass="math inline">\(F(t) = f\left(\frac{l}{\pi}t\right)\)</span> 为<span class="math inline">\([-\pi,\pi]\)</span> 上的可积函数，从而</p><p><span class="math display">\[F(t) \sim\frac{a_0}{2}+\sum_{n=1}^{+\infty}a_n\cos(nt)+\sum_{n=1}^{+\infty}b_n\sin(nt)\]</span></p><p>其中</p><p><span class="math display">\[\begin{aligned}a_n &amp;= \frac{1}{\pi}\int_{-\pi}^{\pi}F(t)\cos(nt)\,\mathrm{d}t =\frac{1}{l}\int_{-l}^{l}f(x)\cos\left(\frac{\pin}{l}x\right)\,\mathrm{d}x\\b_n &amp;= \frac{1}{\pi}\int_{-\pi}^{\pi}F(t)\sin(nt)\,\mathrm{d}t =\frac{1}{l}\int_{-l}^{l}f(x)\sin\left(\frac{\pin}{l}x\right)\,\mathrm{d}x\end{aligned}\]</span></p><p>故</p><p><span class="math display">\[f(x) \sim \frac{a_0}{2}+\sum_{n=1}^{+\infty}\left(a_n\cos\left(\frac{\pin}{l}x\right)+b_n\sin\left(\frac{\pi n}{l}x\right)\right)\]</span></p><p>其中</p><p><span class="math display">\[\begin{aligned}a_n &amp;= \frac{1}{l}\int_{-l}^{l}f(x)\cos\left(\frac{\pin}{l}x\right)\,\mathrm{d}x\\b_n &amp;= \frac{1}{l}\int_{-l}^{l}f(x)\sin\left(\frac{\pin}{l}x\right)\,\mathrm{d}x\end{aligned}\]</span></p><p><strong>定理：</strong></p><p>若 <span class="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\([-l,l]\)</span> 上满足 Dirichlet 条件，则 Fourier级数</p><p><span class="math display">\[\frac{a_0}{2}+\sum_{n=1}^{+\infty}\left(a_n\cos\left(\frac{\pin}{l}x\right)+b_n\sin\left(\frac{\pi n}{l}x\right)\right)\]</span></p><p>收敛到</p><p><span class="math display">\[S(n) =\begin{cases}  f(x), &amp; x \text{为} f(x) \text{的连续点}\\  \frac{f(x^+)+f(x^-)}{2}, &amp; x \text{为} f(x) \text{的间断点}\\  \frac{f(l^-)+f(-l^+)}{2} ,&amp; x=\pm l\end{cases}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理方法笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E6%95%B0%E7%90%86%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E6%95%B0%E7%90%86%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数理方法笔记">数理方法笔记</h1><h2id="几类偏微分方程的导出和定解问题">几类偏微分方程的导出和定解问题</h2><h3 id="偏微分方程的基本概念">偏微分方程的基本概念</h3><h4 id="什么是微分方程">什么是微分方程</h4><p>函数 <span class="math inline">\(u\)</span> 关于 <spanclass="math inline">\(t\)</span> 及 <spanclass="math inline">\((x,y,z)\)</span> 的各阶偏导数满足的关系式</p><p>一般形式：</p><p><span class="math display">\[F(x_1,x_2,\ldots,x_n,u,\mathrm{D}u,\mathrm{D}^2u,\ldots,\mathrm{D}^Nu)=0\]</span></p><p>其中</p><ul><li><spanclass="math inline">\(\displaystyle(x_1,x_2,\ldots,x_n)\)</span>为自变量</li><li><span class="math inline">\(\displaystyleu=u(x_1,x_2,\ldots,x_n)\)</span> 为未知函数</li><li><span class="math inline">\(\displaystyle\mathrm{D}u=\left(\frac{\partial u}{\partial x_1},\frac{\partialu}{\partial x_2},\ldots,\frac{\partial u}{\partialx_n}\right)\)</span></li><li><spanclass="math inline">\(\displaystyle\mathrm{D}^ku=\left(\frac{\partial^ku}{\partialx_1^{k_1}\partial x_2^{k_2}\ldots\partialx_n^{k_n}},k_1+k_2+\ldots+k_n=k\right)\)</span>，其中 <spanclass="math inline">\(k=1,2,\ldots,N\)</span></li></ul><h4 id="相关基本概念">相关基本概念</h4><ul><li>阶：未知函数偏导数的最高阶数</li><li>维数：空间变量的个数</li><li>发展型方程：包含时间变量 <span class="math inline">\(t\)</span>的偏微分方程的统称</li><li>对于非发展型方程，维数等于自变量个数</li><li>解： 在求解区域 <spanclass="math inline">\((x_1,x_2,\ldots,x_n)\in\Omega\)</span> 中，称<span class="math inline">\(u=\varphi(x_1,x_2,\ldots,x_n)\)</span>是方程的经典解 在 <span class="math inline">\(\Omega\)</span>内，方程出现的个街道数都存在且连续，并且能满足方程<ul><li>间断解：本身或者导数有跳跃</li></ul></li><li>自由项：方程中不含未知函数及其导数的项</li><li>齐次方程：自由项为 <span class="math inline">\(0\)</span>的方程</li><li>非齐次方程：自由项不为 <span class="math inline">\(0\)</span>的方程</li></ul><h5 id="按照是否线性对方程进行分类">按照是否线性对方程进行分类</h5><h6 id="线性方程">线性方程</h6><p>方程中未知函数及其各阶导数均以一次幂出现，且各项系数仅为自变量的函数</p><p><span class="math display">\[\hat{G}u=g(x_1,x_2,\ldots,x_n)\Rightarrow\hat{G}(au+bv)=a\hat{G}u+b\hat{G}v\]</span></p><p>其基本形式为</p><p><span class="math display">\[\sum_{\sum a_i\leq N}A_{a_i}(x)D^a u = g(x)\]</span></p><h6 id="非线形方程">非线形方程</h6><p><strong>半线性</strong></p><p>含有最高阶导数的部分线性</p><p><span class="math display">\[\sum_{\sum a_i= N}A_{a_i}(x)D^a u +A_0(x,u,\mathrm{D}u,\ldots,\mathrm{D}^{N-1}u)=g(x)\]</span></p><p><strong>拟线性</strong></p><p>最高阶导数本身是线性的，也就是说最高阶导数的系数可以含有未知函数及其低阶导数</p><p><span class="math display">\[\sum_{\sum a_i= N}A_{a_i}(x,u,Du,\ldots,D^{N-1}u)D^a u+A_0(x,u,\mathrm{D}u,\ldots,\mathrm{D}^{N-1}u) = g(x)\]</span></p><p><strong>完全非线性</strong></p><p>最高阶导数部分也是非线性的</p><h3id="三类偏微分方程的导出和定解问题">三类偏微分方程的导出和定解问题</h3><h4id="弦振动热传导调和方程的导出定解问题">弦振动、热传导、调和方程的导出，定解问题</h4><h5 id="弦振动方程">弦振动方程</h5><p>一条弦固定在区间 <span class="math inline">\([0,l]\)</span>上，密度为 <spanclass="math inline">\(\rho\)</span>，在平衡处附近做微小的振动，记 <spanclass="math inline">\(u(t,x)\)</span> 为弦在时刻 <spanclass="math inline">\(t\)</span> 处于位置 <spanclass="math inline">\(x\)</span> 的位移，满足以下的微分方程</p><p><span class="math display">\[\begin{equation}u_{tt} -a^2u_{xx}=F(t,x), \quad 0 &lt; x &lt; l, \quad t &gt; 0\end{equation}\]</span></p><p>其中 <span class="math inline">\(a\)</span> 为待定的弦的波速</p><p>在弦振动方程中，若 <span class="math inline">\(F\equiv0\)</span>，则称为其次方程，否则为非齐次方程</p><h6 id="弦振动方程的证明">弦振动方程的证明</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509190831381.png"alt="微小的弦" /><figcaption aria-hidden="true">微小的弦</figcaption></figure><p>任取一段弦 <span class="math inline">\([x,x+\Deltax]\)</span>，这段弦的长度为</p><p><span class="math display">\[\Delta s = \int_x^{x+\Delta x}\sqrt{1+\left(\frac{\partial u}{\partialx}\right)^2}\,\mathrm{d}x.\]</span></p><p>其中 <span class="math inline">\(\left\vert\frac{\partial u}{\partialx}\right\vert\ll 1\)</span>，则 <span class="math inline">\(\Delta s\approx \Delta x\)</span>，则其弹力与时间无关，设为 <spanclass="math inline">\(T(x)\)</span></p><p>我们分别在水平方向和竖直方向上对这段弦进行受力分析</p><ol type="1"><li><p>水平方向上速度为 <spanclass="math inline">\(0\)</span>，则其受力平衡</p><p><span class="math display">\[T(x+\Delta x)\cos\beta - T(x)\cos\alpha = 0\]</span></p><p>其中 <span class="math inline">\(\alpha\)</span> 和 <spanclass="math inline">\(\beta\)</span> 分别为 <spanclass="math inline">\(x\)</span> 和 <span class="math inline">\(x+\Deltax\)</span>处的切线与水平线的夹角，由于假设弦在平衡位置附近做微小振动，则 <spanclass="math inline">\(\cos\alpha \approx 1\)</span>， <spanclass="math inline">\(\cos\beta \approx1\)</span>，则可以得到弹力为恒定的，计为 <spanclass="math inline">\(T\)</span></p></li><li><p>在竖直方向( <span class="math inline">\(u^+\)</span>)上进行受力分析，受到的力有</p><ul><li>重力 <span class="math inline">\(\rho\Delta sg\)</span>，方向向下</li><li>弹力 <spanclass="math inline">\(T(x)\sin\theta\)</span>，默认方向向上</li><li>外力 <span class="math inline">\(F(t,x)\Delta s\)</span></li></ul><p><span class="math display">\[\rho\Delta s \frac{\partial^2u}{\partial x^2}=T(\sin\beta - \sin\alpha)+ F(t,x)\Delta s - \rho\Delta s g\]</span></p><p>其中 <span class="math inline">\(\displaystyle\lim_{\theta\to0}\sin\theta = \lim_{\theta\to 0}\tan\theta\)</span>，再将 <spanclass="math inline">\(\Delta s = \Delta x\)</span> 代入上式，得到</p><p><span class="math display">\[\rho\Delta x \frac{\partial^2u}{\partial t^2}=T(\frac{\partialu}{\partial x}(x+\Delta x) - \frac{\partial u}{\partial x}(x)) +F(t,x)\Delta x - \rho\Delta x g\]</span></p><p>再令 <span class="math inline">\(\Delta x \to 0\)</span>，得到</p><p><span class="math display">\[\rho \frac{\partial^2u}{\partial t^2} = T\frac{\partial^2u}{\partialx^2} + F(t,x)-\rho g\]</span></p><p>我们令 <span class="math inline">\(a^2 =\frac{T}{\rho},F(t,x)=\frac{f(t,x)}{\rho}\)</span>，并且忽略 <spanclass="math inline">\(g\)</span> 则得到 <spanclass="math inline">\(\boxed{弦振动方程}\)</span></p><p><span class="math display">\[u_{tt} -a^2u_{xx}=F(t,x), \quad 0 &lt; x &lt; l, \quad t &gt; 0\]</span></p></li></ol><h6 id="弦振动方程的定解问题">弦振动方程的定解问题</h6><p><strong>初值条件</strong></p><p>当一条弦足够长并且需要研究远离两端的点的振动情况时，可以假设弦无限长</p><p><span class="math display">\[\left\{    \begin{aligned}        &amp;u_{tt}-a^2u_{xx}=F(t,x),\\        &amp;u(0,x)=\varphi(x),\\        &amp;u_t(0,x)=\psi(x).    \end{aligned}\right.\]</span></p><p>这三个条件分别表示了方程本身、初始位移和初始速度</p><p>这个问题被称为弦振动方程的 <strong>初值问题</strong>或者<strong>Cauchy 问题</strong></p><p><strong>边界条件</strong></p><p>当我们要考虑的弦在一个有限的区间 <spanclass="math inline">\(I=[0,l]\)</span>上的振动情况时，需要给出边界条件，即弦在端点处的条件</p><p>我们以一个端点 <span class="math inline">\(x=a\)</span>为例，常见的边界条件有以下三种</p><ol type="1"><li><p>Dirichlet 边界条件：</p><p><span class="math display">\[u(t,a)=\varphi(t),\forall t&gt; 0\]</span></p></li><li><p>Neumann 边界条件：</p><p><span class="math display">\[u_x(t,a)=\mu(t),\forall t&gt; 0\]</span></p><p>这表示了端点处的力。特别的，当 <span class="math inline">\(\mu(t)=0\)</span> 时，表示端点处没有力的作用，称为自由条件</p></li><li><p>Robin 边界条件：</p><p><span class="math display">\[\begin{aligned}&amp;T\frac{\partial u}{\partial x}(t,a)-ku(t,a)=0\\\Rightarrow &amp;\left(\frac{\partial u}{\partial x}-\sigmau\right)|_{x=a}=h(t)\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\sigma = \frac{k}{T}\)</span>表示弦的一端与一线性弹簧连接自由振动</p><p>若弹簧为非线性的，则有</p><p><span class="math display">\[\left(\frac{\partial u}{\partial x}-\sigma (u)\right)|_{x=a}=0\]</span></p><p>若 <span class="math inline">\(h(t)\neq0\)</span>，则表示弹簧有外力作用</p><p>并且当 <span class="math inline">\(\sigma\to 0\)</span> 时，Robin边界条件退化为 Neumann 边界条件</p><p>当 <span class="math inline">\(\sigma\to \infty\)</span> 时，Robin边界条件退化为 Dirichlet 边界条件</p></li></ol><h5 id="热传导方程">热传导方程</h5><p>温度分布与时间的关系为热传导方程，同样的物质的浓度分布与时间的关系也满足热传导方程。</p><p>物体的温度为 <spanclass="math inline">\(u(t,x)\)</span>，则热传导方程为：</p><p><span class="math display">\[u_t-a^2\Delta u=\tilde{f}\]</span></p><p>其中 <spanclass="math inline">\(\displaystyle\Delta=\nabla^2=\sum\frac{\partial^2}{\partial{x_i}^2}\)</span> 为 Laplace 算子</p><h6 id="热传导方程的证明">热传导方程的证明</h6><p>三维空间 <span class="math inline">\(\mathbb{R}^3\)</span> 中的物体<span class="math inline">\(\Omega\)</span>，设其温度分布函数为 <spanclass="math inline">\(u(t,x_1,x_2,x_3)\)</span>，比热容均匀为 <spanclass="math inline">\(c\)</span></p><p>我们取 <span class="math inline">\(\Omega\)</span> 上的一个子区域<span class="math inline">\(D\)</span>，分析其在时间 <spanclass="math inline">\(t_1\)</span> 到 <spanclass="math inline">\(t_2\)</span> 之间的热量变化</p><p><span class="math inline">\(D\)</span> 上温度变化需要的热量为</p><p><span class="math display">\[Q=\int_D c\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\,\mathrm{d}V\]</span></p><p><span class="math inline">\(Q\)</span> 的来源有两个</p><ol type="1"><li><span class="math inline">\(D\)</span> 的边界 <spanclass="math inline">\(\partial D\)</span> 处流入的热量 <spanclass="math inline">\(Q_1\)</span></li><li><span class="math inline">\(D\)</span> 内部的热源提供的热量 <spanclass="math inline">\(Q_2\)</span></li></ol><p>热量的传导满足 Fourier 实验定律：对给定 <spanclass="math inline">\(\Omega\)</span>内的任意一个界面，从界面的一侧传导到另一侧的热量与温度沿该界面的法向的导数大小、界面的面积、传导的时间段成正比</p><p><span class="math display">\[\mathrm{d}Q=-k\frac{\partial u}{\partial \vec{n}}\mathrm{d}s\mathrm{d}t.\]</span></p><p>则 <span class="math inline">\(D\)</span> 的边界 <spanclass="math inline">\(\partial D\)</span> 处流入的热量 <spanclass="math inline">\(Q_1\)</span> 为</p><p><span class="math display">\[Q_1=\int_{t_1}^{t_2}\int_{\partial D}k\frac{\partial u}{\partial\vec{n}}\,\mathrm{d}S\mathrm{d}t\]</span></p><p>物体内部热源产热量 <span class="math inline">\(Q_2\)</span> 为</p><p><span class="math display">\[Q_2=\int_{t_1}^{t_2}\int_D f(t,x_1,x_2,x_3)\,\mathrm{d}V\mathrm{d}ts\]</span></p><p>其中 <span class="math inline">\(f(t,x_1,x_2,x_3)\)</span>为单位体积在单位时间内产生的热量</p><p>在 <span class="math inline">\(t_1\)</span> 到 <spanclass="math inline">\(t_2\)</span> 之间，热量守恒定律告诉我们</p><p><span class="math display">\[Q=Q_1+Q_2\]</span></p><p>即</p><p><span class="math display">\[\int_Dc\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\,\mathrm{d}V=\int_{t_1}^{t_2}\int_{\partialD}k\frac{\partial u}{\partial\vec{n}}\,\mathrm{d}S\mathrm{d}t+\int_{t_1}^{t_2}\int_Df(t,x_1,x_2,x_3)\,\mathrm{d}V\mathrm{d}t\]</span></p><p>变换得到</p><p><span class="math display">\[\int_{t_1}^{t_2}\int_D c\rho\frac{\partial u}{\partialt}\,\mathrm{d}V\mathrm{d}t=\int_{t_1}^{t_2}\int_{D}\operatorname{div}(k\cdot\nablau)\,\mathrm{d}V\mathrm{d}t+\int_{t_1}^{t_2}\int_Df(t,x_1,x_2,x_3)\,\mathrm{d}V\mathrm{d}t\]</span></p><p>即</p><p><span class="math display">\[c\rho\frac{\partial u}{\partial t}=k\nabla^2 u+f(t,x_1,x_2,x_3)\]</span></p><p>令 <spanclass="math inline">\(a^2=\frac{k}{c\rho},\tilde{f}=\frac{f}{c\rho}\)</span>，并用Laplace 算子代替 <span class="math inline">\(\nabla^2\)</span>则得到热传导方程</p><p><span class="math display">\[u_t-a^2\Delta u=\tilde{f}\]</span></p><h6 id="热传导方程的定解问题">热传导方程的定解问题</h6><p><strong>初值条件</strong></p><p>只需要给出初始的温度分布</p><p><span class="math display">\[u(0,x_1,x_2,x_3)=\varphi(x_1,x_2,x_3)\]</span></p><p><strong>边界条件</strong></p><p>为了由热传导方程及其初值条件得到温度分布函数，还需要给定在边界 <spanclass="math inline">\(\partial\Omega\)</span> 上的边界条件</p><ol type="1"><li><p>Dirichlet 边界条件：</p><p><span class="math display">\[u(t,x_1,x_2,x_3)|_{\partial\Omega}=\varphi(t,x_1,x_2,x_3),\forallt&gt;0,x\in\partial\Omega,\]</span></p><p>这表明了边界上的温度变化情况</p></li><li><p>Neumann 边界条件：</p><p><span class="math display">\[\frac{\partial u}{\partial\vec{n}}(t,x_1,x_2,x_3)|_{\partial\Omega}=\mu(t,x_1,x_2,x_3),\forallt&gt;0,x\in\partial\Omega,\]</span></p><p>这表明了边界上热量的传递情况</p><p>特别的，当 <span class="math inline">\(\mu(t,x_1,x_2,x_3)\equiv0\)</span> 时，表示边界上没有热量传递，称为绝热条件</p></li><li><p>Robin 边界条件：当物体处在一个温度为 <spanclass="math inline">\(u_0\)</span> 的介质中，物体与介质的热传导符合Newton 交换律，物体 <span class="math inline">\(\Omega\)</span>在边界与介质交换的热流量与物体表面的温度 <spanclass="math inline">\(u\)</span> 与介质在物面的温度 <spanclass="math inline">\(u_0\)</span>之差成正比，也与物面面积及交换的时间成正比，从物体表面流出的热量是</p><p><span class="math display">\[\mathrm{d}Q=-k_1(u-u_0)\mathrm{d}s\mathrm{d}t.\]</span></p><p>在边界上流入的热量必须等于流出的热量，则</p><p><span class="math display">\[-k\frac{\partial u}{\partial \vec{n}}=k_1(u-u_0)\]</span></p><p>整理得到</p><p><span class="math display">\[\left(\frac{\partial u}{\partial \vec{n}}+\sigma u\right)\vert_{\partial\Omega}=\varphi(t,x_1,x_2,x_3)\]</span></p></li></ol><h5 id="调和方程">调和方程</h5><p>调和方程常用于描述保守力场中的势函数</p><p><span class="math display">\[\Delta u = \phi\]</span></p><p>当 <span class="math inline">\(\phi \equiv 0\)</span> 时，称为Laplace 方程，否则称为 Poisson 方程</p><h6 id="调和方程的证明">调和方程的证明</h6><p><strong>Laplace 方程</strong></p><p>在空间 <span class="math inline">\(\mathbb{R}^3\)</span> 中，有一物体<span class="math inline">\(D\)</span>，其密度为 <spanclass="math inline">\(\rho(x,y,z)\)</span>，在 <spanclass="math inline">\(D\)</span> 外有一点 <spanclass="math inline">\(P(x,y,z)\)</span> 有一单位质量的物体</p><p>物体中质心在 <spanclass="math inline">\((\varepsilon,\eta,\zeta)\)</span> 的一微元对 <spanclass="math inline">\(P\)</span> 处物体的引力为</p><p><span class="math display">\[\mathrm{d}\vec{F}=k\int_D\frac{\rho}{r^2}\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta\]</span></p><p>但是不推导这个好像对最终结果没有什么影响，不管了</p><p>引力势能为</p><p><span class="math display">\[u(x,y,z)=int_D\frac{\rho}{r}\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta\]</span></p><p>则</p><p><span class="math display">\[\Delta u =\Delta\left(\int_D\frac{\rho}{r}\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta\right)=\int_D\rho\Delta\left(\frac{1}{r}\right)\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta=0\]</span></p><p><strong>Poisson 方程</strong></p><p>我们考虑真空中的静电场，这是由一个电荷分布为 <spanclass="math inline">\(\rho(x,y,z)\)</span> 的物体 <spanclass="math inline">\(D\)</span> 产生的</p><p>我们由 Gauss 定律可得</p><p><span class="math display">\[\int_s\vec{E}\mathrm{d}S=\frac{1}{\varepsilon_0}\iiint_V\rho\,\mathrm{d}V\]</span></p><p>由 Green 定理可得</p><p><span class="math display">\[\int_s\vec{E}\mathrm{d}S=\iiint_V\vec{\nabla}\cdot\vec{E}\,\mathrm{d}V=\frac{1}{\varepsilon_0}\iiint_V\rho\,\mathrm{d}V\]</span></p><p>则</p><p><span class="math display">\[\iiint_V\vec{\nabla}\cdot\vec{E}\,\mathrm{d}V=\frac{1}{\varepsilon_0}\iiint_V\rho\,\mathrm{d}V\]</span></p><p>我们去掉积分号，得到</p><p><span class="math display">\[\vec{\nabla}\cdot\vec{E}=\frac{\rho}{\varepsilon_0}\]</span></p><p>由电场的保守性可知，存在一个电势函数 <spanclass="math inline">\(u\)</span>，使得 <spanclass="math inline">\(\vec{E}=-\vec{\nabla}u\)</span>，则</p><p><span class="math display">\[\vec{\nabla}\cdot\vec{E}=-\vec{\nabla}\cdot\vec{\nabla}u=-\Delta u=\]</span></p><p>所以我们得到 Poisson 方程</p><p><span class="math display">\[\Delta u = -\frac{\rho}{\varepsilon_0}\]</span></p><h6 id="调和方程的定解问题">调和方程的定解问题</h6><p>调和方程的定解问题只需要给出边界条件</p><ol type="1"><li><p>Dirichlet 边界条件：</p><p><span class="math display">\[u(x_1,x_2,x_3)|_{\partial\Omega}=\varphi(x_1,x_2,x_3),x\in\partial\Omega,\]</span></p><p>这表明了边界上的势函数变化情况</p></li><li><p>Neumann 边界条件：</p><p><span class="math display">\[\frac{\partial u}{\partial\vec{n}}(x_1,x_2,x_3)|_{\partial\Omega}=\mu(x_1,x_2,x_3),x\in\partial\Omega,\]</span></p><p>这表明了边界上力的变化情况</p></li><li><p>Robin 边界条件：</p><p><span class="math display">\[\left(\frac{\partial u}{\partial \vec{n}}+\sigma u\right)\vert_{\partial\Omega}=\varphi(x_1,x_2,x_3)\]</span></p><p>其中 <span class="math inline">\(\sigma\)</span> 为常数或者 <spanclass="math inline">\(\sigma(x_1,x_2,x_3)\)</span></p></li></ol><h3 id="线性偏微分方程的叠加原理">线性偏微分方程的叠加原理</h3><p>对于一线性问题 <span class="math inline">\(\hat{G}u=g(x)\)</span>，若<span class="math inline">\(u_1\)</span> 和 <spanclass="math inline">\(u_2\)</span> 分别是该问题的两个解，则对于任意常数<span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span>， <span class="math inline">\(au_1 +bu_2\)</span> 也是该问题的解</p><h2 id="分离变量法">分离变量法</h2><h3 id="fourier-级数">Fourier 级数</h3><p>设 <span class="math inline">\(f_T(t)\)</span> 是以 <spanclass="math inline">\(T\)</span> 为周期的实函数，且在 <spanclass="math inline">\([-\frac{T}{2},\frac{T}{2}]\)</span> 上满足Dirichlet 条件</p><ol type="1"><li><span class="math inline">\(f_T(t)\)</span>连续或仅有有限个第一类间断点</li><li><span class="math inline">\(f_T(t)\)</span> 在 <spanclass="math inline">\([-\frac{T}{2},\frac{T}{2}]\)</span>上有有限个极值点</li></ol><p>则 <span class="math inline">\(f_T(t)\)</span> 在 <spanclass="math inline">\([-\frac{T}{2},\frac{T}{2}]\)</span> 可展开为Fourier 级数，且在连续点 <span class="math inline">\(t\)</span> 处有</p><p><span class="math display">\[f_T(t)=\frac{a_0}{2}+\sum_{n=1}^{+\infty}(a_n\cos n\omega t + b_n\sinn\omega t)\]</span></p><p>其中</p><ul><li><span class="math inline">\(\displaystyle\omega =\frac{2\pi}{T}\)</span></li><li><span class="math inline">\(\displaystylea_n=\frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\cos n\omegax\,\mathrm{d}x\)</span></li><li><span class="math inline">\(\displaystyleb_n=\frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\sin n\omegax\,\mathrm{d}x\)</span></li><li><span class="math inline">\(\displaystyle a_0 =\frac{1}{\pi}\int_{-\pi}^\pi f(x)\,\mathrm{d}x\)</span></li></ul><p>并且在断点 <span class="math inline">\(t\)</span> 处有</p><p><span class="math display">\[\frac{f_T(t-)+f_T(t^+)}{2}=\frac{a_0}{2}+\sum_{n=1}^{+\infty}(a_n\cosn\omega t + b_n\sin n\omega t)\]</span></p><blockquote><p>定理</p><p>若 <span class="math inline">\(f\)</span> 可积或平方可积，则 Fourier展开式的系数满足 Parseval 等式</p><p><span class="math display">\[\frac{a_0^2}{2}+\sum_{n=1}^{+\infty}(a_n^2+b_n^2)=\frac{1}{\pi}\int_{-\pi}^{\pi}\vertf(x)\vert^2\,\mathrm{d}x\]</span></p></blockquote><h4 id="正弦函数与余弦函数">正弦函数与余弦函数</h4><h5 id="正弦级数">正弦级数</h5><p>若 <span class="math inline">\(f(x)\)</span> 是奇函数，则其 Fourier级数展开式中</p><p><span class="math display">\[a_n=\frac{1}{\pi} \int_{-\pi}^{\pi}f(x)\cos nx\,\mathrm{d}x=0\]</span></p><p>则其 Fourier 级数展开式为</p><p><span class="math display">\[f(x)=\sum_{n=1}^{+\infty}b_n\sin nx\]</span></p><p>对其做周期延拓则变为正弦级数</p><h5 id="余弦级数">余弦级数</h5><p>若 <span class="math inline">\(f(x)\)</span> 是偶函数，则其 Fourier级数展开式中</p><p><span class="math display">\[b_n=\frac{1}{\pi} \int_{-\pi}^{\pi}f(x)\sin nx\,\mathrm{d}x=0\]</span></p><p>则其 Fourier 级数展开式为</p><p><span class="math display">\[f(x)=\frac{a_0}{2}+\sum_{n=1}^{+\infty}a_n\cos nx\]</span></p><p>对其做周期延拓则变为余弦级数</p><h3 id="弦振动方程初边值问题的求解">弦振动方程初边值问题的求解</h3><h4 id="第一类齐次边界条件">第一类齐次边界条件</h4><p>若弦的两端固定，器自由振动由以下定解问题解决</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{tt}-a^2u_{xx}=0,&amp;&amp;(0&lt;x&lt;l,t&gt;0)\\      &amp;t=0:u=\phi(x),u_t=\psi(x)\\      &amp;u\vert_{x=0}=0,u\vert_{x=l}=0   \end{aligned}\right.\]</span></p><p>使用分离变量法进行求解，我们设</p><p><span class="math display">\[u(t,x)=X(x)T(t)\]</span></p><p>则弦振动方程可化为</p><p><span class="math display">\[\begin{aligned}   &amp;X(x)T&#39;&#39;(t)-a^2X&#39;&#39;(x)T(t)=0\\   \Rightarrow&amp;\frac{T&#39;&#39;(t)}{a^2T(t)}=\frac{X&#39;&#39;(x)}{X(x)}=-\lambda\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X&#39;&#39;(x)+\lambda X(x)=0\\      &amp;T&#39;&#39;(t)+a^2\lambda T(t)=0   \end{aligned}\right.\]</span></p><p>由边界条件可得</p><p><span class="math display">\[\left\{\begin{aligned}   &amp;X&#39;&#39;(x)+\lambda X(x)=0\\   &amp;X(0)=X(l)=0\end{aligned}\right.\]</span></p><p>这里的 <span class="math inline">\(\lambda\)</span> 称为特征值，<span class="math inline">\(X(x)\)</span>称为特征函数，这个问题被称为<strong>特征值问题</strong></p><p>其特征方程为</p><p><span class="math display">\[\mu^2+\lambda=0\]</span></p><ol type="1"><li><p><span class="math inline">\(\lambda&lt;0\)</span></p><p><span class="math display">\[X(x)=A\mathrm{e}^{\sqrt{-\lambda}x}+B\mathrm{e}^{-\sqrt{-\lambda}x}\]</span></p><p>此时若有 <span class="math inline">\(2\)</span> 零点则 <spanclass="math inline">\(X(x)\equiv 0\)</span>，舍去</p></li><li><p><span class="math inline">\(\lambda=0\)</span></p><p><span class="math display">\[X(x)=Ax+B\]</span></p><p>此时若有 <span class="math inline">\(2\)</span> 零点则 <spanclass="math inline">\(X(x)\equiv 0\)</span>，舍去</p></li><li><p><span class="math inline">\(\lambda&gt;0\)</span></p><p><span class="math display">\[X(x)=A\cos\sqrt{\lambda}x+B\sin\sqrt{\lambda}x\]</span></p></li></ol><p>由边界条件可得</p><p><span class="math display">\[X(0)=A=0\]</span></p><p><span class="math display">\[X(l)=B\sin\sqrt{\lambda}l=0\]</span></p><p>当 <span class="math inline">\(B\neq 0\)</span> 时， <spanclass="math inline">\(\sqrt{\lambda}l=n\pi,n=1,2,3,\ldots\)</span>，则</p><p><span class="math display">\[\lambda_n=\left(\frac{n\pi}{l}\right)^2\]</span></p><p>这个方程的特征函数系为</p><p><span class="math display">\[\left\{\sin{\frac{n\pi}{l}x}\right\}_{n=1}^{\infty}\]</span></p><p>为了方便我们令 <span class="math inline">\(B_n=1\)</span>则我们得到一组特解</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X_n(x)=\sin{\frac{n\pi}{l}x}\\      &amp;T_n(t)=A_n\cos{\frac{an\pi}{l}t}+B_n\sin{\frac{an\pi}{l}t}   \end{aligned}\right.\]</span></p><p>则方程的通解为</p><p><span class="math display">\[u_n(t,x)=\left(A_n\cos{\frac{an\pi}{l}t}+B_n\sin{\frac{an\pi}{l}t}\right)\sin{\frac{n\pi}{l}x}\]</span></p><p>叠加得到形式解</p><p><span class="math display">\[u(t,x)=\sum_{n=1}^{\infty}\left(A_n\cos{\frac{an\pi}{l}t}+B_n\sin{\frac{an\pi}{l}t}\right)\sin{\frac{n\pi}{l}x}\]</span></p><p>接下来使用初值条件对 <span class="math inline">\(A_n\)</span> 和<span class="math inline">\(B_n\)</span> 进行求解</p><p><span class="math display">\[\left\{   \begin{aligned}      u(0,x)= &amp;\sum_{n=1}^{\infty}A_n\sin{\frac{n\pi}{l}x}=\phi(x)\\      u_t(l,x)=&amp;\sum_{n=1}^{\infty}B_n\frac{an\pi}{l}\sin{\frac{n\pi}{l}x}=\psi(x)   \end{aligned}\right.\]</span></p><p>得到</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;A_n=\frac{2}{l}\int_0^l\phi(x)\sin{\frac{n\pi}{l}x}\,\mathrm{d}x\\      &amp;B_n=\frac{2}{an\pi}\int_0^l\psi(x)\sin{\frac{n\pi}{l}x}\,\mathrm{d}x   \end{aligned}\right.\]</span></p><h4 id="第二类齐次边界条件">第二类齐次边界条件</h4><p>若弦的两端为自由端，器自由振动由以下定解问题解决</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{tt}-a^2u_{xx}=0,&amp;&amp;(0&lt;x&lt;l,t&gt;0)\\      &amp;t=0:u=\phi(x),u_t=\psi(x)\\      &amp;u_x\vert_{x=0}=0,u_x\vert_{x=l}=0   \end{aligned}\right.\]</span></p><p>使用分离变量法进行求解，我们设</p><p><span class="math display">\[u(t,x)=X(x)T(t)\]</span></p><p>则弦振动方程可化为</p><p><span class="math display">\[\begin{aligned}   &amp;X(x)T&#39;&#39;(t)-a^2X&#39;&#39;(x)T(t)=0\\   \Rightarrow&amp;\frac{T&#39;&#39;(t)}{a^2T(t)}=\frac{X&#39;&#39;(x)}{X(x)}=-\lambda\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X&#39;&#39;(x)+\lambda X(x)=0\\      &amp;T&#39;&#39;(t)+a^2\lambda T(t)=0   \end{aligned}\right.\]</span></p><p>由边界条件可得</p><p><span class="math display">\[\left\{   \begin{aligned}   &amp;X&#39;&#39;(x)+\lambda X(x)=0\\   &amp;X&#39;(0)=0,X&#39;(l)=0   \end{aligned}\right.\]</span></p><p>同样可以证明 <span class="math inline">\(\displaystyle \lambda&gt;0\)</span></p><p><span class="math display">\[X(x)=A\cos\sqrt{\lambda}x+B\sin\sqrt{\lambda}x\]</span></p><p>由边界条件可得</p><p><span class="math display">\[X&#39;(0)=-A\sqrt{\lambda}=0\]</span></p><p>则 <span class="math inline">\(A=0\)</span></p><p><span class="math display">\[X&#39;(l)=B\sqrt{\lambda}\cos\sqrt{\lambda}l=0\]</span></p><p>当 <span class="math inline">\(B\neq 0\)</span> 时， <spanclass="math inline">\(\sqrt{\lambda}l=\frac{n\pi}{2},n=0,1,2,3,\ldots\)</span>，则</p><p><span class="math display">\[\lambda_n=\left(\frac{n\pi}{l}\right)^2\]</span></p><p>这个方程的特征函数系为</p><p><span class="math display">\[\left\{\cos{\frac{n\pi}{l}x}\right\}_{n=0}^{\infty}\]</span></p><p>为了方便我们令 <span class="math inline">\(B_n=1\)</span>则我们得到一组特解</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X_n(x)=\cos{\frac{n\pi}{l}x}\\      &amp;T_n(t)=A_n\cos{\frac{an\pi}{l}t}+B_n\sin{\frac{an\pi}{l}t}   \end{aligned}\right.\]</span></p><p>并且当 <span class="math inline">\(n=0\)</span> 时，有</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X_0(x)=B_0\\      &amp;T_0(t)=C_0+D_0t   \end{aligned}\right.\]</span></p><p>则方程的形式解为</p><p><span class="math display">\[u(t,x)=\frac{a_0+b_0t}{2}+\sum_{n=0}^{\infty}\left(A_n\cos{\frac{an\pi}{l}t}+B_n\sin{\frac{an\pi}{l}t}\right)\cos{\frac{n\pi}{l}x}\]</span></p><p>同样通过初值条件可以求得 <span class="math inline">\(A_n\)</span> 和<span class="math inline">\(B_n\)</span></p><p><span class="math display">\[\left\{   \begin{aligned}      a_0=&amp;\frac{2}{l}\int_0^l\phi(x)\,\mathrm{d}x\\      b_0=&amp;\frac{2}{al}\int_0^l\psi(x)\,\mathrm{d}x\\      A_n=&amp;\frac{2}{l}\int_0^l\phi(x)\cos{\frac{n\pi}{l}x}\,\mathrm{d}x\\      B_n=&amp;\frac{2}{an\pi}\int_0^l\psi(x)\cos{\frac{n\pi}{l}x}\,\mathrm{d}x   \end{aligned}\right.\]</span></p><h3 id="热传导方程初边值问题的求解">热传导方程初边值问题的求解</h3><h4 id="第一类齐次边界条件-1">第一类齐次边界条件</h4><p>若一杆的两端温度保持为 <spanclass="math inline">\(0\)</span>，则杆的温度分布由以下定解问题解决</p><p><span class="math display">\[\left\{   \begin{aligned}      u_t-a^2u_{xx}=0,&amp;&amp;(0&lt;x&lt;l,t&gt;0)\\      t=0:u=\varphi(x)\\      u\vert_{x=0}=0,u\vert_{x=l}=0   \end{aligned}\right.\]</span></p><p>使用分离变量法进行求解，我们设</p><p><span class="math display">\[u(t,x)=X(x)T(t)\]</span></p><p>则热传导方程可化为</p><p><span class="math display">\[\begin{aligned}   &amp;X(x)T&#39;(t)-a^2X&#39;&#39;(x)T(t)=0\\   \Rightarrow&amp;\frac{T&#39;(t)}{a^2T(t)}=\frac{X&#39;&#39;(x)}{X(x)}=-\lambda\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X&#39;&#39;(x)+\lambda X(x)=0\\      &amp;T&#39;(t)+a^2\lambda T(t)=0   \end{aligned}\right.\]</span></p><p>由边界条件可得</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;X&#39;&#39;(x)+\lambda X(x)=0\\      &amp;X(0)=X(l)=0   \end{aligned}\right.\]</span></p><p>可以证明 <span class="math inline">\(\displaystyle \lambda&gt;0\)</span></p><p><span class="math display">\[X(x)=A\cos\sqrt{\lambda}x+B\sin\sqrt{\lambda}x\]</span></p><p>解得</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\lambda_n=\left(\frac{n\pi}{l}\right)^2\\      &amp;X_n(x)=A_n\sin{\frac{n\pi}{l}x}\\      &amp;T_n(t)=B_n\mathrm{e}^{-\frac{a^2n^2\pi^2}{l^2}t}   \end{aligned}\right.\]</span></p><p>则方程的解为</p><p><span class="math display">\[u(t,x)=\sum_{n=1}^{\infty}\varphi_n\mathrm{e}^{-\frac{a^2n^2\pi^2}{l^2}t}\sin{\frac{n\pi}{l}x}\]</span></p><p>由初值条件可求得</p><p><span class="math display">\[\varphi_n=\frac{2}{l}\int_0^l\varphi(x)\sin{\frac{n\pi}{l}x}\,\mathrm{d}x\]</span></p><h3 id="调和方程边值问题的求解">调和方程边值问题的求解</h3><h4 id="矩形域上的分离变量法">矩形域上的分离变量法</h4><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{xx}+u_{yy}=0，&amp;&amp;(0&lt;x&lt;a,0&lt;y&lt;b)\\      &amp;u\vert_{x=0}=\varphi_0(y),u\vert_{x=a}=\varphi_1(y)\\      &amp;u\vert_{y=0}=\psi_0(x),u\vert_{y=b}=\psi_1(x)   \end{aligned}\right.\]</span></p><p>我们将 <span class="math inline">\(u\)</span> 分解为 <spanclass="math inline">\(u=v+w\)</span>，其中 <spanclass="math inline">\(v\)</span> 满足</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;v_{xx}+v_{yy}=0，&amp;&amp;(0&lt;x&lt;a,0&lt;y&lt;b)\\      &amp;v\vert_{x=0}=0,v\vert_{x=a}=0\\      &amp;v\vert_{y=0}=\psi_0(x),v\vert_{y=b}=\psi_1(x)   \end{aligned}\right.\]</span></p><p>再使用分离变量法可以求得</p><p><span class="math display">\[v(t,x)=\sum_{n=1}^{\infty}\left(A_n\mathrm{e}^{\frac{n\pi}{a}y}+B_n\mathrm{e}^{-\frac{n\pi}{a}y}\right)\sin{\frac{n\pi}{a}x}=\sum_{k=1}^{\infty}(a_k\sinh{\frac{k\pi}{a}y}+b_k\cosh{\frac{k\pi}{a}y})\sin{\frac{k\pi}{a}x}\]</span></p><p>其中</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;a_k=\frac{2}{a}\int_0^a\psi_0(x)\sin{\frac{k\pi}{a}x}\,\mathrm{d}x\\      &amp;b_k=\frac{2}{a\sinh{\frac{k\pi}{a}b}}\int_0^a\left[\psi_1(x)-\psi_0(x)\cosh{\frac{k\pi}{a}b}\right]\sin{\frac{k\pi}{a}x}\,\mathrm{d}x   \end{aligned}\right.\]</span></p><p>同理 <span class="math inline">\(w\)</span> 满足</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;w_{xx}+w_{yy}=0，&amp;&amp;(0&lt;x&lt;a,0&lt;y&lt;b)\\      &amp;w\vert_{x=0}=\varphi_0(y),w\vert_{x=a}=\varphi_1(y)\\      &amp;w\vert_{y=0}=0,w\vert_{y=b}=0   \end{aligned}\right.\]</span></p><p>使用分离变量法可以求得</p><p><span class="math display">\[w(t,x)=\sum_{n=1}^{\infty}\left(C_n\mathrm{e}^{\frac{n\pi}{b}x}+D_n\mathrm{e}^{-\frac{n\pi}{b}x}\right)\sin{\frac{n\pi}{b}y}=\sum_{k=1}^{\infty}(c_k\sinh{\frac{k\pi}{b}x}+d_k\cosh{\frac{k\pi}{b}x})\sin{\frac{k\pi}{b}y}\]</span></p><p>其中</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;c_k=\frac{2}{b}\int_0^b\varphi_0(y)\sin{\frac{k\pi}{b}y}\,\mathrm{d}y\\      &amp;d_k=\frac{2}{b\sinh{\frac{k\pi}{b}a}}\int_0^b\left[\varphi_1(y)-\varphi_0(y)\cosh{\frac{k\pi}{b}a}\right]\sin{\frac{k\pi}{b}y}\,\mathrm{d}y   \end{aligned}\right.\]</span></p><h4 id="圆域上的分离变量法">圆域上的分离变量法</h4><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{xx}+u_{yy}=0，&amp;&amp;(x^2+y^2&lt; a^2)\\      &amp;u\vert_{x^2+y^2=R^2}=\varphi(x,y)   \end{aligned}\right.\]</span></p><p>引入极坐标</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;x=r\cos\theta\\      &amp;y=r\sin\theta   \end{aligned}\right.\]</span></p><p>则</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_r=u_x\cos\theta+u_y\sin\theta\\      &amp;u_\theta=-u_xr\sin\theta+u_yr\cos\theta\\      &amp;u_{rr}=u_{xx}\cos^2\theta+2u_{xy}\sin\theta\cos\theta+u_{yy}\sin^2\theta\\      &amp;u_{\theta\theta}=u_{xx}r^2\sin^2\theta-2u_{xy}r^2\sin\theta\cos\theta+u_{yy}r^2\cos^2\theta-u_xr\cos\theta-u_yr\sin\theta   \end{aligned}\right.\]</span></p><p><span class="math display">\[\begin{aligned}   &amp;u_{rr}+\frac{1}{r^2}u_{\theta\theta}=\frac{-1}{r}u_r\\   \Rightarrow&amp;u_{rr}+\frac{1}{r^2}u_{\theta\theta}+\frac{1}{r}u_r=0\end{aligned}\]</span></p><p>并且</p><p><span class="math display">\[\Delta u = u_{xx}+u_{yy}=\frac{1}{r}\frac{\partial}{\partialr}\left(r\frac{\partial u}{\partialr}\right)+\frac{1}{r^2}\frac{\partial^2 u}{\partial\theta^2}=\frac{\partial^2 u}{\partial r^2}+\frac{1}{r}\frac{\partialu}{\partial r}+\frac{1}{r^2}\frac{\partial^2 u}{\partial \theta^2}\]</span></p><p>则圆域上的调和方程化为</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{rr}+\frac{1}{r}u_r+\frac{1}{r^2}u_{\theta\theta}=0，&amp;&amp;(0&lt;r&lt;a,0&lt;\theta&lt;2\pi)\\      &amp;u\vert_{r=a}=f(\theta)   \end{aligned}\right.\]</span></p><p>使用分离变量法进行求解，我们设</p><p><span class="math display">\[u(r,\theta)=R(r)\Theta(\theta)\]</span></p><p>则调和方程可化为</p><p><span class="math display">\[\begin{aligned}   &amp;R&#39;&#39;(r)\Theta(\theta)+\frac{1}{r}R&#39;(r)\Theta(\theta)+\frac{1}{r^2}R(r)\Theta&#39;&#39;(\theta)=0\\   \Rightarrow&amp;-\frac{2R&#39;&#39;(r)+\frac{1}{r}R&#39;(r)}{\frac{1}{r^2}R(r)}=\frac{\Theta&#39;&#39;(\theta)}{\Theta(\theta)}=-\lambda\end{aligned}\]</span></p><p>即</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;r^2R&#39;&#39;(r)+rR&#39;(r)-\lambda R(r)=0\\      &amp;\Theta&#39;&#39;(\theta)+\lambda\Theta(\theta)=0   \end{aligned}\right.\]</span></p><p>由周期条件 <spanclass="math inline">\(\displaystyle\Theta(\theta+2\pi)=\Theta(\theta)\)</span>可得</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\lambda_n=n^2,n=0,1,2,3,\ldots\\      &amp;\Theta_n(\theta)=A_n\cos n\theta+B_n\sin n\theta   \end{aligned}\right.\]</span></p><p>对于 <span class="math inline">\(R(r)\)</span>，我们需要求解一个Euler 方程</p><p><span class="math display">\[r^2R&#39;&#39;(r)+rR&#39;(r)-n^2R(r)=0\]</span></p><p>其特征方程为</p><p><span class="math display">\[\begin{aligned}   \mu(\mu-1)+\mu - n^2&amp;=0\\   \Rightarrow \mu &amp;= \pm n\end{aligned}\]</span></p><p>则</p><p><span class="math display">\[R_n(r)=\left\{   \begin{aligned}      &amp;C_n r^n + D_n r^{-n},&amp;&amp; n=1,2,3,\ldots\\      &amp;C_0 + D_0 \ln r,&amp;&amp; n=0   \end{aligned}\right.\]</span></p><p>由于 <span class="math inline">\(\vertR(0)\vert&lt;+\infty\)</span>，则 <spanclass="math inline">\(D_n=0\)</span>，并且 <spanclass="math inline">\(D_0=0\)</span></p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;R_n(r)=C_n r^n,&amp;&amp; n=1,2,3,\ldots\\      &amp;R_0(r)=C_0,&amp;&amp; n=0   \end{aligned}\right.\]</span></p><p>则方程的解为</p><p><span class="math display">\[u(r,\theta)=\frac{a_0}{2} + \sum_{n=1}^{\infty}\left(\alpha_n\cosn\theta + \beta_n\sin n\theta\right)r^n\]</span></p><p>由边界条件可得</p><p><span class="math display">\[u(a,\theta)=\frac{a_0}{2} + \sum_{n=1}^{\infty}\left(\alpha_n\cosn\theta + \beta_n\sin n\theta\right)a^n=f(\theta)\]</span></p><p>则</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;a_0=\frac{1}{\pi}\int_0^{2\pi}f(\theta)\,\mathrm{d}\theta\\      &amp;\alpha_n=\frac{1}{\pi a^n}\int_0^{2\pi}f(\theta)\cosn\theta\,\mathrm{d}\theta\\      &amp;\beta_n=\frac{1}{\pi a^n}\int_0^{2\pi}f(\theta)\sinn\theta\,\mathrm{d}\theta   \end{aligned}\right.\]</span></p><h2 id="积分变换法">积分变换法</h2><h3 id="fourier-变换">Fourier 变换</h3><h4 id="fourier-变换的定义">Fourier 变换的定义</h4><blockquote><p>Fourier 积分定理</p><p>设函数 <span class="math inline">\(f(t)\)</span>在任意一有限区间上满足 Dirichlet 条件，且在 <spanclass="math inline">\((-\infty,+\infty)\)</span> 上绝对可积，则 <spanclass="math inline">\(f(t)\)</span> 可表示为 Fourier 积分形式</p><p><span class="math display">\[\frac{1}{2\pi}\int_{-\infty}^{+\infty}\left[\int_{-\infty}^{+\infty}f(\tau)\mathrm{e}^{-i\omega\tau}\,\mathrm{d}\tau\right]\mathrm{e}^{i\omega t}\,&gt;\mathrm{d}\omega\]</span></p><p>并且当 <span class="math inline">\(f(t)\)</span> 在点 <spanclass="math inline">\(t\)</span> 处连续时，有</p><p><span class="math display">\[f(t)=\frac{1}{2\pi}\int_{-\infty}^{+\infty}\left[\int_{-\infty}^{+\infty}f(\tau)\mathrm{e}^{-i\omega\tau}\,\mathrm{d}\tau\right]\mathrm{e}^&gt; {i\omegat}\,\mathrm{d}\omega\]</span></p><p>当 <span class="math inline">\(f(t)\)</span> 在点 <spanclass="math inline">\(t\)</span> 处不连续时，有</p><p><span class="math display">\[\frac{f(t^-)+f(t^+)}{2}=\frac{1}{2\pi}\int_{-\infty}^{+\infty}\left[\int_{-\infty}^{+\infty}f(\tau)\mathrm{e}^{-i\omega\tau}\,\mathrm{d}\tau\right]&gt; \mathrm{e}^{i\omegat}\,\mathrm{d}\omega\]</span></p><p>记</p><p><span class="math display">\[F(\omega)=\int_{-\infty}^{+\infty}f(t)\mathrm{e}^{-i\omegat}\,\mathrm{d}t,\quad\omega\in(-\infty,+\infty)\]</span></p><p>在 Fourier 积分公式中，若 <span class="math inline">\(t\)</span> 为<span class="math inline">\(f(t)\)</span> 的连续点，则有</p><p><span class="math display">\[f(t)=\frac{1}{2\pi}\int_{-\infty}^{+\infty}F(\omega)\mathrm{e}^{i\omegat}\,\mathrm{d}\omega\]</span></p></blockquote><p>设 <span class="math inline">\(f(t)\)</span> 和 <spanclass="math inline">\(f(\omega)\)</span> 分别为定义在 <spanclass="math inline">\(R\)</span> 上的实值函数和复函数，则称它们为一组<strong>Fourier 变换对</strong></p><ul><li><span class="math inline">\(F(\omega)\)</span> 称为 <spanclass="math inline">\(f(t)\)</span> 的<strong>像函数</strong>或<strong>Fourier 变换</strong>，记作 <spanclass="math inline">\(\mathcal{F}[f(t)]\)</span> 或 <spanclass="math inline">\(\hat{f}(\omega)\)</span></li><li><span class="math inline">\(f(t)\)</span> 称为 <spanclass="math inline">\(F(\omega)\)</span> 的<strong>原函数</strong>或<strong>Fourier 逆变换</strong>，记作 <spanclass="math inline">\(\mathcal{F}^{-1}[F(\omega)]\)</span> 或 <spanclass="math inline">\(\check{F}(t)\)</span></li></ul><p>记</p><p><span class="math display">\[\mathcal{D}=\left\{f(t)\vert f(t)=\mathcal{F}^{-1}[F(\omega)]\right\}\]</span></p><p><span class="math display">\[\mathcal{R}=\left\{F(\omega)\vert F(\omega)=\mathcal{F}[f(t)]\right\}\]</span></p><p>称 <span class="math inline">\(\mathcal{D}\)</span>为<strong>原像空间</strong>， <spanclass="math inline">\(\mathcal{R}\)</span>为<strong>像空间</strong>，Fourier变换和逆变换建立了原像空间和像空间之间的对应</p><h4 id="余弦与正弦-fourier-变换">余弦与正弦 Fourier 变换</h4><p>当 <span class="math inline">\(f(t)\)</span> 为偶函数时，有</p><p><span class="math display">\[f(t)=\frac{2}{\pi}\int_0^{+\infty}\left[\int_0^{+\infty}f(\tau)\cos\omega \tau\,\mathrm{d}\tau\right]\cos \omega t\,\mathrm{d}\omega\]</span></p><p>记</p><p><span class="math display">\[\mathcal{F}_c[f(t)]=\mathcal{F}_c(\omega)=\int_0^{+\infty}f(t)\cos\omega t\,\mathrm{d}t\]</span></p><p>为 <span class="math inline">\(f(t)\)</span> 的<strong>余弦 Fourier变换</strong></p><p>记</p><p><span class="math display">\[\mathcal{F}_c^{-1}[\mathcal{F}_c(\omega)]=f(t)=\frac{2}{\pi}\int_0^{+\infty}\mathcal{F}_c(\omega)\cos\omega t\,\mathrm{d}\omega\]</span></p><p>为 <span class="math inline">\(\mathcal{F}_c(\omega)\)</span>的<strong>余弦 Fourier 逆变换</strong></p><h4 id="fourier-变换与逆变换的性质">Fourier 变换与逆变换的性质</h4><p>为了方便，记 <spanclass="math inline">\(\mathcal{F}[f(t)]=F(\omega)\)</span>， <spanclass="math inline">\(\mathcal{F}^{-1}[F(\omega)]=f(t)\)</span>，<spanclass="math inline">\(\mathcal{F}[G(t)]=g(\omega)\)</span>， <spanclass="math inline">\(\mathcal{F}^{-1}[g(\omega)]=G(t)\)</span></p><table><thead><tr><th style="text-align: left;">性质名称</th><th style="text-align: left;">正变换性质</th><th style="text-align: left;">逆变换性质</th></tr></thead><tbody><tr><td style="text-align: left;">线性性质</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}[\alpha f(t)+\beta G(t)]=\alpha F(\omega)+\betag(\omega)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}[\alpha F(\omega)+\beta g(\omega)]=\alpha f(t)+\betaG(t)\)</span></td></tr><tr><td style="text-align: left;">对称性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}[F(t)]=2\pi f(-\omega)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}[f(\omega)]=\frac{1}{2\pi}F(-t)\)</span></td></tr><tr><td style="text-align: left;">位移性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}[f(t-t_0)]=\mathrm{e}^{-i\omega t_0}F(\omega)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}[\mathrm{e}^{i\omegat_0}F(\omega)]=f(t-t_0)\)</span></td></tr><tr><td style="text-align: left;">相似性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}[f(at)]=\frac{1}{\verta\vert}F\left(\frac{\omega}{a}\right),\quad (a\neq 0)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}\left[\frac{1}{\verta\vert}F(a\omega)\right]=\frac{1}{\verta\vert}f(\frac{t}{a})\)</span></td></tr><tr><td style="text-align: left;">微分性（原像函数）</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}\left[\frac{\mathrm{d}^nf(t)}{\mathrm{d}t^n}\right]=(i\omega)^n F(\omega)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}[(i\omega)^n F(\omega)]=\frac{\mathrm{d}^nf(t)}{\mathrm{d}t^n}\)</span></td></tr><tr><td style="text-align: left;">微分性（像函数）</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}[(-it)^n f(t)]=\frac{\mathrm{d}^nF(\omega)}{\mathrm{d}\omega^n}\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}\left[\frac{\mathrm{d}^nF(\omega)}{\mathrm{d}\omega^n}\right]=(-it)^n f(t)\)</span></td></tr><tr><td style="text-align: left;">积分性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}\left[\int_{-\infty}^tf(\tau)\,\mathrm{d}\tau\right]=\frac{1}{i\omega}F(\omega)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{F}^{-1}\left[\frac{1}{i\omega}F(\omega)\right]=\int_{-\infty}^tf(\tau)\,\mathrm{d}\tau\)</span></td></tr></tbody></table><h4 id="fourier-变换的卷积和卷积定理">Fourier 变换的卷积和卷积定理</h4><p>设 <span class="math inline">\(f(t)\)</span> 和 <spanclass="math inline">\(g(t)\)</span> 是定义在 <spanclass="math inline">\(R\)</span> 上的两个可积函数，则称函数</p><p><span class="math display">\[(f*g)(t)=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)\,\mathrm{d}\tau\]</span></p><p>为 <span class="math inline">\(f(t)\)</span> 和 <spanclass="math inline">\(g(t)\)</span> 的<strong>卷积</strong>，记作 <spanclass="math inline">\(f(t)*g(t)\)</span></p><h5 id="卷积定理">卷积定理</h5><p>设 <span class="math inline">\(f_1(t)\)</span> 和 <spanclass="math inline">\(f_2(t)\)</span> 的 Fourier 变换存在，则</p><p><span class="math display">\[\mathcal{F}[f_1(t)*f_2(t)]=\mathcal{F}[f_1(t)]\cdot\mathcal{F}[f_2(t)]\Leftrightarrow \mathcal{F}^{-1}[F_1(\omega)\cdotF_2(\omega)]=f_1(t)*f_2(t)\]</span></p><p><span class="math display">\[\mathcal{F}[f_1(t)\cdotf_2(t)]=\frac{1}{2\pi}\mathcal{F}[f_1(t)]*\mathcal{F}[f_2(t)]\Leftrightarrow\mathcal{F}^{-1}[F_1(\omega)*F_2(\omega)]=2\pi f_1(t)\cdot f_2(t)\]</span></p><h3 id="laplace-变换">Laplace 变换</h3><p>Fourier 变换要求函数在 <spanclass="math inline">\((-\infty,+\infty)\)</span>上绝对可积，在任意有限区间上满足 Dirichlet条件，但是很多函数不满足这个条件，并且实际应用中很多问题只涉及 <spanclass="math inline">\(t\geq 0\)</span> 的情况，因此引入 Laplace 变换</p><p>为了解决定义域以及绝对可积的问题，将 <spanclass="math inline">\(f(t)\)</span> 乘上单位阶跃函数 <spanclass="math inline">\(u(t)=\left\{\begin{aligned}&amp;1,&amp;&amp; t\geq0\\&amp;0,&amp;&amp;t&lt;0\end{aligned}\right.\)</span>，并且引入一个衰减因子 <spanclass="math inline">\(\mathrm{e}^{-\sigma t}\)</span>， <spanclass="math inline">\(\sigma&gt;0\)</span>，再对其作 Fourier 变换</p><p><span class="math display">\[F(\omega)=\mathcal{F}[f(t)]=\int_{-\infty}^{+\infty}f(t)u(t)\mathrm{e}^{-\sigmat}\mathrm{e}^{-i\omegat}\,\mathrm{d}t=\int_0^{+\infty}f(t)\mathrm{e}^{-(\sigma+i\omega)t}\,\mathrm{d}t\]</span></p><p>记 <span class="math inline">\(p=\sigma+i\omega\)</span>，则</p><p><span class="math display">\[F(p)=\mathcal{L}[f(t)]=\int_0^{+\infty}f(t)\mathrm{e}^{-pt}\,\mathrm{d}t\]</span></p><p>可以看出 Laplace 变换实际上就是 <spanclass="math inline">\(f(t)u(t)\mathrm{e}^{-\sigma t}\)</span> 的 Fourier变换，为一种单边的广义 Fourier 变换</p><p>同 Fourier 变换相似</p><p><span class="math display">\[\mathcal{D}=\left\{f(t)\vert f(t)=\mathcal{L}^{-1}[F(p)]\right\}\]</span></p><p><span class="math display">\[\mathcal{R}=\left\{F(p)\vert F(p)=\mathcal{L}[f(t)]\right\}\]</span></p><p>称 <span class="math inline">\(\mathcal{D}\)</span>为<strong>原像空间</strong>， <spanclass="math inline">\(\mathcal{R}\)</span> 为<strong>像空间</strong></p><h4 id="laplace-变换存在定理">Laplace 变换存在定理</h4><blockquote><p>指数级函数</p><p>对于实变量的实值（或复值）函数 <spanclass="math inline">\(f(t)\)</span>，存在常数 <spanclass="math inline">\(M&gt;0\)</span>， <spanclass="math inline">\(\sigma_0\)</span> 和 <spanclass="math inline">\(T&gt;0\)</span>，使得</p><p><span class="math display">\[\vert f(t)\vert \leq Me^{\sigma_0 t},\quad \forall t&gt;0\]</span></p><p>则称 <span class="math inline">\(f(t)\)</span>为<strong>指数级函数</strong>， <spanclass="math inline">\(\sigma_0\)</span> 称为 <spanclass="math inline">\(f(t)\)</span> 的<strong>增长指数</strong></p></blockquote><p>若函数满足</p><ol type="1"><li><span class="math inline">\(\displaystyle t\ge 0\)</span>的任一有限区间内分段连续</li><li><span class="math inline">\(\displaystyle t\ge 0\)</span>上为指数增长函数</li></ol><p>则其 Laplace 变换存在</p><h4 id="常用函数的-laplace-变换">常用函数的 Laplace 变换</h4><h4 id="单位阶跃函数-ut">单位阶跃函数 <spanclass="math inline">\(u(t)\)</span></h4><p><span class="math display">\[\mathcal{L}u(t)=\int_0^{+\infty}\mathrm{e}^{-pt}\,\mathrm{d}t=-\frac{1}{p}\mathrm{e}^{-pt}\Big\vert_0^{+\infty}\]</span></p><p>由于</p><p><span class="math display">\[\vert \mathrm{e}^{-pt}\vert=\vert\mathrm{e}^{-(\sigma+i\omega)t}\vert=\mathrm{e}^{-\sigma t}\]</span></p><p>当 <span class="math inline">\(\sigma&gt;0\)</span> 时， <spanclass="math inline">\(\displaystyle \lim_{t\to+\infty}\mathrm{e}^{-pt}=0\)</span>，则</p><p><span class="math display">\[\mathcal{L}u(t)=\frac{1}{p},\quad \mathrm{Re}\,p&gt;0\]</span></p><p>同样</p><p><span class="math display">\[\mathcal{L}[u(t-a)]=\frac{1}{p}\mathrm{e}^{-ap},\quad\mathrm{Re}\,p&gt;0\]</span></p><h4 id="指数函数-ekt">指数函数 <spanclass="math inline">\(e^{kt}\)</span></h4><p><span class="math display">\[\mathcal{L}\mathrm{e}^{kt}=\int_0^{+\infty}\mathrm{e}^{(k-p)t}\,\mathrm{d}t=-\frac{1}{k-p}\mathrm{e}^{(k-p)t}\Big\vert_0^{+\infty}=\frac{1}{p-k},\quad\left(\mathrm{Re}\,p&gt;\mathrm{Re}\,k\right)\]</span></p><h4 id="正弦函数-sin-omega-t">正弦函数 <span class="math inline">\(\sin\omega t\)</span></h4><p><span class="math display">\[\begin{aligned}   \mathcal{L}[\sin \omega t]&amp;=\int_0^{+\infty}\sin \omegat\mathrm{e}^{-pt}\,\mathrm{d}t\\                             &amp;=\frac{1}{2i}\int_0^{+\infty}\left(\mathrm{e}^{-(p-i\omega)t}-\mathrm{e}^{-(p+i\omega)t}\right)\,\mathrm{d}t\\                             &amp;=\frac{1}{2i}\left[\frac{1}{p-i\omega}-\frac{1}{p+i\omega}\right]=\frac{\omega}{p^2+\omega^2},\quad\mathrm{Re}\,p&gt;\vert\mathrm{lm} \, \omega\vert\end{aligned}\]</span></p><h4 id="余弦函数-cos-omega-t">余弦函数 <span class="math inline">\(\cos\omega t\)</span></h4><p><span class="math display">\[\begin{aligned}   \mathcal{L}[\cos \omega t]&amp;=\int_0^{+\infty}\cos \omegat\mathrm{e}^{-pt}\,\mathrm{d}t\\                             &amp;=\frac{1}{2}\int_0^{+\infty}\left(\mathrm{e}^{-(p-i\omega)t}+\mathrm{e}^{-(p+i\omega)t}\right)\,\mathrm{d}t\\                             &amp;=\frac{1}{2}\left[\frac{1}{p-i\omega}+\frac{1}{p+i\omega}\right]=\frac{p}{p^2+\omega^2},\quad\mathrm{Re}\,p&gt;\vert\mathrm{lm} \, k\vert\end{aligned}\]</span></p><h4 id="ftt"><span class="math inline">\(f(t)=t\)</span></h4><p><span class="math display">\[\mathcal{L}[t]=\int_0^{+\infty}t\mathrm{e}^{-pt}\,\mathrm{d}t=-\frac{t}{p}\mathrm{e}^{-pt}\Big\vert_0^{+\infty}+\frac{1}{p}\int_0^{+\infty}\mathrm{e}^{-pt}\,\mathrm{d}t=\frac{1}{p^2},\quad\mathrm{Re}\,p&gt;0\]</span></p><h4 id="fttn-n123ldots"><span class="math inline">\(f(t)=t^n\)</span>，<span class="math inline">\(n=1,2,3,\ldots\)</span></h4><p><span class="math display">\[\mathcal{L}[t^n]=\int_0^{+\infty}t^n\mathrm{e}^{-pt}\,\mathrm{d}t=\frac{n}{p}\int_0^{+\infty}t^{n-1}\mathrm{e}^{-pt}\,\mathrm{d}t=\frac{n!}{p^{n+1}},\quad\mathrm{Re}\,p&gt;0\]</span></p><h4 id="laplace-变换的性质">Laplace 变换的性质</h4><p>为了方便，记 <spanclass="math inline">\(\mathcal{L}[f(t)]=F(p)\)</span>， <spanclass="math inline">\(\mathcal{L}^{-1}[F(p)]=f(t)\)</span>，<spanclass="math inline">\(\mathcal{L}[G(t)]=G(p)\)</span>， <spanclass="math inline">\(\mathcal{L}^{-1}[G(p)]=G(t)\)</span></p><table><thead><tr><th style="text-align: left;">性质名称</th><th style="text-align: left;">正变换性质</th><th style="text-align: left;">逆变换性质</th></tr></thead><tbody><tr><td style="text-align: left;">线性性质</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}[af(t)+\beta G(t)]=aF(p)+bG(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}[aF(p)+bG(p)]=af(t)+bG(t)\)</span></td></tr><tr><td style="text-align: left;">延迟性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}[f(t-t_0)u(t-t_0)]=\mathrm{e}^{-p t_0}F(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}[\mathrm{e}^{-p t_0}F(p)]=f(t-t_0)u(t-t_0)\)</span></td></tr><tr><td style="text-align: left;">相似性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}[f(at)]=\frac{1}{a}F\left(\frac{p}{a}\right),\quad(a&gt;0)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}\left[F(ap)\right]=\frac{1}{a}f(\frac{t}{a})\)</span></td></tr><tr><td style="text-align: left;">平移性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}[\mathrm{e}^{p_0 t}f(t)]=F(p-p_0)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}[F(p-p_0)]=\mathrm{e}^{p_0 t}f(t)\)</span></td></tr><tr><td style="text-align: left;">微分性</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}\left[\frac{\mathrm{d}^n f(t)}{\mathrm{d}t^n}\right]=p^nF(p)-\sum_{k=0}^{n-1}p^{n-1-k}f^{(k)}(0)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}\left[p^n F(p)\right]=\frac{\mathrm{d}^nf(t)}{\mathrm{d}t^n}+\sum_{k=0}^{n-1}f^{(k)}(0)\frac{t^{n-1-k}}{(n-1-k)!}\)</span></td></tr><tr><td style="text-align: left;">积分性（原像函数）</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}\left[\int_0^tf(\tau)\,\mathrm{d}\tau\right]=\frac{1}{p}F(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}\left[\frac{1}{p}F(p)\right]=\int_0^tf(\tau)\,\mathrm{d}\tau\)</span></td></tr><tr><td style="text-align: left;">积分性（像函数）</td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}[\frac{f(t)}{t}]=\int_p^{+\infty}F(q)\,\mathrm{d}q\)</span></td><td style="text-align: left;"><span class="math inline">\(\displaystyle\mathcal{L}^{-1}\left[\int_p^{+\infty}F(q)\,\mathrm{d}q\right]=\frac{f(t)}{t}\)</span></td></tr></tbody></table><h4 id="laplace-变换的卷积性质">Laplace 变换的卷积性质</h4><p>如果 <span class="math inline">\(t&lt;0\)</span> 时， <spanclass="math inline">\(f(t)=0\)</span>， <spanclass="math inline">\(g(t)=0\)</span>，此时</p><p><span class="math display">\[\begin{aligned}   f*g(t)&amp;=\int_{-\infty}^{+\infty}f(\tau)g(t-\tau)\,\mathrm{d}\tau\\            &amp;=\int_0^tf(\tau)g(t-\tau)\,\mathrm{d}\tau+\int_t^{+\infty}f(\tau)g(t-\tau)\,\mathrm{d}\tau\\            &amp;=\int_0^t f(\tau)g(t-\tau)\,\mathrm{d}\tau\end{aligned}\]</span></p><p>称</p><p><span class="math display">\[(f*g)(t)=\int_0^t f(\tau)g(t-\tau)\,\mathrm{d}\tau\]</span></p><p>为 <span class="math inline">\(f(t)\)</span> 和 <spanclass="math inline">\(g(t)\)</span> 在区间 <spanclass="math inline">\([0,+\infty)\)</span> 上的卷积</p><p>若 <span class="math inline">\(f(t)\)</span> 和 <spanclass="math inline">\(g(t)\)</span> 的 Laplace 变换存在，则 <spanclass="math inline">\(f*g\)</span> 的 Laplace 变换也存在，且有</p><p><span class="math display">\[\mathcal{L}[f*g(t)]=\mathcal{L}[f(t)]\cdot\mathcal{L}[g(t)]\Leftrightarrow \mathcal{L}^{-1}[F(p)\cdot G(p)]=f*g(t)\]</span></p><h3 id="弦振动方程的初值问题">弦振动方程的初值问题</h3><h4 id="用-fourier-变换法求解弦振动方程的初值问题">用 Fourier变换法求解弦振动方程的初值问题</h4><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{tt}-a^2u_{xx}=0,&amp;&amp;(-\infty&lt;x&lt;+\infty,t&gt;0)\\      &amp;t=0:u=\varphi(x),u_t=\psi(x)\\   \end{aligned}\right.\]</span></p><p>对方程对 <span class="math inline">\(x\)</span> 做 Fourier 变换</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\frac{\partial^2 \hat{u}}{\partial t^2}+a^2\xi^2\hat{u}=0,\\      &amp;t=0:\hat{u}=\hat{\varphi}(\xi),\frac{\partial\hat{u}}{\partial t}=\hat{\psi}(\xi)\\   \end{aligned}\right.\]</span></p><p>解得</p><p><span class="math display">\[\hat{u}(t,\xi)=\hat{\varphi}(\xi)\cos a\xit+\frac{\hat{\psi}(\xi)}{a\xi}\sin a\xi t\]</span></p><p><span class="math display">\[\begin{aligned}   \hat{\varphi}(\xi)\cos a\xit=&amp;\frac{1}{2}\hat{\varphi}(\xi)\left(\mathrm{e}^{ia\xit}+\mathrm{e}^{-ia\xit}\right)+\frac{\hat{\psi}(\xi)}{2a\xi}\left(\mathrm{e}^{ia\xit}-\mathrm{e}^{-ia\xi t}\right)\\                     =&amp;\frac{1}{2}(\mathcal{F}[\varphi(x+at)]+\mathcal{F}[\varphi(x-at)])+\frac{1}{2a}(\mathcal{F}[\int_{x-at}^{x+at}\psi(\tau)\,\mathrm{d}\tau])\end{aligned}\]</span></p><p>这个公式被称为 <strong>D’Alembert 公式</strong></p><p>设 <span class="math inline">\(\varphi\in C^2(\mathbf{R}),\psi\inC^1(\mathbf{R})\)</span>，则 Caucy 问题存在唯一解 <spanclass="math inline">\(u(x,t)\)</span></p><h4id="特征线法行波法求解弦振动方程的初值问题">特征线法（行波法）求解弦振动方程的初值问题</h4><p>引入坐标变换</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\xi=x-at\\      &amp;\eta=x+at   \end{aligned}\right.\]</span></p><p>则</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_t=u_\xi\xi_t+u_\eta\eta_t=-au_\xi+au_\eta\\      &amp;u_x=u_\xi\xi_x+u_\eta\eta_x=u_\xi+u_\eta\\      &amp;u_{tt}=a^2u_{\xi\xi}-2a^2u_{\xi\eta}+a^2u_{\eta\eta}\\      &amp;u_{xx}=u_{\xi\xi}+2u_{\xi\eta}+u_{\eta\eta}   \end{aligned}\right.\]</span></p><p>则弦振动方程化为</p><p><span class="math display">\[-4a^2u_{\xi\eta}=0\]</span></p><p>可以设</p><p><span class="math display">\[u(\xi,\eta)=F(\xi)+G(\eta)\]</span></p><p>带回原变量</p><p><span class="math display">\[u(x,t)=F(x-at)+G(x+at)\]</span></p><p>由初始条件可得</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\varphi(x)=F(x)+G(x)\\      &amp;\psi(x)=-aF&#39;(x)+aG&#39;(x)   \end{aligned}\right.\]</span></p><p>解得</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;F(x)=\frac{1}{2}\varphi(x)-\frac{1}{2a}\int\psi(x)\,\mathrm{d}x\\      &amp;G(x)=\frac{1}{2}\varphi(x)+\frac{1}{2a}\int\psi(x)\,\mathrm{d}x   \end{aligned}\right.\]</span></p><p>将其带回 <span class="math inline">\(u(x,t)\)</span> 中，得到D’Alembert 公式</p><p><span class="math display">\[u(x,t)=\frac{1}{2}[\varphi(x-at)+\varphi(x+at)]+\frac{1}{2a}\int_{x-at}^{x+at}\psi(\tau)\,\mathrm{d}\tau\]</span></p><h5 id="行波法的物理意义">行波法的物理意义</h5><ul><li><p>当初始速度为 <span class="math inline">\(0\)</span>，即 <spanclass="math inline">\(\psi(x)=0\)</span> 时</p><p><span class="math display">\[u(x,t)=\frac{1}{2}[\varphi(x-at)+\varphi(x+at)]\]</span></p><p>可以认为是两个形状相同、振幅均为 <spanclass="math inline">\(\frac{1}{2}\varphi(x)\)</span> 的波，一个以速度<span class="math inline">\(a\)</span> 向右传播，另一个以速度 <spanclass="math inline">\(a\)</span> 向左传播</p></li><li><p>当初始位移为 <span class="math inline">\(0\)</span>，即 <spanclass="math inline">\(\varphi(x)=0\)</span> 时</p><p><span class="math display">\[u(x,t)=\frac{1}{2a}\int_{x-at}^{x+at}\psi(\tau)\,\mathrm{d}\tau=\Psi(x+at)-\Psi (x-at)\]</span></p><p>其中 <span class="math inline">\(\displaystyle\Psi&#39;(x)=\frac{1}{2a}\Psi(x)\)</span></p><p>可以认为是两个形状相同、振幅均为 <spanclass="math inline">\(\Psi(x)\)</span> 的波，一个以速度 <spanclass="math inline">\(a\)</span> 向右传播，另一个以速度 <spanclass="math inline">\(a\)</span> 向左传播</p></li></ul><p>波的传播速度为 <spanclass="math inline">\(a=\sqrt{\frac{T}{\rho}}\)</span>，其中 <spanclass="math inline">\(T\)</span> 为绳的张力， <spanclass="math inline">\(\rho\)</span> 为绳的线密度</p><h5 id="解的性质">解的性质</h5><h6 id="不变性">不变性</h6><ul><li>平移不变性<ul><li>如果 <span class="math inline">\(u(x,t)\)</span>是弦振动方程的解，则对于任意常数 <spanclass="math inline">\(x_0\)</span>， <spanclass="math inline">\(u(x-x_0,t)\)</span> 也是弦振动方程的解</li></ul></li><li>反演不变性<ul><li>解关于时间和空间变量反演后仍然是解，即如果 <spanclass="math inline">\(u(x,t)\)</span> 是弦振动方程的解，则 <spanclass="math inline">\(u(-x,-t)\)</span> 也是弦振动方程的解</li></ul></li><li>尺度不变性<ul><li>如果 <span class="math inline">\(u(x,t)\)</span>是弦振动方程的解，则对于任意非零常数 <spanclass="math inline">\(a\)</span>， <spanclass="math inline">\(u(ax,at)\)</span> 也是弦振动方程的解</li></ul></li><li>加法不变性<ul><li>解的任意线性组合仍是解</li></ul></li><li>导数不变性<ul><li>解的任意阶导数仍是解</li></ul></li><li>积分不变性<ul><li>如果 <span class="math inline">\(S(x,t)\)</span>是解，则对任意的函数 <span class="math inline">\(g(x)\)</span>，<spanclass="math inline">\(\displaystyle S(x-y,t)g(y)\ \mathrm{d}y\)</span>仍为解</li></ul></li><li>奇偶不变性<ul><li>奇/偶函数的初始数据对应奇/偶函数的解</li></ul></li><li>周期不变性<ul><li>周期的初始数据对应周期的解</li></ul></li></ul><h5 id="最大绝对值原理">最大绝对值原理</h5><p><span class="math display">\[\left|u(x,t)\right|\le M_\varphi+\frac{1}{2a}l_\varphi\]</span></p><ul><li><span class="math inline">\(\displaystyle M_\varphi=\max_{x\in\mathbf{R}}\left|\varphi(x)\right|\)</span></li><li><span class="math inline">\(\displaystyle l_\varphi=\max_{\alpha ,\beta}\left|\int_{\alpha}^{\beta}\psi(x)\,\mathrm{d}x\right|\)</span></li></ul><h5 id="波的有限传播速度">波的有限传播速度</h5><h6 id="依赖区间">依赖区间</h6><p>在未来的某个特定时空点 <span class="math inline">\((x_0,t_0)\)</span>处的解</p><p><span class="math display">\[u(x_0,t_0)=\frac{\left(\varphi(x_0-at_0)+\varphi(x_0+at_0)\right)}{2}+\frac{1}{2a}\int_{x_0-at_0}^{x_0+at_0}\psi(\tau)\,\mathrm{d}\tau\]</span></p><p>这个值只依赖于</p><ul><li>初始位移 <span class="math inline">\(\varphi(x)\)</span> 在 <spanclass="math inline">\(x_0-at_0\)</span> 和 <spanclass="math inline">\(x_0+at_0\)</span> 的取值</li><li>初始速度 <span class="math inline">\(\psi(x)\)</span> 在区间 <spanclass="math inline">\([x_0-at_0,x_0+at_0]\)</span> 上的所有值</li></ul><p>所以我们称解在点 <span class="math inline">\((x_0,t_0)\)</span> 处的<strong>依赖区间</strong> 为 <spanclass="math inline">\([x_0-at_0,x_0+at_0]\)</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511041653892.png"alt="依赖区间" /><figcaption aria-hidden="true">依赖区间</figcaption></figure><h6 id="决定区域">决定区域</h6><p>解决的问题是初始区间 <span class="math inline">\([x_1,x_2]\)</span>上的初始数据能够完全决定未来哪个时空区域的解</p><p>要求满足</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;x-at\ge x_1\\      &amp;x+at\le x_2   \end{aligned}\right.\]</span></p><p>则区间 <span class="math inline">\([x_1+at,x_2-at]\)</span>完全决定了在下面三角形区域内的解</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202511041721278.png"alt="决定区域" /><figcaption aria-hidden="true">决定区域</figcaption></figure><p><span class="math display">\[\{ (x, t) \mid x_1 + at \le x \le x_2 - at, t &gt; 0 \}\]</span></p><h6 id="影响区间">影响区间</h6><p>初始某个点上的扰动，会影响到未来的哪个时空区间</p><p>受到影响即依赖区间包含了扰动点</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;x-at\le x_0\\      &amp;x+at\ge x_0   \end{aligned}\right.\]</span></p><p>点 <span class="math inline">\(x_0\)</span> 的初值变化只影响区域</p><p><span class="math display">\[\{ (x, t) \mid x_0 - at \le x \le x_0 + at, t &gt; 0 \}\]</span></p><p>这个区域称为点 <span class="math inline">\(x_0\)</span> 的<strong>影响区域</strong></p><h4 id="齐次化原理">齐次化原理</h4><p>对于非齐次弦振动方程的 Cauchy 问题</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{tt}-a^2u_{xx}=f(x,t),&amp;&amp;(-\infty&lt;x&lt;+\infty,t&gt;0)\\      &amp;t=0:u=\varphi(x),u_t=\psi(x)\\   \end{aligned}\right.\]</span></p><p>可以将其转化为两个 Cauchy 问题的叠加</p>$$ {<span class="math display">\[\begin{aligned}      &amp;u_{tt}-a^2u_{xx}=0\\      &amp;t=0:u=\varphi(x),u_t=\psi(x)\\   \end{aligned}\]</span><p>.</p>{<span class="math display">\[\begin{aligned}      &amp;u_{tt}-a^2u_{xx}=f(x,t)\\      &amp;t=0:u=0,u_t=0\\   \end{aligned}\]</span><p>. $$</p><p>第一个问题已经有 D’Alembert 公式的解</p><p><span class="math display">\[u_1(x,t)=\frac{1}{2}[\varphi(x-at)+\varphi(x+at)]+\frac{1}{2a}\int_{x-at}^{x+at}\psi(\tau)\,\mathrm{d}\tau\]</span></p><p>第二个问题可以用变分法求解</p><p><span class="math display">\[u_2(x,t)=\int_0^tw(x,t;\tau)\,\mathrm{d}\tau=\frac{1}{2a}\int_0^t\int_{x-a(t-\tau)}^{x+a(t-\tau)}f(\xi,\tau)\,\mathrm{d}\xi\,\mathrm{d}\tau\]</span></p><p>其中</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;w_{tt}-a^2w_{xx}=0,&amp;&amp;(-\infty&lt;x&lt;+\infty,t&gt;\tau)\\      &amp;t=\tau:w=0,w_t=f(x,\tau)\\   \end{aligned}\right.\]</span></p><p>则非齐次问题的解为</p><p><span class="math display">\[\begin{aligned}   u(x,t)=&amp;u_1(x,t)+u_2(x,t)\\         =&amp;\frac{1}{2}[\varphi(x-at)+\varphi(x+at)]+\frac{1}{2a}\int_{x-at}^{x+at}\psi(\tau)\,\mathrm{d}\tau+\frac{1}{2a}\int_0^t\int_{x-a(t-\tau)}^{x+a(t-\tau)}f(\xi,\tau)\,\mathrm{d}\xi\,\mathrm{d}\tau\end{aligned}\]</span></p><h5 id="非齐次边界情形">非齐次边界情形</h5><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{tt}-a^2u_{xx}=f(x,t),&amp;&amp;(-\infty&lt;x&lt;+\infty,t&gt;0)\\      &amp;t=0:u=\varphi(x),u_t=\psi(x)\\      &amp;u(0,t)=\lambda(t),u(l,t)=\mu(t)\\   \end{aligned}\right.\]</span></p><p>接下来想办法消除边界条件中的非齐次项 <spanclass="math inline">\(\lambda(t)\)</span> 和 <spanclass="math inline">\(\mu(t)\)</span></p><p>我们构建一个关于 <span class="math inline">\(x\)</span>的一次多项函数</p><p><span class="math display">\[h(x,t)=\frac{\mu(t)-\lambda(t)}{l}x+\lambda(t)\]</span></p><p>则 <span class="math inline">\(h(x,t)\)</span> 满足边界条件</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;h(0,t)=\lambda(t)\\      &amp;h(l,t)=\mu(t)\\   \end{aligned}\right.\]</span></p><p>设</p><p><span class="math display">\[v(x,t)=u(x,t)-h(x,t)\]</span></p><p>则</p><p><span class="math display">\[u(x,t)=v(x,t)+h(x,t)\]</span></p><p>将其带入原定解问题中</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;v_{tt}-a^2v_{xx}=f(x,t)-h_{tt}\\      &amp;t=0:v=\varphi(x)-h(x,0),v_t=\psi(x)-h_t(x,0)\\      &amp;v(0,t)=0,v(l,t)=0\\   \end{aligned}\right.\]</span></p><p>我们成功将原问题转换为一个关于 <spanclass="math inline">\(v(t,x)\)</span> 的齐次边界问题</p><p>可以用叠加原理将其分解为两个问题的叠加求解</p><h3 id="热传导方程的初值问题">热传导方程的初值问题</h3><h4 id="一维齐次热传导方程的-cauchy-问题">一维齐次热传导方程的 Cauchy问题</h4><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_t-a^2u_{xx}=0,&amp;&amp;(-\infty&lt;x&lt;+\infty,t&gt;0)\\      &amp;t=0:u=\varphi(x)\\   \end{aligned}\right.\]</span></p><p>对方程对 <span class="math inline">\(x\)</span> 做 Fourier 变换</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\hat{u}_t+a^2\xi^2\hat{u}=0,\\      &amp;t=0:\hat{u}=\hat{\varphi}(\xi)   \end{aligned}\right.\]</span></p><p>解得</p><p><span class="math display">\[\hat{u}=\hat{\varphi(\xi)}e^{-a^2\xi^2 t}\]</span></p><p><span class="math display">\[u(t,x)=\mathcal{F}^{-1}[\hat{u(t,\xi)}]=\mathcal{F}^{-1}[\hat{\varphi}(\xi)e^{-a^2\xi^2t}]=\mathcal{F}^{-1}[\hat{\xi}]*\mathcal{F}^{-1}[e^{-a^2\xi^2t}]=\frac{1}{2a\sqrt{\pit}}\int_{-\infty}^{+\infty}e^{-\frac{(\xi-x)^2}{4a^2t}}\varphi(\tau)\,\mathrm{d}\tau\]</span></p><p>称为齐次方程的 Poisson 公式</p><h4 id="一维非齐次热传导方程的-cauchy-问题">一维非齐次热传导方程的Cauchy 问题</h4><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_t-a^2u_{xx}=f(x,t),&amp;&amp;(-\infty&lt;x&lt;+\infty,t&gt;0)\\      &amp;t=0:u=\varphi(x)\\   \end{aligned}\right.\]</span></p><p>可以将其转化为两个 Cauchy 问题的叠加</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_t-a^2u_{xx}=0\\      &amp;t=0:u=\varphi(x)\\   \end{aligned}\right.\oplus\left\{   \begin{aligned}      &amp;u_t-a^2u_{xx}=f(x,t)\\      &amp;t=0:u=0\\   \end{aligned}\right.\]</span></p><p>解得</p><p><span class="math display">\[u(t,x)=\frac{1}{2a\sqrt{\pit}}\int_{-\infty}^{+\infty}e^{-\frac{(x-\xi)^2}{4a^2t}}\varphi(\xi)\,\mathrm{d}\xi+\int_0^t\int_{-\infty}^{+\infty}\frac{1}{2a\sqrt{\pi(t-\tau)}}e^{-\frac{(x-\xi)^2}{4a^2 (t-\tau)}}f(\xi,\tau)\,\mathrm{d}\xi\,\mathrm{d}\tau\]</span></p><h4 id="用-fourier-变换求解-laplce-方程">用 Fourier 变换求解 Laplce方程</h4><p>求半平面 Laplacec 方程边界问题的有界解</p><p><span class="math display">\[\left\{   \begin{aligned}      u_{xx}+u_{yy}=0(x\in \mathbf{R},y&gt;0)\\      y=0:u=f(x)\\   \end{aligned}\right.\]</span></p><p>对 <span class="math inline">\(x\)</span> 做 Fourier 变换</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;-\xi^2\hat{u}+\hat{u}_{yy}=0,\\      &amp;y=0:\hat{u}=\hat{f}(\xi)\\   \end{aligned}\right.\]</span></p><p>解得</p><p><span class="math display">\[\hat{u}(\xi,y)=C_1e^{-\vert \xi \vert y}+C_2e^{\vert \xi \vert y}\]</span></p><p><span class="math inline">\(u\)</span> 有界则 <spanclass="math inline">\(C_2=0\)</span>，由边界条件可得 <spanclass="math inline">\(C_1=\hat{f}(\xi)\)</span>，则</p><p><span class="math display">\[\hat{u}(\xi,y)=\hat{f}(\xi)e^{-\vert \xi \vert y}\]</span></p><p>对其做逆变换</p><p><span class="math display">\[u(x,y)=\mathcal{F}^{-1}[\hat{u}(\xi,y)]=\mathcal{F}^{-1}[\hat{f}(\xi)e^{-\vert\xi \vert y}]=\mathcal{F}^{-1}[\hat{f}(\xi)]*\mathcal{F}^{-1}[e^{-\vert\xi \verty}]=\frac{y}{\pi}\int_{-\infty}^{+\infty}\frac{f(\tau)}{(x-\tau)^2+y^2}\,\mathrm{d}\tau\]</span></p><h3 id="半空间上的初边值问题">半空间上的初边值问题</h3><h4 id="一维齐次波动方程的初边界问题">一维齐次波动方程的初边界问题</h4><p>考虑初边值问题，这里假设 <span class="math inline">\(b\)</span>为常数</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;u_{tt}-a^2u_{xx}=0,&amp;&amp;(x&gt;0,t&gt;0)\\      &amp;u(t,0)=0,&amp;&amp;(t&gt;0)\\      &amp;u(0,x)=0,u_t(0,x)=b,&amp;&amp;(x&gt;0)\\   \end{aligned}\right.\]</span></p><p>对 <span class="math inline">\(t\)</span> 进行 Laplace 变换</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;a^2p^2\bar{u}(p,x)-b-a^2\frac{\mathrm{d}^2\bar{u}(p,x)}{\mathrm{d} x^2}=0,&amp;&amp;(x&gt;0)\\      &amp;\bar{u}(p,0)=0\\      &amp;\bar{u}(0,x)=0,p\bar{u}(0,x)=b,&amp;&amp;(x&gt;0)\\   \end{aligned}\right.\]</span></p><p>对弦振动方程求解得到</p><p><span class="math display">\[\bar{u}(p,x)=C_1e^{-\frac{p}{a}x}+C_2e^{\frac{p}{a}x}+\frac{b}{p^2}\]</span></p><p><span class="math inline">\(u\)</span> 有界则 <spanclass="math inline">\(C_2=0\)</span>，由边界条件可得 <spanclass="math inline">\(C_1=-\frac{b}{p^2}\)</span>，则</p><p><span class="math display">\[\bar{u}(p,x)=-\frac{b}{p^2}e^{-\frac{p}{a}x}+\frac{b}{p^2}\]</span></p><p>对其做逆变换</p><p><span class="math display">\[u(t,x)=\mathcal{L}^{-1}[\bar{u}(p,x)]=\mathcal{L}^{-1}\left[-\frac{b}{p^2}e^{-\frac{p}{a}x}+\frac{b}{p^2}\right]=-b\left(t-\frac{x}{a}\right)H\left(t-\frac{x}{a}\right)+bt\]</span></p><h2id="二阶线性偏微分方程的分类和总结">二阶线性偏微分方程的分类和总结</h2><h3 id="两个自变量的情形的分类">两个自变量的情形的分类</h3><p><span class="math display">\[a_{11}u_{xx}+2a_{12}u_{xy}+a_{22}u_{yy}+b_1u_x+b_2u_y+cu=f\]</span></p><p>其中的 <span class="math inline">\(a_{ij},b_i,c,f\)</span> 均为自变量<span class="math inline">\(x,y\)</span> 的连续可微函数，并且 <spanclass="math inline">\(\displaystyle a_{11}^2+a_{12}^2+a_{22}^2\neq0\)</span></p><p>判别式</p><p><span class="math display">\[\Delta =a_{12}^2-a_{11}a_{22}:\left\{   \begin{aligned}      &amp;\Delta &gt; 0\text{：双曲型(Hyperbolic)}\\      &amp;\Delta = 0\text{：抛物型(Parabolic)}\\      &amp;\Delta &lt; 0\text{：椭圆型(Elliptic)}   \end{aligned}\right.\]</span></p><p>同样的对于二次曲线也有类似的分类</p><p><span class="math display">\[a_{11}x^2+2a_{12}xy+a_{22}y^2+2b_1x+2b_2y+c=0\]</span></p><p><span class="math display">\[\Delta =a_{12}^2-a_{11}a_{22}:\left\{   \begin{aligned}      &amp;\Delta &gt; 0\text{：双曲型曲线}\\      &amp;\Delta = 0\text{：抛物线}\\      &amp;\Delta &lt; 0\text{：椭圆}   \end{aligned}\right.\]</span></p><h3 id="两个自变量情形的化简">两个自变量情形的化简</h3><p>目标为通过自变量变换，使得方程的形式化简，有时甚至可以求出其通解</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;\xi=\xi(x,y)\\      &amp;\eta=\eta(x,y)   \end{aligned}\right.\]</span></p><p>可逆要求其 Jacobbi 行列式不为 <spanclass="math inline">\(0\)</span></p><p><span class="math display">\[J=\frac{\partial(\xi,\eta)}{\partial(x,y)}=\left|   \begin{array}{cc}      \xi_x &amp; \xi_y\\      \eta_x &amp; \eta_y\\   \end{array}\right|\neq 0\]</span></p><p>对其变换前后的方程类型不变，并且</p><p><span class="math display">\[\bar{\Delta}=J^2\Delta\]</span></p><h2 id="解析函数">解析函数</h2><h3 id="复数及其表示">复数及其表示</h3><h4 id="复数的定义">复数的定义</h4><p>形如</p><p><span class="math display">\[x+iy\quad (x,y\in\mathbf{R})\]</span></p><p>的数称为复数， <span class="math inline">\(\displaystylei=\sqrt{-1}\)</span> 为虚数单位</p><ul><li><span class="math inline">\(x\)</span> 称为复数的实部，记为 <spanclass="math inline">\(\mathrm{Re}\,z\)</span></li><li><span class="math inline">\(y\)</span> 称为复数的虚部，记为 <spanclass="math inline">\(\mathrm{Im}\,z\)</span></li></ul><h4 id="复数的表示">复数的表示</h4><h5 id="代数表示">代数表示</h5><p><span class="math display">\[z=x+iy\]</span></p><h5 id="几何表示">几何表示</h5><p>复数与有序实数对 <span class="math inline">\((x,y)\)</span>一一对应，那么在平面直角坐标系中，可以将复数 <spanclass="math inline">\(z=x+iy\)</span> 看作平面上点 <spanclass="math inline">\((x,y)\)</span> 或向量 <spanclass="math inline">\(\vec{OP}\)</span>，从而复数与复平面上的向量一一对应</p><ul><li><p>向量 <span class="math inline">\(\vec{OP}\)</span> 的模</p><p><span class="math display">\[\vert z \vert =\sqrt{x^2+y^2}\]</span></p></li><li><p>向量 <span class="math inline">\(\vec{OP}\)</span> 与 <spanclass="math inline">\(x\)</span> 轴的夹角称为幅角，记为 <spanclass="math inline">\(\theta=\arg z\)</span>，当 <spanclass="math inline">\(z=0\)</span> 时， <spanclass="math inline">\(\theta\)</span> 未定义，当 <spanclass="math inline">\(z\neq 0\)</span> 时， <spanclass="math inline">\(\theta\)</span> 为</p><p><span class="math display">\[\arg z=\left\{   \begin{aligned}       &amp;\arctan \frac{y}{x},&amp;&amp;(x&gt;0)\\       &amp;\arctan \frac{y}{x}+\pi,&amp;&amp;(x&lt;0,y\ge 0)\\       &amp;\arctan \frac{y}{x}-\pi,&amp;&amp;(x&lt;0,y&lt;0)\\       &amp;\frac{\pi}{2},&amp;&amp;(x=0,y&gt;0)\\       &amp;-\frac{\pi}{2},&amp;&amp;(x=0,y&lt;0)\\   \end{aligned}\right.\]</span></p></li></ul><h5 id="三角表示与指数表示">三角表示与指数表示</h5><p>直角坐标和极坐标的关系</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;x=r\cos \theta\\      &amp;y=r\sin \theta   \end{aligned}\right.\]</span></p><p>则复数 <span class="math inline">\(z=x+iy\)</span>的<strong>三角表示</strong>为</p><p><span class="math display">\[z=r\cos \theta +ir\sin \theta=r(\cos \theta +i\sin \theta)\]</span></p><ul><li><span class="math inline">\(r=\vert z \vert=\sqrt{x^2+y^2}\)</span></li><li><span class="math inline">\(\theta=\arg z\)</span></li></ul><p>利用 Euler 公式可将三角表示转化为<strong>指数表示</strong></p><p><span class="math display">\[z=re^{i\theta}\]</span></p><p>对 <span class="math inline">\(e^{i\theta}\)</span>进行泰勒展开可以证明 Eular 公式</p><h3 id="复数的运算及其几何意义">复数的运算及其几何意义</h3><h4 id="复数的四则运算">复数的四则运算</h4><p>与实数一致，并且满足交换律、结合律和分配律</p><h5 id="复数的三角不等式">复数的三角不等式</h5><p><span class="math display">\[\vert z_1+z_2 \vert \le \vert z_1 \vert +\vert z_2 \vert\]</span></p><p><span class="math display">\[\vert z_1-z_2 \vert \ge \left|\vert z_1 \vert -\vert z_2 \vert\right|\]</span></p><h5 id="复数积与商的模和幅角公式">复数积与商的模和幅角公式</h5><p>设 <spanclass="math inline">\(z_1=r_1(\cos\theta_1+i\sin\theta_1)\)</span>，<spanclass="math inline">\(z_2=r_2(\cos\theta_2+i\sin\theta_2)\)</span>，则</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;z_1z_2=r_1r_2[\cos(\theta_1+\theta_2)+i\sin(\theta_1+\theta_2)]\\      &amp;\frac{z_1}{z_2}=\frac{r_1}{r_2}[\cos(\theta_1-\theta_2)+i\sin(\theta_1-\theta_2)]   \end{aligned}\right.\]</span></p><p>即</p><p><span class="math display">\[\left\{   \begin{aligned}      &amp;|z_1z_2|=|z_1|\cdot |z_2|\\      &amp;\arg(z_1z_2)=\arg z_1+\arg z_2   \end{aligned}\right.\]</span></p><p>由于幅角的多值性，我们将幅角的规则理解为：对于任意一个幅角 <spanclass="math inline">\(\arg(z_1z_2)\)</span>，都存在幅角 <spanclass="math inline">\(\arg z_1\)</span> 和 <spanclass="math inline">\(\arg z_2\)</span> 使得 <spanclass="math inline">\(\arg(z_1z_2)=\arg z_1+\arg z_2\)</span></p><h5 id="复数乘方和方根">复数乘方和方根</h5><h6 id="乘方">乘方</h6><p>设 <span class="math inline">\(z=r(\cos\theta+i\sin\theta)\)</span>，则</p><p><span class="math display">\[z^n=r^n[\cos(n\theta)+i\sin(n\theta)]\]</span></p><p>当 <span class="math inline">\(r=1\)</span> 时，为 De Moivre 公式</p><p><span class="math display">\[(\cos\theta +i\sin\theta)^n=\cos(n\theta)+i\sin(n\theta)\]</span></p><h6 id="方根">方根</h6><p>设 <span class="math inline">\(z=r(\cos\theta+i\sin\theta)\)</span></p><p><span class="math display">\[z_k=r^{\frac{1}{n}}\left[\cos\left(\frac{\theta+2k\pi}{n}\right)+i\sin\left(\frac{\theta+2k\pi}{n}\right)\right],\quadk=0,1,2,\ldots,n-1\]</span></p><h3 id="平面点集和区域">平面点集和区域</h3><h4 id="复平面上的点集">复平面上的点集</h4><p>复平面上的点集 <span class="math inline">\(D\)</span>是复平面上某些点的集合，记为 <span class="math inline">\(D\subset\mathbf{C}\)</span></p><p>由不等式 <spanclass="math inline">\(|z-z_0|&lt;\varepsilon_0\)</span> 所确定的点集称为<span class="math inline">\(z\)</span> 的 <spanclass="math inline">\(\varepsilon_0\)</span> 邻域，记为 <spanclass="math inline">\(N(z_0,\varepsilon_0)\)</span></p><p>设 <span class="math inline">\(E\)</span> 为一点集，<spanclass="math inline">\(z_0\)</span> 为复平面上的一点，且 <spanclass="math inline">\(z_0\in E\)</span>，如果 $ _0&gt;0$，使得 <spanclass="math inline">\(N(z_0,\varepsilon_0)\subset E\)</span>，则称 <spanclass="math inline">\(z_0\)</span> 为点集 <spanclass="math inline">\(E\)</span> 的内点；如果 <spanclass="math inline">\(\exists\varepsilon_0&gt;0\)</span>，使得 <spanclass="math inline">\(N(z_0,\varepsilon_0)\)</span> 中的点都不属于 <spanclass="math inline">\(E\)</span>，则称 <spanclass="math inline">\(z_0\)</span> 为点集 <spanclass="math inline">\(E\)</span> 的外点；如果对于任意 <spanclass="math inline">\(\varepsilon&gt;0\)</span>， <spanclass="math inline">\(N(z_0,\varepsilon)\)</span> 中既有属于 <spanclass="math inline">\(E\)</span> 的点，又有不属于 <spanclass="math inline">\(E\)</span> 的点，则称 <spanclass="math inline">\(z_0\)</span> 为点集 <spanclass="math inline">\(E\)</span> 的边界点</p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>数理方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理3笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="大学物理-3-笔记">大学物理 3 笔记</h1><h2 id="基本常数">基本常数</h2><table><thead><tr><th>名称</th><th>符号</th><th>数值</th><th>单位</th></tr></thead><tbody><tr><td>斯特番常数</td><td><span class="math inline">\(\sigma\)</span></td><td><span class="math inline">\(5.67\times 10^{-8}\)</span></td><td><span class="math inline">\(W\cdot m^{-2}\cdot K^{-4}\)</span></td></tr><tr><td>维恩常数</td><td><span class="math inline">\(b\)</span></td><td><span class="math inline">\(2.898\times 10^{-3}\)</span></td><td><span class="math inline">\(m\cdot K\)</span></td></tr><tr><td>玻尔兹曼常数</td><td><span class="math inline">\(k\)</span></td><td><span class="math inline">\(1.38\times 10^{-23}\)</span></td><td><span class="math inline">\(J\cdot K^{-1}\)</span></td></tr><tr><td>普朗克常数</td><td><span class="math inline">\(h\)</span></td><td><span class="math inline">\(6.63\times 10^{-34}\)</span></td><td><span class="math inline">\(J\cdot s\)</span></td></tr><tr><td>康普顿波长</td><td><span class="math inline">\(\lambda_c\)</span></td><td><span class="math inline">\(0.02426\)</span></td><td><span class="math inline">\(\text{Å}\)</span></td></tr><tr><td>里德伯常数</td><td><span class="math inline">\(R\)</span></td><td><span class="math inline">\(1.097\times 10^{7}\)</span></td><td><span class="math inline">\(m^{-1}\)</span></td></tr></tbody></table><h2 id="算符">算符</h2><table><thead><tr><th>名称</th><th>表达式</th></tr></thead><tbody><tr><td>能量算符</td><td><span class="math inline">\(\hat{E} = i\hbar\frac{\partial}{\partialt}\)</span></td></tr><tr><td>动量算符</td><td><span class="math inline">\(\hat{p} = -i\hbar\nabla\)</span></td></tr><tr><td>哈密顿算符</td><td><span class="math inline">\(\hat{H} = -\frac{\hbar^2}{2m}\nabla ^2 +U(\boldsymbol{r},t)\)</span></td></tr><tr><td>角动量算符</td><td><span class="math inline">\(\hat{L} = \hat{r}\times\hat{p}\)</span></td></tr></tbody></table><h2 id="量子物理基础">量子物理基础</h2><h3 id="黑体辐射">黑体辐射</h3><h4 id="热辐射的基本概念">热辐射的基本概念</h4><ul><li>所有物在有限体温度下都会发射电磁波，这种与温度有关的辐射称为热辐射(heat radiation).</li><li>热辐射是连续谱.</li><li>基本性质：温度越高，发射的能量越大，电磁波的短波成分能量越大.</li><li>平衡热辐射：热辐射是热平衡状态下的辐射.</li></ul><h5 id="热辐射基本参数">热辐射基本参数</h5><p><strong>单色辐出度 <spanclass="math inline">\(M_{\lambda}(W/m^3)\)</span></strong></p><p>物体单位表面在单位时间内发出的波长在 <spanclass="math inline">\(\lambda\)</span>附近单位波长间隔内的电磁波的能量，用于描述物体辐射能量的能力</p><p><span class="math display">\[M_{\lambda}(T)=\frac{\mathrm{d}E_{\lambda}}{\mathrm{d}\lambda}\]</span></p><p><strong>辐出度 <spanclass="math inline">\(M(T)(W/m^2)\)</span></strong></p><p>物体从单位面积上发射的所有波长的辐射总功率</p><p><span class="math display">\[M(t)=\int _0^{+\infty}M_{\lambda}(T)\,\mathrm{d}\lambda\]</span></p><p><strong>吸收比 <span class="math inline">\(\alpha(T)\)</span>和反射比 <span class="math inline">\(r(T)\)</span></strong></p><ul><li><strong>吸收比</strong>：辐射从外界入射到物体表面时，吸收的能量和入射的能量之比，是吸收能力的量度.</li></ul><p><span class="math display">\[\alpha(T)=\frac{E^\text{吸收}}{E^\text{入射}}\]</span></p><ul><li><strong>反射比</strong>：辐射从外界入射到物体表面时，反射的能量和入射的能量之比，是反射能力的量度.</li></ul><p><span class="math display">\[r(T)=\frac{E^\text{反射}}{E^\text{入射}}\]</span></p><p><strong>单色吸收比 <spanclass="math inline">\(\alpha(\lambda,T)\)</span> 和单色反射比 <spanclass="math inline">\(r(\lambda,T)\)</span></strong></p><ul><li><strong>单色吸收比</strong>：当辐射从外界入射到物体表面时，吸收的波长从<span class="math inline">\(\lambda\)</span> 到 <spanclass="math inline">\(\lambda +\mathrm{d}\lambda\)</span>波长间隔内的能量 <spanclass="math inline">\(E_\lambda^\text{吸收}\mathrm{d}\lambda\)</span>和入射的能量 <spanclass="math inline">\(E_\lambda^\text{入射}\mathrm{d}\lambda\)</span>之比.</li></ul><p><span class="math display">\[\alpha(\lambda,T)=\frac{E_\lambda^\text{吸收}}{E_\lambda^\text{入射}}\]</span></p><ul><li><strong>单色反射比</strong>：当辐射从外界入射到物体表面时，反射的波长从<span class="math inline">\(\lambda\)</span> 到 <spanclass="math inline">\(\lambda +\mathrm{d}\lambda\)</span>波长间隔内的能量 <spanclass="math inline">\(E_\lambda^\text{反射}\mathrm{d}\lambda\)</span>和入射的能量 <spanclass="math inline">\(E_\lambda^\text{入射}\mathrm{d}\lambda\)</span>之比.</li></ul><p><span class="math display">\[r(\lambda,T)=\frac{E_\lambda^\text{反射}}{E_\lambda^\text{入射}}\]</span></p><p>对于不透明物体，有 <spanclass="math inline">\(\alpha(\lambda,T)+r(\lambda,T)=1\)</span>.</p><h5 id="基尔霍夫定律">基尔霍夫定律</h5><p>一个好的发射体一定是个好的吸收体（黑白盘子实验） <imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E7%99%BD%E7%9B%98%E5%AE%9E%E9%AA%8C.png"alt="黑白盘实验" /></p><p>温度一定时物体在某波长处的单色辐出度与单色吸收比的比值与物体及物体表面的性质无关，即</p><p><span class="math display">\[\frac{M_1(\lambda,T)}{\alpha_1(\lambda,T)} =\frac{M_2(\lambda,T)}{\alpha_2(\lambda,T)}=\ldots=M_0(\lambda,T).\]</span></p><p>其中 <span class="math inline">\(M_0(\lambda,T)\)</span>是一个只与波长和温度有关，与物体材料、表面状态无关的函数，称为黑体辐射强度，是黑体的单色辐出度.</p><h5 id="黑体">黑体</h5><p>能完全吸收各种波长电磁波而无反射的物体是黑体黑体是理想模型，可以建立只有小孔的空腔，小孔是黑体，空腔内的辐射是黑体辐射</p><h6 id="黑体辐射的基本规律">黑体辐射的基本规律</h6><p>温度一定时，黑体辐射的强度与波长有关，存在一定的波长 <spanclass="math inline">\(\lambda _{\max}\)</span>使得辐射强度最大，称为黑体辐射的主波长. <imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%9B%BE.png"alt="黑体辐射图" /></p><ul><li><strong>斯特番-玻尔兹曼定律(J. Stefan, L. Boltzmann)</strong>实验证明，黑体的总辐出度 <span class="math inline">\(M_0(T)\)</span>与温度 <span class="math inline">\(T\)</span> 的四次方成正比</li></ul><p><span class="math display">\[M_0(T)=\sigma T^4\]</span></p><p>其中 <span class="math inline">\(\sigma = 5.67\times 10^{-8} W\cdotm^{-2}\cdot K^{-4}\)</span>，称为斯特番常数. 1879年斯特番实验总结得到，1884 年玻尔兹曼理论证明. 表明热辐射对温度的敏感性<span class="math inline">\(\propto T^4\)</span>.</p><ul><li>维恩位移定律(W. Wien) 黑体辐射中单色辐出值的极值波长 <spanclass="math inline">\(\lambda_m\)</span> 与黑体温度 <spanclass="math inline">\(T\)</span> 之积为常数</li></ul><p><span class="math display">\[\lambda_mT=b\]</span></p><p>其中 <span class="math inline">\(b=2.898\times 10^{-3}m\cdotK\)</span> ，为 Wien 常数.</p><h5id="普朗克的能量子假说和黑体辐射公式">普朗克的能量子假说和黑体辐射公式</h5><h6 id="维恩公式">维恩公式</h6><p><span class="math display">\[M_0(\nu,T)=\alpha\nu^3e^{-\beta/T}\]</span></p><ul><li>在高频段与实验符合得很好，但是在低频段明显偏离实验曲线</li></ul><h6 id="瑞利-金斯公式">瑞利-金斯公式</h6><p><span class="math display">\[M_0(\nu,T)=\frac{2\pi \nu^2}{c^2}kT\]</span></p><ul><li>其中 <span class="math inline">\(k=1.38\times 10^{-23} J\cdotK^{-1}\)</span> ，为玻尔兹曼常数.</li><li>低频段与实验符合得很好，但是在高频段明显偏离实验曲线.</li><li>且当 <span class="math inline">\(\nu\to\infty\)</span> 时，<spanclass="math inline">\(M_0(\nu,T)\to \infty\)</span>，称为紫外灾难.</li></ul><h6 id="普朗克公式">普朗克公式</h6><p>普朗克以适用于高频段的维恩公式和适用于低频段的瑞利-金斯公式为基础，提出了<strong>普朗克黑体辐射公式</strong>，是一个半经验公式.</p><p><span class="math display">\[M_0(\nu,T)=\frac{2\pi\nu^2}{c^2}\frac{h\nu}{e^{\frac{h\nu}{kT}}-1}\]</span></p><ul><li><p>其中 <span class="math inline">\(h=6.63\times 10^{-34}J\cdots\)</span> 为普朗克常量.</p></li><li><p>普朗克公式在整个频段都符合实验结果.</p></li><li><p>普朗克认为：空腔内壁的分子、原子的振动可以看成是许多带电的简谐振子，这些简谐振子可以辐射和吸收能量，并与空腔内的辐射达到平衡。从空腔小孔辐射出的电磁波，就是由这些空腔内壁的简谐振子辐射出的。他假定对于频率为<span class="math inline">\(\nu\)</span>的振子，振子能量不是连续的，而是分立的，它的取值是某一最小能量 <spanclass="math inline">\(h\)</span>的整数倍，即<strong>当振子吸收或放出能量时，以 <spanclass="math inline">\(h\nu\)</span> 为单位.</strong></p></li><li><p>我们计 <span class="math inline">\(\varepsilon =h\nu\)</span>，称为<strong>能量子（quanta of enmergy）</strong></p></li><li><p>由普朗克公式可以推出其他热辐射公式</p><p><span class="math display">\[M_0(\nu,T)=\frac{2\pi\nu^2}{c^2}\frac{h\nu}{e^{\frac{h\nu}{kT}}-1}\ \\left\{  \begin{aligned}  &amp;\text{积分} \rightarrow M=\sigma T^4, \ \\text{斯特番-玻尔兹曼定律}\\  &amp;\text{求导} \rightarrow \lambda_mT=b. \ \ \text{维恩位移定律}\\  &amp;\text{低频极限} \rightarrow M_0(\nu,T)=\frac{2\pi\nu^2}{c^2}kT, \\ \text{瑞利-金斯公式}\\  &amp;\text{高频极限} \rightarrow M_0(\nu,T)=\alpha\nu^3e^{-\beta/T}, \\ \text{维恩公式}  \end{aligned}\right.\]</span></p></li></ul><h3 id="光电效应photoelectric-effect">光电效应（Photoelectriceffect）</h3><h4 id="实验模型">实验模型</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250228160736.png"alt="实验装置" /><figcaption aria-hidden="true">实验装置</figcaption></figure><p>当光照在金属表面，电子从金属中脱出的现象，称为光电效应</p><h4 id="基本参数">基本参数</h4><h4 id="饱和电流">饱和电流</h4><p>实验表明，当入射光强度不变，加速电势差 <spanclass="math inline">\(U\)</span> 越大，光电流 <spanclass="math inline">\(I\)</span>也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为<strong>饱和电流</strong>。若改变入射光强，<strong>饱和电流的大小与入射光强成正比</strong>，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比.</p><h4 id="遏制电压差">遏制电压差</h4><p>改变阴极与阳极之间的电压，当电压增大到一定值时，光电流减小到零，此时的电压差称为<strong>遏制电压差</strong>。遏制电压差的大小与入射光的频率有关，与光强无关.光电子从表面逸出的最大初速度 <span class="math inline">\(v_m\)</span>满足：</p><p><span class="math display">\[\frac{1}{2} m v_m^2 = eU_0\]</span></p><h4 id="爱因斯坦的光量子论">爱因斯坦的光量子论</h4><p>电子辐射由以光速 <span class="math inline">\(c\)</span>运动的局限于空间某小范围的光量子（光子），即光子流组成 光子的能量为<span class="math inline">\(\varepsilon = h\nu\)</span> ，动量为 <spanclass="math inline">\(p = \frac{h}{\lambda}\)</span></p><ul><li>光电效应的基本方程</li></ul><p><span class="math display">\[h \nu=\frac{1}{2} m v_{\mathrm{m}}^{2}+A\]</span></p><p>其中 <spanclass="math inline">\(\frac{1}{2}mv_{\mathrm{m}}^{2}\)</span>是光电子的最大初动能.</p><p><strong>解释：</strong>光照射金属时，电子吸收光子，能量增加，一部分用于克服金属脱出功，一部分增加电子的初动能</p><h4 id="光的波粒二象性">光的波粒二象性</h4><ul><li>一些情况下，光的波动性表现得很明显，如干涉、衍射、偏振等现象.</li><li>一些情况下，光的粒子性表现得很明显，如光电效应、康普顿散射等现象.</li></ul><p>这被称为光的波粒二象性</p><ul><li>光不是牛顿经典粒子，也不是康普顿的经典波</li></ul><p>基本关系式</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;\varepsilon = h\nu \quad \text{粒子性}\\    &amp;p = \frac{\varepsilon}{c}=\frac{h}{\lambda} \quad \text{波动性}  \end{aligned}\right.\]</span></p><h3 id="康普顿散射">康普顿散射</h3><p>在散射的 X射线中，存在与入射光波长相等的波，也存在波长比入射光波长大的波，这种现象称为<strong>康普顿散射</strong>.</p><h4 id="特点">特点</h4><p><span class="math display">\[\Delta \lambda = \lambda&#39; - \lambda = \lambda _{c} (1-\cos\theta)\]</span></p><p>其中</p><ul><li><span class="math inline">\(\lambda_c =\frac{h}{m_{0}c}= 0.02426\text{Å}\)</span> 被称为康普顿波长. 当光子的波长等于 <spanclass="math inline">\(\lambda_c\)</span> 时，其能量等于电子的能量 <spanclass="math inline">\(m_{c}c^{2} =1.511 \text{MeV}\)</span> .</li><li><span class="math inline">\(\theta\)</span> 为散射角.</li></ul><ol type="1"><li>波长改变量随散射角 <span class="math inline">\(\theta\)</span>的增大而增大</li><li>新成分的相对强度随散射角 <span class="math inline">\(\theta\)</span>的增大而增大</li><li>同一个散射角下，所有散射物质的波长差相等</li><li>随着原子序数的增加，原波长成分的相对强度增大，即对对于轻元素康普顿散射更为明显.</li></ol><p>其中 3、4 是由吴有训发现的</p><h4 id="推导">推导</h4><p>使用动量守恒和能量守恒进行推导（X射线光子与静止的自由电子的碰撞）</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250302131054.png"alt="康普顿散射推导" /><figcaption aria-hidden="true">康普顿散射推导</figcaption></figure><p>由能量守恒：</p><p><span class="math display">\[\begin{equation}  h\nu + m_{e}c^{2} = h\nu&#39; +mc^{2}\end{equation}\]</span></p><p>其中 <spanclass="math inline">\(m=\frac{m_{e}}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></p><p>由 <span class="math inline">\(x\)</span> 方向上的动量守恒</p><p><span class="math display">\[\begin{equation}  \frac{h\nu _0}{c} = \frac{h\nu}{c} \cos{\theta} + mv\cos{\varphi}\end{equation}\]</span></p><p>由 <span class="math inline">\(y\)</span> 方向上的动量守恒</p><p><span class="math display">\[\begin{equation}  0 = \frac{h\nu}{c} \sin{\theta} - mv\sin{\varphi}\end{equation}\]</span></p><p>解方程组即可得到康普顿散射的公式</p><p><span class="math display">\[\Delta \lambda = \lambda _{0} -\lambda =\frac{h}{m_{e}c}(1-\cos{\theta})\]</span></p><h3 id="波尔氢原子理论">波尔氢原子理论</h3><h4 id="原子模型的发展">原子模型的发展</h4><ol type="1"><li>汤姆逊的面包夹葡萄干模型</li><li>卢瑟福的 <span class="math inline">\(\alpha\)</span>粒子散射实验和原子的核结构模型</li></ol><h4 id="氢原子光谱">氢原子光谱</h4><h5 id="公式">公式</h5><h6 id="里德伯公式">里德伯公式</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)\quad(m=1,2,3,\cdots;n=m+1,m+2,m+3,\cdots)\]</span></p><p>其中：</p><ul><li><span class="math inline">\(\widetilde{\nu} =\frac{1}{\lambda}\)</span> 为波长的倒数，即波数</li><li><span class="math inline">\(R=1.097\times 10^{7}m^{-1}\)</span>为里德伯常数</li></ul><h6 id="赖曼系-m1-紫外区">赖曼系（ <spanclass="math inline">\(m=1\)</span> ，紫外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{1^{2}}-\frac{1}{n^{2}}\right)\quad(n=2,3,4,\cdots)\]</span></p><h6 id="巴尔末系-m2">巴尔末系（ <span class="math inline">\(m=2\)</span>）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{2^{2}}-\frac{1}{n^{2}}\right)\quad(n=3,4,5,\cdots)\]</span></p><h6 id="帕邢系-m3-红外区">帕邢系（ <spanclass="math inline">\(m=3\)</span> ，红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{3^{2}}-\frac{1}{n^{2}}\right)\quad(n=4,5,6,\cdots)\]</span></p><h6 id="布拉开系-m4-近红外区">布拉开系 （ <spanclass="math inline">\(m=4\)</span> ，近红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{4^{2}}-\frac{1}{n^{2}}\right)\quad(n=5,6,7,\cdots)\]</span></p><h6 id="普丰德系-m5-远红外区">普丰德系（ <spanclass="math inline">\(m=5\)</span> ，远红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{5^{2}}-\frac{1}{n^{2}}\right)\quad(n=6,7,8,\cdots)\]</span></p><h6 id="汉弗莱系-m6-远红外区">汉弗莱系 （ <spanclass="math inline">\(m=6\)</span> ，远红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{6^{2}}-\frac{1}{n^{2}}\right)\quad(n=7,8,9,\cdots)\]</span></p><h5 id="波尔的氢原子模型">波尔的氢原子模型</h5><h5 id="波尔假设">波尔假设</h5><ol type="1"><li><p>原子中的电子只能在一些分离的轨道上运行，在每一个轨道上运动的电子处于不稳定的能量状态（定态<span class="math inline">\(EW_{n}\)</span> ），不向外辐射能量</p></li><li><p><strong>频率条件：</strong>当电子从一个定态跃迁另一个定态时，发射或吸收一个光子，$h_{nm}=E_n-E_m$</p></li><li><p><strong>结论：</strong></p><p><span class="math display">\[\nu=\frac{E_{n}-E_{m}}{h}=\frac{m e^{4}}{8 \varepsilon _{0}^{2}h^{3}}\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)\]</span></p></li></ol><h5 id="波尔角动量量子化条件">波尔角动量量子化条件</h5><p><span class="math display">\[L=n \frac{h}{2 \pi}=n \hbar,n=1,2,3,\cdots\]</span></p><p>其中， <span class="math inline">\(n\)</span> 为量子数， <spanclass="math inline">\(\hbar=\frac{h}{2\pi}\)</span> 为约化普朗克常数.<strong>定量计算：</strong> 由电子的向心力和轨道角动量的量子化得到</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;m\frac{v^{2}}{r}=\frac{1}{4\pi \varepsilon _{0}}\cdot\frac{e^2}{r^2}\\    &amp;L=mvr=n\hbar  \end{aligned}\right.\]</span></p><p>解得：</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;r_n=n^2\frac{4\pi \varepsilon _{0} \hbar^{2}}{m e^{2}}=n^2r_1\\    &amp;v_n=\frac{e^{2}}{4\pi \varepsilon _{0} n \hbar}=\alpha\frac{c}{n}  \end{aligned}\right.\]</span></p><p>其中 <span class="math inline">\(r_1 = \frac{4\pi \varepsilon _{0}\hbar^{2}}{m e^{2}} = 0.529\text{Å}\)</span>为氢原子中电子的最小轨道</p><p><strong>轨道能量：</strong></p><p><span class="math display">\[E_n =\frac{1}{2}mv_n^2 + (-\frac{1}{4\pi \varepsilon _0}\cdot\frac{e^2}{r_n^2}) =-\frac{me^4}{8\varepsilon_0^2h^2n^2}=-\frac{1}{n^2}E_1\]</span></p><p>其中 <span class="math inline">\(E_1 = 13.6eV\)</span>为氢原子基态能量</p><h5 id="波尔的对应原理">波尔的对应原理</h5><p>当 <span class="math inline">\(n\rightarrow +\infty\)</span>时，<span class="math inline">\(r_n \rightarrow 0\)</span> ，<spanclass="math inline">\(E_n \rightarrow 0\)</span> ，<spanclass="math inline">\(\displaystyle \Delta E = E_n - E_{n+1} =\frac{me^4}{4 \varepsilon _0h^2n^3}\rightarrow 0\)</span>，即能级间距趋于零，能级连续，形成连续谱.</p><h2 id="量子动力学入门">量子动力学入门</h2><p>量子力学的两条路线</p><ol type="1"><li>波动力学 普朗克、爱因斯坦、德布罗意、薛定谔</li><li>矩阵力学 普朗克、波尔、海森堡</li></ol><ul><li>最后由玻恩给出统计解释</li><li>波动力学和矩阵力学完全等价</li></ul><h3 id="物质波">物质波</h3><h4 id="德布罗意假说">德布罗意假说</h4><p>德布罗意假设：实物具有波粒二象性</p><table><thead><tr><th>量</th><th>粒子性</th><th>波动性</th></tr></thead><tbody><tr><td><span class="math inline">\(E\)</span></td><td><span class="math inline">\(mc^2\)</span></td><td><span class="math inline">\(h\nu\)</span></td></tr><tr><td><span class="math inline">\(p\)</span></td><td><span class="math inline">\(mv\)</span></td><td><span class="math inline">\(\frac{h}{\lambda}\)</span></td></tr></tbody></table><h4 id="德布罗意原子稳定性驻波思想">德布罗意原子稳定性驻波思想</h4><p>原子中的电子在原子核库仑场中运动表现得波动性具有驻波得特征，驻波的稳定性使得电子不会坠落到原子核内</p><h5 id="能量的量子化">能量的量子化</h5><ul><li><span class="math inline">\(\lambda = \frac{2L}{n}\)</span></li><li><span class="math inline">\(p=\frac{h}{2L}n\)</span></li><li><span class="math inline">\(E = \frac{p^2}{2m} =\frac{h^2}{8mL^2}n^2\)</span></li></ul><h5id="物质波的概念对波尔轨道角动量量子化条件的解释">物质波的概念对波尔轨道角动量量子化条件的解释</h5><p>德布罗意认为电子在经典的圆轨道上运动，形成一个环形驻波</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308170617.png"alt="电子驻波" /><figcaption aria-hidden="true">电子驻波</figcaption></figure><p>电子绕行原子一周，圆周长应等于波长的整数倍</p><p><span class="math display">\[2\pi r = n\lambda\]</span></p><p><span class="math display">\[L = rmv = \frac{n\lambda}{2\pi} \cdot \frac{h}{\lambda} = n\hbar\]</span></p><h4 id="物质波的实验验证">物质波的实验验证</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308171040.png"alt="物质波的实验验证" /><figcaption aria-hidden="true">物质波的实验验证</figcaption></figure><h5 id="布拉格公式">布拉格公式</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png"alt="布拉格公式推导" /><figcaption aria-hidden="true">布拉格公式推导</figcaption></figure><p><span class="math display">\[\delta = 2d\sin\theta = n\lambda \quad (n=1,2,3,\cdots)\]</span></p><h4 id="微观粒子波动性的应用">微观粒子波动性的应用</h4><ul><li>显微镜使用电子波提大大提高了分辨率</li></ul><h3 id="波函数的统计解释">波函数的统计解释</h3><h4 id="对电子是什么的两种经典观点">对电子是什么的两种经典观点</h4><ol type="1"><li>电子是波包<ul><li>由两种不同频率的波合成一个波包</li><li>这种观点夸大了波动性，忽略了粒子性<ol type="1"><li>不同频率波在媒质中传播速度不同，波包会逐步扩展而消失，但是实际粒子并没有消失说明波包是电子的某种实际结果</li><li>在媒质界面上一部分反射，一部分折射，但实际例子或整个反射，或整个折射</li></ol></li></ul></li><li>经典粒子<ul><li>粒子是基本的，波动性源于粒子与粒子的相互作用，或者粒子与狭缝周围原子的相互作用。</li><li>这种观点夸大了粒子性，抹杀了波动性<ol type="1"><li>电子的双缝衍射实验表明电子具有波动性</li><li>电子的波动性并不是很多电子在空间聚集在一起时的相互作用的结果，而是单个电子就具有波动性，是电子自己和自己的干涉</li></ol></li></ul></li></ol><h4 id="对波函数的统计解释">对波函数的统计解释</h4><p>1926 年，玻恩提出了对波函数 <spanclass="math inline">\(\Psi(\boldsymbol{r},t)\)</span>的统计解释，将实物粒子的波动性和粒子性有机地结合在一起。</p><h5 id="对亮度的解释">对亮度的解释</h5><ol type="1"><li>波的观点 亮度是该点德布罗意波强度的大小</li><li>粒子的观点亮度与该点附近出现的感光点的数目成正比，即与该点附近电子的数目成正比，即与该点附近电子的概率成正比</li></ol><h5 id="玻恩对波函数的统计解释">玻恩对波函数的统计解释</h5><p>波函数 <span class="math inline">\(\Psi\)</span>是描述粒子在空间概率分布的<strong>概率振幅</strong>，其模的平方 <spanclass="math inline">\(\vert \Psi(\boldsymbol{r},t)\vert ^2 =\Psi(\boldsymbol{r},t) ^{*} \Psi(\boldsymbol{r},t)\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻，在坐标 <spanclass="math inline">\(\boldsymbol{r}\)</span>附近单位体积中发现一个粒子的概率，被称为<strong>概率密度</strong></p><ul><li>目前对波函数最好的解释是概率波</li><li><span class="math inline">\(t\)</span> 时刻，一个粒子处于 <spanclass="math inline">\(x\rightarrow x+\mathrm{d}x\)</span> ，<spanclass="math inline">\(y\rightarrow y+\mathrm{d}y\)</span> ，<spanclass="math inline">\(z\rightarrow z+\mathrm{d}z\)</span> 的概率为 <spanclass="math inline">\(\vert \Psi(x,y,z,t)\vert^2\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span>，记 <spanclass="math inline">\(\rho(x,y,z,t)=\vert \Psi(x,y,z,t)\vert ^2\)</span>为概率密度.</li><li>在空间 <span class="math inline">\(\Omega\)</span>中发现粒子的概率为 <span class="math inline">\(\displaystyle\int_{\Omega}\rho(x,y,z,t)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span></li></ul><h4 id="波函数满足的条件">波函数满足的条件</h4><ol type="1"><li>单值性<ul><li>在空间的任何地方，概率密度只能有一个，所以一般波函数在任何地方都是单值的；</li></ul></li><li>有限性<ul><li>粒子必然在空间的某处出现，概率综合为 1，所以在空间的任何有限体积元<span class="math inline">\(\mathrm{d}V\)</span> 中，概率密度 <spanclass="math inline">\(\rho(x,y,z,t)\)</span> 有限；</li><li><strong>归一化条件</strong>：<spanclass="math inline">\(\displaystyle \int_\Omega \vert\Psi(\boldsymbol{r},t)\vert ^{2}\,\mathrm{d} V =1\)</span> ，其中 <spanclass="math inline">\(\Omega\)</span> 为全空间；</li><li>归一化条件并不能排除在某些孤立奇点上 <spanclass="math inline">\(\vert \Psi(\boldsymbol{r},t)\vert ^2 \rightarrow\infty\)</span></li></ul></li><li>连续性<ul><li>波函数一阶导数连续（即使在势能函数有限大小间断点处）</li></ul></li></ol><h3 id="不确定度关系">不确定度关系</h3><h4 id="形式-1位置-动量不确定关系">形式 1（位置-动量不确定关系）</h4><p>当粒子处在 <span class="math inline">\(x\)</span> 方向的一个有限范围<span class="math inline">\(\Delta x\)</span> 内时，其动量 <spanclass="math inline">\(p_x\)</span> 的有一个不完全确定的数值范围 <spanclass="math inline">\(\Delta p_x\)</span> ，两者的乘积满足：</p><p><span class="math display">\[\Delta x \Delta p \geq \frac{\hbar}{2}\]</span></p><p>若记 <span class="math inline">\(k=\frac{2\pi}{\lambda}\)</span>，则</p><p><span class="math display">\[\Delta x \Delta k \geq \frac{1}{2}\]</span></p><ul><li><strong>含义</strong>：微观粒子的位置和动量不能同时准确地测定</li><li>规律<ol type="1"><li>当 <span class="math inline">\(\Delta x\)</span> 越小，<spanclass="math inline">\(\Delta p\)</span> 越大</li><li>当 <span class="math inline">\(\Delta p\)</span> 越小，<spanclass="math inline">\(\Delta x\)</span> 越大</li></ol></li></ul><p>电子的单缝衍射为例</p><ul><li>进入单缝之前的 <span class="math inline">\(\Delta x\)</span>趋向无穷大</li></ul><h4 id="形式-2">形式 2</h4><p>若粒子在能量状态 <span class="math inline">\(E\)</span> 附近停留时间<span class="math inline">\(\Delta t\)</span> ，则其能量 <spanclass="math inline">\(E\)</span> 有一个不完全确定的数值范围 <spanclass="math inline">\(\Delta E\)</span> ，两者的乘积满足：</p><p><span class="math display">\[\Delta t \Delta E \geq \frac{\hbar}{2}\]</span></p><p>只有当粒子的停留时间为无穷大（定态）时，其能量才是确定的（<spanclass="math inline">\(\Delta E = 0\)</span> ）</p><h4 id="电子单缝衍射的结论">电子单缝衍射的结论</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281611015.png"alt="电子单缝衍射实验示意图" /><figcaption aria-hidden="true">电子单缝衍射实验示意图</figcaption></figure><ul><li>电子通过单缝之后，动量在 <span class="math inline">\(x\)</span>方向上的分量 <span class="math inline">\(P_x\)</span> 的大小为</li></ul><p><span class="math display">\[- p \cdot \sin{\theta_1} \leq p_x = p \cdot \sin{\theta} \leq p \cdot\sin{\theta_1}\]</span></p><ul><li>电子通过单缝后，动量在 <span class="math inline">\(x\)</span>方向分量的不确定量为</li></ul><p><span class="math display">\[\Delta p_x = 2p \cdot \sin{\theta_1} =\frac{2p\lambda}{\Delta x}\]</span></p><p>带入德布罗意关系 <span class="math inline">\(p\lambda=h\)</span>，得到</p><p><span class="math display">\[\Delta x \cdot \Delta p_x =2h\]</span></p><p>这里的讨论只反映不确定度关系的实质，并不表示准确的量值关系</p><h2 id="量子力学">量子力学</h2><h3 id="薛定谔方程">薛定谔方程</h3><ul><li>建立的是描写波函数随时间变化的方程，它必须是波函数应满足的含有对时间微商的微分方程</li><li>是一个假设，无法被推导出来</li></ul><h4 id="满足的条件">满足的条件</h4><ol type="1"><li>方程是线性的 如果 <span class="math inline">\(\Psi_1\)</span> 和<span class="math inline">\(\Psi_2\)</span> 是薛定谔方程的解，则 <spanclass="math inline">\(a\Psi_1 + b\Psi_2\)</span> 也是薛定谔方程的解这是由态叠加原理决定的</li><li>方程的系数不应当包含状态参量，如动量、能量等否则这个方程只能被粒子的部分状态满足</li></ol><h4 id="自由粒子的薛定谔方程">自由粒子的薛定谔方程</h4><p>动量为 <span class="math inline">\(p\)</span> 、质量为 <spanclass="math inline">\(m\)</span> 、能量为 <spanclass="math inline">\(E\)</span> 的粒子在 <spanclass="math inline">\(x\)</span> 方向上自由运动的薛定谔方程为</p><p><span class="math display">\[\Psi \left(x,t\right) =\Psi _0 e^{-\frac{i}{\hbar}\left(Et-px\right)}\]</span></p><p><strong>对时间求偏导</strong></p><p><span class="math display">\[\frac{\partial \Psi (x,t)}{\partial t} = -\frac{i}{\hbar}E\Psi (x,t)\]</span></p><p>左右两边同乘 <span class="math inline">\(i\hbar\)</span></p><p><span class="math display">\[i\hbar \frac{\partial \Psi (x,t)}{\partial t} = E\Psi (x,t)\]</span></p><p>我们记算符 <span class="math inline">\(\hat{E}\)</span>为能量算符</p><p><span class="math display">\[\boxed{\hat{E} \equiv i\hbar \frac{\partial}{\partial t}}\]</span></p><p>则</p><p><span class="math display">\[\hat{E} \Psi (x,t) = E\Psi (x,t)\]</span></p><p><strong>对 <span class="math inline">\(x\)</span> 求偏导</strong></p><p><span class="math display">\[\frac{\partial \Psi (x,t)}{\partial x} = \frac{i}{\hbar}p_x\Psi (x,t)\]</span></p><p>左右两边同乘 <span class="math inline">\(-i\hbar\)</span></p><p><span class="math display">\[-i\hbar \frac{\partial \Psi (x,t)}{\partial x} = p_x\Psi (x,t)\]</span></p><p>我们记算符 <span class="math inline">\(\hat{p_x}\)</span>为动量算符</p><p><span class="math display">\[\boxed{\hat{p_x} \equiv -i\hbar \frac{\partial}{\partial x}}\]</span></p><p>则</p><p><span class="math display">\[\hat{p_x} \Psi (x,t) = p_x\Psi (x,t)\]</span></p><p><strong>对 <span class="math inline">\(x\)</span>做二次偏导</strong></p><p><span class="math display">\[\frac{\partial^2 \Psi (x,t)}{\partial x^2} = -\frac{p_x^2}{\hbar^2}\Psi(x,t)\]</span></p><p><strong>综合考虑</strong></p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;i\hbar \frac{\partial \Psi (x,t)}{\partial t} = E\Psi (x,t)\\    &amp;\frac{\partial ^2 \Psi (x,t)}{\partial x^2} =-\frac{p_x^2}{\hbar^2}\Psi (x,t)    \end{aligned}\right.\]</span></p><p>由 <span class="math inline">\(E = \frac{p_x^2}{2m}\)</span>，有</p><p><span class="math display">\[i\hbar \frac{\partial \Psi (x,t)}{\partial t} = E\Psi (x,t) =-\frac{p_x^2}{2m}\Psi (x,t)=-\frac{\hbar^2}{2m}\frac{\partial^2 \Psi(x,t)}{\partial x^2}\]</span></p><p><strong>即</strong></p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (x,t)}{\partial t} =-\frac{\hbar^2}{2m}\frac{\partial^2 \Psi (x,t)}{\partial x^2}}\]</span></p><p>这就是自由粒子的薛定谔方程</p><h4 id="薛定谔方程的一般形式">薛定谔方程的一般形式</h4><p>将自由粒子运动算符推广到非自由粒子运动，粒子所处的势场为 <spanclass="math inline">\(U(x,t)\)</span>对于保守系统，其能量等于<strong>哈密顿量</strong></p><p><span class="math display">\[E = H = \frac{p^2}{2m} + U(x,t)\]</span></p><p>哈密顿量算符化，称为<strong>哈密顿算符</strong></p><p><span class="math display">\[\hat{H} = \frac{\hat p_x^2}{2m} +U(x,t)=\frac{-\hbar^2}{2m}\frac{\partial^2}{\partial x^2} + U(x,t)\]</span></p><p><strong>薛定谔方程</strong>：对于保守系统，其能量算符作用在波函数上，等于哈密顿算符作用在波函数上</p><p><span class="math display">\[\boxed{\hat{E} \Psi (x,t) = \hat{H} \Psi (x,t)}\]</span></p><p>将其展开</p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (x,t)}{\partial t} =\left(\frac{-\hbar^2}{2m}\frac{\partial ^2}{\partial x^2} +U(x,t)\right) \Psi (x,t)}\]</span></p><p>推广到三维势场</p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (\boldsymbol{r},t)}{\partial t} =\left(-\frac{\hbar^2}{2m}\nabla^2 + U(\boldsymbol{r},t)\right) \Psi(\boldsymbol{r},t)}\]</span></p><h4 id="定态薛定谔方程">定态薛定谔方程</h4><p>若微观粒子在稳定的势场中，则其势能函数 <spanclass="math inline">\(U\)</span> 与时间无关，称这类问题为定态问题</p><p><span class="math display">\[\hat{H} = -\frac{\hbar^2}{2m}\nabla^2 + U(\boldsymbol{r})\]</span></p><p><span class="math display">\[\i\hbar \frac{\partial}{\partial t}\Psi (\boldsymbol{r},t) = \hat{H} \Psi(\boldsymbol{r},t)\]</span></p><p>此时哈密顿算符与时间无关，薛定谔方程可以用分离变量法求解，波函数<span class="math inline">\(\Psi\)</span>分解为空间函数和时间函数的乘积</p><p>设 <span class="math inline">\(\Psi (\boldsymbol{r},t) =\Phi(\boldsymbol{r})T(t)\)</span></p><p><span class="math display">\[i\hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}\Phi(\boldsymbol{r}) =\left[\hat{H} \Phi(\boldsymbol{r})\right] T(t)\]</span></p><p><span class="math display">\[i\hbar \frac{1}{T(t)}\mathrm{d} t =\frac{1}{\Phi(\boldsymbol{r})}\hat{H} \Phi(\boldsymbol{r}) = const = E\]</span></p><p>其中 <span class="math inline">\(E\)</span> 为本征值，<spanclass="math inline">\(\Phi\)</span> 为本征函数 得到分别只含有变量 <spanclass="math inline">\(t\)</span> 和 <spanclass="math inline">\(\boldsymbol{r}\)</span> 的两个方程</p><p><span class="math display">\[\left\{\begin{aligned}  &amp;i \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t} =ET(t)  &amp;&amp;\text{(1)}\\  &amp;\hat{H} \Phi(\boldsymbol{r}) =E\Phi(\boldsymbol{r})  &amp;&amp;\text{(2)}\end{aligned}\right.\]</span></p><p>方程(1)的解为</p><p><span class="math display">\[T(t) = e^{-\frac{i}{\hbar}Et}\]</span></p><p>方程(2)是关于变量 <span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span>、<span class="math inline">\(z\)</span>的微分方程，称为<strong>定态薛定谔方程</strong>，又称为哈密顿算符的本征方程</p><p><span class="math display">\[\boxed{\left[-\frac{\hbar^2}{2m}\nabla^2 + U(x,y,z)\right] \Phi(x,y,z) =E\Phi(x,y,z)}\]</span></p><p>其解与外力场 <span class="math inline">\(U\)</span> 和边界条件有关波函数是两者的乘积</p><p><span class="math display">\[\boxed{\Psi (\boldsymbol{r},t) =\Phi(\boldsymbol{r})e^{-i\frac{1}{\hbar}Et}}\]</span></p><ul><li>粒子在空间中出现的几率密度与时间无关——<strong>定态</strong></li></ul><p><span class="math display">\[\vert\Psi (\boldsymbol{r},t)\vert^2 =\vert\Phi(\boldsymbol{r})e^{-i\frac{1}{\hbar}Et}\vert^2 = \vert\Phi(\boldsymbol{r})\vert^2\]</span></p><h4 id="薛定谔方程的应用">薛定谔方程的应用</h4><h5 id="一维无限深方势阱">一维无限深方势阱</h5><p>金属中的电子由于金属表面势能（能垒）的束缚而被限制在一个有限的空间范围内运动如果金属表面的能垒很高，可以将金属表面看成一个刚性的盒子。若只考虑一维运动，则其势能函数为</p><p><span class="math display">\[U(x) =\left\{  \begin{aligned}    &amp;0 \quad (0 \leq x \leq L)\\    &amp;\infty \quad (x &lt; 0 \text{ or } x &gt; L)  \end{aligned}\right.\]</span></p><p>称为<strong>一维无限深方势阱</strong></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504111721435.png"alt="无限深方势阱" /><figcaption aria-hidden="true">无限深方势阱</figcaption></figure><ul><li>势阱内</li></ul><p><span class="math display">\[-\frac{\hbar^2}{2m}\frac{\mathrm{d}^2}{\mathrm{d} x^2} \Phi_i(x) =E\Phi_i(x)\]</span></p><p>令 <span class="math inline">\(k=\sqrt{\frac{2mE}{\hbar^2}}\)</span>，得</p><p><span class="math display">\[\frac{\mathrm{d}^2\Phi_i}{\mathrm{d} x^2} + k^2\Phi_i = 0\]</span></p><p>其解为</p><p><span class="math display">\[\Phi_i(x)=C\sin(kx+\delta)\]</span></p><p>其中 <span class="math inline">\(C\)</span> 和 <spanclass="math inline">\(\delta\)</span> 为常数，由波函数的自然条件确定</p><ul><li>势阱外</li></ul><p><span class="math display">\[-\frac{\hbar^2}{2m}(\frac{\mathrm{d}^2}{\mathrm{d}x^2}+\infty)\Phi_e(x)= E\Phi_e(x)\]</span></p><p>其解为</p><p><span class="math display">\[\Phi_e(x)=0\]</span></p><ul><li>波函数在肼壁上连续的条件为</li></ul><p><span class="math display">\[\left\{  \begin{aligned}    &amp;\Phi_i(0) = \Phi_e(0) \\    &amp;\Phi_i(L) = \Phi_e(L) \\  \end{aligned}\right.\]</span></p><p>由边界条件可得</p><p><span class="math display">\[\begin{cases}  \Phi_i(0)= 0 &amp;&amp; \text{(1)}\\  \Phi_i(L) = 0 &amp;&amp; \text{(2)}\end{cases}\]</span></p><p>由 <span class="math inline">\((1)\)</span> 可得 <spanclass="math inline">\(\delta = 0\)</span>、</p><p>由 <span class="math inline">\((2)\)</span> 可得 <spanclass="math inline">\(kL = n\pi\)</span>，其中 <spanclass="math inline">\(n\in \mathbb{N}^*\)</span>，即 <spanclass="math inline">\(k = \frac{n\pi}{L}\)</span></p><p><span class="math display">\[\Phi(x) =\sqrt{\frac{2}{L}}\sin\left(\frac{n\pi}{L}x\right)\]</span></p><ul><li><strong>粒子的能量:</strong> <span class="math inline">\(E =\frac{\hbar^2k^2}{2m} = \frac{n^2\pi^2\hbar^2}{2mL^2}\)</span>，<spanclass="math inline">\(n\)</span> 为能量量子数<ul><li>能量取分立值（能级），这是<strong>能量量子化</strong>的表现</li></ul></li></ul><p><span class="math display">\[\Delta E = E_{n+1} - E_n =\frac{\hbar^2}{2m}\left(\left(\frac{(n+1)\pi}{L}\right)^2 -\left(\frac{n\pi}{L}\right)^2\right) = (2n+1)\frac{\hbar^2\pi^2}{2mL^2}\]</span></p><ul><li>当 <span class="math inline">\(a\uparrow\)</span> 时 <spanclass="math inline">\(\Delta E \downarrow\)</span>，并且当 <spanclass="math inline">\(n \rightarrow \infty\)</span> 时， <spanclass="math inline">\(\Delta E \rightarrow0\)</span>，即能级间隔趋于零，能级连续，形成连续谱</li><li>最低能量（零点能）<spanclass="math inline">\(E_1=\frac{\pi^2\hbar^2}{amL^2}&gt;0\)</span>，具有波动性</li><li>在势阱中形成驻波</li></ul><p><span class="math display">\[\Phi(x) =C\sin\left(\frac{n\pi}{L}x\right)\]</span></p><p>由归一化条件</p><p><span class="math display">\[\int_{-\infty}^{+\infty} \vert \Phi(x) \vert^2\,\mathrm{d}x =\int_{0}^{L} C^2\sin^2\left(\frac{n\pi}{L}x\right)\,\mathrm{d}x = C^2\cdot \frac{L}{2} = 1\]</span></p><p>解得</p><p><span class="math display">\[C = \sqrt{\frac{2}{L}}\]</span></p><p>故定态波函数为</p><p><span class="math display">\[\Phi(x) =\left\{  \begin{aligned}    &amp;\sqrt{\frac{2}{L}}\sin\left(\frac{n\pi}{L}x\right) &amp;&amp;(0 \leq x \leq L)\\    &amp;0 &amp;&amp; (x &lt; 0 \text{ or } x &gt; L)  \end{aligned}\right.\]</span></p><h6id="一维无线深方势阱中粒子的波函数和概率密度">一维无线深方势阱中粒子的波函数和概率密度</h6><p><span class="math display">\[\Phi (x,t) = \sqrt{\frac{2}{L}} \sin\left(\frac{n\pi}{L}x\right), \quad(0 \leq x \leq L)\]</span></p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504131458204.png"alt="波函数和概率密度" /><figcaption aria-hidden="true">波函数和概率密度</figcaption></figure><p>可以看出</p><ul><li>势阱中的粒子波函数为驻波</li><li>基态 <span class="math inline">\(n=1\)</span> 除了 <spanclass="math inline">\(x=0\)</span> 和 <spanclass="math inline">\(x=L\)</span> 处为节点外，其余无节点</li><li>第 <span class="math inline">\(n\)</span> 量子态有 <spanclass="math inline">\(n-1\)</span> 个 node</li></ul><h6id="一维无限深势阱中粒子的波函数是正交归一的">一维无限深势阱中粒子的波函数是正交归一的</h6><p>设不同能级的波函数为 <span class="math inline">\(\Phi_n(x)\)</span>和 <span class="math inline">\(\Phi_m(x)\)</span></p><ul><li>正交性</li></ul><p><span class="math display">\[\int_{-\infty}^{+\infty} \Phi_n(x) \Phi_m(x)\,\mathrm{d}x = \int_{-\infty }^{+\infty }\sqrt{\frac{2}{L}}\sin\frac{m\pi }{L} x\cdot\sqrt{\frac{2}{L}}\sin\frac{n\pi }{L}\,\mathrm{d} x=\frac{1}{L}\int_{0}^{L}\left(\cos\frac{m-n}{L} -\cos\frac{m+n}{L}\right)\,\mathrm{d}x=0\]</span></p><ul><li>归一性</li></ul><p><span class="math display">\[\int_{-\infty}^{+\infty} \Phi_n(x) \Phi_n(x)\,\mathrm{d}x = \int_{-\infty }^{+\infty }\sqrt{\frac{2}{L}}\sin\frac{n\pi }{L} x\cdot\sqrt{\frac{2}{L}}\sin\frac{n\pi }{L}\,\mathrm{d} x=\frac{1}{L}\int_{0}^{L}\left(\cos 0 -\cos\frac{2n\pi }{L}\right)\,\mathrm{d} x=1\]</span></p><h5 id="波尔对应原理">波尔对应原理</h5><ul><li>在大量子数极限下，量子规律必须转化为经典规律，这也被称为<strong>量子物理的对应原理</strong></li></ul><p>比如</p><ul><li>本征能量</li></ul><p><span class="math display">\[E = E_n = \frac{\hbar^2 \pi^2 n^2}{2mL^2} = n^2 \frac{h^2}{8mL^2}\]</span></p><ul><li>相邻能级的间隔为</li></ul><p><span class="math display">\[\Delta E_n = (2n+1)\frac{h^2}{8mL^2}\]</span></p><ul><li>相对能级间隔</li></ul><p><span class="math display">\[\frac{\Delta E_n}{E_n} = \frac{2n+1}{n^2}\]</span></p><ul><li>当 <span class="math inline">\(n\rightarrow \infty\)</span> 时，<span class="math inline">\(\Delta E_n \rightarrow 0\)</span>，即能级间隔趋于零，能级连续，形成连续谱</li></ul><p>粒子在势阱中的概率分布为</p><p><span class="math display">\[\rho(x) = \vert \Phi(x) \vert^2 =\left\{  \begin{aligned}    &amp;\frac{2}{L}\sin^2(\frac{n\pi}{L}x) &amp;&amp; (0 \leq x \leqL)\\    &amp;0 &amp;&amp; (x &lt; 0 \text{ or } x &gt; L)  \end{aligned}\right.\]</span></p><h5 id="德布罗意的驻波思想">德布罗意的驻波思想</h5><ul><li>一个频率为 <span class="math inline">\(\nu\)</span> 、波长 <spanclass="math inline">\(\lambda\)</span> 沿 <spanclass="math inline">\(x\)</span> 方向传播的单色平面波的表达式为</li></ul><p><span class="math display">\[\Psi(x,t) = \Psi_0 e^{-i \frac{2\pi}{h}(Et -Px)}\]</span></p><ul><li>全波函数为</li></ul><p><span class="math display">\[\begin{aligned}\Psi ( x,t) =\Phi ( x) e^{-\frac{i}{\hbar } Et} &amp;=\sqrt{\frac{2}{L}}e^{-i\frac{Et}{\hbar }}\sin\frac{n\pi }{L} x\\&amp;=\frac{1}{2i}\sqrt{\frac{2}{L}} e^{-i\frac{Et}{\hbar }}\left(e^{i\frac{n\pi }{L} x} -e^{-i\frac{n\pi }{L} x}\right)\\&amp;=\frac{1}{2i}\sqrt{\frac{2}{L}} e^{-i\frac{Et}{\hbar }}\left(e^{i\frac{p_{n}}{\hbar }} -e^{-i\frac{p_{n}}{\hbar } x}\right)\end{aligned}\]</span></p><p>可以将波函数视为频率相同、波长相同、传播方向相反的两单色平面波的叠加</p><p>则由德布罗意的物质波理论，一个动量为 <spanclass="math inline">\(p\)</span>、质量为 <spanclass="math inline">\(m\)</span>、能量为 <spanclass="math inline">\(E\)</span> 的自由粒子，沿着 <spanclass="math inline">\(x\)</span> 轴运动的波函数为</p><p><span class="math display">\[\Psi ( x,t) =\Psi _{0} e^{-\frac{i}{\hbar }( Et-px)}\]</span></p><p>波函数也为频率相同、波长相同、传播方向相反的两单色平面波的叠加形成驻波</p><ul><li>势阱中粒子的动量和波长<ul><li>动量：<span class="math inline">\(p_n =\sqrt{2mE_n} =\pm\frac{n\hbar}{2L} = \pm n \frac{ h}{2L}\)</span></li><li>波长：<span class="math inline">\(\lambda_n =\frac{\hbar}{p_n}=\frac{2L}{n}\)</span>说明势阱中粒子的每一个能量本征态正好对应德布罗意波的一个特征波长的驻波</li></ul></li><li>符合德布罗意的驻波理论</li></ul><h5 id="一维方势垒和隧穿效应">一维方势垒和隧穿效应</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504181642705.png"alt="Tunel effect" /><figcaption aria-hidden="true">Tunel effect</figcaption></figure><p>设</p><p><span class="math display">\[V(x)=\begin{cases}    0, &amp; x &lt; x_1 \quad \text{or} \quad x &gt; x_2 \\    V_0, &amp; x_1 &lt; x &lt; x_2\end{cases}\]</span></p><p>称为方势垒</p><p>现有一能量为 <span class="math inline">\(E\)</span>的粒子从左向右入射</p><p>在经典力学中，若 <span class="math inline">\(E &lt;V_0\)</span>，则粒子无法穿过势垒，<span class="math inline">\(E &gt;V_0\)</span> 时，粒子能够完全穿过势垒</p><p>但是在量子力学中，粒子是一种物质波，情况完全不一样，需要通过求解薛定谔方程来确定</p><p><span class="math display">\[\frac{d^2\psi(x)}{dx^2}=\frac{2m}{\hbar^2}(V_0-E)\psi(x)\]</span></p><p>在这里我们设 <span class="math inline">\(V_0&gt;E\)</span>，令 <spanclass="math inline">\(k=\sqrt{\frac{2mE}{\hbar^2}}\)</span> 和 <spanclass="math inline">\(k&#39; =\sqrt{\frac{2m(V_0-E)}{\hbar^2}}\)</span></p><p>则薛定谔方程可化为</p><p><span class="math display">\[\begin{cases}  \frac{d^2\psi_1(x)}{dx^2} = -k^2\psi_1(x), &amp; x &lt; x_1 \\  \frac{d^2\psi_2(x)}{dx^2} = k&#39;^2\psi_2(x), &amp; x_1 &lt; x &lt;x_2 \\  \frac{d^2\psi_3(x)}{dx^2} = -k^2\psi_3(x), &amp; x &gt; x_2\end{cases}\]</span></p><p>解得</p><p><span class="math display">\[\begin{cases}  \psi_1 = A e^{ikx} + A&#39; e^{-ikx}, &amp; x &lt; x_1 \\  \psi_2 = B e^{k&#39;x} + B&#39; e^{-k&#39;x}, &amp; x_1 &lt; x &lt;x_2 \\  \psi_3 = C e^{ikx} , &amp; x &gt; x_2\end{cases}\]</span></p><p>由连续性（在这里我们令 <spanclass="math inline">\(x_1=0\)</span>，<spanclass="math inline">\(x_2=a\)</span>）</p><p><span class="math display">\[\begin{cases}  \psi_1(0) = \psi_2(0) \rightarrow A + A&#39; = B + B&#39; \\  \psi_1&#39;(0) = \psi_2&#39;(0) \rightarrow ik(A - A&#39;) = k&#39; (B- B&#39;) \\  \psi_2(a) = \psi_3(a) \rightarrow B e^{k&#39;a} + B&#39; e^{-k&#39;a}= C e^{ika} \\  \psi_2&#39;(a) = \psi_3&#39;(a) \rightarrow k&#39; B e^{k&#39;a} -k&#39; B&#39; e^{-k&#39;a} = ikC e^{ika}\end{cases}\]</span></p><p>求解并经过计算得到</p><ul><li><strong>反射系数：</strong> <spanclass="math inline">\(\displaystyle R =\frac{\vert A&#39;\vert^2}{\vertA\vert^2}=\frac{(k^2+k&#39;^2)^2\sinh^2(k&#39;a)}{\left(k^2+k&#39;^2\right)\sinh^2(k&#39;a)+ 4k^2k&#39;^2}\)</span></li><li><strong>透射系数：</strong> <spanclass="math inline">\(\displaystyle T =\frac{\vert C\vert^2}{\vertA\vert^2} =\frac{4k^2k&#39;^2}{\left(k^2+k&#39;^2\right)\sinh^2(k&#39;a)+ 4k^2k&#39;^2}\)</span></li></ul><p>显然有 <span class="math inline">\(\boxed{T+R=1}\)</span></p><h2 id="定态问题">定态问题</h2><h2 id="量子力学的基本假设">量子力学的基本假设</h2><h3 id="波函数假设">波函数假设</h3><p>微观粒子的状态可以被一个波函数完全描述，从这个波函数可以得到体系的所有性质</p><p>波函数一般满足连续性、有限性和单值性三个条件</p><ol type="1"><li>物质波可以用一个随时间、空间变化的波函数 <spanclass="math inline">\(\Psi(\boldsymbol{r},t)\)</span> 来描述</li><li>自由粒子的波函数是单色平面波 <span class="math inline">\(\Psi(x,t) =\Psi_0 e^{-i\frac{2\pi}{h}(Et - Px)} = \Psi_0 e^{-i\frac{1}{\hbar}(Et -Px)}\)</span></li><li>波恩：德布罗意波是描述粒子在空间概率分布的概率波 波函数的模的平方<span class="math inline">\(\vert \Psi(\boldsymbol{r},t)\vert^2\)</span>表示 <span class="math inline">\(t\)</span> 时刻，在坐标 <spanclass="math inline">\(\boldsymbol{r}\)</span> 处粒子出现的概率密度</li><li>波函数满足<strong>单值、有限、连续</strong>的条件，称为<strong>波函数的标准条件</strong></li><li><strong>归一化条件：</strong> 在整个空间中发现粒子的概率为 <spanclass="math inline">\(1\)</span>，即 <spanclass="math inline">\(\displaystyle \int_{\Omega} \vert\Psi(\boldsymbol{r},t)\vert^2\,\mathrm{d}V = 1\)</span>，其中 <spanclass="math inline">\(\Omega\)</span> 为全空间</li></ol><h3 id="力学算符假设">力学算符假设</h3><p>量子力学中的力学量用线性厄米（Hermite）算符表示。如果经典力学中有相关的力学量，则在量子力学中也有相应表示这个力学量的算符</p><p>算符能将波函数变换为另一个波函数</p><ul><li>动量算符 <span class="math inline">\(\hat{p} = -i\hbar\nabla\)</span></li><li>位置算符 <span class="math inline">\(\hat{\boldsymbol{r}} =\boldsymbol{r}\)</span></li><li>能量算符 <span class="math inline">\(\hat{H} = \frac{\hat{p}^2}{2m}+ U(\boldsymbol{r}) = -\frac{\hbar ^2}{2m}\nabla ^2 +U(\boldsymbol{r})\)</span></li><li>角动量算符 <span class="math inline">\(\hat{\boldsymbol{L}}=\hat{\boldsymbol{r}} \times \hat{\boldsymbol{p}}=\left\vert\begin{smallmatrix}\boldsymbol{i} &amp; \boldsymbol{j} &amp;\boldsymbol{k} \newline x &amp; y &amp; z \newline p_x &amp; p_y &amp;p_z \end{smallmatrix}\right\vert\)</span><ul><li><span class="math inline">\(\hat{L}_x =y\hat{p}_z-z\hat{p}_y\)</span></li><li><span class="math inline">\(\hat{L}_y =z\hat{p}_x-x\hat{p}_z\)</span></li><li><span class="math inline">\(\hat{L}_z =x\hat{p}_y-y\hat{p}_x\)</span></li></ul></li></ul><h4 id="厄米hermite算符">厄米（Hermite）算符</h4><p><span class="math inline">\(\hat{A}\)</span>是厄米算符的充分必要条件是</p><p><span class="math display">\[\int \Psi^* \hat{A} \varphi \,\mathrm{d}V = \int \Psi \left(\hat{A}\Psi^* \right) \,\mathrm{d}V\]</span></p><p>其中 <span class="math inline">\(\Psi\)</span> 和 <spanclass="math inline">\(\varphi\)</span> 是在无穷远处趋向 <spanclass="math inline">\(0\)</span> 的任意函数</p><ul><li>如果 <span class="math inline">\(\hat{A}\)</span> 和 <spanclass="math inline">\(\hat{B}\)</span> 都是厄米算符，则 <spanclass="math inline">\(\hat{A}\hat{B} + \hat{B}\hat{A}\)</span>也是厄米算符</li></ul><p><strong>证明：</strong></p><p><span class="math display">\[\begin{aligned}&amp;\int _{-\infty }^{+\infty }\Psi ^{*}\left(\hat{A}\hat{B} +\hat{B}\hat{A}\right)\varphi\,\mathrm{d}x \\= &amp;\int _{-\infty }^{+\infty }\Psi^{*}\hat{A}(\hat{B}\varphi)\,\mathrm{d}x + \int _{-\infty }^{+\infty}\Psi ^{*}\hat{B}(\hat{A}\varphi)\,\mathrm{d}x\\= &amp;\int _{-\infty }^{+\infty }(\hat{A}\Psi)^{*}(\hat{B}\varphi)\,\mathrm{d}x + \int _{-\infty }^{+\infty}(\hat{B}\Psi) ^{*}(\hat{A}\varphi)\,\mathrm{d}x\\= &amp;\int_{-\infty}^{+\infty}\left[\varphi\left(\hat{B}\hat{A}\Psi\right)^*+\varphi\left(\hat{A}\hat{B}\Psi\right)^*\right]\\= &amp;\int_{-\infty}^{+\infty}\varphi\left[\left(\hat{A}\hat{B}+\hat{B}\hat{A}\right)\Psi\right]^*\,\mathrm{d}x\end{aligned}\]</span></p><ul><li>如果 <span class="math inline">\(\hat{A}\)</span> 和 <spanclass="math inline">\(\hat{B}\)</span> 都是厄米算符，则 <spanclass="math inline">\(i\left(\hat{A}\hat{B}-\hat{B}\hat{A}\right)\)</span> 也是厄米算符</li></ul><h5 id="厄米算符的性质">厄米算符的性质</h5><ol type="1"><li>对于系统的任何量子态，其厄米算符的平均值 <spanclass="math inline">\(\bar{F}=\displaystyle\int _{-\infty}^{+\infty}\Psi ^*\hat{F}\Psi \,\mathrm{d}V\)</span> 是实数</li><li><strong>厄米算符的本征值是实数</strong>，所以量子力学中的任何力学算符都是厄米算符</li><li><strong>厄米算符属于不同本征值的本征函数彼此正交</strong><ul><li><strong>厄米算符的本征函数是正交统一的完全集</strong></li><li>任何物理上合理的波函数都可以用这个正交统一的完全集展开</li></ul></li></ol><p><strong>证明：</strong></p><ul><li>平均值为实数</li></ul><p><span class="math display">\[\bar{F} = \int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi \,\mathrm{d}V =\int _{-\infty}^{+\infty} \left(\hat{F}\Psi\right)^* \Psi \,\mathrm{d}V= \left(\int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi\,\mathrm{d}V\right)^* = \bar{F}^*\]</span></p><p>故 <span class="math inline">\(\bar{F}\)</span> 是实数</p><ul><li><p>本征值是实数</p><p>由厄米算符的定义</p></li></ul><p><span class="math display">\[\int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi_n \,\mathrm{d}V = \int_{-\infty}^{+\infty} \left(\hat{F}\Psi\right)^* \Psi \,\mathrm{d}V\]</span></p><p>设 <span class="math inline">\(\hat{F}\Psi= F\Psi\)</span>，则</p><p><span class="math display">\[\begin{aligned}    \int _{-\infty} ^{+\infty} \Psi ^*F\Psi\mathrm{d}\,V &amp;= \int_{-\infty}^{+\infty} \left(F\Psi\right)^* \Psi\,\mathrm{d}V\\    \Rightarrow F\int _{-\infty} ^{+\infty} \Psi ^*\Psi\mathrm{d}\,V&amp;= F^*\int _{-\infty}^{+\infty} \Psi^* \Psi\,\mathrm{d}V\end{aligned}\]</span></p><p>则 <span class="math inline">\(F=F^*\)</span>，故本征值为实数</p><ul><li><p>属于不同本征值的本征函数正交</p><p>由厄米算符的定义</p></li></ul><p><span class="math display">\[\begin{aligned}  \int \Psi _{m}^{*}\hat{F} \Psi _{n} \, \mathrm{d}V&amp;=\int (\hat{F}\Psi _{m})^{*} \Psi _{n} \, \mathrm{d} V\\F_{n}\int \Psi m^{*} \Psi _{n}\,\mathrm{d} V&amp;=F_{m}^{*}\int \Psi_{m}^{*} \Psi _{n} \, \mathrm{d} V\\( F_{n} -F_{m})\int \Psi _{m}^{*} \Psi _{n} \,\mathrm{d} V&amp;=0\end{aligned}\]</span></p><p><span class="math inline">\(\displaystyle m\neq n\)</span>，则 <spanclass="math inline">\(\displaystyle \int \Psi _m^n \Psi _n \, \mathrm{d}V=1\)</span>，则 <span class="math inline">\(\displaystyle F_n=F_m\)</span></p><p>这里有 <span class="math inline">\(\displaystyle \int \Psi _m^*\Psi_n \, \mathrm{d}V = \delta _{nm} =\begin{cases} 0 &amp;,n\neq m\\ 1&amp;,n=m\end{cases}\)</span></p><ul><li><p>波函数可以用正交统一的完全集展开 <spanclass="math inline">\(\displaystyle\Psi = \sum _n c_n\Psi_n\)</span></p><p>使用数学归纳法，假设当 <span class="math inline">\(n\)</span>时成立</p></li></ul><p><span class="math display">\[\begin{aligned}  &amp; \Psi &amp;&amp;= \sum _{n} c_n\Psi _n \\  &amp; \Psi _m^*\Psi &amp;&amp;= \sum _{n} c_n\Psi _m^*\Psi _n\\  &amp; \int\Psi _m^*\Psi \,\mathrm{d}V &amp;&amp;= \sum _{n} c_n\int\Psi _m^*\Psi _n \,\mathrm{d}V \\  &amp;                                   &amp;&amp;= \sum _n c_n \delta_{mn}\\  &amp;                                  &amp;&amp;= c_m\\\end{aligned}\]</span></p><p>可以得到 <span class="math inline">\(\displaystyle c_m = \int \Psi_m^*\Psi \,\mathrm{d}V\)</span> ，当 <spanclass="math inline">\(m\)</span> 时成立</p><h3 id="测量假设">测量假设</h3><p>当一个量子系统处于量子态 <span class="math inline">\(\Psi\)</span>时，对力学量 <span class="math inline">\(\hat{F}\)</span>的测量结果一定是该力学算符的本征值之一，结果为 <spanclass="math inline">\(F_n\)</span> 的概率为 <spanclass="math inline">\(\left\vert c_n\right\vert ^2 = \left\vert\int\phi_n^*\Psi\,\mathrm{d}V\right\vert^2\)</span></p><p>这里 <span class="math inline">\(\hat{F}\varphi _n = F_n\varphi_n\)</span> 是力学量 <span class="math inline">\(\hat{F}\)</span>的本征方程，测量完成后，该量子系统坍缩至 <spanclass="math inline">\(\varphi _n\)</span></p><p><strong>结论</strong></p><ul><li>根据测量假设，当一个量子系统处在量子态 <spanclass="math inline">\(\Psi\)</span> 时，对力学量 <spanclass="math inline">\(\hat{F}\)</span> 的测量结果的统计平均值为</li></ul><p><span class="math display">\[\bar{F} = \sum _n F_n \left\vert c_n \right\vert ^2 = \sum _n F_n\left\vert \int\phi_n^*\Psi\,\mathrm{d}V\right\vert ^2 =\boxed{\int\Psi^* \hat{F} \Psi\,\mathrm{d}V}\]</span></p><p><strong>证明：</strong></p><p><span class="math display">\[\begin{aligned}   &amp;\int \Psi ^* \hat{F} \Psi \mathrm{d}V\\   =&amp;\int \left(\sum_m c_m\Psi_m\right)^*\hat{F}\left(\sum_nc_n\Psi_n\right)\mathrm{d}V\\   =&amp;\int \left(\sum_m c_m\Psi_m\right)^*\left(\sum_n c_n\hat{F}\Psi_n\right)\mathrm{d}V\\   =&amp;\int \left(\sum_m c_m\Psi_m\right)^*\left(\sum_n c_nF_n\Psi_n\right)\mathrm{d}V\\   =&amp;\sum_{mn}c_m c_n F_n \int\left(\Psi_m^*\Psi_n\right)\mathrm{d}V\\   =&amp;\sum_{mn}c_m c_n F_n \delta _{mn}\\   =&amp;\sum_n\left\vert c_n \right\vert ^2 F_n\end{aligned}\]</span></p><ul><li>测量假设推论：当一个量子系统处于量子态 <spanclass="math inline">\(\Psi\)</span> 时，且满足 <spanclass="math inline">\(\displaystyle \sum _n \vert c_n\vert^2=1\)</span>时，对力学量的测量结果一定是该力学算符的本征值之一，测量结果为 <spanclass="math inline">\(F_n\)</span> 的概率为 <spanclass="math inline">\(\vert c_n\vert^2\)</span>，测量完成之后，该量子系统探索至 <spanclass="math inline">\(\phi_n\)</span></li></ul><h4 id="动量本征方程">动量本征方程</h4><p><span class="math display">\[-i\hbar\nabla\Phi _{\boldsymbol{r}}(\boldsymbol{r}) = \hat{p}\Phi_{\boldsymbol{r}}(\boldsymbol{r}) = p\Phi_{\boldsymbol{r}}(\boldsymbol{r})\]</span></p><p>其在三个坐标轴上的分量为</p><p><span class="math display">\[\begin{cases}  -i\hbar \frac{\partial \Phi _{\boldsymbol{r}}}{\partial x} = p_x\Phi_{\boldsymbol{r}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{r}}}{\partial y} = p_y\Phi_{\boldsymbol{r}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{r}}}{\partial z} = p_z\Phi_{\boldsymbol{r}}\end{cases}\]</span></p><p>其解为</p><p><span class="math display">\[\Phi _{\boldsymbol{p}}(\boldsymbol{r}) =\frac{1}{(2\pi\hbar)^\frac{3}{2}}e^{\frac{i}{\hbar}\boldsymbol{p}\cdot\boldsymbol{r}}\]</span></p><p>测量结果为 <span class="math inline">\(p\)</span> 的概率密度为</p><p><span class="math display">\[\vert c_p \vert^2 = \left\vert \int\Phi_p^*\Psi\,\mathrm{d}v\right\vert^2 = \left\vert \int\frac{1}{(2\pi\hbar)^\frac{3}{2}}e^{-\frac{i}{\hbar}\boldsymbol{p}\cdot\boldsymbol{r}}\Psi\,\mathrm{d}v\right\vert^2\]</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{p} = \sum_{n} p_i\vert c_{p_i} \vert ^2\]</span></p><h4 id="动能本征方程">动能本征方程</h4><p><span class="math display">\[-i\hbar \nabla \Phi _{\boldsymbol{p}}(\boldsymbol{r}) = \hat{p}\Phi_{\boldsymbol{p}}(\boldsymbol{r})\]</span></p><p>其在三个坐标轴的分量为</p><p><span class="math display">\[\begin{cases}  -i\hbar \frac{\partial \Phi _{\boldsymbol{p}}}{\partial x} = p_x\Phi_{\boldsymbol{p}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{p}}}{\partial y} = p_y\Phi_{\boldsymbol{p}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{p}}}{\partial z} = p_z\Phi_{\boldsymbol{p}}\end{cases}\]</span></p><p>记动能算符为 <span class="math inline">\(\hat{T}\)</span></p><p><span class="math display">\[\hat{T}\Phi _{\boldsymbol{p}}(\boldsymbol{r}) =-\frac{\hbar^2}{2m}\nabla ^2\Phi _{\boldsymbol{p}}(\boldsymbol{r})=\frac{\hat{p}^2}{2m}\Phi _{\boldsymbol{p}}(\boldsymbol{r})\]</span></p><p>所以<strong>动量的本征函数等于动能的本征函数</strong></p><p>同样当一个量子系统处于量子态 <spanclass="math inline">\(\Psi\)</span> 时，测量动能为 <spanclass="math inline">\(\frac{p^2}{2m}\)</span> 的概率为</p><p><span class="math display">\[\vert c_{\frac{p^2}{2m}} \vert^2 = \left\vert \int\Phi_{\frac{p^2}{2m}}^*\Psi\,\mathrm{d}v\right\vert^2 = \left\vert \int\frac{1}{(2\pi\hbar)^\frac{3}{2}}e^{-\frac{i}{\hbar}\boldsymbol{p}\cdot\boldsymbol{r}}\Psi\,\mathrm{d}v\right\vert^2\]</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{\frac{p^2}{2m}} = \sum_{n} \frac{p_i^2}{2m}\vertc_{\frac{p_i^2}{2m}} \vert ^2\]</span></p><h3 id="态叠加原理">态叠加原理</h3><p>如果 <span class="math inline">\(\Psi_1 , \Psi_2 \ldots\)</span>是体系的一系列可能的状，则 <span class="math inline">\(\displaystyle\Psi= \sum _i ^n c_n\Psi_n\)</span> 也是体系的一个可能的状态。对于处于 <spanclass="math inline">\(\Psi\)</span> 态的体系，该体系分别部分地处在 <spanclass="math inline">\(\Psi_1 , \Psi_2 \ldots \Psi_n \ldots\)</span>态中</p><h3 id="薛定谔方程-1">薛定谔方程</h3><p>波函数随时间演化满足<strong>薛定谔方程</strong></p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (\boldsymbol{r},t)}{\partial t} =\hat{H} \Psi (\boldsymbol{r},t)}\]</span></p><h4 id="定态问题-1">定态问题</h4><p>若粒子处于稳定的势场中，则势能函数 <spanclass="math inline">\(U\)</span> 与时间无关，称这类问题为定态问题</p><p><span class="math display">\[\Psi(\boldsymbol{r} , t) = \Phi(\boldsymbol{r})e^{-i\frac{1}{\hbar}Et}\]</span></p><p><span class="math display">\[\left[ -\frac{\hbar^2}{2m}\nabla^2   + U(\boldsymbol{r})\right]\Phi(\boldsymbol{r}) = E\Phi(\boldsymbol{r})\]</span></p><p>也称为哈密顿算符的本征方程</p><h3 id="同类粒子的不可分辨性原理">同类粒子的不可分辨性原理</h3><p>在量子力学中，内禀属行完全相同的粒子是<strong>不可分辨</strong>的，对任意这两个粒子进行交换，不会改变系统的状态</p><p>经典力学中，能够得到粒子的运动方程和轨道方程 <spanclass="math inline">\(\vec{r} =\vec{r}(t)\)</span>，然而在量子力学中，只能得到粒子在空间中分布的概率密度<spanclass="math inline">\(\rho=\vert\Psi(\boldsymbol{r},t)\vert^2\)</span>，而不能得到粒子在空间中的轨道方程，因此得不到粒子的轨道方程</p><p>对于内禀性相同的粒子，因为没有轨道方程，所以无法分辨，对于任意的两个这样的粒子进行交换，不会改变系统的状态，即粒子在空间中出现的概率密度不会改变</p><p><span class="math display">\[\begin{aligned}  &amp;&amp;\left\vert\Psi(1,\ldots , i , \ldots , j \ldotsn)\right\vert &amp;= \left\vert\Psi(1,\ldots , j , \ldots , i \ldotsn)\right\vert\\  \Rightarrow&amp;&amp;\Psi(1,\ldots , i , \ldots , j \ldots n) &amp;=e^{i\theta}\Psi(1,\ldots , j , \ldots , i \ldots n)\end{aligned}\]</span></p><p>实验表明，所有粒子可以分为两类</p><ol type="1"><li><strong>玻色子：</strong> <spanclass="math inline">\(\theta=0\)</span>，交换粒子后波函数不变</li><li><strong>费米子：</strong> <spanclass="math inline">\(\theta=\pi\)</span>，交换粒子后波函数反对称</li></ol><h3 id="算符之间的对易关系">算符之间的对易关系</h3><p>两个算符 <span class="math inline">\(\hat{A}\)</span> 和 <spanclass="math inline">\(\hat{B}\)</span> 的对易子记为 <spanclass="math inline">\(\left[\hat{A} , \hat{B}\right] =\hat{A}\hat{B}-\hat{B}\hat{A}\)</span></p><h4id="动量算符和坐标算符之间的对易关系">动量算符和坐标算符之间的对易关系</h4><p><span class="math display">\[\left[x,\hat{p}_{x}\right] = -i\hbar\]</span></p><p><strong>证明：</strong></p><p>将 <span class="math inline">\(\left[x,\hat{p}_x\right] = x\hat{p}_X- \hat{p}_x x\)</span> 作用于任意波函数 <spanclass="math inline">\(\Psi\)</span> 上</p><p><span class="math display">\[\begin{aligned}  \left[x,\hat{p}_{x}\right]\Psi &amp;= \left(x\hat{p}_{x} - \hat{p}_xx\right)\Psi\\  &amp;=-i\hbar\left(x\frac{\partial}{\partial x} -\frac{\partial}{\partial x}x\right)\Psi\\  &amp;=-i\hbar\left[x\frac{\partial \Psi}{\partialx}-\frac{\partial}{\partial x}\left(x\Psi\right)\right]\\  &amp;=i\hbar\Psi\end{aligned}\]</span></p><p>故 <span class="math inline">\(\left[x,\hat{p}_{x}\right] =-i\hbar\)</span></p><h3 id="共同本征函数">共同本征函数</h3><h4 id="两个算符对易">两个算符对易</h4><p>如果两个算符 <span class="math inline">\(\hat{A}\)</span> 和 <spanclass="math inline">\(\hat{B}\)</span> 满足对易子为 <spanclass="math inline">\(0\)</span> ，即 <spanclass="math inline">\(\left[\hat{A},\hat{B}\right] = \hat{A}\hat{B} -\hat{B}\hat{A} = 0\)</span>，则称这两个算符<strong>对易</strong></p><h4 id="对易的一个定理">对易的一个定理</h4><p>若两个力学量算符有一组共同完备的本征函数系，则二算符对易</p><p><strong>证明：</strong></p><p>假设</p><p><span class="math display">\[\begin{cases}  \hat{F}\varphi _n = F_n \varphi _n\\  \hat{G}\varphi _n = G_n \varphi _n\end{cases}\]</span></p><p><span class="math inline">\(\varphi\)</span> 组成完备系，则任意量子态<span class="math inline">\(\Phi(x)\)</span> 可以按其展开为 <spanclass="math inline">\(\Phi(x) = \sum _n c_i \varphi _i (x)\)</span></p><p>则</p><p><span class="math display">\[\begin{aligned}  \left(\hat{F}\hat{G}-\hat{G}\hat{F}\right)\Psi(x)  &amp;= \left(\hat{F}\hat{G}-\hat{G}\hat{F}\right)\sum _n c_n \varphi_n (x)\\  &amp;= \sum _n c_n \left(\hat{F}\hat{G}-\hat{G}\hat{F}\right)\varphi_n (x)\\  &amp;= \sum _n c_n \left(F_nG_n - G_nF_n\right)\varphi _n (x)\\  &amp; = 0\end{aligned}\]</span></p><p>由于 <span class="math inline">\(\Psi(x)\)</span> 是任意的函数，则<span class="math inline">\(\hat{F}\hat{G} = \hat{G}\hat{F}\)</span></p><ul><li><strong>其逆定理：</strong>若两个力学算符对易，则这两个算符有组成完备系的共同本征函数</li></ul><p><strong>证明：</strong></p><p>已知 <span class="math inline">\(\hat{F}\hat{G} =\hat{G}\hat{F}\)</span>，<spanclass="math inline">\(\hat{F}\phi_n=F\phi_n\)</span></p><p><span class="math display">\[\hat{F}\hat{G}\varphi _n = \hat{G}\hat{F}\varphi _n= F\hat{G}\varphi _n\]</span></p><p>即</p><p><span class="math display">\[\hat{F}\left(\hat{G}\varphi _n\right) = F\left(\hat{G}\varphi _n\right)\]</span></p><p>说明 <span class="math inline">\(\hat{G}\varphi _n\)</span> 也是<span class="math inline">\(\hat{F}\)</span> 的本征函数，本征值为 <spanclass="math inline">\(F\)</span> 故 <spanclass="math inline">\(\hat{G}\varphi _n\)</span> 和 <spanclass="math inline">\(\varphi _n\)</span> 表示统一个量子态，<spanclass="math inline">\(\hat{G}\varphi _n = G\varphi\)</span></p><h3 id="力学量完全集合">力学量完全集合</h3><ul><li><strong>定义：</strong>能够完全确定状态的一组两两对易的力学量算符的最小（数目）集称为<strong>力学量完全集</strong></li><li>力学量完全集中的力学量数目一般与体系自由度数相同</li><li>由力学量的完全集所确定的本征函数系构成该体系态空间的一组完备的本征函数，即体系中的任何状态均可用它展开</li></ul><h3 id="角动量算符之间的对易关系">角动量算符之间的对易关系</h3><h4 id="角动量算符">角动量算符</h4><ul><li><span class="math inline">\(\displaystyle \left[\hat{L}_{x} ,\hat{L}_y\right] = i\hbar \hat{L}_z\)</span></li><li><span class="math inline">\(\displaystyle \left[\hat{L}_{y} ,\hat{L}_z\right] = i\hbar \hat{L}_x\)</span></li><li><span class="math inline">\(\displaystyle \left[\hat{L}_{z} ,\hat{L}_x\right] = i\hbar \hat{L}_y\)</span></li></ul><h4 id="角动量平方算符">角动量平方算符</h4><p><span class="math display">\[\begin{aligned}\hat{L} ^2 =\hat{L} \cdot \hat{L} &amp;= \hat{L}_x^2 + \hat{L}_y^2 +\hat{L}_z^2\\  &amp;= -\hbar ^2 \left[\frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial}{\partial\theta}\right)+\frac{1}{\sin\theta^2}\frac{\partial^2}{\partial\varphi^2}\right]\end{aligned}\]</span></p><p><span class="math display">\[\left[\hat{L}^2 , \hat{L}_x\right] = \left[\hat{L}^2 , \hat{L}_y\right]= \left[\hat{L}^2 , \hat{L}_z\right] = 0\]</span></p><h5 id="角动量算符的本征方程">角动量算符的本征方程</h5><p><span class="math display">\[\begin{aligned}  &amp;&amp;-\hbar ^2 \left[\frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial}{\partial\theta}\right)+\frac{1}{\sin^2\theta}\frac{\partial^2}{\partial\varphi^2}\right]Y &amp;= \mu \hbar ^2 Y\\  \Rightarrow&amp;&amp;\frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partialY}{\partial\theta}\right)+\frac{1}{\sin^2\theta}\frac{\partial^2}{\partial\varphi^2}Y +\mu Y &amp;= 0\end{aligned}\]</span></p><p>令 <span class="math inline">\(Y(\theta , \varphi) =\Theta(\theta)f(\varphi)\)</span>，得到</p><p><span class="math display">\[\begin{aligned}  &amp;\frac{sin\theta}{\Theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial\Theta}{\partial \theta }\right) +\mu\sin^2\theta = -\frac{1}{f}\frac{\partial ^2 f}{\partial\varphi ^2} =const = \lambda\\  \Rightarrow &amp;  \begin{cases}    \frac{1}{\sin\theta}\frac{\mathrmd}{\mathrm{d}\theta}\left(\sin\theta\frac{\mathrm{d}\Theta}{\mathrm{d}\theta}\right)+\left(\mu -\frac{\lambda}{\sin^2\theta}\right)\Theta = 0\\    \frac{\mathrm{d}^2 f}{\mathrm{d}\varphi ^2} +\lambda f = 0  \end{cases}\end{aligned}\]</span></p><p>先处理关于 <span class="math inline">\(\varphi\)</span> 的方程</p><p>令 <span class="math inline">\(\lambda = m_l ^2 , m_l = 0, \pm 1, \pm2, \ldots\)</span>，则</p><p><span class="math display">\[f(\varphi) = A\cos(m_l \varphi) + B\sin(m_l \varphi)\]</span></p><p>再处理关于 <span class="math inline">\(\theta\)</span> 的方程</p><p><span class="math display">\[\begin{aligned}  &amp;\frac{1}{\sin\theta}\frac{\mathrmd}{\mathrm{d}\theta}\left(\sin\theta\frac{\mathrm{d}\Theta}{\mathrm{d}\theta}\right)+\left(\mu -\frac{\lambda}{\sin^2\theta}\right)\Theta = 0\\  \Rightarrow &amp; \frac{1}{\sin\theta}\frac{\mathrmd}{\mathrm{d}\theta}\left(\sin\theta\frac{\mathrm{d}\Theta}{\mathrm{d}\theta}\right)+\left(\mu -\frac{m_l^2}{\sin^2\theta}\right)\Theta = 0\\\end{aligned}\]</span></p><p>令 <span class="math inline">\(x = \cos \theta ,y(x) =\Theta(\theta)\)</span>，则</p><p><span class="math display">\[\frac{1}{1-x^2}\frac{\mathrm{d}^2y}{\mathrm{d}x^2}-2x\frac{\mathrm{d}y}{\mathrm{d}x}+ \left(\mu-\frac{m_l^2}{1-x^2}\right)y = 0 \quad\left(\text{连带勒让德方程}\right)\]</span></p><ul><li><strong>本征值：</strong><span class="math inline">\(\mu =l(l+1)\)</span>，<spanclass="math inline">\(l=0,1,2,\ldots\)</span></li><li><span class="math inline">\(\Theta(\theta) =P_l^m\left(\theta\right)\)</span></li></ul><p>则角动量平方算符的本征方程变为</p><p><span class="math display">\[\hat{L}^2 Y_{l,m_l} = -\hbar ^2\left[\frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial}{\partial\theta}\right)+\frac{1}{\sin^2\theta}\frac{\partial^2}{\partial\varphi^2}\right]Y_{l,m_l} = l(l+1)\hbar ^2 Y_{l,m_l}\]</span></p><p>其解为</p><p><span class="math display">\[Y_{L,m_l}(\theta , \varphi) = (-1)^{m_l}\sqrt{\frac{(2l+1)(l-\vertm_l\vert)!}{4\pi (l+\vertm_l\vert)!}}P_l^{m_l}(\cos\theta)e^{im_l\varphi}\]</span></p><p>其中 <span class="math inline">\(l = 0 , 1 , 2 , \ldots\)</span>，<span class="math inline">\(m_l = -l , -l +1 , \ldots , l\)</span>该函数同时也为角动量算符 <span class="math inline">\(\hat{L}_z\)</span>的本征函数</p><h5 id="统计平均值">统计平均值</h5><p>当一个量子系统处于量子态 <span class="math inline">\(\Psi\)</span>时，且满足 <span class="math inline">\(\displaystyle \Psi\left(\theta ,\varphi\right) = \sum_{l}\sum_{m_l=-1}^l c_{l,m_l}Y_{l,m_l}\left(\theta, \varphi\right)\)</span> ，<spanclass="math inline">\(\sum_{l}\sum_{m_l = -1}^l =\left\vertc_{l,l_m}\right\vert^2 = 1\)</span> 时，对测量结果为 <spanclass="math inline">\(l(l+1)\hbar ^2\)</span> 的概率为 <spanclass="math inline">\(\left\vertc_{l,m_l}\right\vert^2\)</span>，测量完成之后，该量子系统坍缩至 <spanclass="math inline">\(Y_{l,m_l}\)</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{L}^2 = \sum_{l}l(l+1)\hbar ^2 \sum_{m_l=-l}^{l} \left\vertc_{l,m_l}\right\vert^2\]</span></p><p>对角动量 <span class="math inline">\(z\)</span>分量进行测量的结果一定是该力学量算符的本征值之一，测量结果为 <spanclass="math inline">\(m_l\hbar\)</span> 的概率为 <spanclass="math inline">\(\left\vert c_{l,m_l}\right\vert^2\)</span>，测量完成之后，该量子系统坍缩至 <spanclass="math inline">\(Y_{l,m_l}\)</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{L}_z = \sum_{l}  \sum_{m_l=-l}^{l} m_l\hbar\left\vertc_{l,m_l}\right\vert^2\]</span></p><p>这里角动量平方算符和角动量算符的本征方程分别为</p><p><span class="math display">\[\hat{L}^2 Y_{l,m_l} = l(l+1)\hbar ^2 Y_{l,m_l}\]</span></p><p><span class="math display">\[\hat{L}_z Y_{l,m_l} = m_l\hbar Y_{l,m_l}\]</span></p><h2 id="算符与电子自旋">算符与电子自旋</h2><h3id="未归一化的量子态下的算符平均值">未归一化的量子态下的算符平均值</h3><p><span class="math display">\[\bar{A} = \frac{\iiint\Psi^*(x,y,z)\hat{A}\Psi(x,y,z)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z}{\iiint\Psi^*(x,y,z)\Psi(x,y,z)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z}\]</span></p><h3 id="线性算符">线性算符</h3><p>线性算符 <span class="math inline">\(\hat{F}\)</span> 满足</p><p><span class="math display">\[\hat{F}\left(a\Psi_1 + b\Psi_2\right) = a\hat{F}\Psi_1 + b\hat{F}\Psi_2\]</span></p><p>位置算符 <span class="math inline">\(\hat{x} = x\)</span> 和动量算符<span class="math inline">\(\hat{p_x} = -i\hbar\frac{\partial}{\partialx}\)</span> 均为线性算符</p><p>由于态叠加原理，哈密顿算符 <spanclass="math inline">\(\hat{H}\)</span>也是线性算符，薛定谔方程是线性微分方程，则若 <spanclass="math inline">\(\Psi_1\)</span> 和 <spanclass="math inline">\(\Psi_2\)</span> 是薛定谔方程的解，则 <spanclass="math inline">\(c_1\Psi_1 + c_2\Psi_2\)</span>也是薛定谔方程的解</p><p>对于定态薛定谔方程也满足这个条件</p><p>态叠加原理要求算符是线性的厄米算符</p><h3 id="厄米算符">厄米算符</h3><h4 id="厄米算符的本征值是实数">厄米算符的本征值是实数</h4><h4 id="厄米算符的平均值是实数">厄米算符的平均值是实数</h4><h4 id="厄米算符本征值具有正交性">厄米算符本征值具有正交性</h4><p>当两个函数 <span class="math inline">\(\Psi_q\)</span> 和 <spanclass="math inline">\(\Psi_2\)</span> 满足下列关系</p><p><span class="math display">\[\int \Psi_1^*\Psi_2\,\mathrm{d}x \equiv \int\left\langle\Psi_1\vert\Psi_2\right\rangle =0\]</span></p><p>则我们称这两个函数相互正交，<spanclass="math inline">\(\left\langle\Psi_1\vert\Psi_2\right\rangle\)</span>称为内积</p><p>厄米算符两个不同本征值的本征函数总是正交的</p><p><strong>证明：</strong></p><p>（待补充 o_O）</p><p>将这些正交的本征函数归一化，<span class="math inline">\(\displaystyle\int \Psi_1^*\Psi_2\,\mathrm{d}x =1\)</span>，所以<strong>厄米算符</strong>有一组正交化的本征函数</p><p><span class="math display">\[\int \Psi_k^*\Psi_l\,\mathrm{d}x =\delta_{kl} =\begin{cases}  0 &amp;,k\neq l\\  1 &amp;,k=l\end{cases}\]</span></p><p>所以厄米算符的分立谱的所有本征函数都是正交归一化的</p><h3 id="动量算符的厄米性">动量算符的厄米性</h3><p><strong>证明：</strong></p><p>（待补充）</p><h3 id="算符运算初步">算符运算初步</h3><h4 id="算符之和">算符之和</h4><p><span class="math display">\[\hat{A} + \hat{B} = \hat{C}\]</span></p><p><span class="math display">\[\hat{C}\Psi = \left(\hat{A}+\hat{B}\right)\Psi=\hat{A}\Psi + \hat{B}\Psi\]</span></p><h4 id="算符之积">算符之积</h4><p><span class="math display">\[\hat{A}\hat{B} = \hat{C}\]</span></p><p><span class="math display">\[\hat{C}\Psi = \hat{A}\left(\hat{B}\Psi\right)\]</span></p><p>一般情况下，算符之积<strong>不满足</strong>交换律，即</p><p><span class="math display">\[\hat{A}\hat{B} \neq \hat{B}\hat{A}\]</span></p><h4 id="算符的对易性">算符的对易性</h4><p>如果 <span class="math inline">\(\hat{A}\hat{B} =\hat{B}\hat{A}\)</span>，则称 <spanclass="math inline">\(\hat{A}\)</span> 和 <spanclass="math inline">\(\hat{B}\)</span> 是<strong>对易的</strong></p><p>记为 <span class="math inline">\(\left[\hat{A},\hat{B}\right] \equiv\hat{A}\hat{B} - \hat{B}\hat{A} = 0\)</span>，称 <spanclass="math inline">\(\left[\hat{A},\hat{B}\right]\)</span> 为 <spanclass="math inline">\(\hat{A}\)</span> 和 <spanclass="math inline">\(\hat{B}\)</span> 的<strong>对易子</strong></p><h3 id="电子自旋">电子自旋</h3><h4 id="电子自旋角动量及其空间量子化">电子自旋角动量及其空间量子化</h4><h5 id="斯特恩-盖拉赫实验">斯特恩-盖拉赫实验</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192235176.png"alt="Stern-Garlach experiment" /><figcaption aria-hidden="true">Stern-Garlach experiment</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192240318.png"alt="磁力线" /><figcaption aria-hidden="true">磁力线</figcaption></figure><p>磁铁的特殊形状使得磁极之间的磁力线不是均匀的，从而产生非匀强磁场</p><p>在非匀强磁场之中，银原子和磁场的相互作用能为</p><p><span class="math display">\[W = -\boldsymbol{M}\cdot\boldsymbol{B}\]</span></p><p>对 <span class="math inline">\(z\)</span> 方向求微分</p><p><span class="math display">\[F_z = -\frac{\partial W}{\partial z} = M_z \frac{\partial B}{\partial z}\]</span></p><p>实验结果为</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192317946.png"alt="result" /><figcaption aria-hidden="true">result</figcaption></figure><p>加入磁场之后，银原子分裂为两束。银原子的角动量数 <spanclass="math inline">\(l=0\)</span>，且最外层为 <spanclass="math inline">\(s\)</span>电子，无轨道角动量，说明会银原子有自由度，且有两个取值</p><h6 id="斯特恩-盖拉赫实验的意义">斯特恩-盖拉赫实验的意义</h6><ol type="1"><li>证明了角动量空间量子化的存在<ul><li>原子沉积层不是连续的一片，而是分开的线，说明了角动量空间量子化的存在</li></ul></li><li>发现了新的矛盾<ul><li><spanclass="math inline">\(l=0\)</span>，应当有一条沉积线，但是实验结果却又两条沉积线，这说明原来对原子中的电子运动的描述是不完全的</li></ul></li><li>提供了原子的“态分离”技术</li></ol><h6 id="理论解释">理论解释</h6><p>1925年乌伦贝克和古兹米特根据斯特恩-盖拉赫实验的结果，<strong>提出了电子不是质点，具有固有的自旋角动量<span class="math inline">\(\boldsymbol{S}\)</span> 和相应的自旋磁矩<span class="math inline">\(\boldsymbol{\mu_s}\)</span></strong>的观点</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192340149.png"alt="电子自旋角动量和磁矩" /><figcaption aria-hidden="true">电子自旋角动量和磁矩</figcaption></figure><p>由于电子带负电，其自旋磁矩和根据右手螺旋定律得到的方向相反</p><p>相对于外磁场方向，<span class="math inline">\(\boldsymbol{B}\)</span>有朝上和朝下两种取向</p><p>但是若将电子视为 <span class="math inline">\(r=10^{-16}m\)</span>的小球，按照 <spanclass="math inline">\(\boldsymbol{S}\sim\hbar\)</span>估计得到的电子表面速度 <span class="math inline">\(&gt;c\)</span></p><p>电子在任意一个方向测量其自旋角动量的结果都是 <spanclass="math inline">\(\pm\hbar\)</span></p><h5 id="泡利不相容原理">泡利不相容原理</h5><ol type="1"><li>费米子和玻色子<ol type="1"><li><strong>费米子：</strong> 自旋量子数为半奇数的粒子</li><li><strong>玻色子：</strong> 自旋量子数为整数的粒子</li></ol></li><li>泡利不相容原理<ul><li>不能有两个电子具有相同的 <spanclass="math inline">\(n,m,l,m_l,m_s\)</span></li></ul></li><li>玻色凝聚<ul><li>玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子</li></ul></li></ol><h5 id="电子的自旋算符和自旋波函数">电子的自旋算符和自旋波函数</h5><h6 id="自旋算符">自旋算符</h6><p>自旋角动量是纯量子概念，但也是一个力学量</p><p>自旋角动量与电子的坐标和动量无关，是电子内部状态的表征，是描述电子状态的第四个自由度</p><p>自旋算符记为 <span class="math inline">\(\hat{S}\)</span></p><ul><li><spanclass="math inline">\(\hat{\boldsymbol{S}}\times\hat{\boldsymbol{S}}=i\hbar\hat{\boldsymbol{S}}\)</span></li><li><spanclass="math inline">\([\hat{\boldsymbol{S}_x},\hat{\boldsymbol{S}}_y] =i\hbar \hat{\boldsymbol{S}}_z\)</span></li><li><spanclass="math inline">\([\hat{\boldsymbol{S}}_y,\hat{\boldsymbol{S}}_z] =i\hbar \hat{\boldsymbol{S}}_x\)</span></li><li><spanclass="math inline">\([\hat{\boldsymbol{S}}_z,\hat{\boldsymbol{S}}_x] =i\hbar \hat{\boldsymbol{S}}_y\)</span></li></ul><p>由于<strong>自旋角动量</strong>在空间任意方向上的投影都只能取 <spanclass="math inline">\(\pm\frac{\hbar}{2}\)</span>，则 <spanclass="math inline">\(\hat{\boldsymbol{S}}_x\)</span>，<spanclass="math inline">\(\hat{\boldsymbol{S}}_y\)</span> 和 <spanclass="math inline">\(\hat{\boldsymbol{S}}_z\)</span> 的本征值都是 <spanclass="math inline">\(\pm\frac{\hbar}{2}\)</span>，其平方为 <spanclass="math inline">\(\frac{\hbar}{2}^2\)</span></p><h6 id="含自旋的状态波函数">含自旋的状态波函数</h6><p>电子的含自旋的波函数为</p><p><span class="math display">\[\Psi =\Psi(x,y,z,S_z,t)\]</span></p><p>由于 <span class="math inline">\(S_z\)</span> 只有两个取值 <spanclass="math inline">\(\pm\frac{\hbar}{2}\)</span>，所以可以写为两个分量</p><p><span class="math display">\[\begin{cases}  \psi_1=\psi(x,y,z,\frac{\hbar}{2},t)\\  \psi_2=\psi(x,y,z,-\frac{\hbar}{2},t)\end{cases}\]</span></p><p>写作列矩阵</p><p><span class="math display">\[\Psi = \begin{pmatrix}  \psi_1(\boldsymbol{r},t)\\  \psi_2(\boldsymbol{r},t)\end{pmatrix}\]</span></p><p>这里的正负号是规定好的</p><p>若已知电子处于 <span class="math inline">\(S_z =\frac{\hbar}{2}\)</span> 或 <span class="math inline">\(S_z =-\frac{\hbar}{2}\)</span> 的状态，则其波函数分别可以写为：</p><p><span class="math display">\[\Psi = \begin{pmatrix}  \psi_1(\boldsymbol{r},t)\\  0\end{pmatrix}\qquad\Psi = \begin{pmatrix}  0\\  \psi_2(\boldsymbol{r},t)\end{pmatrix}\]</span></p><h6 id="自旋算符的矩阵表示pauli-矩阵">自旋算符的矩阵表示，Pauli矩阵</h6><p><strong><span class="math inline">\(\hat{S}_z\)</span>的矩阵形式</strong></p><p><span class="math display">\[\hat{S}_z = \frac{\hbar}{2}\begin{pmatrix}  1 &amp; 0\\  0 &amp; -1\end{pmatrix}\]</span></p><p><strong>Pauli 算符</strong></p><p>对于 <span class="math inline">\(\hat{S}_z\)</span>的矩阵形式，我们定义 Pauli 算符，使得</p><p><span class="math display">\[\hat{S}_z = \frac{\hbar}{2}\hat{\sigma}\]</span></p><p>从自旋算符与 Pauli 矩阵之间的关系，可以得到自旋算符的矩阵表示</p><p><span class="math display">\[\hat{S}_x = \frac{\hbar}{2}\begin{pmatrix}  0 &amp; 1\\  1 &amp; 0\end{pmatrix}\quad\hat{S}_y = \frac{\hbar}{2}\begin{pmatrix}  0 &amp; -i\\  i &amp; 0\end{pmatrix}\quad\hat{S}_z = \frac{\hbar}{2}\begin{pmatrix}  1 &amp; 0\\  0 &amp; -1\end{pmatrix}\]</span></p><h6 id="自旋波函数">自旋波函数</h6><p>波函数 <span class="math inline">\(\Psi =\begin{pmatrix}\psi_1\newline \psi_2\end{pmatrix}\)</span>中，一般情况下，<spanclass="math inline">\(\Psi_1\neq\Psi_2\)</span>，两者对 <spanclass="math inline">\((x,y,z)\)</span>的依赖是不相同的，因为自旋对轨道运动有一定的影响，但是当影响足够小时，可以忽略，此时认为<span class="math inline">\(\Psi_1\)</span> 和 <spanclass="math inline">\(\Psi_2\)</span> 的函数形式相同，<spanclass="math inline">\(\Psi\)</span> 可以写作如下的形式</p><p><span class="math display">\[\Psi(\boldsymbol{r},S_z,t) =\psi(\boldsymbol{r},t)\chi(S_z)\]</span></p><p>其中 <span class="math inline">\(\chi(S_z)\)</span> 是 <spanclass="math inline">\(\hat{S}_z\)</span> 的本征函数，称为自旋波函数</p><p><span class="math display">\[\chi_{\frac{1}{2}}(S_z) = \begin{pmatrix}  1\\  0\end{pmatrix}\quad\chi_{-\frac{1}{2}}(S_z) = \begin{pmatrix}  0\\  1\end{pmatrix}\]</span></p><p>这两个自旋波函数相互正交</p><h3 id="无限深势阱">无限深势阱</h3><h3 id="谐振子">谐振子</h3><h4 id="势能">势能</h4><p>若先择线性谐振子平衡位置为坐标原点和势能零点，则一维线性谐振子得到势能可以表示为</p><p><span class="math display">\[U(x) = \frac{1}{2}kx^2 = \frac{1}{2}m\omega^2x^2\]</span></p><h5 id="谐振子的定态薛定谔方程">谐振子的定态薛定谔方程</h5><p>一维谐振子的哈密顿量为</p><p><span class="math display">\[\hat{H} = -\frac{\hbar^2}{2m}\frac{\partial^2}{\partial x^2} +\frac{1}{2}m\omega^2x^2\]</span></p><p>满足的定态薛定谔方程为</p><p><span class="math display">\[\left[-\frac{\hbar^2}{2m}\frac{\partial^2}{\partial x^2} +\frac{1}{2}m\omega^2x^2\right]\Phi(x) = E\Phi(x)\]</span></p><p>一维谐振子的能量是量子化的</p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>物理</tag>
      
      <tag>量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构笔记">数据结构笔记</h1><p><a href="https://oi-wiki.org/ds">oiWiki 中的数据结构</a></p><h2 id="引言">引言</h2><h3 id="算法与数据结构">算法与数据结构</h3><p>数据结构的研究内容</p><ol type="1"><li>数据之间的<strong>逻辑关系</strong>，以及这种关系对应的操作</li><li><strong>储存实现</strong>：数据及逻辑关系的存储</li><li><strong>运算实现</strong>：具体存储模式下，运算的实现，即<strong>算法</strong></li></ol><h4 id="数据的逻辑结构">数据的逻辑结构</h4><ul><li><strong>集合结构</strong>次序任意，元素之间除了<strong>同处于一个集合内</strong>之外没有任意其他的关系.</li><li><strong>线性结构</strong>数据元素的<strong>有序</strong>排列，除了头尾的元素外其余元素都有一个前趋和一个后继.</li><li><strong>树形结构</strong>除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.</li><li><strong>图形结构</strong> 每个元素的前趋和后继数量都不限 <imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png"alt="FourLogicalDataStructures" /></li></ul><h4 id="数据结构的操作">数据结构的操作</h4><ul><li><strong>创造</strong></li><li><strong>清除</strong></li><li><strong>插入</strong></li><li><strong>删除</strong></li><li><strong>更新</strong></li><li><strong>搜索</strong></li><li><strong>访问</strong></li><li><strong>遍历（traverse）</strong>：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次</li><li>每一种数据结构的特定操作</li></ul><p>数据结构的<strong>五大类</strong>：构建类、属性类、数据操纵类、遍历类、特定类</p><h3 id="存储实现">存储实现</h3><h3 id="算法分析">算法分析</h3><h4 id="时间复杂度的概念">时间复杂度的概念</h4><ul><li>是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，<spanclass="math inline">\(T(n)\)</span></li><li>算法的时间复杂度也与被处理的数据分布有关</li><li>算法的时间复杂度分为三种<ul><li>最好的</li><li>最坏的</li><li>平均</li></ul></li></ul><h4 id="算法运算量的计算">算法运算量的计算</h4><h4 id="渐进时间复杂度">渐进时间复杂度</h4><h4 id="算法的优化">算法的优化</h4><h4 id="空间复杂度的概念">空间复杂度的概念</h4><ul><li>渐进的空间复杂度</li><li>一般只考虑<strong>辅助</strong>空间的占用情况</li><li>空间复杂度一般按照最坏情况处理</li><li>空间复杂度的计算、表示方法与时间复杂度相同</li></ul><h3 id="面向对象方法">面向对象方法</h3><h4 id="类模板的定义">类模板的定义</h4><p>类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型</p><h5 id="定义格式">定义格式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 标识符&gt;<br><span class="hljs-keyword">class</span> 类名<br>&#123;<br>    <span class="hljs-comment">// 类成员声明</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="类定义的一般格式">类定义的一般格式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 类名<br>&#123;<br>  [<span class="hljs-keyword">private</span>:]<br>    <span class="hljs-comment">// 私有数据成员和成员函数声明</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公有数据成员和成员函数声明</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="虚函数">虚函数</h4><ul><li><p>在基类中用关键词 <code>virtual</code>声明的成员函数，并在派生类中重新定义的函数称为虚函数</p></li><li><p>虚函数的一般格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> 返回类型 函数名(参数表)<br>&#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（<strong>继承</strong>）</p></li><li><p>当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数</p></li><li><p>虚函数在基类中有默认实现，派生类可以选择性地对其进行重写</p></li></ul><h4 id="纯虚函数">纯虚函数</h4><ul><li><p>是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数</p></li><li><p>纯虚函数的一般形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> 返回类型 函数名(参数表) = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>纯虚函数在基类中无实现，只有函数原型，派生类必须实现</p></li></ul><h4 id="抽象类">抽象类</h4><ul><li>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类就是抽象类</li><li>抽象类只能作为其他类的基类，不能建立抽象类的对象</li></ul><h4 id="继承">继承</h4><ul><li>在已有类的基础上建立新的类</li><li>基类（父类）和派生类（子类）</li><li>继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题</li></ul><h5 id="派生类">派生类</h5><ul><li><p>一般格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 派生类名 : [派生方式] 基类名<br>&#123;<br>  <span class="hljs-comment">// 派生类新增的数据成员和成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>派生方法</p><ul><li>公有派生：<code>public</code></li><li>私有派生：<code>protected</code></li><li>保护派生：<code>private</code></li></ul></li><li><p><code>class</code> 默认是 <code>private</code> 继承，<code>struct</code> 默认是 <code>public</code> 继承</p></li></ul><h6 id="派生类对基类成员的访问性">派生类对基类成员的访问性</h6><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><code>public</code> 继承</th><th style="text-align: center;"><code>protected</code> 继承</th><th style="text-align: center;"><code>private</code> 继承</th></tr></thead><tbody><tr><td style="text-align: center;"><code>public</code> 成员</td><td style="text-align: center;">public</td><td style="text-align: center;">protected</td><td style="text-align: center;">private</td></tr><tr><td style="text-align: center;"><code>protected</code> 成员</td><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td><td style="text-align: center;">private</td></tr><tr><td style="text-align: center;"><code>private</code> 成员</td><td style="text-align: center;">不可访问</td><td style="text-align: center;">不可访问</td><td style="text-align: center;">不可访问</td></tr></tbody></table><h4id="类定义时常见的两种const用法">类定义时常见的两种<code>const</code>用法</h4><p>以函数 <code>int search(constelemType&amp;x) const</code> 为例</p><ol type="1"><li>修饰参数 <code>x</code> 的 <code>const</code> 和 <code>&amp;</code>组合<ul><li><code>const</code> 修饰参数 <code>x</code>，表示函数<code>search</code> 不会修改参数 <code>x</code> 的值</li><li>参数加了 <code>const</code>之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数<code>x</code> 的修改操作，若有则会报错</li><li><strong>如果确认函数实现中不准备改变 <code>x</code> 的值，养成加<code>const</code>的习惯</strong></li><li><code>&amp;</code> 修饰参数 <code>x</code>，表示参数 <code>x</code>是引用传递，即传递的是实参的地址，而不是实参的值</li></ul></li><li>修饰函数 <code>search</code> 的 <code>const</code><ul><li>参数表后的 <code>const</code> 保护调用对象的值不被修改</li><li>如果没有 <code>const</code> 修饰，那么在调用对象为<code>const</code> 类型时，不能调用该函数 常量对象只能调用参数表后带<code>const</code> 的常量成员函数</li></ul></li></ol><h2 id="线性表">线性表</h2><h3 id="线性表的定义">线性表的定义</h3><h4 id="线性表的概念">线性表的概念</h4><ul><li><p>是一种<strong>线性结构</strong>，是由 <spanclass="math inline">\(n(n\geq0)\)</span>个数据元素组成的有限序列</p></li><li><p>除了首节点 <span class="math inline">\(A_0\)</span> 和尾节点<span class="math inline">\(A_{n-1}\)</span> 之外，每个节点 <spanclass="math inline">\(A_i\)</span> 有且仅有一个前趋 <spanclass="math inline">\(A_{i-1}\)</span> 和一个后继 <spanclass="math inline">\(A_{i+1}\)</span></p></li><li><p><span class="math inline">\(A_0\)</span> 只有后趋，<spanclass="math inline">\(A_{n-1}\)</span> 只有前趋</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png"alt="线性表" /><figcaption aria-hidden="true">线性表</figcaption></figure></li></ul><h4 id="表的基本操作">表的基本操作</h4><ul><li><strong>创建 <code>create()</code></strong>：创建一个空的线性表</li><li><strong>清除<code>clear()</code></strong>：删除线性表中的所有数据元素</li><li><strong>长度 <code>length()</code></strong>：返回线性表的长度</li><li><strong>插入 <code>insert(i,x)</code></strong>：在线性表的第 <spanclass="math inline">\(i\)</span> 个位置插入一个新元素<code>x</code></li><li><strong>删除 <code>remove(i)</code></strong>：删除线性表中第 <spanclass="math inline">\(i\)</span> 个位置的元素</li><li><strong>搜索 <code>search(x)</code></strong>：在线性表中搜索元素<code>x</code>，返回其位置</li><li><strong>访问 <code>visit(i)</code></strong>：返回线性表中第 <spanclass="math inline">\(i\)</span> 个位置的元素</li><li><strong>遍历<code>traverse()</code></strong>：依次访问线性表中的每个元素</li></ul><h4 id="线性表的抽象类">线性表的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                           <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 返回长度</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 访问</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">list</span>() &#123;&#125;                                  <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现</li><li><strong>抽象类无构造函数</strong></li></ul><h3 id="线性表的顺序实现">线性表的顺序实现</h3><h4 id="顺序存储结构">顺序存储结构</h4><ul><li>节点存储在存储器的一块<strong>连续</strong>的空间中</li><li>节点依照逻辑顺序依次<strong>存放</strong></li><li>节点存放的物理位置和逻辑顺序是对应的</li><li>线性表的顺序实现通常被称为<strong>顺序表</strong></li></ul><h4 id="顺序表类的定义">顺序表类的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqList</span> : <span class="hljs-keyword">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *data;<br>    <span class="hljs-type">int</span> currentLength;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);             <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqList</span>()                              <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>                            <span class="hljs-comment">//清空</span></span><br><span class="hljs-function">    </span>&#123;<br>      currentLength = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                      <span class="hljs-comment">// 返回长度</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> elemType &amp;x)</span></span>;  <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;                     <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                  <span class="hljs-comment">// 遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="函数实现">函数实现</h4><h5 id="构造函数">构造函数</h5><ul><li>定义对象时自动调用，用于初始化对象的数据成员</li><li><strong>函数名与类名相同</strong></li><li>可以有任何类型的参数，也可以没有参数，但是<strong>不能有返回类型</strong>，所以定义时不能说明类型</li><li>若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqList&lt;elemType&gt;::<span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  data = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png"alt="seqList" /><figcaption aria-hidden="true">seqList</figcaption></figure><h5 id="析构函数">析构函数</h5><ul><li>用于释放对象所占用的内存空间，由编译系统自动调用</li><li><strong>函数名与类名相同，前面加 <code>~</code></strong></li><li>不能有参数，也不能有返回类型</li><li>若没有给出析构函数，编译器会自动生成一个默认的析构函数</li><li>不是所有类都要由析构函数</li><li>一般在构造函数中动态申请内存的，必须有析构函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">seqList</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] data;<br>&#125;  <span class="hljs-comment">//在线性表的类中已经实现了，不用到类外定义</span><br></code></pre></td></tr></table></figure><h5 id="顺序表的运算实现">顺序表的运算实现</h5><h6 id="search"><code>search</code></h6><p>从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到<code>x</code> 或找到表尾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">int</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> elemType &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> i ;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; currentLength &amp;&amp; data[i] != x ; ++i);<br>  <span class="hljs-keyword">if</span> (i == currentLength)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="traverse"><code>traverse</code></h6><p>从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemtype</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; currentLength ; ++i)<br>  &#123;<br>    cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="insert"><code>insert</code></h6><ul><li>在第 <code>i</code> 个位置插入元素 <code>x</code></li><li>若插入后表长超过 <code>maxSize</code>，则将 <code>maxSize</code>扩大一倍</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png"alt="seqList::insert" /><figcaption aria-hidden="true">seqList::insert</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (currentSize = maxSize)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = currentLength ; j &gt; i ; --j)<br>  &#123;<br>    data[j] = data[j - <span class="hljs-number">1</span>];<br>  &#125;<br>  data[i] = x;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="doublespace-操作的实现"><code>doubleSpace</code> 操作的实现</h6><ul><li>重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png"alt="seqList::doublespace" /><figcaption aria-hidden="true">seqList::doublespace</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">doublespace</span>()<br>&#123;<br>  elemtype *tmp = data;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  data = <span class="hljs-keyword">new</span> elemtype[maxSize];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; currentLength ; +<span class="hljs-number">+1</span>)<br>  &#123;<br>    data[i] = tmp[i];<br>  &#125;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="remove"><code>remove</code></h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png"alt="seqlist::remove" /><figcaption aria-hidden="true">seqlist::remove</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> ||i &gt; currentlength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i ; j &lt; currentlength <span class="hljs-number">-1</span> ; ++j)<br>  &#123;<br>    data[j] = data[j + <span class="hljs-number">1</span>];<br>  &#125;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性表的链接存储">线性表的链接存储</h3><h4 id="单链表">单链表</h4><ul><li>每个节点附加指针字段，如<code>next</code>，指向直接后继节点，最后一个节点的 <code>next</code>指向 <code>nullptr</code></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png"alt="单链表" /><figcaption aria-hidden="true">单链表</figcaption></figure><h5 id="头节点头指针">头节点、头指针</h5><ul><li>在表头额外增加一个相同类型的特殊结点</li><li>不是线性表中的组成部分</li><li>头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png"alt="带头节点的单链表" /><figcaption aria-hidden="true">带头节点的单链表</figcaption></figure><h5 id="结点及其组成">结点及其组成</h5><ul><li>链表的节点包含两个部分<ul><li>数据字段<ul><li>可以存储任何类型的数据，仍然使用 <code>elemType</code> 表示</li></ul></li><li>指针字段<ul><li>用于存储<strong>后继节点</strong>的地址值</li></ul></li><li>结点类型是链表专用的，可以设为内嵌类</li><li>将节点类定义为 <code>struct</code> 方便链表类访问</li></ul></li></ul><h5 id="单链表类的定义">单链表类的定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sLinkList</span>:<span class="hljs-keyword">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>                                    <span class="hljs-comment">// 节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br><br>    node *head;<br>    <span class="hljs-type">int</span> currentLength;<br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sLinkList</span>();<br>    ~<span class="hljs-built_in">sLinkList</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-1">构造函数</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png"alt="sLinklist" /><figcaption aria-hidden="true">sLinklist</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>sLinkList&lt;elemType&gt;::<span class="hljs-built_in">sLinkList</span>()<br>&#123;<br>  head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="clear"><code>clear</code></h5><ul><li>将单链表变成一个空表</li><li>回收节点空间</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png"alt="sLinkList::clear" /><figcaption aria-hidden="true">sLinkList::clear</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>  node *p = head-&gt;next , *q;<br><br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)        <span class="hljs-comment">// 删除节点</span><br>  &#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="move"><code>move</code></h5><ul><li>返回第 <span class="math inline">\(i\)</span> 个元素的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sLinkList</span>&lt;elemType&gt;::node *sLinkList&lt;elemType&gt;::<span class="hljs-built_in">move</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>  node *p = head;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; ++j)<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="insert-1"><code>insert</code></h5><ol type="1"><li>指针 <code>p</code> 指向要插入的位置 <code>i</code>的前一个节点</li><li>申请一个新节点 <code>s</code></li><li>将 <code>s</code> 的 <code>next</code> 指向 <code>p</code> 的<code>next</code></li><li>将 <code>p</code> 的 <code>next</code> 指向 <code>s</code></li></ol><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png"alt="sLinkList::insert" /><figcaption aria-hidden="true">sLinkList::insert</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sinkList&lt;elemtype&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  node *p = <span class="hljs-built_in">move</span>(i<span class="hljs-number">-1</span>);<br>  node *s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x , p-&gt;next);<br>  p-&gt;next = s;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="remove-1"><code>remove</code></h5><ol type="1"><li>找到被删除节点的前一个节点 <code>pos</code></li><li>让 <code>delp</code> 指向被删除节点</li><li>让 <code>pos</code> 的 <code>next</code> 指向 <code>delp</code> 的<code>next</code></li><li>释放 <code>delp</code> 的空间</li></ol><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png"alt="sLinkList::remove" /><figcaption aria-hidden="true">sLinkList::remove</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  node *pos = <span class="hljs-built_in">move</span>(i<span class="hljs-number">-1</span>);<br>  node *delp = pos-&gt;next;<br>  pos-&gt;next = delp-&gt;next;<br>  <span class="hljs-keyword">delete</span> delp;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="search-1"><code>search</code></h5><ul><li>从头节点开始，依次访问每个节点，直到找到 <code>x</code>或到达表尾</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">int</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> elemtype <span class="hljs-number">7</span>x) <span class="hljs-type">const</span><br>&#123;<br>  node *p = head -&gt; next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data != x) <span class="hljs-comment">// 访问每个节点，条件的顺序不能交换</span><br>  &#123;<br>    p = p-&gt;next;<br>    ++i;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果判定条件改为<code>p-&gt;data != x &amp;&amp; p != nullptr</code>，会在<code>p</code> 为空时试图访问<code>p-&gt;data</code>，导致访问空指针，从而产生未定义行为</li></ul><h5 id="visit"><code>visit</code></h5><ol type="1"><li>找到第 <code>i</code> 个节点</li><li>返回 <code>p-&gt;data</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType sLinkList&lt;elemType&gt;::<span class="hljs-built_in">visit</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">move</span>(i)-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="traverse-1"><code>traverse</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>  node *p = head-&gt;next;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    p = p-&gt;next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双链表">双链表</h4><ul><li>每个节点有两个指针字段<ul><li><code>next</code> 指向直接后继节点</li><li><code>prev</code> 指向直接前驱节点</li></ul></li></ul><h5 id="双链表的头尾节点">双链表的头尾节点</h5><ul><li>头节点<ul><li><code>prev</code> 指向 <code>nullptr</code></li><li><code>next</code> 指向首节点</li></ul></li><li>尾节点 <code>tail</code><ul><li><code>prev</code> 指向最后一个节点</li><li><code>next</code> 指向 <code>nullptr</code></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png"alt="双链表" /><figcaption aria-hidden="true">双链表</figcaption></figure><h5 id="双链表类的定义">双链表类的定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dLinkList</span>:<span class="hljs-keyword">public</span> list&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>                                                         <span class="hljs-comment">// 双链表中的节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      node *prev;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *p = <span class="hljs-literal">nullptr</span> , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        prev = p;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *head , *tail;                                                  <span class="hljs-comment">// 头节点和尾节点</span><br>    <span class="hljs-type">int</span> currentLength;                                                   <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;                                             <span class="hljs-comment">// 返回第 i 个节点的指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">dLinkList</span>();<br>    ~<span class="hljs-built_in">dLinkList</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-2">构造函数</h5><ul><li>申请头节点和尾节点</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png"alt="dLinkList" /><figcaption aria-hidden="true">dLinkList</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>dLinkList&lt;elemType&gt;::<span class="hljs-built_in">dLinkList</span>()<br>&#123;<br>  head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  head-&gt;next = tail;<br>  tail-&gt;prev = head;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="insert-2"><code>insert</code></h5><ol type="1"><li>申请一个新节点 <code>tmp</code>，找到要插入的位置<code>pos</code></li><li>将 <code>tmp</code> 的 <code>prev</code> 指向 <code>pos</code> 的<code>prev</code>，<code>tmp</code> 的 <code>next</code> 指向<code>pos</code></li><li>将 <code>pos</code> 的前一个结点的 <code>next</code> 指向<code>tmp</code></li><li>将 <code>pos</code> 的 <code>prev</code> 指向 <code>tmp</code></li></ol><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png"alt="dLinkList::insert" /><figcaption aria-hidden="true">dLinkList::insert</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> dLinkList&lt;elemtype&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i ,<span class="hljs-type">const</span> elemTypr &amp;x)<br>[<br>  node *pos , *tmp;<br><br>  pos = <span class="hljs-built_in">move</span>(i);<br>  temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x,pos -&gt; prev , pos);<br>  pos-&gt;prev-&gt;next = tmp;<br>  pos-&gt;prev = tmp;<br><br>  ++currentLength;<br>]<br></code></pre></td></tr></table></figure><h5 id="remove-2"><code>remove</code></h5><ol type="1"><li>找到要删除的节点 <code>pos</code></li><li>将 <code>pos</code> 的前一个节点的 <code>next</code> 指向<code>pos</code> 的后一个节点</li><li>将 <code>pos</code> 的后一个节点的 <code>prev</code> 指向<code>pos</code> 的前一个节点</li></ol><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png"alt="dLinkList::remove" /><figcaption aria-hidden="true">dLinkList::remove</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> dLinkList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  node *pos = <span class="hljs-built_in">move</span>(i);<br><br>  pos-&gt;prev-&gt;next = pos-&gt;next;<br>  pos-&gt;next-&gt;prev = pos-&gt;prev;<br><br>  <span class="hljs-keyword">delete</span> pos;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单循环链表">单循环链表</h4><ul><li>一般单循环链表不带头节点</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png"alt="单循环链表" /><figcaption aria-hidden="true">单循环链表</figcaption></figure><h4 id="双循环链表">双循环链表</h4><ul><li>头结点中 <code>prev</code> 字段给出尾结点的地址，尾结点中<code>next</code> 字段给出头结点的地址</li><li>一般也不设置头尾节点</li></ul><h2 id="栈">栈</h2><h3 id="栈的定义">栈的定义</h3><ul><li>栈是一种特殊的线性表</li><li>只允许在一段进行插入和删除操作</li><li>先进后出（LIFO，Last In First Out）</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png"alt="栈" /><figcaption aria-hidden="true">栈</figcaption></figure><h4 id="栈的基本操作">栈的基本操作</h4><ul><li><strong>创建 <code>create()</code></strong>：创建一个空栈</li><li><strong>进栈 <code>push(x)</code></strong>：将元素 <code>x</code>压入栈顶</li><li><strong>出栈<code>pop()</code></strong>：删除栈顶元素并返回其值</li><li><strong>访问栈顶元素<code>top()</code></strong>：返回栈顶元素的值但是不删除</li><li><strong>判断是否为空 <code>isEmpty()</code></strong>：若栈空返回<code>true</code>，否则返回 <code>false</code></li></ul><h4 id="栈的抽象类">栈的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stack</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;       <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 访问栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">stack</span>() &#123;&#125;                             <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="栈的顺序实现">栈的顺序实现</h3><ul><li>使用数组储存栈中的节点</li><li>进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png"alt="顺序栈" /><figcaption aria-hidden="true">顺序栈</figcaption></figure><h4 id="顺序栈类">顺序栈类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *data;                     <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-type">int</span> top_p;                          <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> maxSize;                        <span class="hljs-comment">// 栈的最大容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);        <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqStack</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;       <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="顺序存储的运算实现">顺序存储的运算实现</h4><h5 id="构造函数-3">构造函数</h5><ul><li>按照用户估计的栈的规模申请一个动态数组，将数组地址保存在<code>elem</code> 中，数组规模保存在 <code>maxSize</code> 中，并设<code>top_p</code> 的值为 <span class="math inline">\(-1\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::<span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  elem = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  top_p = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="push"><code>push</code></h4><ul><li>先判断栈是否已满，若满则调用 <code>doubleSpace</code>扩大栈的容量</li><li>将 <code>top_p</code> 加 1，指向栈顶元素</li><li>将 <code>x</code> 压入栈顶</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (top_p == maxSize - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  elem[++top_p] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doublespace"><code>doubleSpace</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class="hljs-keyword">new</span> elemType[maxSize * <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[i];<br>  &#125;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pop"><code>pop</code></h5><ul><li>返回 <code>top_p</code> 指向的元素</li><li>将 <code>top_p</code> 减 1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> elem[top_p--];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="top"><code>top</code></h5><ul><li>返回 <code>top_p</code> 指向的元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty"><code>isEmpty</code></h5><ul><li>判断 <code>top_p</code> 是否为 <spanclass="math inline">\(-1\)</span>，若是则栈空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="析构函数-1">析构函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::~<span class="hljs-built_in">seqStack</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="性能分析">性能分析</h4><ul><li>所有运算实现的时间复杂度都为 <spanclass="math inline">\(O(1)\)</span></li><li>进栈运算在最坏的情况下的时间复杂度为 <spanclass="math inline">\(O(n)\)</span> （需要 <code>doublespace</code>时）</li></ul><h3 id="栈的链接实现">栈的链接实现</h3><ul><li>使用<strong>不含头结点的单链表</strong>实现栈</li><li>从使用方便性上看，将单链表的头指针指向栈顶</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png"alt="链接栈" /><figcaption aria-hidden="true">链接栈</figcaption></figure><h4 id="链接栈类">链接栈类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *top_p;                       <span class="hljs-comment">// 栈顶指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedStack</span>();                    <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">LinkedStack</span>();                   <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;     <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="链接存储的运算实现">链接存储的运算实现</h4><h5 id="构造函数-4">构造函数</h5><ul><li>将 <code>top_p</code> 初始化为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br>  top_p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-2">析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>LinkStack&lt;elemType&gt;::~<span class="hljs-built_in">LinkStack</span>()<br>&#123;<br>  node *tmp;<br>  <span class="hljs-keyword">while</span> (top_p != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    tmp = top_p;<br>    top_p = top_p-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="push-1"><code>push</code></h5><ul><li>在表头插入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  top_p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x , top_p);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pop-1"><code>pop</code></h5><ul><li>删除表头节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>  node *tmp = top_p;<br>  elemType x = top_p-&gt;data;<br>  top_p = top_p-&gt;next;<br>  <span class="hljs-keyword">delete</span> tmp;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="top-1"><code>top</code></h5><ul><li>返回 <code>top_p</code> 指向的节点的 <code>data</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-1"><code>isEmpty</code></h5><ul><li>判断 <code>top_p</code> 是否为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1">性能分析</h4><ul><li>所有运算实现的时间复杂度都为 <spanclass="math inline">\(O(1)\)</span>，因为都是对栈顶进行操作</li></ul><h3 id="栈的应用">栈的应用</h3><h4 id="递归函数的非递归实现">递归函数的非递归实现</h4><h5 id="函数调用">函数调用</h5><ul><li>递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  r1:<span class="hljs-built_in">f1</span>();<br>  r2:<br>  ..<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  t1:<span class="hljs-built_in">f2</span>();<br>  t2:<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png"alt="函数执行过程" /><figcaption aria-hidden="true">函数执行过程</figcaption></figure><ul><li>设置一个栈模拟函数调用，当调用发生时，将函数压入栈中</li><li>函数返回时，将栈顶元素弹出</li></ul><h6 id="递归算法的例子">递归算法的例子</h6><p>hanoi 塔算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">int</span> Height , <span class="hljs-type">int</span> FromNeedle ,<span class="hljs-type">int</span> ToNeedle ,<span class="hljs-type">int</span> UsingNeedle)</span> <span class="hljs-comment">// FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (Height &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">Move</span>(Height - <span class="hljs-number">1</span>，FromNeedle , UsingNeeedle,ToNeedle); <span class="hljs-comment">// 将上面n-1个盘子从FromNeedle移动到UsingNeedle</span><br>    cout &lt;&lt; FromNeedle &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; ToNeedle &lt;&lt; endl; <span class="hljs-comment">// 将最底下的盘子从FromNeedle移动到ToNeedle&gt;</span><br>    <span class="hljs-built_in">Move</span>(Height - <span class="hljs-number">1</span>,UsingNeedle , ToNeedle , FromNeedle); <span class="hljs-comment">// 将上面的盘子从UsingNeedle移动到ToNeedle</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="递归算法的时间复杂度">递归算法的时间复杂度</h5><h6 id="数学归纳法">数学归纳法</h6><p>以 Hanio 塔问题为例</p><p><span class="math display">\[\begin{cases}T(n) = 2T(n-1) + 1 &amp;\\T(1) = 1 &amp;\end{cases}\]</span></p><p>可以使用数学归纳法证明 <span class="math inline">\(T(n) = 2^n -1\)</span></p><h6 id="递归方程">递归方程</h6><p><strong>主定理</strong>：设 <span class="math inline">\(a \geq1\)</span>，<span class="math inline">\(b &gt; 1\)</span> 为常数，<spanclass="math inline">\(f(n)\)</span> 是一个函数，则递归方程</p><p><span class="math display">\[T(n) = aT(\frac{n}{b}) + f(n) \quad (n &gt; 1)\]</span></p><p>的解为</p><ol type="1"><li>若 <span class="math inline">\(f(n) &lt;O\left(n^{\log_{b}a}\right)\)</span>，则 <spanclass="math inline">\(T(n)=O\left(n^{\log_{b}a}\right)\)</span></li><li>若 <span class="math inline">\(f(n) =O\left(n^{\log_{b}a}\right)\)</span>，则 <spanclass="math inline">\(T(n)=O\left(n^{\log_{b}a}\log_{2}n\right)\)</span></li><li>若 <span class="math inline">\(f(n) &gt;O\left(n^{\log_{b}a}\right)\)</span>，则 <spanclass="math inline">\(T(n)=O\left(f(n)\right)\)</span></li></ol><h6 id="生成函数">生成函数</h6><p><strong>定义</strong>：设 <span class="math inline">\(u_0 , u_1 , u_2, \ldots , u_n ,\ldots\)</span> 是一无穷序列，称形式幂级数 <spanclass="math inline">\(\displaystyle G(t) = \sum_{i\geq0}u_it^i\)</span>为其生成函数</p><p>利用生成函数求通项的方法</p><ol type="1"><li>按照递归关系式消去无限延长的部分</li><li>展开为 <span class="math inline">\(t\)</span> 的幂级数求通项</li></ol><p>以 Fibonacci 数列为例</p><p><span class="math display">\[\begin{dcases}F_{0} =0 &amp; \\F_{1} =1 &amp; \\F_{n} =F_{n-1} +F_{n-2} &amp;\end{dcases}\]</span></p><p><span class="math display">\[\begin{aligned}  &amp;G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \cdots \\  &amp;G(t) = t + t^2 + t^3 + \cdots \\  &amp;tG(t)=t^2 + t^3 + t^4 + \cdots \\  &amp;t^2G(t)=t^3 + t^4 + t^5 + \cdots \\  &amp;(1-t-t^2)G(t) = t \\  &amp;G(t) = \frac{t}{1-t-t^2} = \frac{1}{\sqrt{5}}\left(\frac{1}{1-\frac{1+\sqrt{5}}{2}t} -\frac{1}{1-\frac{1-\sqrt{5}}{2}t}\right) \\\end{aligned}\]</span></p><p>令 <span class="math inline">\(\Phi =\frac{1}{2}(1+\sqrt{5})\)</span>，<spanclass="math inline">\(\hat{\Phi}=\frac{1}{2}(1-\sqrt{5})\)</span></p><p><span class="math display">\[G(t) =\frac{1}{\sqrt{5}}(\frac{1}{1-\Phi t} - \frac{1}{1-\hat{\Phi}t})\]</span></p><p>有 <span class="math inline">\(\displaystyle\frac{1}{1-\Phi t} =\sum_{n=0}^{\infty} \Phi^n t^n\)</span></p><p><span class="math display">\[G(t) = \frac{1}{\sqrt{5}} \sum_{n=0}^{\infty} (\Phi^n t^n - \hat{\Phi}^nt^n)\]</span></p><p>则</p><p><span class="math display">\[F_n = \frac{1}{\sqrt{5}}(\Phi^n - \hat{\Phi}^n)\]</span></p><h4 id="递归消除">递归消除</h4><p>以打印正整数为例</p><h5 id="递归实现">递归实现</h5><h6 id="代码">代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">10</span>)<br>  &#123;<br>    <span class="hljs-built_in">printNum</span>(num / <span class="hljs-number">10</span>);<br>    cout.<span class="hljs-built_in">put</span>(num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout.<span class="hljs-built_in">put</span>(num + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="代码运行过程中栈的变化">代码运行过程中栈的变化</h6><ol type="1"><li><code>push(1234)</code></li><li><code>pop(1234)</code>，<code>push(4)</code>，<code>push(123)</code></li><li><code>pop(123)</code>，<code>push(3)</code>，<code>push(12)</code></li><li><code>pop(12)</code>，<code>push(2)</code>，<code>push(1)</code></li><li><code>pop(1)</code>，<code>pop(2)</code>，<code>pop(3)</code>，<code>pop(4)</code></li></ol><h5 id="非递归实现">非递归实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkStack&lt;<span class="hljs-type">int</span>&gt; s;<br>  <span class="hljs-type">int</span> tmp;<br>  s.<span class="hljs-built_in">push</span>(num);<br>  <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">9</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp % <span class="hljs-number">10</span>);<br>      s.<span class="hljs-built_in">push</span>(tmp / <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      cout.<span class="hljs-built_in">put</span>(tmp + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="括号匹配">括号匹配</h3><ul><li>判断一个表达式中的括号是否匹配</li><li>遇到左括号就入栈，遇到右括号就出栈</li></ul><p>判断错误的原则</p><ol type="1"><li>栈空时遇到右括号</li><li>出栈时遇到不匹配的括号</li><li>栈不空时结束</li></ol><h3 id="简单的计算数学表达式">简单的计算数学表达式</h3><h4 id="前缀式中缀式和后缀式">前缀式、中缀式和后缀式</h4><p>对于一个表达式 <span class="math inline">\(a+b\)</span></p><ul><li>前缀式 <code>+ab</code>，波兰式</li><li>中缀式 <code>a+b</code></li><li>后缀式 <code>ab+</code>，逆波兰式</li></ul><h4 id="后缀式的优点">后缀式的优点</h4><ul><li>不需要括号</li><li>不需要考虑运算符的优先级</li><li>计算机容易处理</li></ul><h4 id="后缀式的计算">后缀式的计算</h4><ul><li>使用栈来存储操作数</li><li>遇到操作数就入栈</li><li>遇到操作符就出栈两个操作数，进行计算，将结果入栈</li><li>最后栈中只剩下一个元素，就是结果</li></ul><h4 id="中缀式转换为后缀式的算法">中缀式转换为后缀式的算法</h4><p>操作方法见<ahref="/本科/编程/数据结构/中缀计算式转换为后缀计算式.md">中缀计算式转换为后缀计算式</a></p><h2 id="队列">队列</h2><ul><li><p>队列的定义</p></li><li><p>先进先出（FIFO，First In First Out）</p></li><li><p>只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png"alt="队列" /><figcaption aria-hidden="true">队列</figcaption></figure><h4 id="队列的基本操作">队列的基本操作</h4><ul><li><strong>创建 <code>create()</code></strong>：创建一个空队列</li><li><strong>入队 <code>enQueue(x)</code></strong>：将元素 <code>x</code>入队</li><li><strong>出队<code>deQueue()</code></strong>：删除队首元素并返回其值</li><li><strong>访问队首元素<code>getHead()</code></strong>：返回队首元素的值但不删除</li><li><strong>判断是否为空 <code>isEmpty()</code></strong>：若队列空返回<code>true</code>，否则返回 <code>false</code></li></ul><h4 id="队列的抽象类">队列的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;       <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;              <span class="hljs-comment">// 访问队首元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>() &#123;&#125;                                 <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="队列的顺序实现">队列的顺序实现</h3><ul><li>使用数组来存储队列中的元素</li><li>元素下标的范围为 <span class="math inline">\(0\)</span> 到<code>maxSize - 1</code></li><li>存储队里的三种组织方法<ol type="1"><li>队头位置固定</li><li>队头位置不固定</li><li>循环队列</li></ol></li></ul><h4 id="队头位置固定">队头位置固定</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png"alt="队头位置固定" /><figcaption aria-hidden="true">队头位置固定</figcaption></figure><p><strong>缺点</strong>：出队的时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，因为出队时需要将所有元素向前移动一位</p><h4 id="队头位置不固定">队头位置不固定</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png"alt="队头位置不固定" /><figcaption aria-hidden="true">队头位置不固定</figcaption></figure><p><strong>优点</strong>：所有操作的时间复杂度均为 <spanclass="math inline">\(O(1)\)</span><strong>缺点</strong>：浪费大量的空间</p><h4 id="循环队列">循环队列</h4><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png"alt="循环队列" /><figcaption aria-hidden="true">循环队列</figcaption></figure><ul><li>入队<ul><li><code>rear = (rear + 1) % maxSize</code>;<code>elem[rear] = x</code></li></ul></li><li>出队<ul><li><code>front = (front + 1) % maxSize</code>;<code>return elem[front]</code></li></ul></li></ul><p>为了解决队列空和队列满的判断问题，令 <code>front</code>指向的单元不能存储队列元素，只能起到标志作用</p><ul><li>队列空：<code>front == rear</code></li><li>队列满：<code>(rear + 1) % maxSize == front</code></li></ul><h6 id="循环队列类的定义">循环队列类的定义</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span>:<span class="hljs-keyword">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *elem;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-type">int</span> front , rear;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);        <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqQueue</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-5">构造函数</h5><ul><li>申请一块空间，将 <code>front</code> 和 <code>rear</code> 初始化为<span class="math inline">\(0\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::<span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  elem = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  front = rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-3">析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::~<span class="hljs-built_in">seqQueue</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="enqueue"><code>enQueue</code></h5><ul><li>先判断队列是否已满，若满则调用 <code>doubleSpace</code>扩大队列的容量</li><li>将 <code>rear</code> 加 1，指向队尾元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> ((rear + <span class="hljs-number">1</span>) % maxSize == front)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  rear = (rear + <span class="hljs-number">1</span>) % maxSize;<br>  elem[rear] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doublespace-1"><code>doubleSpace</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class="hljs-keyword">new</span> elemType[maxSize * <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[(front + i) % maxSize];<br>  &#125;<br>  front = <span class="hljs-number">0</span>;<br>  rear = maxSize - <span class="hljs-number">1</span>;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dequeue"><code>deQueue</code></h5><ul><li>将 <code>front</code> 加 1，指向队首元素</li><li>返回 <code>elem[front]</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  front = (front + <span class="hljs-number">1</span>) % maxSize;<br>  <span class="hljs-keyword">return</span> elem[front];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gethead"><code>getHead</code></h5><ul><li>返回 <code>elem[(front + 1) % maxSize]</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">getHead</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> elem[(front + <span class="hljs-number">1</span>) % maxSize];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-2"><code>isEmpty</code></h5><ul><li>判断 <code>front</code> 是否等于 <code>rear</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> front == rear;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列的链接实现">队列的链接实现</h3><ul><li>为了方便操作，使用含头节点和尾节点的单链表实现</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png"alt="链接队列" /><figcaption aria-hidden="true">链接队列</figcaption></figure><p><strong>链接队列的特点</strong></p><ul><li>不会出现队列满的情况，但是会出现队列空的情况</li><li>队列为空时，单链表中没有节点存在，即头尾指针都为<code>nullptr</code></li><li>保存一个链接队列只需要两个分别指向单链表节点的指针<code>front</code> 和 <code>rear</code><ul><li><code>front</code> 指向队首元素</li><li><code>rear</code> 指向队尾元素</li></ul></li></ul><h4 id="连接队列类">连接队列类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkQueue</span>:<span class="hljs-keyword">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *front , *rear;                <span class="hljs-comment">// 队头和队尾指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">linkQueue</span>();                       <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">linkQueue</span>();                      <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>;              <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;   <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;                <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-6">构造函数</h5><ul><li>将 <code>front</code> 和 <code>rear</code> 初始化为<code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::<span class="hljs-built_in">linkQueue</span>()<br>&#123;<br>  front = rear = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="enqueue-1"><code>enQueue</code></h5><ol type="1"><li>申请一个节点空间 <code>x</code></li><li>将 <code>rear</code> 指向的节点的 <code>next</code> 指向<code>x</code></li><li>将 <code>rear</code> 指向 <code>x</code></li></ol><p><strong>注意</strong>：存在队列为空的情况，此时我们只需要将<code>front</code> 和 <code>rear</code> 都指向 <code>x</code> 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> linkQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (rear == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    front = rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    rear = rear-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dequeue-1"><code>deQueue</code></h5><ol type="1"><li>返回 <code>front</code> 指向的节点的 <code>data</code></li><li>将 <code>front</code> 指向的节点从链表中摘下</li><li>释放空间</li></ol><p><strong>注意</strong>：当队列中只有一个元素时，删除后队列为空，此时需要将<code>front</code> 和 <code>rear</code> 都置为 <code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> LinkQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  node *tmp = front;<br>  <span class="hljs-keyword">if</span> (front)<br>  &#123;<br>    emelType value = front-&gt;data;<br>    front = front-&gt;next;<br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      rear = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> tmp;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gethead-1"><code>getHead</code></h5><ul><li>返回 <code>front</code> 指向的节点的 <code>data</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType linkQueue&lt;elemType&gt;::<span class="hljs-built_in">getHead</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> front-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-3"><code>isEmpty</code></h5><ul><li>判断 <code>front</code> 或 <code>rear</code> 是否为<code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> linkQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> front == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-4">析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::~<span class="hljs-built_in">linkQueue</span>()<br>&#123;<br>  node *tmp;<br>  <span class="hljs-keyword">while</span> (front != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    tmp = front;<br>    front = front-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树">树</h2><h3 id="树的定义">树的定义</h3><h4 id="树的递归定义">树的递归定义</h4><ul><li>树是 <span class="math inline">\(n\)</span>个节点的有限集合，它或者是空集，或者满足<ul><li>有一个特殊的节点称为根节点</li><li>除根节点外，其他节点分为 <span class="math inline">\(m\)</span>个互不相交的有限集合 <span class="math inline">\(T_1 , T_2 , \ldots ,T_m\)</span>，每个集合都是一棵树</li></ul></li></ul><h4 id="树的术语">树的术语</h4><ul><li><strong>根节点、叶节点、内部节点</strong>：<ul><li>根节点：没有父节点的节点</li><li>叶节点：没有子节点的节点</li><li>内部节点：有子节点的节点</li></ul></li><li><strong>节点的度和树的度</strong>：<ul><li>节点的度：节点的子树个数</li><li>树的度：树中所有节点的度的最大值</li></ul></li><li><strong>儿子节点</strong></li><li><strong>父亲节点</strong></li><li><strong>兄弟节点</strong></li><li><strong>祖先节点</strong></li><li><strong>子孙节点</strong></li><li><strong>节点所处层次</strong></li><li><strong>树的高度</strong></li><li><strong>有序树</strong></li><li><strong>无序树</strong></li><li><strong>森林</strong></li></ul><h4 id="树的运算">树的运算</h4><ul><li><strong>建树 <code>create()</code></strong>：创建一个空树</li><li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li><li><strong>判空 <code>IsEmpty()</code></strong>：判断是否为空树</li><li><strong>找根节点<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li><li><strong>找父节点<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li><li><strong>找子节点<code>child()</code></strong>：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值</li><li><strong>剪枝 <code>remove()</code></strong>：删除节点的某棵子树</li><li><strong>遍历<code>traverse()</code></strong>：访问树上的每个节点</li></ul><h4 id="树的抽象类">树的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tree</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">child</span><span class="hljs-params">(T x , <span class="hljs-type">int</span> i , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树">二叉树</h3><h4 id="二叉树的定义">二叉树的定义</h4><ul><li>二叉树（BinaryTree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树</li></ul><p><strong>注意</strong>：二叉树是<strong>有序树</strong>，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树</p><p>二叉树有五种基本形态</p><ol type="1"><li>空树</li><li>只有一个节点的树</li><li>只有左子树的树</li><li>只有右子树的树</li><li>左右子树都有的树</li></ol><h5 id="满二叉树">满二叉树</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png"alt="满二叉树" /><figcaption aria-hidden="true">满二叉树</figcaption></figure><ul><li>每个节点的度都为 <span class="math inline">\(0\)</span> 或 <spanclass="math inline">\(2\)</span> 的二叉树称为满二叉树</li><li>性质<ul><li>高度为 <span class="math inline">\(h\)</span> 的满二叉树有 <spanclass="math inline">\(2^h - 1\)</span> 个节点</li><li>任意一层的节点个数达到了上限 <spanclass="math inline">\(2^{n-1}\)</span></li></ul></li></ul><h5 id="完全二叉树">完全二叉树</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png"alt="完全二叉树" /><figcaption aria-hidden="true">完全二叉树</figcaption></figure><ul><li>在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树</li><li>满二叉树是完全二叉树，完全二叉树不一定是满二叉树</li><li>性质<ul><li>所有的叶节点都出现在最低的两层生</li><li>对于任意节点，如果其右子树的高度为 <spanclass="math inline">\(h\)</span>，则其左子树的高度为 <spanclass="math inline">\(h\)</span> 或 <spanclass="math inline">\(h+1\)</span></li></ul></li></ul><h4 id="二叉树的性质">二叉树的性质</h4><ol type="1"><li>二叉树的第 <span class="math inline">\(i\)</span> 层最多有 <spanclass="math inline">\(2^{i-1}\)</span> 个节点</li><li>二叉树的深度为 <span class="math inline">\(h\)</span>，则最多有<span class="math inline">\(2^h - 1\)</span> 个节点</li><li>对于一棵非空二叉树，若其叶节点个数为 <spanclass="math inline">\(n_0\)</span>，则其度为 <spanclass="math inline">\(2\)</span> 的节点个数为 <spanclass="math inline">\(n_2\)</span>，则有 <span class="math inline">\(n_0= n_2 + 1\)</span></li><li>具有 <span class="math inline">\(n\)</span> 个节点的二叉树的高度为<span class="math inline">\(h\)</span>，则 <span class="math inline">\(h= \lfloor \log_2n \rfloor +1\)</span></li><li>对于一棵具有 <span class="math inline">\(n\)</span>个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为<span class="math inline">\(1\)</span>，则对任一编号为 <spanclass="math inline">\(u\)</span> 的节点，有<ol type="1"><li>如果 <span class="math inline">\(i=1\)</span>，则 <spanclass="math inline">\(u\)</span> 为根节点</li><li>如果 <span class="math inline">\(i&gt;1\)</span>，则 <spanclass="math inline">\(u\)</span> 的父节点编号为 <spanclass="math inline">\(\lfloor \frac{u}{2} \rfloor\)</span></li><li>如果 <span class="math inline">\(2i \geq n\)</span>，则编号为 <spanclass="math inline">\(i\)</span>的节点为叶子节点，没有儿子；否则，其左子编号为 <spanclass="math inline">\(2i\)</span></li><li>如果 <span class="math inline">\(2i+1 \geq n\)</span>，则编号为<span class="math inline">\(i\)</span>的节点无右儿子；否则，其右子编号为 <spanclass="math inline">\(2i+1\)</span></li></ol></li></ol><h4 id="二叉树的基本运算">二叉树的基本运算</h4><ul><li><strong>建树 <code>create()</code></strong>：创建一棵空树</li><li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li><li><strong>判空 <code>isEmpty()</code></strong>：判断是否为空树</li><li><strong>找根节点<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li><li><strong>找父节点<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li><li><strong>找左子节点<code>lchild()</code></strong>：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值</li><li><strong>找右子节点<code>rchild()</code></strong>：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值</li><li><strong>删除左子树<code>delLeft()</code></strong>：删除节点的左子树</li><li><strong>删除右子树<code>delRight()</code></strong>：删除节点的右子树</li><li><strong>遍历<code>traverse()</code></strong>：访问树上的每个节点</li></ul><h4 id="二叉树的遍历">二叉树的遍历</h4><h5 id="前序遍历">前序遍历</h5><ul><li>如果树为空，则操作为空</li><li>如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树</li></ul><h5 id="中序遍历">中序遍历</h5><ul><li>如果树为空，则操作为空</li><li>如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树</li></ul><h5 id="后序遍历">后序遍历</h5><ul><li>如果树为空，则操作为空</li><li>如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点</li></ul><h5 id="层次遍历">层次遍历</h5><ul><li>从上到下，从左到右访问树的每个节点</li></ul><h5 id="性质">性质</h5><ul><li>由前序遍历和中序遍历可以唯一确定一棵二叉树</li><li>由中序遍历和后序遍历可以唯一确定一棵二叉树</li><li>由前序遍历和后序遍历<strong>不能</strong>唯一确定一棵二叉树</li></ul><h4 id="二叉树抽象类">二叉树抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 找根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找父节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">lchild</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找左子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">rchild</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找右子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;                <span class="hljs-comment">// 删除左子树</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 删除右子树</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;           <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;          <span class="hljs-comment">// 层次遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树的实现">二叉树的实现</h4><h5 id="二叉树的顺序实现">二叉树的顺序实现</h5><ul><li>使用数组来存储二叉树中的节点</li><li>将二叉树补全为完全二叉树再进行存储</li><li>会导致空间浪费</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png"alt="顺序二叉树" /><figcaption aria-hidden="true">顺序二叉树</figcaption></figure><h5 id="二叉树的链接实现">二叉树的链接实现</h5><ul><li>使用链表来存储二叉树中的节点<ul><li>标准形式：<code>left</code>，<code>data</code>，<code>right</code></li></ul></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png"alt="标准形式" /><figcaption aria-hidden="true">标准形式</figcaption></figure><ul><li>广义标准形式：<code>data</code>，<code>left</code>，<code>parent</code>，<code>right</code></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png"alt="广义标准形式" /><figcaption aria-hidden="true">广义标准形式</figcaption></figure><h4 id="二叉树类">二叉树类</h4><h5 id="节点类">节点类</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    Node *left *right;                                                                <span class="hljs-comment">// 左右子树指针</span><br>    T data;                                                                           <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;                                             <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(T item , Node *L = <span class="hljs-literal">nullptr</span>,Node *R = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(item),<span class="hljs-built_in">left</span>(L),<span class="hljs-built_in">right</span>(R)&#123;&#125;  <span class="hljs-comment">// 带参数的构造函数</span><br>    ~<span class="hljs-built_in">Node</span>()&#123;&#125;                                                                         <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="二叉树类-1">二叉树类</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span>:<span class="hljs-keyword">public</span> tree&lt;T&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(<span class="hljs-type">const</span> binaryTree &amp;t, t flag)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>      <span class="hljs-keyword">public</span>:<br>        Node *left *right;<br>        T data;<br>        <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(T item , Node *L = <span class="hljs-literal">nullptr</span>,Node *R = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(item),<span class="hljs-built_in">left</span>(L),<span class="hljs-built_in">right</span>(R)&#123;&#125;<br>        ~<span class="hljs-built_in">Node</span>()&#123;&#125;<br>    &#125;<br>    Node *root;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">binaryTree</span>():<span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;                    <span class="hljs-comment">// 构造函数,创建空树</span><br>    <span class="hljs-built_in">binaryTree</span>(T x):<span class="hljs-built_in">root</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x))&#123;&#125;             <span class="hljs-comment">// 构造函数,创建只有根节点的树</span><br>    ~<span class="hljs-built_in">binaryTree</span>()&#123;&#125;                                 <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;                                   <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                           <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function">T <span class="hljs-title">Root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span></span>;                           <span class="hljs-comment">// 找根节点</span><br>    <span class="hljs-function">T <span class="hljs-title">lchild</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 找左子节点</span><br>    <span class="hljs-function">T <span class="hljs-title">rchild</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 找右子节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;                       <span class="hljs-comment">// 删除左子树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;                      <span class="hljs-comment">// 删除右子树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                          <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                          <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                         <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                        <span class="hljs-comment">// 层次遍历</span><br>    <span class="hljs-function">coid <span class="hljs-title">creatTree</span><span class="hljs-params">(T flag)</span></span>;                         <span class="hljs-comment">// 创建树</span><br>    <span class="hljs-function">T <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span>             <span class="hljs-comment">// 找父节点</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x, Node *t)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 查找节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *&amp;x)</span></span>;                             <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                     <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                     <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                    <span class="hljs-comment">// 后序遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-7">构造函数</h5><p>将 <code>root</code> 初始化为 <code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>binaryTree&lt;T&gt;::<span class="hljs-built_in">binaryTree</span>()<br>&#123;<br>  root = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-4"><code>isEmpty</code></h5><ul><li>判断 <code>root</code> 是否为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">bool</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> root == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="root"><code>Root</code></h5><p>返回 <code>Root</code> 指向的节点的数据，若为空树则返回特殊值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">Root</span>(T flag)<span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> root-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的遍历-1">二叉树的遍历</h5><h6 id="前序遍历-1">前序遍历</h6><ol type="1"><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(t -&gt; left);<br>    <span class="hljs-built_in">preorder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n前序遍历：&quot;</span><br>  <span class="hljs-built_in">preOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="中序遍历-1">中序遍历</h6><ol type="1"><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">midOrder</span>(t -&gt; left);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">midOrder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n中序遍历：&quot;</span><br>  <span class="hljs-built_in">midOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="后序遍历-1">后序遍历</h6><ol type="1"><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">postOrder</span>(t -&gt; left);<br>    <span class="hljs-built_in">postOrder</span>(t -&gt; right);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n后序遍历：&quot;</span><br>  <span class="hljs-built_in">postOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="size"><code>size</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;t&gt;::<span class="hljs-built_in">size</span>(binarytree&lt;t&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t = <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">sizze</span>(t -&gt; left)+<span class="hljs-built_in">size</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="height"><code>height</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">size</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-type">int</span> lt = <span class="hljs-built_in">height</span>(t -&gt; left);<br>    <span class="hljs-type">int</span> rt = <span class="hljs-built_in">height</span>(t -&gt; right);<br>    <span class="hljs-keyword">return</span> (lt &gt; rt ? lt : rt) + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">height</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="层次遍历-1">层次遍历</h5><ul><li>使用链接队列实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">levelOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n层次遍历：&quot;</span>;<br>  que.<span class="hljs-built_in">enQueue</span>(root);<br>  <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = que.<span class="hljs-built_in">deQueue</span>();<br>    cout &lt;&lt; tmp -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span> (tmp.left)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp.right)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="clear-1"><code>clear</code></h5><ul><li>递归删除树中所有节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">clear</span>(Node *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">clear</span>(t -&gt; left);<br>    <span class="hljs-built_in">clear</span>(t -&gt; right);<br>    <span class="hljs-keyword">delete</span> t;<br>    t = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>  <span class="hljs-built_in">clear</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-5">析构函数</h5><ul><li>调用 <code>clear</code> 函数删除树中所有节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>binaryTree&lt;T&gt;::~<span class="hljs-built_in">binaryTree</span>()<br>&#123;<br>  <span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="find"><code>Find</code></h5><ul><li>使用前序遍历查找 <code>x</code> 节点</li><li>首先检查根节点是否存放 <code>x</code>的值，若是则返回根节点地址</li><li>对左子树递归调用 <code>Find</code> 函数，若返回空指针则说明<code>x</code> 不在左子树中</li><li>对右子树递归调用 <code>Find</code> 函数，若返回空指针则说明<code>x</code> 不在右子树中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binaryTree</span>&lt;T&gt;:: Node *binaryTree&lt;T&gt;::<span class="hljs-built_in">Find</span>(<span class="hljs-type">const</span> T &amp;x ,binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t -&gt; data == x)<br>  &#123;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (tmp = <span class="hljs-built_in">Find</span>(x,t-&gt;left))<br>    &#123;<br>      <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(x,t-&gt;right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="delleft"><code>delLeft</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">delLeft</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root);<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">clear</span>(tmp -&gt; left);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="delright"><code>delRight</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">delRight</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root);<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">clear</span>(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="lchild"><code>lchild</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">lchild</span>(<span class="hljs-type">const</span> T &amp;x ,T flag) <span class="hljs-type">const</span><br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root)<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span> || tmp -&gt; left ==<span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> tmp -&gt; left;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="rchild"><code>rchild</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">rchild</span>(<span class="hljs-type">const</span> T &amp;x ,T flag) <span class="hljs-type">const</span><br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root)<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span> || tmp -&gt; right ==<span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> tmp -&gt; right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="createtree"><code>createTree</code></h5><ul><li>创建过程（类似层次遍历？）<ol type="1"><li>输入根节点的值，创建根节点</li><li>对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入<code>flag</code></li></ol></li><li>实现过程<ul><li>使用队列，将新加入到书中的节点添加到队列中</li><li>依次出队，对每个出队的元素输入它的儿子</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">createTree</span>(T flag)<br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  T x , ldata , rdata;<br><br>  <span class="hljs-comment">// 创建树，flag表示空</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n输入根节点：&quot;</span><br>  cin &gt;&gt; x;<br>  root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x);<br>  que.<span class="hljs-built_in">enQueue</span>(root);<br>  <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = que,<span class="hljs-built_in">deQueue</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入&quot;</span> &lt;&lt; tmp -&gt; data &lt;&lt; <span class="hljs-string">&quot;的两个儿子（&quot;</span>&lt;&lt;flag&lt;&lt;<span class="hljs-string">&quot;表示空节点）：&quot;</span>;<br>    cin &gt;&gt; ldata &gt;&gt; rdata;<br>    <span class="hljs-keyword">if</span> (ldata != flag)<br>    &#123;<br>      tmp -&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(ldata);<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rdata != flag)<br>    &#123;<br>      tmp -&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(rdata);<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;that&#x27;s good!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="printtree"><code>printTree</code></h5><ul><li>层次遍历输出每个节点和它的左右孩子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(<span class="hljs-type">const</span> binaryTree&lt;T&gt; &amp;t,T flag)</span></span><br><span class="hljs-function"></span>&#123;<br>  linkQueue&lt;T&gt; que;<br>  que.<span class="hljs-built_in">enQueue</span>(t.<span class="hljs-built_in">root</span>());<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    T tmp = que.<span class="hljs-built_in">deQueue</span>();<br>    T l = tmp.<span class="hljs-built_in">lchild</span>(tmp , flag);<br>    T r = tmp.<span class="hljs-built_in">rchild</span>(tmp , flag);<br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (l != flag)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(l);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r != flag)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(r);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树遍历的非递归实现">二叉树遍历的非递归实现</h4><h5 id="前序遍历-2">前序遍历</h5><ol type="1"><li>将根节点入栈</li><li>栈顶元素出栈并输出值</li><li>将左右子树入栈（先右后左，以便输出时先输出左子树）</li><li>循环直至栈为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  Node *tmp = t;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n前序遍历：&quot;</span>;<br>  <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class="hljs-built_in">pop</span>();<br>    cout &lt;&lt; tm -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span> (tmp -&gt; right != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp -&gt; right);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp -&gt; left != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp -&gt; left);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历-2">中序遍历</h5><ol type="1"><li>根节点入栈</li><li>左子树入栈</li><li>栈顶元素出栈并输出值</li><li>左子树出栈完成之后根节点出栈</li><li>右子树入栈</li><li>循环直至栈为空</li></ol><p>栈的设计</p><ul><li>根节点入栈出栈两次<ul><li>第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈</li><li>第二次出栈后返回值，并且将右子树入栈</li></ul></li><li>对于根节点要记住<ul><li>在哪棵树上</li><li>第几次出栈</li></ul></li><li>每个节点在某种意义上都是根节点</li></ul><h6 id="stnode-类定义"><code>StNode</code> 类定义</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StNode</span><br>&#123;<br>  Node *node;<br>  <span class="hljs-type">int</span> TimesPop;<br>  <span class="hljs-built_in">StNode</span>(Node *N=<span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">node</span>(N),<span class="hljs-built_in">TimesPop</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="中序遍历的非递归实现">中序遍历的非递归实现</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *t&gt; s;<br>  <span class="hljs-function">StNode <span class="hljs-title">current</span><span class="hljs-params">(root)</span></span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n中序遍历：&quot;</span>;<br>  s.<span class="hljs-built_in">push</span>(current);<br>  <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (++current.TimesPop == <span class="hljs-number">2</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class="hljs-keyword">if</span> (current.node -&gt; right != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; right));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(current);<br>      <span class="hljs-keyword">if</span> (current.node -&gt; left != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历-2">后序遍历</h5><ol type="1"><li>根节点入栈</li><li>左子树入栈</li><li>右子树入栈</li><li>栈顶元素出栈并输出值</li><li>循环直至栈为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  <span class="hljs-function">StNode <span class="hljs-title">current</span><span class="hljs-params">(root)</span></span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n后序遍历：&quot;</span>;<br>  s.<span class="hljs-built_in">push</span>(current);<br>  <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (++current.TimesPop == <span class="hljs-number">3</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(current);<br>      <span class="hljs-keyword">if</span> (current.node -&gt; right != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; right));<br>      &#125;<br>      <span class="hljs-keyword">if</span> (current.node -&gt; left != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h3><h4 id="字符的机内表示">字符的机内表示</h4><ul><li>用二进制数来表示字符</li><li>前缀编码<ul><li>字符只放在叶结点中</li><li>字符编码可以有不同的长度</li><li>每个字符的编码都不可能是其他字符编码的前缀</li><li>可以被唯一解码</li></ul></li></ul><h4 id="哈夫曼树">哈夫曼树</h4><ul><li>最小代价，即带权路径长度最小的二叉树</li><li>所有字符都在叶结点上</li><li>权值大的字符离根节点近，权值小的字符离根节点远</li><li>哈夫曼编码是一种前缀编码</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png"alt="huffmanTree" /><figcaption aria-hidden="true">huffmanTree</figcaption></figure><h4 id="哈夫曼算法">哈夫曼算法</h4><ol type="1"><li>给定一个具有 <span class="math inline">\(n\)</span> 个权值 <spanclass="math inline">\(\{w_1 , w_2 , \ldots , w_4\}\)</span> 的节点的集合<span class="math inline">\(\mathbb{A}\)</span> <spanclass="math inline">\(\mathbb{F} = \{T_1 , T_2 , \ldots ,T_n\}\)</span></li><li>初始时，设集合 <span class="math inline">\(\mathbb{A} =\mathbb{F}\)</span></li><li>执行从 <span class="math inline">\(i\)</span> 到 <spanclass="math inline">\(n-1\)</span> 的循环<ol type="1"><li>从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点<span class="math inline">\(b_i\)</span> 的左右儿子，<spanclass="math inline">\(b_i\)</span> 的权值为这两个节点的权值之和</li><li>集合中去除这两个节点，将 <span class="math inline">\(b_i\)</span>加入其中</li></ol></li><li>循环结束后，集合 <spanclass="math inline">\(\mathbb{A}\)</span>中只剩下一个节点 <spanclass="math inline">\(b_n\)</span>，即为哈夫曼树的根节点</li></ol><h4 id="哈夫曼编码">哈夫曼编码</h4><ul><li>每个节点的编码是从根节点到该节点的路径</li><li>左子树为 <code>0</code>，右子树为 <code>1</code></li></ul><h4 id="哈夫曼树类的实现">哈夫曼树类的实现</h4><ol type="1"><li>接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码</li><li>有两个公有的成员函数<ol type="1"><li>构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树</li><li><code>getCode</code>：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码</li></ol></li></ol><h5 id="哈夫曼树的存储">哈夫曼树的存储</h5><ul><li>在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为<span class="math inline">\(2\)</span> 的节点</li><li>若待编码的元素个数为 <spanclass="math inline">\(n\)</span>，则哈夫曼树的节点数为 <spanclass="math inline">\(2n-1\)</span></li><li>哈夫曼树使用一个大小为 <span class="math inline">\(2n\)</span>的数组来存储，不使用 <span class="math inline">\(0\)</span>节点，将根节点存储在下标为 <span class="math inline">\(1\)</span>的位置，叶节点依次存储在下标为 <span class="math inline">\(n+1\)</span>到 <span class="math inline">\(2n\)</span> 的位置，<spanclass="math inline">\(0\)</span> 结点作为结束的判断依据</li><li>每个数组保存<strong>节点的数据</strong>，<strong>节点的权值</strong>，<strong>节点的父节点下标</strong>，<strong>左子节点下标</strong>，<strong>右子节点下标</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hfTree</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>      Type data; <span class="hljs-comment">//节点数据</span><br>      <span class="hljs-type">int</span> weight; <span class="hljs-comment">//节点权值</span><br>      <span class="hljs-type">int</span> parent; <span class="hljs-comment">//父节点下标</span><br>      <span class="hljs-type">int</span> left , right; <span class="hljs-comment">//左右子节点下标</span><br>    &#125;;<br><br>    Node *elem;<br>    <span class="hljs-type">int</span> length;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hfCode</span><br>    &#123;<br>      Type data; <span class="hljs-comment">//节点数据</span><br>      string code; <span class="hljs-comment">//哈夫曼编码</span><br>    &#125;;<br><br>    <span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *v , <span class="hljs-type">const</span> <span class="hljs-type">int</span> *w , <span class="hljs-type">int</span> size);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCode</span><span class="hljs-params">(hfCode result[])</span></span>;<br>    ~<span class="hljs-built_in">hfTree</span>()<br>    &#123;<br>      <span class="hljs-keyword">delete</span> [] elem;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-8">构造函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>hfTree&lt;Type&gt;::<span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *v , <span class="hljs-type">const</span> <span class="hljs-type">int</span> *w , <span class="hljs-type">int</span> size)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_INT = <span class="hljs-number">32767</span>;<br>  <span class="hljs-type">int</span> min1 , min2; <span class="hljs-comment">// 最小树、次最小树的权值</span><br>  <span class="hljs-type">int</span> x , y ; <span class="hljs-comment">// 最小树、次最小树的下标</span><br><br>  <span class="hljs-comment">/* 初始化 */</span><br>  length = <span class="hljs-number">2</span> * size ;                                            <span class="hljs-comment">// 哈夫曼树的节点数为 $2\text&#123;size&#125;-1$，但我们只需要存储 $2\text&#123;size&#125;$ 个节点</span><br>  elem = <span class="hljs-keyword">new</span> Node[length];                                       <span class="hljs-comment">// 创建一个大小为 $2\text&#123;size&#125;$ 的数组来存储哈夫曼树的节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; i &lt; length ; i++)                          <span class="hljs-comment">// 对数组 `elem` 中的节点进行初始化，前 $\text&#123;size&#125;$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值</span><br>  &#123;<br>    elem[i].weight = w[i-size]; <span class="hljs-comment">// 储存权值</span><br>    elem[i].data = v[i-size]; <span class="hljs-comment">// 储存待编码的元素</span><br>    elem[i].parent = elem[i].left = elem[i].right = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 初始化父节点、左子节点和右子节点的下标为 `0`</span><br>  &#125;<br><br>  <span class="hljs-comment">/* 构造新的二叉树 */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span> ; i--)                           <span class="hljs-comment">// 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点</span><br>  &#123;<br>    min1 = min2 = MAX_INT;                                       <span class="hljs-comment">// 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值</span><br>    x = y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; length ; j++)                       <span class="hljs-comment">// 遍历当前节点之后的所有节点</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (elem[j].parent == <span class="hljs-number">0</span>)                                   <span class="hljs-comment">// 判断是否未加入树中</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (elem[j].weight &lt; min1)                               <span class="hljs-comment">// 找到真正的最小值和次小值以及他们对应的下标</span><br>        &#123;<br>          min2 = min1;<br>          min1 = elem[j].weight;<br>          x = y;<br>          y = j;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(elem[j].weight &lt; min2)<br>        &#123;<br>          min2 = elem[j].weight;<br>          x = j;<br>        &#125;<br>      &#125;<br>    &#125;<br>    elem[i].weight = min1 + min2;                                <span class="hljs-comment">// 将最小值和次小值的权值相加，作为当前节点的权值</span><br>    elem[i].left = x;                                            <span class="hljs-comment">// 将最小值的节点作为当前节点的左子节点</span><br>    elem[i].right = y;                                           <span class="hljs-comment">// 将次小值的节点作为当前节点的右子节点</span><br>    elem[x].parent = i;                                          <span class="hljs-comment">// 将当前节点作为最小值节点的父节点</span><br>    elem[y].parent = i;                                          <span class="hljs-comment">// 将当前节点作为次小值节点的父节点</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="getcode"><code>getCode</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">void</span> hdTree&lt;Type&gt;::<span class="hljs-built_in">getcode</span>(hfCode result[])<br>&#123;<br>  <span class="hljs-type">int</span> size = length / <span class="hljs-number">2</span> ;<br>  <span class="hljs-type">int</span> p , s ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &lt; length; ++i)<br>  &#123;<br>    result[i -size].data = elem[i].data;<br>    result[i -size].code = <span class="hljs-string">&quot;&quot;</span>;<br>    p = elem[i].parent; s = i;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (elem[p].left == s)<br>      &#123;<br>        result[i -size].code = <span class="hljs-string">&#x27;0&#x27;</span> + result[i -size].code;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        result[i -size].code = <span class="hljs-string">&#x27;1&#x27;</span> + result[i -size].code;<br>      &#125;<br>      s = p;<br>      p = elem[p].parent;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树和森林">树和森林</h3><h4 id="树的存储实现">树的存储实现</h4><ul><li><strong>标准形式</strong>：除了数据字段之外，还有 <spanclass="math inline">\(K\)</span> 个指针字段，指向 <spanclass="math inline">\(K\)</span> 个孩子节点，其中 <spanclass="math inline">\(K\)</span> 是树的度</li><li><strong>广义标准形式</strong>：除了数据字段之外，还有 <spanclass="math inline">\(K\)</span> 个指针字段，指向 <spanclass="math inline">\(K\)</span>个孩子节点和一个指针字段，指向父节点</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png"alt="树的存储实现" /><figcaption aria-hidden="true">树的存储实现</figcaption></figure><h4 id="树的表示方法">树的表示方法</h4><h5 id="孩子链表示法">孩子链表示法</h5><ul><li><p>每个节点的所有孩子组织成一个链表</p></li><li><p>节点由两个部分组成</p><ul><li>储存数据元素值的数据部分</li><li>指向孩子链的指针</li></ul></li><li><p><strong>静态</strong>的孩子链表：树的所有节点存放在一个名叫表头数组的<strong>数组</strong>中</p></li><li><p><strong>动态</strong>的孩子链表：树的所有节点组织成一个<strong>链表</strong></p></li></ul><h5 id="孩子兄弟链表示法">孩子兄弟链表示法</h5><ul><li>将一棵树转化为二叉树</li><li>左子树指向第一颗子树树根的指针</li><li>右子树指向兄弟节点的指针</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png"alt="孩子兄弟链" /><figcaption aria-hidden="true">孩子兄弟链</figcaption></figure><h5 id="双亲表示法">双亲表示法</h5><ul><li>每一个节点由两个部分组成<ul><li>储存数据元素的数据字段</li><li>储存父节点的父指针字段</li></ul></li><li>便于查找节点的祖先，但是不便于查找指定节点的子孙</li></ul><h3 id="树的遍历">树的遍历</h3><h4 id="前序遍历-3">前序遍历</h4><ol type="1"><li>访问根节点</li><li>依次前序遍历所有子树</li></ol><h4 id="后序遍历-3">后序遍历</h4><ol type="1"><li>依次后序遍历所有子树</li><li>访问根节点</li></ol><h4 id="层次遍历-2">层次遍历</h4><ol type="1"><li>访问根节点</li><li>若第 <span class="math inline">\(i\)</span> 层已被访问，且第 <spanclass="math inline">\(i+1\)</span>层的结点尚未被访问，则从左到右依次访问第 <spanclass="math inline">\(i+1\)</span> 层的结点</li></ol><h4 id="特点">特点</h4><ul><li>树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的</li><li>树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的</li></ul><p>由前序遍历和后序遍历可以唯一确定一棵树</p><h3 id="树森林和二叉树">树、森林和二叉树</h3><h4 id="森林的定义">森林的定义</h4><ul><li>森林通常被定义为树的集合或树的序列</li><li>存储<ul><li>存储森林的每一棵树</li><li>表示这些树属于同一个森林</li></ul></li></ul><h4 id="森林的二叉树存储">森林的二叉树存储</h4><ol type="1"><li>将每棵树 <span class="math inline">\(T_i\)</span> 转化为二叉树 <spanclass="math inline">\(B_i\)</span></li><li>将 <span class="math inline">\(B_i\)</span> 作为 <spanclass="math inline">\(B_{i-1}\)</span> 根节点的右子树</li></ol><h2 id="优先级队列">优先级队列</h2><h3 id="优先级队列的定义">优先级队列的定义</h3><ul><li>节点之间的关系是由节点的优先级决定的</li><li>优先级高的先出队，优先级低的后出队</li><li>继承于队列的抽象类</li></ul><h3 id="优先级队列的简单实现">优先级队列的简单实现</h3><ol type="1"><li>入队时进行排序，出队操作不变 入队时间复杂度为 <spanclass="math inline">\(O(n)\)</span>，出队时间复杂度为 <spanclass="math inline">\(O(1)\)</span></li><li>出队时进行排序，入队操作不变 入队时间复杂度为 <spanclass="math inline">\(O(1)\)</span>，出队时间复杂度为 <spanclass="math inline">\(O(n)\)</span></li></ol><h3 id="二叉堆">二叉堆</h3><ul><li>二叉堆是一个完全二叉树</li><li>二叉堆满足下述关系之一（下标是按层次遍历的次序）<ol type="1"><li><strong>最大化堆</strong>：<span class="math inline">\(k_i &gt;k_{2i},\quad k_i &gt; k{2i+1} \quad (i = 1,2,\ldots,\lfloor\frac{n}{2}\rfloor\)</span></li><li><strong>最小化堆</strong>：<span class="math inline">\(k_i &lt;k_{2i},\quad k_i &lt; k{2i+1} \quad (i = 1,2,\ldots,\lfloor\frac{n}{2}\rfloor)\)</span></li></ol></li><li>后面的讨论都以最小化堆为例</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png"alt="binaryHeap" /><figcaption aria-hidden="true">binaryHeap</figcaption></figure><h4 id="二叉堆的特性">二叉堆的特性</h4><ul><li><strong>结构性</strong><ul><li>符合完全二叉树的结构</li></ul></li><li><strong>有序性</strong><ul><li>父节点小于子节点（最小化堆）</li><li>父节点大于子节点（最大化堆）</li></ul></li></ul><h3 id="基于二叉堆的优先级队列">基于二叉堆的优先级队列</h3><ul><li>如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列</li><li>最小化堆中，最小元素为根元素，存放在数组下标为 <code>1</code> 的位置<ul><li>获取队头元素的操作为返回下标为 <code>1</code> 的元素值</li><li>出队操作为删除下标为 <code>1</code> 的元素，重新调整堆</li><li>入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆</li></ul></li></ul><h3 id="优先级队列类的定义">优先级队列类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span>:<span class="hljs-keyword">public</span> quque&lt;T&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> currentSize;<br>    T *array;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">voif <span class="hljs-title">buildHeap</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 建堆，被 priorityQueue() 调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">int</span> hole)</span></span>; <span class="hljs-comment">// 向下过滤</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">100</span>) <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>      array = <span class="hljs-keyword">new</span> T[capacity];<br>      maxSize = capacity;<br>      currentSize = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> T data[] , <span class="hljs-type">int</span> size); <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">priorityQueue</span>(); <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 是否为空</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentSize == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>; <span class="hljs-comment">//入队</span><br>    <span class="hljs-function">T <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 获取队头元素</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> array[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="enqueue-2"><code>enQueue</code></h4><ul><li>在堆中插入一个新元素</li><li>在最大序号中的元素之后插入新的元素或者节点</li><li>如果没有违反堆的<strong>有序性</strong>，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> priorityQueue&lt;T&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (currentSize == maxSize - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 向上过滤</span><br>  <span class="hljs-type">int</span> hole = ++currentSize;<br>  <span class="hljs-keyword">for</span> (;hole &gt; <span class="hljs-number">1</span> &amp;&amp; x &lt; array[hole/<span class="hljs-number">2</span>] ; hole /= <span class="hljs-number">2</span>)<br>  &#123;<br>    array[hole] = array[hole/<span class="hljs-number">2</span>];<br>  &#125;<br>  array[hole] = x;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最坏情况时间复杂度为 <span class="math inline">\(O(\logn)\)</span></li><li>平均情况来说，过滤会提前结束。资料表明平均为 <spanclass="math inline">\(2.6\)</span> 次比较，即平均上移 <spanclass="math inline">\(1.6\)</span> 层</li></ul><h4 id="dequeue-2"><code>deQueue</code></h4><ul><li>删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树</li><li>空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T priorityQueue&lt;T&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  T minItem;<br>  minItem = array[<span class="hljs-number">1</span>];<br>  array[<span class="hljs-number">1</span>] = array[currentSize--];<br>  <span class="hljs-built_in">percolateDown</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> minItem;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="percolatedown"><code>percolateDown</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> priorityQueue&lt;T&gt;::<span class="hljs-built_in">precolateDown</span>(<span class="hljs-type">int</span> hole)<br>&#123;<br>  <span class="hljs-type">int</span> child;<br>  T tmp = array[hole];<br><br>  <span class="hljs-keyword">for</span> (;hole * <span class="hljs-number">2</span> &lt;= currentSize; hole = child)<br>  &#123;<br>    child = hole * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (child != currentSIze &amp;&amp; array[child + <span class="hljs-number">1</span>] &lt; array[child])<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[child] &lt; tmp)<br>    &#123;<br>      array[hole] = array[child];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  array[hole] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="buildheap"><code>buildHeap</code></h4><h5 id="连续插入">连续插入</h5><ul><li>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span></li></ul><h5 id="自上而下调整二叉树">自上而下调整二叉树</h5><ul><li>对左子树和右子树递归调用<code>buildHeaap</code>，再对根节点向下过滤</li><li>时间复杂度为 <span class="math inline">\(O(n)\)</span></li></ul><h5 id="非递归实现-1">非递归实现</h5><p>从编号最大的非叶节点 <span class="math inline">\(\lfloor \frac{n}{2}\rfloor\)</span> 开始逆层次遍历，每个节点调用<code>percolateDown</code>，直到根节点</p><h2 id="集合与静态查找表">集合与静态查找表</h2><h3 id="集合的基本概念">集合的基本概念</h3><ol type="1"><li>数据元素除了属于同一集合之外，没有任何逻辑关系</li><li>每个数据元素有一个区别于其他元素的唯一标识，称为<strong>键值</strong>或者<strong>关键字值</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;calss KEY , <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SET</span><br>&#123;<br>  KEY key; <span class="hljs-comment">// 关键字值</span><br>  OTHER other; <span class="hljs-comment">// 其他信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运算</p><ul><li><strong>查找</strong> 某一元素是否存在</li><li>将集合中的元素按照它的唯一标识排序</li></ul><p>这些都是对 <code>key</code> 的操作</p><h3 id="集合的存储">集合的存储</h3><ul><li>任何容器都能存储集合</li><li>常用的表达形式是借鉴于<strong>线性表</strong>和<strong>树</strong></li><li>唯一一个仅适合于存储和处理集合的数据结构是<strong>散列表</strong></li></ul><h3 id="查找">查找</h3><h4 id="查找的基本概念">查找的基本概念</h4><ul><li>用于查找的集合称之为<strong>查找表</strong></li><li>查找表的分类<ul><li>静态查找表</li><li>动态查找表</li><li>内部查找</li><li>外部查找</li></ul></li></ul><h4 id="静态查找表">静态查找表</h4><ul><li>数据元素的个数和值不允许变化的查找表称为静态查找表</li><li>不允许插入和删除操作</li><li>实例：字典</li><li>可以用顺序表 <code>seqList</code> 存储，或直接存储在C++的原始数组中</li></ul><h4 id="无序表的查找">无序表的查找</h4><ul><li><p>只能做顺序查找</p></li><li><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p></li><li><p>可以使用哨兵减少 <span class="math inline">\(n\)</span>次查找</p></li><li><p>优化后的顺序查找</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  data[<span class="hljs-number">0</span>].key = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; x != data[i].key; --i)<br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h4 id="有序表的查找">有序表的查找</h4><h5 id="顺序查找">顺序查找</h5><ul><li><p>与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头</p></li><li><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p></li><li><p>有序表的顺序查找</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(SET&lt;KEY , OTHER&gt; data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  data[<span class="hljs-number">0</span>].key = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; x &lt; data[i].key; --i);<br>  <span class="hljs-keyword">if</span> (x == data[i].key)<br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二分查找">二分查找</h5><ol type="1"><li>每次检查中间的元素（向下取整）</li><li>若中间的元素等于要查找的元素，则查找成功</li><li>若中间的元素大于要查找的元素，则在左半部分继续查找</li><li>若中间的元素小于要查找的元素，则在右半部分继续查找</li></ol><ul><li>时间复杂度为 <span class="math inline">\(O(\log n)\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(SET&lt;KEY , OTHER&gt;data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>,  high = size, mid;<br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;                 <span class="hljs-comment">//查找区间存在</span><br>      mid = (low + high) / <span class="hljs-number">2</span>;         <span class="hljs-comment">//计算中间位置</span><br>      <span class="hljs-keyword">if</span> ( x == data[mid].key )<br>      &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (x &lt; data[mid].key)<br>      &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插值查找">插值查找</h5><ul><li>适用于数据分布较为均匀的情况</li><li>计算中间位置的公式为</li></ul><p><span class="math display">\[\text{next} = \text{low} + \frac{(x - a[\text{low}])}{(a[\text{high}] -a[\text{low}])} \times (\text{high} - \text{low}+1)\]</span></p><ul><li>缺点：计算量大</li></ul><h5 id="分块查找">分块查找</h5><ul><li>将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的</li><li>查找分为两个阶段<ol type="1"><li>查找索引</li><li>查找块 设表长为 <span class="math inline">\(n\)</span>，块长为 <spanclass="math inline">\(m\)</span> 则平均所需的时间为 <spanclass="math inline">\(\frac{m+1}{2}+\frac{\frac{n}{m}+1}{2}\)</span> 当<span class="math inline">\(m=\sqrt{n}\)</span>时，平均所需的时间<strong>最短</strong>，为 <spanclass="math inline">\(O(\sqrt{n})\)</span></li></ol></li></ul><h2 id="动态查找表">动态查找表</h2><h3 id="二叉查找树">二叉查找树</h3><h4 id="抽象类-1">抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的定义">二叉查找树的定义</h4><ul><li>对于任意一个节点 <code>p</code><ul><li><code>p</code> 的左子树中所有节点的值都小于 <code>p</code> 的值</li><li><code>p</code> 的右子树中所有节点的值都大于 <code>p</code> 的值</li><li><code>p</code> 的左子树和右子树都是二叉查找树</li></ul></li><li>二叉查找树的<strong>中序遍历</strong>是排好序的，又称为<strong>排序树</strong></li><li>最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的</li></ul><h4 id="二叉查找树的存储实现">二叉查找树的存储实现</h4><ul><li>使用二叉链表存储，需要一个指向根节点的数据成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryNode</span><br>    &#123;<br>      SET&lt;KEY, OTHER&gt; data;<br>      BinaryNode*left;<br>      BinaryNode*right;<br>      <span class="hljs-built_in">BinaryNode</span>( <span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; thedata,<br>      BinaryNode *lt = <span class="hljs-literal">nullptr</span> , BinaryNode *rt = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(thedata) , <span class="hljs-built_in">left</span>(lt) , <span class="hljs-built_in">right</span>(rt)&#123;&#125;<br>    &#125;;<br>    BinaryNode*root;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BinarySearchTree</span>();<br>    ~<span class="hljs-built_in">BinarySearchTree</span>();<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *&amp;t)</span></span>;<br>    <span class="hljs-function">SET&lt;KEY , OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *t )</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">(BinaryNode *t)</span></span>;<span class="hljs-comment">//析构用，同二叉树的clear</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的操作">二叉查找树的操作</h4><h5 id="查找-1">查找</h5><ol type="1"><li>检查根节点的关键字值</li><li>如果等于要查找的值，则查找成功，返回根节点地址</li><li>如果小于要查找的值，则在右子树中查找</li><li>如果大于要查找的值，则在左子树中查找</li></ol><ul><li>公有函数 <code>find(const KEY &amp;x)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x ) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>( x, root );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有辅助函数 <code>find(const KEY &amp;x, BinaryNode *t)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x, BinaryNode *t ) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span> || t-&gt;data.key == x)<br>  &#123;<br>    <span class="hljs-keyword">return</span> (SET&lt;KEY , OTHER&gt; *)t;<span class="hljs-comment">//强制类型转换</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(x &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x , t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x , t-&gt;right );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入">插入</h5><ul><li><p>若二叉树为空树，则插入的节点为根节点</p></li><li><p>若二叉树非空</p><ul><li>判断是左儿子还是右儿子，作为叶节点插入</li></ul></li><li><p>公有的<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x)</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-built_in">insert</span>(x, root);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有的<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x, BinaryNode *&amp;t)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)<br>  t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryNode</span>(x , <span class="hljs-literal">nullptr</span> , <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key&lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x, t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; “is exist” &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除">删除</h5><ul><li><p><span class="math inline">\(P_L\)</span> 和 <spanclass="math inline">\(P_R\)</span> 分别是 <spanclass="math inline">\(P\)</span> 的左子树和右子树</p><ol type="1"><li>如果 <span class="math inline">\(P\)</span>是叶节点，则直接删除</li><li>如果 <span class="math inline">\(P\)</span> 只有一个子树，则将 <spanclass="math inline">\(P\)</span> 的父节点指向 <spanclass="math inline">\(P\)</span> 的子树</li><li>如果 <span class="math inline">\(P\)</span> 有两个子树，则<ol type="1"><li>找到 <span class="math inline">\(P\)</span>的右子树中最左的节点或者左子树的最右节点 <spanclass="math inline">\(Q\)</span></li><li>将 <span class="math inline">\(Q\)</span> 的值赋给 <spanclass="math inline">\(P\)</span></li><li>删除 <span class="math inline">\(Q\)</span> 节点</li></ol></li></ol></li><li><p>公有的 <code>remove(const KEY &amp;x)</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-built_in">remove</span>(x , root);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有的<code>remove(const KEY &amp;x, BinaryNode *&amp;t)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; <span class="hljs-string">&quot;is not exist&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">remove</span>(x , t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">remove</span>(x , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;right != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    BinaryNode *p = t-&gt;right;<br>    <span class="hljs-keyword">while</span>(p-&gt;left != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      p = p-&gt;left;<br>    &#125;<br>    t-&gt;data = p-&gt;data;<br>    <span class="hljs-built_in">remove</span>(p-&gt;data.key , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    BinaryNode *oldNode = t;<br>    t = (t-&gt;left != <span class="hljs-literal">nullptr</span>) ? t-&gt;left : t-&gt;right;<br>    <span class="hljs-keyword">delete</span> oldNode;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的性能">二叉查找树的性能</h4><ul><li>二叉查找树的操作的时间复杂度为树的高度</li><li>如果二叉查找树是平衡的，则访问的代价是 <spanclass="math inline">\(O(\log n)\)</span></li><li>最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 <spanclass="math inline">\(O(n)\)</span></li></ul><p><strong>平均性能</strong></p><p>具有 <span class="math inline">\(n\)</span> 个节点的二叉查找树可能有<span class="math inline">\(n\)</span> 种不同的形态 <spanclass="math inline">\((0,1,n-1) , (1 , 1 n-2) , (2 , 1 , n-3) , \ldots ,(n-1 , 1 , 0)\)</span> 若设这些形态出现的概率是相同的，设 <spanclass="math inline">\(P(n)\)</span> 为查找 <spanclass="math inline">\(n\)</span>个节点的二叉查找树的平均查找时间，则有如下递归关系式：</p><p><span class="math display">\[P(n) = \frac{\sum_{i = 0}^{n-1} \left[ 1 + (P(i)+1) \cdot i + (P( n - i- 1)+1)\cdot (n-i-1)\right]}{n} \leq 2(1 + \frac{1}{n})\ln{n} \approx1.33 \log{n}\]</span></p><h3 id="avl-树">AVL 树</h3><h4 id="avl-树的定义">AVL 树的定义</h4><ul><li>也叫平衡树<ul><li>对于任意一个节点的两棵子树的高度至多相差 1</li></ul></li><li>平衡因子<ul><li>节点的左子树的高度减去右子树的高度</li><li>平衡因子只能是 <span class="math inline">\(-1\)</span>，<spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(1\)</span></li></ul></li><li>优点<ul><li>查找，插入和删除操作的时间复杂度都是 <spanclass="math inline">\(O(\log n)\)</span></li></ul></li></ul><h5 id="查找性能">查找性能</h5><ul><li><p>与二叉树的高度成正比</p></li><li><p>定理：</p><ul><li>具有 <span class="math inline">\(n\)</span> 个节点的平衡树，高度<span class="math inline">\(h\)</span> 满足 <spanclass="math inline">\(\log_2(n+1) \leq h \leq1.44\log_2(n+2)-0.328\)</span></li><li>因此，平衡二叉树的操作都是 <span class="math inline">\(O(\logn)\)</span></li></ul></li></ul><h5 id="斐波那契树">斐波那契树</h5><ul><li><p>斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为1</p></li><li><p>定义</p><ol type="1"><li>空树是高度为 0 的斐波那契树</li><li>单个节点是高度为 1 的斐波那契树</li><li>若 <span class="math inline">\(T_{h-1}\)</span> 和 <spanclass="math inline">\(T_{h-2}\)</span> 分别为高度为 <spanclass="math inline">\(h-1\)</span> 和 <spanclass="math inline">\(h-2\)</span> 的斐波那契树，则 <spanclass="math inline">\(T_h ={T_{h-1},x,T_{h-2}}\)</span> 是高度为 <spanclass="math inline">\(h\)</span> 的斐波那契树</li><li>没有其他的树是斐波那契树</li></ol></li></ul><h6 id="斐波那契树的特点">斐波那契树的特点</h6><p>对于高度为 <span class="math inline">\(h\)</span>的斐波那契树，节点数 <span class="math inline">\(n\)</span> 满足</p><ul><li><span class="math inline">\(n_0 = 0\)</span></li><li><span class="math inline">\(n_1 = 1\)</span></li><li><span class="math inline">\(n_h = n_{h-1} + n_{h-2} +1\)</span></li></ul><h4 id="avl-树的存储实现">AVL 树的存储实现</h4><ul><li>使用二叉链表</li><li>每个节点必须保存平衡信息<ul><li>每棵树的高度</li><li>平衡度即左右子树的高度差</li></ul></li></ul><h5 id="avl-树类的实现">AVL 树类的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;clas KEY,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AvlTree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AvlNode</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data ; <span class="hljs-comment">// 关键字</span><br>      AvlNode *left , *right; <span class="hljs-comment">// 左右子树指针</span><br>      <span class="hljs-type">int</span> height;            <span class="hljs-comment">// 节点高度</span><br><br>      <span class="hljs-built_in">AvlNode</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;element , AvlNode *lt ,AvlNode   *rt , <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>):<span class="hljs-built_in">data</span>(elemeent) , <span class="hljs-built_in">left</span>(lt) , <span class="hljs-built_in">right</span>(rt) , <span class="hljs-built_in">height</span>  (h) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    &#125;;<br><br>    AvlNode *root; <span class="hljs-comment">// 根节点</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AvlTree</span>() <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>      root = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AvlTree</span>() <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>      <span class="hljs-built_in">makeEmpty</span>(root);<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp; x)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">( <span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t )</span> </span>; <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">( <span class="hljs-type">const</span> KEY &amp; x, AvlNode * &amp; t )</span> </span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">( AvlNode *t )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(AvlNode *t)</span> <span class="hljs-type">const</span>  <span class="hljs-comment">// 返回节点的高度</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> t == <span class="hljs-literal">nullptr</span> ? <span class="hljs-number">0</span> : t -&gt; height;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LL</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 左旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RR</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 右旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LR</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 左右旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RL</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 右左旋</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>     <span class="hljs-comment">// 返回两个数中较大的一个</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">adjust</span><span class="hljs-params">(AvlNode *&amp;t, <span class="hljs-type">int</span> subTree)</span></span>; <span class="hljs-comment">//用于删除</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="avl-树的查找">AVL 树的查找</h4><ul><li>与二叉查找树相同</li><li>二叉查找树类采用递归实现</li><li>AVL 树类展示非递归实现</li></ul><h5 id="查找的非递归实现">查找的非递归实现</h5><ol type="1"><li>设当前节点为根节点</li><li>若当前节点非空<ol type="1"><li>若当前节点的值等于 <code>x</code>，则返回当前节点</li><li>若当前节点的值大于 <code>x</code>，则将当前节点指向左子树</li><li>若当前节点的值小于 <code>x</code>，则将当前节点指向右子树</li></ol></li><li>若当前节点为空，则返回空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *AvlTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp; x) <span class="hljs-type">const</span><br>&#123;<br>  AvlNode *t = root; <br>  <span class="hljs-keyword">while</span> (t!=<span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;data.key != x)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; t-&gt;data.key)<br>    &#123;<br>      t = t-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      t = t-&gt;right;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> t-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="avl-树的插入">AVL 树的插入</h4><ul><li>与二叉查找树相同<ul><li>可能改变了根到插入节点的路径上某些节点的平衡度</li><li>需要向上修改树的结构</li></ul></li></ul><h5 id="可能引起节点不平衡的情况">可能引起节点不平衡的情况</h5><ul><li>节点的左孩子的左子树上插入（LL）</li><li>节点的左孩子的右子树上插入（LR）</li><li>节点的右孩子的左子树上插入（RL）</li><li>节点的右孩子的右子树上插入（RR）</li></ul><h5 id="重构的方法">重构的方法</h5><ul><li>指针调整<ul><li>按照投影序保持结点相邻关系不变</li><li>辈分可以改变</li></ul></li></ul><h6 id="ll-问题">LL 问题</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png"alt="LL" /><figcaption aria-hidden="true">LL</figcaption></figure><ul><li><strong>左旋</strong><ol type="1"><li>将失衡点的左儿子作为新的根节点</li><li>左儿子的右儿子作为原根节点的左儿子</li></ol></li><li>若为 RR问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为<strong>右旋</strong></li><li>左旋和右旋统称为<strong>单旋转</strong>，保留了树的有序性和原先的高度</li></ul><h6 id="lr-问题">LR 问题</h6><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png"alt="LR" /><figcaption aria-hidden="true">LR</figcaption></figure><ul><li><strong>双旋转</strong><ol type="1"><li>将失衡点的左儿子右旋</li><li>将失衡点左旋</li></ol></li><li>若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋</li><li>先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使<strong>原先的孙子变成根</strong></li></ul><h5 id="私有的insert-函数">私有的<code>insert</code> 函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AvlNode</span>(x , <span class="hljs-literal">nullptr</span> , <span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;left);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) - <span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (x.key &lt; t-&gt;left-&gt;data.key)<br>      &#123;<br>        <span class="hljs-built_in">LL</span>(t);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">LR</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;right);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) - <span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (x.key &gt; t-&gt;right-&gt;data.key)<br>      &#123;<br>        <span class="hljs-built_in">RR</span>(t);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">RL</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新高度</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ll"><code>LL</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">LL</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;left;<br>  t-&gt;left = t1-&gt;right;<br>  t1-&gt;right = t;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>;<br>  t1-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t1-&gt;left) , <span class="hljs-built_in">height</span>(t1-&gt;right)) + <span class="hljs-number">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="rr"><code>RR</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">RR</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;right;<br>  t-&gt;right = t1-&gt;left;<br>  t1-&gt;left = t;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>;<br>  t1-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t1-&gt;left) , <span class="hljs-built_in">height</span>(t1-&gt;right)) + <span class="hljs-number">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="lr"><code>LR</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">LR</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class="hljs-built_in">RR</span>(t-&gt;left);<br>  <span class="hljs-built_in">LL</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="rl"><code>RL</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">RL</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class="hljs-built_in">LL</span>(t-&gt;right);<br>  <span class="hljs-built_in">RR</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>所有旋转的算法时间复杂度都是 <spanclass="math inline">\(O(1)\)</span>，且只运行一次，所以<code>insert</code> 的时间复杂度为 <span class="math inline">\(O(\logn)\)</span></p><h4 id="avl-树的删除">AVL 树的删除</h4><ol type="1"><li>在 AVL 树上删除节点 <code>x</code>，删除操作和二叉查找树相同</li><li>调整平衡，与插入操作相同</li></ol><h4 id="调整">调整</h4><ul><li>与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度</li><li>删除时无法保证子树在平衡调整之后的高度不变</li><li>递归的删除函数有一个 bool 型的返回值，当返回值为 <code>true</code>时，调整停止</li></ul><h4 id="五种情况">五种情况</h4><h5 id="情况-a">情况 a</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png"alt="Sitiationa" /><figcaption aria-hidden="true">Sitiationa</figcaption></figure><p>此时没有失衡，高度也没有改变，返回<code>true</code></p><h5 id="情况-b">情况 b</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png"alt="Situationb" /><figcaption aria-hidden="true">Situationb</figcaption></figure><p>此时没有失衡，但是高度变矮，返回<code>false</code></p><h5 id="情况-c">情况 c</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png"alt="Situationc" /><figcaption aria-hidden="true">Situationc</figcaption></figure><p>经过 RR 旋转后高度变矮，返回<code>false</code></p><h5 id="情况-d">情况 d</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png"alt="Situationd" /><figcaption aria-hidden="true">Situationd</figcaption></figure><p>经过 RL 旋转后高度变矮，返回<code>false</code></p><h5 id="情况-e">情况 e</h5><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png"alt="Situatione" /><figcaption aria-hidden="true">Situatione</figcaption></figure><p>经过 RR 或 RL 旋转后高度不变，返回<code>true</code></p><h4 id="删除总结">删除总结</h4><ul><li>节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回<code>false</code></li><li>在每次调用后，检查返回值，如果是 <code>true</code>，则返回<code>true</code>，否则分 5 种情况进行处理</li></ul><h4 id="私有的-remove-函数">私有的 <code>remove</code> 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x , AvlNOde *&amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t = <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 被删除节点不存在</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x == t-&gt; data.key)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;left == <span class="hljs-literal">nullptr</span> || t-&gt; right == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      AvlNode *oldNode = t;<br>      t = (t-&gt;left == <span class="hljs-literal">nullptr</span>) ? t-&gt;right : t-&gt;left; <span class="hljs-comment">// 删除节点的孩子节点</span><br>      <span class="hljs-keyword">delete</span> oldNode;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 删除了一个节点，返回 `false`</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      AvlNode *tmp = t-&gt; right;<br>      <span class="hljs-keyword">while</span> (tmp-&gt;left != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 找到右子树的最小节点</span><br>      &#123;<br>        tmp = tmp-&gt;left;<br>      &#125;<br>      t-&gt;data = tmp.data;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(tmp-&gt;data,key , t-&gt;right))<br>      &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &lt; t-&gt;data,key)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x,t-&gt;left))<br>    &#123;<br>      teturn <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x , t-&gt;right))<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="adjust"><code>adjust</code></h4><ul><li>进入调整函数的条件是某棵子树变矮了</li><li>调整函数需要检查节点是否失衡，若失衡则进行相应的调整</li><li>函数的返回值是子树是否变矮<ul><li><code>true</code>：子树没有变矮</li><li><code>false</code>：子树变矮</li></ul></li><li>需要传入两个参数<ul><li><code>AVlNode *&amp;t</code>：传入的节点</li><li><code>int subTree</code>：参数 <code>t</code> 变矮的子树<ul><li><code>0</code>：左子树</li><li><code>1</code>：右子树</li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span> , classs OTHER&gt;<br><span class="hljs-type">bool</span> AvlTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">adjust</span>(AvlNode *&amp;t , <span class="hljs-type">int</span> SubTree)<br>&#123;<br>  <span class="hljs-keyword">if</span> (subTree) <span class="hljs-comment">// 在右子树上删除</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) - <span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-number">1</span>) <span class="hljs-comment">// Situation a</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left)) <span class="hljs-comment">// Situation b</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left-&gt;right) &gt; <span class="hljs-built_in">height</span>(t-&gt;left-&gt;left)) <span class="hljs-comment">// Situation d</span><br>    &#123;<br>      <span class="hljs-built_in">LR</span>(t);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">LL</span>(t); <span class="hljs-comment">// Situation c and e</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-built_in">height</span>(t-&gt;right))s<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">// 在左子树上删除</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) - <span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-number">1</span>) <span class="hljs-comment">// Situation a</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left)) <span class="hljs-comment">// Situation b</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-function">s</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))</span> <span class="hljs-comment">// Situation d</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-built_in">RL</span>(t);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">RR</span>(t); <span class="hljs-comment">// Situation c and e</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left))<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="散列表">散列表</h3><ul><li>也叫哈希表</li><li>通过所求节点的关键字词 <code>KEY</code> 找到这个节点</li><li>时间复杂度为 <span class="math inline">\(O(1)\)</span></li></ul><h4 id="基本概念">基本概念</h4><ol type="1"><li>初始化 将数组转化为一个特殊的、表示单元为空的值</li><li><code>insert(i)</code> 将 <code>i</code> 存放到<code>a[i.key]</code> 中</li><li><code>find(i)</code> 取出 <code>a[i.key]</code> 中的值</li><li><code>remove(i)</code> 将 <code>a[i.key]</code> 中的值置为空</li></ol><h4 id="散列函数">散列函数</h4><p>将一个项映射成一个较小的下标的函数称为散列函数（hush function）</p><ul><li><span class="math inline">\(D = H(key)\)</span> D 为存储地址，key为关键值，H 为散列函数</li><li>散列函数的要求<ul><li>计算速度快</li><li>散列地址均匀分布</li></ul></li></ul><h4 id="常用的散列函数">常用的散列函数</h4><h5 id="直接地址法">直接地址法</h5><p><span class="math inline">\(H(key) = key\)</span> 或 <spanclass="math inline">\(H(key) = a \times key + b\)</span></p><h5 id="除留余数法"><strong>除留余数法</strong></h5><p><span class="math inline">\(H(key) = key \mod p\)</span> 或 <spanclass="math inline">\(H(key) = key \mod p + c\)</span> 这里的 <spanclass="math inline">\(p\)</span> 是一个小于等于 <spanclass="math inline">\(m\)</span> 的素数</p><h5 id="数字分析法">数字分析法</h5><p>对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分</p><h5 id="平方取中法">平方取中法</h5><p>如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字<strong>平方后</strong>，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。</p><h5 id="折叠法">折叠法</h5><ul><li>如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法</li><li>选取一个长度后，将关键字按此长度分组相加</li></ul><h4 id="冲突问题">冲突问题</h4><p>当两个以上的关键字映射到一个存储单元时，称为<strong>冲突或碰撞</strong></p><ul><li>解决冲突的方法<ul><li>闭散列表：利用本散列表中的空余单元<ul><li>线性探测法</li><li>二次探测法</li><li>再次散列法</li></ul></li><li>开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）</li></ul></li></ul><h5 id="闭散列表类的实现">闭散列表类的实现</h5><ul><li>支持三种操作<ul><li><code>insert</code>：插入一个元素</li><li><code>remove</code>：删除一个元素</li><li><code>find</code>：查找一个元素</li></ul></li><li>由一个数组实现，数组的大小由用户定义散列表时指定</li><li>由于删除时的迟删除，每个数组元素还要保存一个状态值<ul><li><code>0</code>：空</li><li><code>1</code>：有效</li><li><code>2</code>：删除</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">closeHashTable</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY, OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>  <span class="hljs-comment">//散列表的结点类</span><br>    &#123;<br>      SET &lt;KEY, OTHER&gt; data;<br>      <span class="hljs-type">int</span> state; <span class="hljs-comment">//0 -- empty 1 -- active 2 -- deleted</span><br>      <span class="hljs-built_in">node</span>()<br>      &#123;<br>        state = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;;<br>    node *array;<br><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-built_in">int</span> (*key)(<span class="hljs-type">const</span> KEY &amp;x);<span class="hljs-comment">//哈希函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultKey</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> x;<br>    &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">closeHashTable</span>(<span class="hljs-type">int</span> length = <span class="hljs-number">101</span>, <span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x) = defaultKey)<br>    ~<span class="hljs-built_in">closeHashTable</span>()<br>    &#123;<br>      <span class="hljs-keyword">delete</span> [] array;<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">closeHashTable</span>(<span class="hljs-type">int</span> length, <span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x))<br>&#123;<br>  size = length;<br>  array = <span class="hljs-keyword">new</span> node[size];<br>  key = f; <span class="hljs-comment">//哈希函数为f</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos= pos = <span class="hljs-built_in">key</span>(x.key) % size; <span class="hljs-comment">//%size保护作用，避免越界</span><br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state != <span class="hljs-number">1</span>)<br>    &#123; <span class="hljs-comment">// 0或2，找到空单元</span><br>      array[pos].data = x;<br>      array[pos].state = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size;<br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>remove</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos= pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//没找到</span><br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">1</span> &amp;&amp; array[pos].data.key== x)<span class="hljs-comment">// 找到，删除</span><br>    &#123;<br>      array[pos].state = <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size; <span class="hljs-comment">//没找到，需要往后找</span><br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>find</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos = pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有找到</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">1</span> &amp;&amp; array[pos].data.key == x) <span class="hljs-comment">// 找到</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> (SET&lt;KEY,OTHER&gt; *)&amp;array[pos];<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size;<br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="线性探测法">线性探测法</h6><p>当散列发生冲突时，依次<strong>探测下一个单元</strong>，直到发现一个空单元</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png"alt="线性探测法" /><figcaption aria-hidden="true">线性探测法</figcaption></figure><h6 id="二次探测法">二次探测法</h6><p>以此向后探测 <span class="math inline">\(1^2\)</span>，<spanclass="math inline">\(2^2\)</span>，<spanclass="math inline">\(3^2\)</span>，<spanclass="math inline">\(4^2\)</span>，<spanclass="math inline">\(5^2\)</span>，<spanclass="math inline">\(\ldots\)</span></p><p><strong>定理</strong></p><ul><li>如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子<spanclass="math inline">\(&lt;0.5\)</span>），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次</li></ul><h6 id="再次散列法">再次散列法</h6><ul><li>采用一个新的散列函数 <spanclass="math inline">\(H_2(key)\)</span></li><li><span class="math inline">\(H_1(x)\)</span>，<spanclass="math inline">\(H_1(x)+H_2(x)\)</span> ，<spanclass="math inline">\(H_1(x)+2H_2(x)\)</span>，<spanclass="math inline">\(H_1(x)+3H_2(x)\)</span>，<spanclass="math inline">\(\ldots\)</span></li></ul><h5 id="开散列表">开散列表</h5><p>链地址法</p><ul><li>将具有同一散列地址的结点保存于 <code>M</code>存区的各自的链表之中</li></ul><h6 id="开散列表的实现">开散列表的实现</h6><ul><li>将所有散列到同一地址的元素链接成一个单链表</li><li>采用不带头结点的单链表</li><li>散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span> , <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">openHashTable</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEU , OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data;<br>      node *next;<br>      <span class="hljs-built_in">node</span> (<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;d , nde *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = d;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>()<br>      &#123;<br>        next = <span class="hljs-literal">nullptr</span>;<br>      &#125;<br>    &#125;;<br>    node **array; <span class="hljs-comment">// 散列表，指针数组</span><br>     <span class="hljs-type">int</span> size;<br>     <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultKry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function">     </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>     &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">openHashTable</span>(<span class="hljs-type">int</span> length = <span class="hljs-number">101</span>,<span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x) = defaultKey);<br>    ~<span class="hljs-built_in">openashTable</span>();<br>    <span class="hljs-function">SET&lt;KEY,OTHER&gt; *<span class="hljs-title">finf</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY,OTHER&gt; &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>openHashTable&lt;KEY, OTHER&gt;::~<span class="hljs-built_in">openHashTable</span>()<br>&#123;<br>  node *p, *q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; size; ++i)<br>  &#123;<br>    p = array[i];<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      q= p-&gt;next; <span class="hljs-keyword">delete</span> p; p = q;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">delete</span> [] array；<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> pos;<br>  node *p;<br>  <span class="hljs-comment">//插入单链表的头部</span><br>  pos = <span class="hljs-built_in">key</span>(x.key) % size;<br>  array[pos] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x, array[pos]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>remove</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> pos ;<br>  node *p, *q;<br>  pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">if</span> (array[pos] == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  p = array[pos];<br>  <span class="hljs-keyword">if</span> (array[pos]-&gt;data.key== x)<br>  &#123; <span class="hljs-comment">// 删除第一个结点</span><br>    array[pos] = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; !(p-&gt;next-&gt;data.key== x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p-&gt;next != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-keyword">delete</span> q;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>find</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> pos ;<br>  node *p;<br>  pos = <span class="hljs-built_in">key</span>(x) % size;<br>  p = array[pos];<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; !(p-&gt;data.key == x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">return</span> (SET&lt;KEY, OTHER&gt; *)p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序">排序</h2><h3 id="基本概念-1">基本概念</h3><ul><li>按照关键字的非递减或非递增序排成一个序列</li><li><strong>稳定与非稳定排序</strong>:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序</li><li>内排序与外排序<ul><li><strong>内排序：</strong>排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置</li><li><strong>外排序：</strong>在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置</li></ul></li></ul><h3 id="插入排序">插入排序</h3><p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的</p><h4 id="直接插入排序">直接插入排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simpleInsertSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt;a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> k;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;size; ++j)<br>  &#123;<br>  tmp = a[j];<br>  <span class="hljs-keyword">for</span> ( k = j<span class="hljs-number">-1</span>; tmp.key &lt; a[k].key &amp;&amp; k &gt;= <span class="hljs-number">0</span>; --k)<br>  &#123;<br>    a[k<span class="hljs-number">+1</span>] = a[k];<br>  &#125;<br>  a[k<span class="hljs-number">+1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li><li>稳定性：稳定</li><li>时间复杂度<ul><li>最好：<span class="math inline">\(O(n)\)</span></li><li>最坏：<span class="math inline">\(O(n^2)\)</span></li><li>平均：<span class="math inline">\(O(n^2)\)</span></li></ul></li><li>适用情况：短序列或者几乎已经排好序的</li></ul><h4 id="折半插入排序">折半插入排序</h4><p>先用二分排序找到插入位置</p><ul><li>时间复杂度<ul><li>最好：<span class="math inline">\(O(n\log n)\)</span></li><li>最坏：<span class="math inline">\(O(n^2)\)</span></li><li>平均：<span class="math inline">\(O(n^2)\)</span></li></ul></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li><li>稳定性：稳定</li></ul><p>改进很小，对于接近排好序的序列甚至<strong>更差</strong></p><h4 id="希尔排序">希尔排序</h4><ul><li>相隔一定的距离的记录组成一个子序列</li><li>逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态</li><li>最后再用直接插入排序对整个序列进行一次排序</li></ul><h5 id="步长序列的选择">步长序列的选择</h5><ul><li><p><span class="math inline">\(1,2,4,8,\ldots\)</span></p></li><li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li><li><p>Knuth 推荐：<spanclass="math inline">\(1,3,7,15,31,63,\ldots\)</span></p></li><li><p>时间复杂度：<spanclass="math inline">\(O(n^{1.5})\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li><li><p>不稳定</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> step, i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (step = size/<span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span>) <span class="hljs-comment">//step为希尔增量</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> (i = step; i &lt; size; ++i)<br>    &#123;<br>      tmp = a[i];<br>      <span class="hljs-keyword">for</span> (j = i -step; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j].key &gt; tmp.key; j -= step)<br>      &#123;<br>        a[j+step] = a[j];<br>      &#125;<br>      a[j+step] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序">选择排序</h3><ol type="1"><li>在 <span class="math inline">\(n\)</span>个元素中选出最小的元素</li><li>从剩下的 <span class="math inline">\(n-1\)</span>个元素中选出最小的元素</li><li>以此类推，直到最后一个元素</li></ol><h4 id="直接选择排序">直接选择排序</h4><ol type="1"><li>在所有元素中逐个比较找到最小元素，与第一个元素交换</li><li>在剩下的元素中逐个比较找到最小元素，与第二个元素交换</li><li>以此类推，直到最后一个元素</li></ol><ul><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li><li>不稳定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simpleSelectSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i, j, min;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size <span class="hljs-number">-1</span>; ++i)<br>  &#123;<br>  min = i;<br>  <span class="hljs-keyword">for</span> (j = i<span class="hljs-number">+1</span>; j &lt; size; ++j)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (a[j].key &lt; a[min].key)<br>    &#123;<br>      min = j;<br>    &#125;<br>  &#125;<br>  tmp = a[i]; a[i] = a[min]; a[min] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序">堆排序</h4><ol type="1"><li>建立一个最大堆</li><li>执行 <span class="math inline">\(n\)</span> 次 <code>deQuqeue</code>操作取出每个项</li></ol><ul><li><p>时间复杂度 <span class="math inline">\(O(n\logn)\)</span></p></li><li><p>堆排序</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  SET&lt;KEY, OTHER&gt; tmp; <span class="hljs-comment">// 创建初始的堆</span><br>  <span class="hljs-keyword">for</span>( i = size / <span class="hljs-number">2</span> <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>  &#123;<br>    <span class="hljs-built_in">percolateDown</span>( a, i, size );<br>  &#125;<br>  <span class="hljs-comment">//执行n-1次deQueue</span><br>  <span class="hljs-keyword">for</span> ( i = size <span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; --i)\<br>  &#123;<br>  tmp = a[<span class="hljs-number">0</span>]; a[<span class="hljs-number">0</span>] = a[i]; a[i] = tmp; <span class="hljs-comment">//delete a[0]</span><br>  <span class="hljs-built_in">percolateDown</span>( a, <span class="hljs-number">0</span>, i );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>precolateDown</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">( SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> hole, <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> child;<br>  SET&lt;KEY, OTHER&gt; tmp= a[ hole ];<br>  <span class="hljs-keyword">for</span>( ; hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; size; hole = child )<br>  &#123;<br>    child = hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>( child != size <span class="hljs-number">-1</span> &amp;&amp; a[ child + <span class="hljs-number">1</span> ].key &gt; a[ child ].key )<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( a[ child ].key &gt;tmp.key)<br>    &#123;<br>      a[ hole ] = a[ child ];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  a[ hole ] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交换排序">交换排序</h3><p>通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动</p><h4 id="冒泡排序">冒泡排序</h4><p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡</p><p>然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置</p><p>依次类推，经过第 <span class="math inline">\(n-1\)</span>趟起泡，将倒数第 <span class="math inline">\(n-1\)</span>个大的元素放入第 2 个单元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//记录一趟起泡中有没有发生过交换</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; size&amp;&amp; flag; ++i)<br>  &#123; <span class="hljs-comment">//size-1次起泡</span><br>    flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; size-i; ++j) <span class="hljs-comment">//第i次起泡</span><br>    <span class="hljs-keyword">if</span> (a[j<span class="hljs-number">+1</span>].key &lt; a[j].key)<br>    &#123;<br>      tmp = a[j]; a[j] = a[j<span class="hljs-number">+1</span>]; a[j<span class="hljs-number">+1</span>] = tmp;<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序">快速排序</h4><ul><li>选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边</li><li>然后对基准元素左边和右边的子序列进行递归排序</li></ul><h5 id="选择中心点">选择中心点</h5><ul><li>第一个元素</li><li>随机</li><li>中值（采样得到）</li></ul><h5 id="划分第一个元素为中心点">划分（第一个元素为中心点）</h5><ol type="1"><li>序列的下标上界为 <code>high</code>，下届为<code>low</code>，中心点选取第一个元素，关键值为<code>K</code>，<code>low</code> 位置空出</li><li>从右向左开始检查：如果 <code>high</code> 的关键值大于<code>K</code>，该位置中的值位置正确，<code>high</code> 减 <spanclass="math inline">\(1\)</span>，继续往前检查，直到遇到一个小于<code>K</code> 的值</li><li>将小于 <code>k</code> 的这个值放入 <code>low</code> 的位置，此时<code>high</code> 的位置又空出。然后从 <code>low</code>位置开始从左向右检查，直到遇到一个大于 <code>K</code> 的值</li><li>将 <code>low</code> 位置的值放入 <code>high</code> 位置，重复第 2步，直到 <code>low</code> 和 <code>high</code> 重叠，将 <code>K</code>放入此位置</li></ol><p>划分函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">( SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>  SET&lt;KEY, OTHER&gt; k = a[low];<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[high].key &gt;= k.key)<br>    &#123;<br>      --high;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>      a[low] = a[high]; ++low;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[low].key &lt;= k.key)<br>    &#123;<br>      ++low;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>      a[high] = a[low]; --high;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (low != high);<br>  a[low] = k;<br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><ul><li>将待排序的序列分成两个子序列，分别进行排序</li><li>将两个有序的子序列合并成一个有序的序列</li><li>递归进行</li></ul><h3 id="基数排序">基数排序</h3><ul><li>称为口袋排序法</li><li>通过分配的方法进行排序</li><li>基数（r）：子关键字的值域的元素的个数<ul><li>十进制数：<spanclass="math inline">\(0,1,2,\ldots,9\)</span>，基数为 <spanclass="math inline">\(10\)</span></li><li>二进制数：<span class="math inline">\(0,1\)</span>，基数为 <spanclass="math inline">\(2\)</span></li><li>英文字符：<spanclass="math inline">\(A,B,C,\ldots,Z\)</span>，基数为 <spanclass="math inline">\(26\)</span></li></ul></li></ul><h4 id="高位优先法msd">高位优先法（MSD）</h4><ul><li>先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列</li></ul><h4 id="低位优先法lsd">低位优先法（LSD）</h4><ul><li>先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起</li><li>然后将次低位进入口袋进行排序，依次类推</li><li>最后将所有记录按照口袋的顺序收在一起</li></ul><h2 id="外存储器中的查找和排序">外存储器中的查找和排序</h2><h3 id="主存储器与外存储器">主存储器与外存储器</h3><ul><li>主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据</li><li>外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息<ul><li>价格低廉、存储量大、永久保存、<strong>访问速度慢</strong></li></ul></li></ul><h3 id="外部查找">外部查找</h3><h4 id="b-树">B 树</h4><p>B 树是一棵平衡的 M 叉查找树，需要 <spanclass="math inline">\(M-1\)</span> 个关键字来判断到哪个分支查找</p><h5 id="b-树的定义">B 树的定义</h5><ul><li>一棵 <span class="math inline">\(m\)</span> 阶 B树要么为空，要么满足一下条件<ul><li>根节点要么是叶节点，要么至少有两个儿子，至多有 <spanclass="math inline">\(m\)</span> 个儿子</li><li>每个非根节点至少有 <span class="math inline">\(\lceil m/2\rceil\)</span> 个儿子，至多有 <span class="math inline">\(m\)</span>个儿子</li><li>有 <span class="math inline">\(s\)</span> 个儿子的非叶节点具有 <spanclass="math inline">\(n=s-1\)</span> 个关键字</li><li>所有的叶子节点都出现在同一层上</li></ul></li></ul><h5 id="b-树的插入">B 树的插入</h5><ul><li>在最底层进行插入</li></ul><ol type="1"><li>在 <span class="math inline">\(m\)</span> 阶 B树上进行查找操作，确定新插入的关键字 <code>key</code>在最底层非叶节点的插入位置</li><li>如果被插入节点的关键字个数小于等于 <spanclass="math inline">\(m-1\)</span>，则插入结束</li><li>如果被插入节点的关键字个数大于 <spanclass="math inline">\(m-1\)</span>，则需要进行分裂</li></ol><ul><li>被插入节点分为三个部分<ul><li>前半部分：前 <span class="math inline">\(m/2\)</span> 个关键字</li><li>中间部分：中间的关键字</li><li>后半部分：后 <span class="math inline">\(m/2\)</span> 个关键字</li></ul></li><li>中间部分的关键字上升到父节点</li><li>前后半部分生成新的两个节点</li></ul><h5 id="b-树的删除">B 树的删除</h5><ul><li>采用替身法，替身为右子树的最小值或者左子树的最大值</li></ul><ol type="1"><li>删除节点，替身进入</li><li>如果删除后的替身原来在的节点满足，则直接删除</li><li>如果删除后的关键字小于下限，<ul><li>向该节点的左或右兄弟借一个关键字</li><li>如果兄弟节点的关键字个数等于下限，则需要进行合并</li></ul></li></ol><h5 id="m-的选择">M 的选择</h5><h4 id="b树">B+树</h4><p>B+树是既能提供随机查找，也能提供顺序访问的存储结构</p><h5 id="b树的定义">B+树的定义</h5><ul><li>所有数据都记录在叶节点中，所有叶节点连成一个单链表</li><li>非叶节点至多保存 <span class="math inline">\(m-1\)</span>个关键字来引导查找，键 <span class="math inline">\(i\)</span> 表示子树<span class="math inline">\(i+1\)</span> 中键的最小值</li><li>根节点或者是叶节点，或者有 <span class="math inline">\(2\)</span> 到<span class="math inline">\(m\)</span> 个子树</li><li>除了根节点之外的所有非叶节点至少有 <spanclass="math inline">\(m/2\)</span> 个儿子，最多有 <spanclass="math inline">\(m\)</span> 个儿子</li><li>所有的叶节点都在同一层上，并且每个叶子有 <spanclass="math inline">\(\lceil L/2 \rceil\)</span> 到 <spanclass="math inline">\(L\)</span> 个关键字</li></ul><h5 id="b树的插入">B+树的插入</h5><ul><li>叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序</li><li>叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项<ul><li>更新父结点</li><li>如果父亲的儿子数量已经满了，就继续分裂父亲</li></ul></li></ul><h3 id="外排序">外排序</h3><p>一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O操作）</p><h4 id="外排序模型">外排序模型</h4><ul><li>外排序由两个阶段组成<ol type="1"><li>预处理阶段：根据内存的大小将一个有 n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段</li><li>归并阶段：将这些有序片段逐步归并成一个有序文件</li></ol></li></ul><p>减少 I/O 操作的关键</p><ol type="1"><li>减少归并轮数</li><li>减少有序片段数量</li><li>增加合并路数</li></ol><h4 id="预处理">预处理</h4><h5 id="减少有序片段数量">减少有序片段数量</h5><ul><li>每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少</li><li>最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段</li></ul><h5 id="置换排序">置换排序</h5><p>置换选择可以在只能容纳 <span class="math inline">\(p\)</span>个记录的内存中生成平均长度为 <span class="math inline">\(2p\)</span>的初始的已排序片段</p><p>只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段</p><p>具体方法</p><ol type="1"><li>初始时，将 <span class="math inline">\(m\)</span> 个元素读入内存，用<code>buildHeap</code> 建立一个优先级队列</li><li>执行一次 <code>deQuqeue</code>，将最小的元素写入输出文件</li><li>从输入磁带读入下一个元素<ul><li>如果它比刚才写进去的元素大，那么将它加入到优先级队列中</li><li>否则，则无法写入队列，进行下一次 <code>deQuqeue</code></li></ul></li><li>重复第 2、3 步，直到输入文件读完</li><li>重新执行 <code>buildHeap</code>，使用存放在空余位置中的元素</li></ol><h4 id="归并">归并</h4><h5 id="二路归并">二路归并</h5><ul><li>归并时，每次将两个有序文件归并为一个有序文件</li><li>如果生成的有序片段数量为 <spanclass="math inline">\(M\)</span>，则归并次数为 <spanclass="math inline">\(\lceil \log_2 M \rceil\)</span></li></ul><h5 id="多路归并">多路归并</h5><ul><li>归并时，每次将 <span class="math inline">\(k\)</span>个有序文件归并为一个有序文件</li><li>优点：减少归并次数，为 <span class="math inline">\(\lceil \log_k M\rceil\)</span> 次</li><li>缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列</li></ul><h5 id="多阶段归并">多阶段归并</h5><ul><li>可以仅使用 <span class="math inline">\(K+1\)</span> 条磁带实现 <spanclass="math inline">\(K\)</span>路归并，称为<strong>多阶段归并</strong></li></ul><p><strong>实现的过程</strong></p><ol type="1"><li>按照非均匀的方法分解原来的已排序的片段</li><li>将每个片段分成 <span class="math inline">\(K\)</span> 个子片段</li></ol><h2 id="图">图</h2><h3 id="图的定义">图的定义</h3><ul><li>图可以用 <span class="math inline">\(G=(V, E)\)</span>表示。其中，<span class="math inline">\(V\)</span> 是顶点集，<spanclass="math inline">\(E\)</span> 是边集。</li><li>如果边是有方向的，称为<strong>有向图</strong>.有向图的边用 <spanclass="math inline">\(\langle \rangle\)</span> 表示<ul><li><span class="math inline">\(\langle A, B \rangle\)</span> 表示从<span class="math inline">\(A\)</span> 到 <spanclass="math inline">\(B\)</span> 的一条边</li></ul></li><li>如果边是无方向的，称为<strong>无向图</strong>.无向图的边用 <spanclass="math inline">\(()\)</span> 表示<ul><li><span class="math inline">\((A, B)\)</span> 表示 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 之间有一条边</li><li>无向图也称为双向图</li></ul></li><li><strong>加权图：</strong>边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图<ul><li>加权图中边的表示：<spanclass="math inline">\((V_i,V_j,W)\)</span></li></ul></li></ul><h3 id="图的基本术语">图的基本术语</h3><ul><li>邻接<ul><li>若 <span class="math inline">\((V_i,V_j)\)</span> 是图 <spanclass="math inline">\(G\)</span> 的一条边，则称 <spanclass="math inline">\(V_i\)</span> 和 <spanclass="math inline">\(V_j\)</span> 是邻接的；若 <spanclass="math inline">\(\langle V_i,V_j \rangle\)</span> 是图 <spanclass="math inline">\(G\)</span> 的一条边，则称 <spanclass="math inline">\(V_i\)</span> 邻接到 <spanclass="math inline">\(V_j\)</span>，<spanclass="math inline">\(V_j\)</span> 和 <spanclass="math inline">\(V_i\)</span> 邻接</li></ul></li><li>度 无向图中邻接与某一顶点的边的总数</li><li>入度 有向图中进入某一顶点的边数</li><li>出度 有向图中离开某一顶点的边数</li><li>边与度的关系 <span class="math inline">\(\displaystylee=\frac{1}{2}\sum_{i=1}^n d_i\)</span>，其中 <spanclass="math inline">\(e\)</span> 是边数，<spanclass="math inline">\(d_i\)</span> 是顶点 <spanclass="math inline">\(V_i\)</span> 的度</li></ul><h4 id="子图">子图</h4><p>设有两个图 <span class="math inline">\(G_1=(V_1,E_1)\)</span> 和<span class="math inline">\(G_2=(V_2,E_2)\)</span>，如果 <spanclass="math inline">\(V_1 \subseteq V_2\)</span>，<spanclass="math inline">\(E_1 \subseteq E_2\)</span>，则称 <spanclass="math inline">\(G_1\)</span> 是 <spanclass="math inline">\(G_2\)</span> 的子图</p><h4 id="路径和路径长度">路径和路径长度</h4><ul><li>对于 <span class="math inline">\(1&lt;i&lt;N\)</span>，顶点序列<span class="math inline">\(w_1,w_2,\ldots,w_N\)</span> 中的顶点对 <spanclass="math inline">\((w_i,w_{i+1})\)</span> 都有 <spanclass="math inline">\((W_i,w_{i+1})\in E\)</span> 或 <spanclass="math inline">\(\langle w_i,w_{i+1} \rangle \in E\)</span>，则称<span class="math inline">\(w_1,w_2,\ldots,w_N\)</span>是图中的一条<strong>路径</strong></li><li><strong>非加权的路径长度</strong>就是组成路径的边数，对于路径 <spanclass="math inline">\(w_1,w_2,\ldots,w_N\)</span>，路径长度为 <spanclass="math inline">\(N-1\)</span></li><li><strong>加权的路径长度</strong>是指路径上所有边的权值之和</li><li><strong>简单路径和环：</strong>如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为<span class="math inline">\(1\)</span></li></ul><h4 id="无向图的连通性">无向图的连通性</h4><ul><li><strong>连通：</strong> 顶点 <span class="math inline">\(V\)</span>和顶点 <span class="math inline">\(V&#39;\)</span> 之间又路径存在</li><li><strong>连通图：</strong> 无向图 G 的任意两点之间都是连通的</li><li><strong>连通分量：</strong> 非连通图中的极大连通子图</li></ul><h4 id="有向图的连通性">有向图的连通性</h4><ul><li><strong>强连通图：</strong> 有向图 G 的任意两点之间都是连通的，则称G 是强连通图</li><li><strong>强连通分量：</strong> 极大连通子图</li><li><strong>弱连通图：</strong> 如有向图 G不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的</li></ul><h4 id="完全图">完全图</h4><ul><li><strong>完全图：</strong>每两个顶点之间都有边的无向图称为完全图。完全图有 <spanclass="math inline">\(\frac{n(n-1)}{2}\)</span> 条边，即 <spanclass="math inline">\(C_n^2\)</span></li><li><strong>有向完全图：</strong>每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 <spanclass="math inline">\(n(n-1)\)</span> 条边，即 <spanclass="math inline">\(P_n^2\)</span></li><li><strong>有向无环图：</strong> 不含环的有向图</li></ul><h4 id="生成树与最小生成树">生成树与最小生成树</h4><ul><li><strong>生成树</strong>是图 G 的<strong>极小</strong>连通子图G’，其中 <span class="math inline">\(V(G&#39;)=V(G)\)</span></li><li>用一棵树把图 G 的所有顶点都连起来，并且没有回路</li><li>生成树有 <span class="math inline">\(n\)</span> 个顶点，<spanclass="math inline">\(n-1\)</span> 条边</li><li>生成树可以有多个</li><li><strong>最小生成树</strong>是所有生成树中权值之和最小的生成树</li></ul><h3 id="图的运算">图的运算</h3><ul><li>常规操作<ul><li>构造一个由若干个顶点、若干条边组成的图</li><li>判断两个顶点之间是否有边存在</li><li>在图中添加或删除一条边</li><li>返回图中的顶点数或边数</li><li>按某种规则<strong>遍历</strong>图中的所有顶点</li></ul></li><li>和应用紧密结合的运算<ul><li>拓扑排序和关键路径</li><li>找最小生成树</li><li>找最短路径等</li></ul></li></ul><h3 id="图的抽象类">图的抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y, TypeOfEdge w)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfVer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> Vers;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfEdge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> Edges;<br>    &#125;<br> <br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> Vers, Edges;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="图的存储">图的存储</h3><h4 id="邻接矩阵和加权邻接矩阵">邻接矩阵和加权邻接矩阵</h4><h5 id="有向图的邻接矩阵">有向图的邻接矩阵</h5><p>设有向图有 <span class="math inline">\(n\)</span> 个顶点，则用一个<span class="math inline">\(n \times n\)</span> 的布尔矩阵 <spanclass="math inline">\(A\)</span> 来表示该有向图</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png"alt="有向图的邻接矩阵" /><figcaption aria-hidden="true">有向图的邻接矩阵</figcaption></figure><ul><li>分别使用 <span class="math inline">\(0,1,2,\ldots,n-1\)</span> 表示顶点 <spanclass="math inline">\(V_0,V_1,\ldots,V_{n-1}\)</span>，如果存在一条从<span class="math inline">\(V_i\)</span> 到 <spanclass="math inline">\(V_j\)</span> 的边，则 <spanclass="math inline">\(A[i][j]=1\)</span>，否则 <spanclass="math inline">\(A[i][j]=0\)</span></li><li>出度：<span class="math inline">\(i\)</span> 行之和</li><li>入度：<span class="math inline">\(j\)</span> 列之和</li><li>真正的顶点数据字段之值放入一个一维数组之中</li></ul><h5 id="无向图的邻接矩阵">无向图的邻接矩阵</h5><p>设无向图有 <span class="math inline">\(n\)</span> 个顶点，则用一个<span class="math inline">\(n \times n\)</span> 的布尔矩阵 <spanclass="math inline">\(A\)</span> 来表示该无向图</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png"alt="无向图的邻接矩阵" /><figcaption aria-hidden="true">无向图的邻接矩阵</figcaption></figure><ul><li>分别使用 <span class="math inline">\(0,1,2,\ldots,n-1\)</span> 表示顶点 <spanclass="math inline">\(V_0,V_1,\ldots,V_{n-1}\)</span>，如果存在一条从<span class="math inline">\(V_i\)</span> 到 <spanclass="math inline">\(V_j\)</span> 的边，则 <spanclass="math inline">\(A[i][j]=A[j][i]=1\)</span>，否则 <spanclass="math inline">\(A[i][j]=A[j][i]=0\)</span></li><li>顶点 <span class="math inline">\(i\)</span> 的度：第 <spanclass="math inline">\(i\)</span> 行或第 <spanclass="math inline">\(i\)</span> 列之和</li><li>无向图的邻接矩阵是一个三角对称矩阵</li></ul><h5 id="邻接矩阵的特点">邻接矩阵的特点</h5><ul><li>优点：判断任意两点之间是否有边方便，仅耗费 <spanclass="math inline">\(O(1)\)</span> 时间</li><li>缺点：即使 <span class="math inline">\(\ll n_2\)</span>条边，也需内存 <span class="math inline">\(n_2\)</span> 单元，太多;仅读入数据耗费 <span class="math inline">\(O(n_2)\)</span>时间，太长。而大多数的图的边数远远小于 <spanclass="math inline">\(n_2\)</span>。<strong>适合稠密网</strong></li><li>不适合增减顶点</li></ul><h4 id="邻接表">邻接表</h4><ul><li><p>设有向图或者无向图由 <span class="math inline">\(n\)</span>个顶点，则用<strong>顶点表</strong>和<strong>边表</strong>来表示该有向图或无向图</p></li><li><p><strong>顶点表：</strong> 用数组或单链表的形式存放所有的顶点</p><ul><li>如果顶点数 <span class="math inline">\(n\)</span>已知，则采用数组</li><li>如果顶点数未知，则采用单链表</li><li>每个元素包含两个部分<ul><li>顶点值</li><li>指向该顶点对应的边表的首地址</li></ul></li></ul></li><li><p><strong>边表：</strong> 每条边用一个节点进行表示</p><p>同一个顶点出发的所有的边形成它的边界点单链表</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png"alt="邻接表" /><figcaption aria-hidden="true">邻接表</figcaption></figure><h4 id="邻接表的特点">邻接表的特点</h4><ul><li>邻接表是图的<strong>标准</strong>存储方式</li><li>优点<ul><li><span class="math inline">\(\text{内存} = \text{顶点数}+\text{边数}\)</span>，时间复杂度为 <spanclass="math inline">\(O\left(\vert V\vert +\vert E\vert\right)\)</span>，<strong>适合稀疏网</strong></li></ul></li><li>当谈及图的线性算法时，一般指的是 <spanclass="math inline">\(O\left(\vert V\vert +\vert E\vert\right)\)</span></li><li>缺点<ul><li>确定 <span class="math inline">\(i\rightarrow j\)</span>是否有边，最坏需耗费 <span class="math inline">\(O(n)\)</span> 时间</li><li>无向图同一条边表示两次。边表空间浪费一倍</li><li>有向图中寻找进入某结点的边，非常困难（逆邻接表）</li></ul></li></ul><h3 id="图的遍历">图的遍历</h3><p>按照某种次序系统地访问图中的所有顶点，并且使得<strong>每个顶点需且只能被访问一次</strong></p><p>需对访问过的顶点加以<strong>标记</strong></p><h4 id="深度优先搜索">深度优先搜索</h4><ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li></ol><p>出现了问题</p><h5 id="存在的问题">存在的问题</h5><p><span id="DFSdamn">如果图不是连通或强连通，在进行 DFS时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span></p><h5 id="深度优先生成森林">深度优先生成森林</h5><p>在<ahref="##图###图的遍历####深度优先搜索#####存在的问题">这种情况</a>下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止</p><p>此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成<strong>森林</strong></p><p>所以将深度优先搜索的流程改为</p><ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li><li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li><li>所有的顶点都被访问到，则结束</li></ol><h5 id="深度优先搜索的实现">深度优先搜索的实现</h5><ul><li>公有的 <code>dfs</code> 函数的伪代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  visited [v] =<span class="hljs-literal">false</span>; <span class="hljs-comment">//对每个节点标记为未访问</span><br><br>  <span class="hljs-keyword">while</span>(v=尚未访问的节点)<br>  &#123;<br>    <span class="hljs-built_in">dfs</span>(v,visited);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有的 <code>dfs</code> 函数的伪代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(v,visited)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">visited</span>(v)=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> 每个 v 的邻接点 w<br>  &#123;<br>    <span class="hljs-keyword">if</span>(!visited[w])<br>    &#123;<br>      <span class="hljs-built_in">dfs</span>(w,visited);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="广度优先搜索">广度优先搜索</h4><ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次访问已访问顶点的未被访问过的第 <spanclass="math inline">\(1\)</span> 个、第 <spanclass="math inline">\(2\)</span> 个、第 <spanclass="math inline">\(3\)</span> 个、<spanclass="math inline">\(\ldots\)</span> 、第 <spanclass="math inline">\(m\)</span> 个邻接顶点 <spanclass="math inline">\(W_1,W_2,W_3,\ldots,W_m\)</span>，进行访问且进行标记，转向 3</li><li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li><li>所有的顶点都被访问到，则结束</li></ol><p>按照顶点序号小的先访问，大的后访问的原则以<strong>队列</strong>的形式实现</p><p>同样能够生成广度优先生成森林</p><h5 id="广度优先搜索的实现">广度优先搜索的实现</h5><ol type="1"><li>将序号最小的顶点放入队列</li><li>重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问<ul><li>如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队</li></ul></li><li>检查是否还有顶点未被访问。如果有，重复上述两个步骤</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class="hljs-built_in">bfs</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">bool</span> *visited = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[Vers];<br>  <span class="hljs-type">int</span> currentNode;<br>  linkQueue&lt;<span class="hljs-type">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>   visited[i] = <span class="hljs-literal">false</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;当前图的广度优先遍历序列为：&quot;</span>&lt;&lt; endl;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-comment">//连续访问队列的队头，将其拉出，若其后继非空则拉入队列</span><br>    &#123;<br>      currentNode = q.<span class="hljs-built_in">deQueue</span>();<br>      <span class="hljs-keyword">if</span> (visited[currentNode] == <span class="hljs-literal">true</span>)<br>      &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      cout &lt;&lt; verList[currentNode].ver &lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span>;<br>      visited[currentNode] = <span class="hljs-literal">true</span>;<br>      p = verList[currentNode].head;<br>      <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (visited[p-&gt;end] == <span class="hljs-literal">false</span>)<br>        q.<span class="hljs-built_in">enQueue</span>(p-&gt;end);<br>        p = p-&gt;next;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图遍历的应用">图遍历的应用</h3><h4 id="无向图的连通性-1">无向图的连通性</h4><ul><li>如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先<strong>生成树</strong></li><li>如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先<strong>生成森林</strong>。每棵树就是一个<strong>连通分量</strong>。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量</li><li>在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量</li></ul><h4 id="有向图的连通性-1">有向图的连通性</h4><ul><li>对有向图，深度优先搜索可以<strong>测试是否强连通</strong>，并<strong>找出所有强连通分量</strong><ol type="1"><li>从任意顶点开始<strong>深度优先遍历</strong> <spanclass="math inline">\(G\)</span></li><li>对森林中的每棵树进行<strong>后序遍历</strong>，并按遍历的顺序给每个顶点编号</li><li>将 <span class="math inline">\(G\)</span> 的每条边逆向，形成 <spanclass="math inline">\(G_r\)</span></li><li>从编号<strong>最大</strong>的顶点开始<strong>深度优先遍历 <spanclass="math inline">\(G_r\)</span></strong>。得到的深度优先遍历森林的每棵树就是<span class="math inline">\(G\)</span> 的强连通分量</li></ol></li></ul><h4 id="欧拉回路">欧拉回路</h4><ul><li>哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径</li></ul><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png"alt="哥尼斯堡七桥问题" /><figcaption aria-hidden="true">哥尼斯堡七桥问题</figcaption></figure><h5 id="欧拉的证明">欧拉的证明</h5><ul><li>如果都是偶数桥，从任意地方出发都能回到原点<strong>（欧拉回路）</strong></li><li>如果都是偶数桥，从任意地方出发都能回到原点<strong>（欧拉路径）</strong></li><li>如果有奇数桥的地方不止两个，满足要求的路径是找不到的</li></ul><h5 id="查找欧拉回路的基本想法">查找欧拉回路的基本想法</h5><ul><li>执行一次<strong>不允许回溯</strong>的 <code>DFS</code>，也被称为一笔画问题</li><li>但是很多搜索都是不符合的</li></ul><h5 id="解决方法">解决方法</h5><p>找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问</p><figure><imgsrc="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png"alt="欧拉回路解决方法" /><figcaption aria-hidden="true">欧拉回路解决方法</figcaption></figure><h4 id="拓扑排序">拓扑排序</h4><p>设 <span class="math inline">\(G=(V,E)\)</span> 是一个具有 <spanclass="math inline">\(n\)</span> 个顶点的<strong>有向无环图</strong></p><p>若 <span class="math inline">\(V\)</span> 中的顶点序列 <spanclass="math inline">\(V_1,V_2,\ldots ,V_n\)</span> 满足下列条件</p><ul><li>在 <span class="math inline">\(G\)</span> 中，从 <spanclass="math inline">\(V_i\)</span> 到 <spanclass="math inline">\(V_j\)</span> 有一条路径</li><li>在序列中 <span class="math inline">\(V_i\)</span> 在 <spanclass="math inline">\(V_j\)</span> 之前</li></ul><p>则称 <span class="math inline">\(V_1,V_2,\ldots ,V_n\)</span> 是<span class="math inline">\(G\)</span>的一个<strong>拓扑排序</strong></p><p>拓扑排序将图转换为线性序，相对前去后继关系不变</p><h5 id="顶点活动网络activu-on-vertex-network">顶点活动网络（Activu onvertex network）</h5><ul><li>顶点表示各项子任务</li><li>有向边表示具有先决条件关系</li><li>仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施</li></ul><p><strong>AOV</strong>的特点</p><ol type="1"><li>有起始顶点</li><li>无回路</li></ol><h5 id="找出拓扑排序的过程">找出拓扑排序的过程</h5><ul><li>第一个输出的顶点必须无前驱，即入度为 <spanclass="math inline">\(0\)</span></li><li>无前驱以及后继的顶点在任何时候都可以输出</li><li>逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度<span class="math inline">\(-1\)</span></li></ul><h5 id="拓扑排序的实现">拓扑排序的实现</h5><ul><li>计算每个顶点的入度，保存在数组 <code>inDegree</code> 中</li><li>检查 <code>inDegree</code> 中的每个元素，将入度为 <spanclass="math inline">\(0\)</span> 的顶点入队</li><li>不断从队列中将入度为 <span class="math inline">\(0\)</span>的顶点入队，输出此顶点，并将该顶点的入度 <spanclass="math inline">\(-1\)</span>，如果某个邻接点的入度为 <spanclass="math inline">\(0\)</span>，则将其入队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class="hljs-built_in">topSort</span>() <span class="hljs-type">const</span><br>&#123;<br>  linkQueue&lt;<span class="hljs-type">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class="hljs-type">int</span> current, *inDegree = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[Vers];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    inDegree[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (p = verList[i].head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next)<br>    &#123;<br>    ++inDegree[p-&gt;end];<br>    &#125;<br>  &#125;                                                                 <span class="hljs-comment">//计算入度</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)   <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">enQueue</span>(i);  <span class="hljs-comment">//入度0节点入队</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;拓扑排序为：&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = q.<span class="hljs-built_in">deQueue</span>( );<br>    cout &lt;&lt; verList[current].ver &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (p = verList[current].head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next)<br>    <span class="hljs-keyword">if</span>( --inDegree[p-&gt;end] == <span class="hljs-number">0</span> )    q.<span class="hljs-built_in">enQueue</span>( p-&gt;end );<br>  &#125;                                                                 <span class="hljs-comment">//出队，删除关联的边</span><br>  cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><ul><li>若图以邻接表表示</li><li>计算入度的时间复杂度为 <span class="math inline">\(O(\vert V\vert+\vert E\vert)\)</span>，搜索入度为 <spanclass="math inline">\(0\)</span> 的顶点的时间复杂度为 <spanclass="math inline">\(O(\vertV\vert)\)</span>，出队和删除边的时间复杂度为 <spanclass="math inline">\(O(\vert E\vert)\)</span>，总执行时间为 <spanclass="math inline">\(O(\vert V\vert +\vert E\vert)\)</span></li></ul><h4 id="关键路径">关键路径</h4><h5 id="边活动网络activity-on-edge">边活动网络（Activity on Edge）</h5><ul><li><strong>AOE 网络：</strong> 加权有向无环图<ul><li>顶点表示事件，边表示活动</li><li>有向边的权值表示活动的持续时间</li><li>有向边的方向表示事件发生的先后次序</li><li>顶点的进入表示事件发生后允许开始的活动</li><li>有一个源点、一个终点</li></ul></li></ul><h5 id="关键路径的定义">关键路径的定义</h5><p>AOE网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序</p><p>再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动</p>]]></content>
    
    
    <categories>
      
      <category>本科课程</category>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 每日一题</title>
    <link href="/2023/10/31/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2023/10/31/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-每日一题">LeetCode 每日一题</h1><h2 id="section">2025-10-31</h2><p><ahref="https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/">3289.数字小镇中的捣蛋鬼</a></p><h3 id="问题描述">问题描述</h3><p>在数字小镇 <strong>Digitville</strong> 中，存在一个数字列表<code>nums</code>，其中包含从 <code>0</code> 到 <code>n - 1</code>的整数。每个数字本应<strong>只出现一次</strong>，然而，有<strong>两个</strong>顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。</p><p>为了恢复 <strong>Digitville</strong>的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。</p><p>返回一个长度为 2 的数组，包含这两个数字（顺序任意）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getSneakyNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (count[num] == <span class="hljs-number">0</span>) &#123;<br>                count[num]++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result.<span class="hljs-built_in">push_back</span>(num);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>编程</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
