<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vim 笔记</title>
    <link href="/2025/09/19/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/vim%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/09/19/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/vim%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>In this note, I use neovim as the example.</p><h2 id="basic-commands">basic commands</h2><p>In terminal, type <code>nvim</code> to open neovim.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvim<br></code></pre></td></tr></table></figure><p>to create a new file, type <code>nvim filename</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvim test.txt<br></code></pre></td></tr></table></figure><p>After opening the file, we are in the editor.</p><h3 id="modes">modes</h3><p>there are three modles in Vim:</p><ol type="1"><li>normal mode: for navigation and manipulation</li><li>insert mode: for inserting text</li><li>command mode: for executing commands</li></ol><p>usually we start in normal mode.</p><h4 id="normal-mode">normal mode</h4><p>we can go through and use commends in normal mode</p><p>In normal mode, we can use keys to move the cursor</p><ul><li><kbd>h</kbd>: move left</li><li><kbd>j</kbd>: move down</li><li><kbd>k</kbd>: move up</li><li><kbd>l</kbd>: move right</li></ul><h4 id="insert-mode">insert mode</h4><p>We can edit text in insert mode.</p><p>there are several ways to enter insert mode</p><ul><li><kbd>i</kbd>: insert</li><li><kbd>a</kbd>: append</li><li><kbd>o</kbd>: open a new line below</li><li><kbd>I</kbd>: insert before the line</li><li><kbd>A</kbd>: append at the end of the line</li><li><kbd>O</kbd>: open a new line above</li></ul><p>and use <kbd>Esc</kbd> to exit insert mode and return to normal mode</p>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Vim</tag>
      
      <tag>编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HPC 宣讲会</title>
    <link href="/2025/09/19/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/HPC%E5%AE%A3%E8%AE%B2%E4%BC%9A/"/>
    <url>/2025/09/19/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/HPC%E5%AE%A3%E8%AE%B2%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="比赛介绍">比赛介绍</h2><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509191907741.png" alt="时间节点" /><figcaption aria-hidden="true">时间节点</figcaption></figure><p>辅助工具</p><ol type="1"><li><code>submit.py</code> 一键生成提交文件</li><li><code>evaluate.py</code> 自主评测脚本</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>高速计算</tag>
      
      <tag>HPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义基本原理</title>
    <link href="/2025/09/19/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E9%A9%AC%E5%8E%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/09/19/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E9%A9%AC%E5%8E%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>公共课程</category>
      
      <category>马克思主义基本原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>马原</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能导论</title>
    <link href="/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    <url>/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>专业课程</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路理论</title>
    <link href="/2025/09/18/%E6%9C%AC%E7%A7%91/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/"/>
    <url>/2025/09/18/%E6%9C%AC%E7%A7%91/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E7%94%B5%E8%B7%AF%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念和基本规律">基本概念和基本规律</h2><h3 id="电路和电路模型">电路和电路模型</h3><h4 id="实际电路与电路模型">实际电路与电路模型</h4><p>电路：由电的器件相互联接所构成的电流的通路复杂的电路又称<strong>网络</strong></p><ul><li>实际电路在数学上难以精确描述</li><li>在电路理论中通过对实际电路进行建模来研究，称为<strong>电路（模型）</strong></li></ul><h5 id="实际电路的符号表示">实际电路的符号表示</h5><p>在电路理论中将电阻器、电容器、灯泡、晶体管、变压器等实际器件用理想的模型符号表示</p><p><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509161514892.png" /></p><h5 id="电路模型图">电路模型图</h5><p>将实际电路中各个部件用其模型符号表示而画出的图形，也简称为电路</p><h4 id="集中参数电路">集中参数电路</h4><p>集中参数元件：当实际电路的尺寸远小于其使用时电磁量的最高工作频率所对应的波长时，可以不必考虑电磁量的空间分布，相应的电路元件称为<strong>集中参数元件</strong></p><p>集中参数电路：由集中参数元件组成的电路集中参数电路可以看成电磁空间的一个点，电路变量是时间的函数</p><p>分布参数电路：电路变量是时间、空间的函数</p><p>我们在分析分布参数电路时，可以将其拆分为多个集中参数电路来分析</p><h5 id="满足集中化条件的电路的性质">满足集中化条件的电路的性质</h5><ol type="1"><li><span class="math inline">\(\forall t\)</span>，流入二端集中参数元件任一端的电流等于从另一端流出的电流，且该元件两个端点上的电位均为确定值（对选定的基准点或称参考点而言）</li><li><span class="math inline">\(\forall t\)</span>，流入多端集中参数元件任一端点的电流等于从其他端点流出电流之和，且其任一端点上的电位均为确定值（对选定的基准点而言）</li></ol><h3 id="电路变量">电路变量</h3><p>电路分析中最常用的电路变量为电流、电压及功率</p><h4 id="电流及其参考方向">电流及其参考方向</h4><h5 id="电流">电流</h5><p>电流即电流强度</p><p><span class="math display">\[i(t)=\frac{\mathrm{d}q}{\mathrm{d}t}\]</span></p><p>直流：若 <span class="math inline">\(i(t)\)</span> 恒为常数，称为恒定（直流）电流，常用 <span class="math inline">\(I\)</span> 表示</p><ul><li>广义的直流指的是单向流动的电流</li></ul><p>单位：安培 <span class="math inline">\(A\)</span>，<span class="math inline">\(1A = 1C/s\)</span></p><h5 id="电流参考方向">电流参考方向</h5><p>实际方向：正电荷运动的方向</p><p>参考方向：假定为正电荷运动的方向</p><p>我们规定：若两者方向一致，电流为正，反之电流为负</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509181637685.png" alt="正电流" /><figcaption aria-hidden="true">正电流</figcaption></figure><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509181637170.png" alt="负电流" /><figcaption aria-hidden="true">负电流</figcaption></figure><h4 id="电压及其参考方向">电压及其参考方向</h4><p>电压是电路之中两点的电位差，用 <span class="math inline">\(u\)</span> 表示</p><p><span class="math display">\[u(t)=\frac{\mathrm{d}w}{\mathrm{q}}\]</span></p><p>单位为伏特 <span class="math inline">\(V\)</span>，<span class="math inline">\(1V=1J/C\)</span></p><p>电压的实际方向为电位实际降低的方向 电压的参考方向为电位假定降低的方向</p><p>关联参考方向：电流的流向是从电压的“+”极流向 “-” 极为关联参考方向</p><h4 id="功率和能量">功率和能量</h4><p>定义：电场力做功的速率，取关联参考方向，一段支路吸收的功率为</p><p><span class="math display">\[p = \frac{\mathrm{d}w}{\mathrm{d}t}=\frac{\mathrm{d}w}{\mathrm{d}q}\cdot \frac{\mathrm{d}q}{\mathrm{d}t}=u\cdot i\]</span></p><p>非关联参考方向时</p><p><span class="math display">\[p = -u\cdot i\]</span></p><p>功率是标量</p><ul><li><span class="math inline">\(p&gt;0\)</span>，支路吸收功率</li><li><span class="math inline">\(p&lt;0\)</span>，支路输出功率</li></ul><p>这里的吸收和输出是相对于电路中的正电荷而言的</p><h3 id="拓扑约束关系">拓扑约束关系</h3><h4 id="图论基础知识">图论基础知识</h4><h5 id="图">图</h5><ul><li>一组节点和一组支路的集合，且每条支路的两端终止在两个节点上网络图通常用符号 G 记之</li><li>画图：将网络转化为图时，将支路用线段表示，支路间的连接用点表示</li></ul><h6 id="连通图">连通图</h6><p>在图 G 中的任意两节点之间至少存在一条由支路构成的路径，则称该图为连通图，否则为非连通图</p><h6 id="有向图">有向图</h6><p>图中的每一条支路规定一个方向所得到的图</p><h6 id="子图">子图</h6><p>设有一图 <span class="math inline">\(G\)</span>，又有一图 <span class="math inline">\(G_i\)</span>，其每个节点都是 <span class="math inline">\(G\)</span> 中的节点，每条支路是 <span class="math inline">\(G\)</span> 中的支路，则称 <span class="math inline">\(G_i\)</span> 是 <span class="math inline">\(G\)</span> 的子图</p><h6 id="回路">回路</h6><p>回路是一条闭合的路经图 <span class="math inline">\(G\)</span> 的子图 <span class="math inline">\(G_1\)</span> 是回路，则有</p><ol type="1"><li><span class="math inline">\(G_1\)</span> 是联通的</li><li><span class="math inline">\(G_1\)</span> 中与每个节点关联的支路数都是 <span class="math inline">\(2\)</span></li></ol><h6 id="网孔">网孔</h6><p>网孔是图中不包含其他回路的最小回路</p><h6 id="树">树</h6><p>树是图的一个子图，满足</p><ol type="1"><li>包含图中所有节点</li><li>是联通的</li><li>不包含回路</li></ol><p>构成树的各支路称为树支，数量为 <span class="math inline">\(N-1\)</span>，其中 <span class="math inline">\(N\)</span> 为图中节点数</p><p>其余的支路为连支</p><p>连支的集合为余树或者补树</p><h6 id="基本回路">基本回路</h6><p>在图 <span class="math inline">\(G\)</span> 中，任选一棵树 <span class="math inline">\(T\)</span>，则每一条连枝与树 <span class="math inline">\(T\)</span> 中的某些树支一起构成一个回路，这个回路称为<strong>基本回路</strong></p><p>基本回路数 <span class="math inline">\(=b-n+1\)</span>，其中 <span class="math inline">\(b\)</span> 为图中支路数，<span class="math inline">\(n\)</span> 为图中节点数</p><h6 id="平面图">平面图</h6><p><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509182234452.png" /></p><p>设一图 <span class="math inline">\(G\)</span>，若将其花在平面上，且各支路仅在节点处相交，则称该图为平面图</p><details closed><summary>看看 Gemimi 给出的解释？</summary><p><strong>生成树的概念</strong></p><p>我们将图想象为一个地图，地图上有多个村庄（节点）</p><p>现在，想象一下你要为这张城市地图规划一个紧急电话网络，你需要用最少的电话线连接所有的城市，并且不能形成任何的闭合环路（否则会造成信号干扰）这个只包含必要线路、连接了所有城市且没有环路的网络，就是这张图的一棵“生成树”</p><p><strong>什么是基本回路？</strong></p><p>理解了生成树之后，基本回路就很容易明白了</p><ol><li><strong>选择一棵生成树</strong>： 对于一个图，我们先选定一棵生成树。这棵树连接了所有的顶点，但自身没有任何环路</li><li><strong>添加“冗余”的边</strong>： 图中除了生成树包含的边之外，通常还会有一些其他的“冗余”边</li><li><strong>形成唯一的环路</strong>： 当你从这些“冗余”边中任意选择一条，并把它添加回生成树中时，必然会形成一个且仅有一个闭合的环路</li></details><h6 id="割集和基本割集">割集和基本割集</h6><p><a href="https://www.cnblogs.com/orzlsw/p/18561798">相关资料</a></p><p>连通图 <span class="math inline">\(G\)</span> 的割集是一组不包括节点的支路集合，其满足</p><ol type="1"><li>若移去该集的所有支路，则 G 成为两个独立的部分</li><li>若保留其中任一支路不去掉，剩下的图仍是连通的</li></ol><p>基本割集：</p><ul><li>对于任意连通图 <span class="math inline">\(G\)</span>，选定一个树，将仅包含一条树支的割集称为基本割集</li><li>基本割集数为 <span class="math inline">\(𝑛−1\)</span></li></ul><details><summary>看看 Gemimi 给出的解释？</summary><p><strong>什么是割集？</strong></p><p>想象一下，为了进行道路维护，你需要临时封闭一些道路，目的是把一个由村庄和道路组成的网络<b>分割成两个独立的区域</b>，让这两个区域的村民暂时无法互相往来</p><p><b>割集</b>就是能达到这个目的的一组道路这组道路需要满足两个条件：</p><ol><li><b>分割网络</b>：当你封闭了这组道路后，整个网络被分成了两个部分</li><li><b>最小性</b>：在这组封闭的道路里，任何一条道路重新开放，都会让这两个区域重新连接起来也就是说，你封闭的道路数量不多不少，恰好能完成分割任务</li></ol><p><b>通俗比喻：</b><br> 假设你要把村庄分成“山南”和“山北”两个区域所有直接连接山南和山北的道路集合，就是一个割集移走这个集合里的所有道路，两个区域就彻底分开了但只要有一条路没被移走，两个区域之间就还能通行</p><hr><p><strong>什么是基本割集？</strong><p>要理解基本割集，我们首先需要一个“骨干网络”的概念，在图论里，这叫做<b>“生成树” (Spanning Tree)</b></p><ul><li><b>生成树</b>：你可以把它想象成连接所有村庄的<b>最核心、<a title="这个似乎是最小生成树的概念？编者注">最经济</a></b>的道路网络这个网络能确保每个村庄都能到达其他任何村庄，但又<b>没有任何多余的环路</b>那些不属于这个骨干网络的道路，我们可以称之为“乡间小道”（在图论里叫<b>弦</b>）</li></ul><p>现在，<b>基本割集</b>就是一种特殊的割集，它是<b>围绕骨干网络的一条核心道路</b>来定义的它的构成如下：</p><ul><li>从你的“骨干网络”（生成树）里，<b>任选一条核心道路</b></li><li>这个基本割集就由这条<b>核心道路</b>和所有能够<b>“跨接”</b>这条核心道路被切断后所形成的两个区域的<b>“乡间小道”</b>（弦）组成</li></ul><p><b>通俗比喻：</b></p><ol><li>你先规划出一个连接所有村庄的骨干路网（生成树），确保没有环路</li><li>现在，你选择骨干路网中的<b>一条路</b>（比如连接村A和村B的主干道）进行封闭</li><li>这一下，村庄网络被分成了两部分（一部分包含村A，另一部分包含村B）</li><li>除了你刚才封闭的那条主干道，可能还有一些“乡间小道”也连接着这两部分</li><li>那么，<b>刚才那条主干道</b> + <b>所有连接这两部分的乡间小道</b>，就共同组成了一个“基本割集”</li></ol><p>这个基本割集的特点是，它<b>有且仅有一条来自骨干网络的道路</b></p><hr><strong>两者总结与区别</strong><table border="1" style="width:100%; border-collapse: collapse;"><thead><tr><th style="padding: 8px; text-align: left; background-color: #f2f2f2;">特性</th><th style="padding: 8px; text-align: left; background-color: #f2f2f2;">割集 (Cut Set)</th><th style="padding: 8px; text-align: left; background-color: #f2f2f2;">基本割集 (Fundamental Cut Set)</th></tr></thead><tbody><tr><td style="padding: 8px;"><b>定义</b></td><td style="padding: 8px;">任何能将网络分成两部分，且自身是最小的道路集合</td><td style="padding: 8px;">一种特殊的割集，它与一个预先定义的“骨干网络”（生成树）相关</td></tr><tr><td style="padding: 8px;"><b>核心</b></td><td style="padding: 8px;">重点在于“<b>分割</b>”这个行为本身</td><td style="padding: 8px;">重点在于“<b>基于一条骨干道路</b>”的分割</td></tr><tr><td style="padding: 8px;"><b>数量</b></td><td style="padding: 8px;">一个网络中可以有很多个不同的割集</td><td style="padding: 8px;">数量是确定的，等于你“骨干网络”里道路的数量每一条骨干道路都对应一个唯一的基本割集</td></tr></tbody></table><p>总而言之，<b>割集</b>是一个更宽泛的概念，就像是说“所有能把村庄分开的封路方案”，而<b>基本割集</b>是一系列更具体、更有规律的“封路方案”，这些方案都是围绕着一个核心的骨干路网来制定的</p></details><p>基本割集是单树枝割集，也就是说给定了树的前提下，任何一个基本割集的组成都为一条树支和若干连枝，将树分为互不连通的两部分；确定了删除的树支后所得到的割集是一定的</p><p>基本割集能够保证所取剩下的两块区域都是联通的</p><h4 id="基尔霍夫定律">基尔霍夫定律</h4><h5 id="基尔霍夫电流定律kcl">基尔霍夫电流定律（KCL）</h5><p>对于集总电路的任一节点，在任一时刻流入该节点的电流之和等于流出该节点的电流之和</p><p><span class="math display">\[\sum i(t)=0\]</span></p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电路</tag>
      
      <tag>电路理论</tag>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>能源化学</title>
    <link href="/2025/09/17/%E6%9C%AC%E7%A7%91/%E5%8C%96%E5%AD%A6/%E8%83%BD%E6%BA%90%E5%8C%96%E5%AD%A6/"/>
    <url>/2025/09/17/%E6%9C%AC%E7%A7%91/%E5%8C%96%E5%AD%A6/%E8%83%BD%E6%BA%90%E5%8C%96%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="能源结构化学">能源结构化学</h2><h3 id="原子的结构和排列">原子的结构和排列</h3><h4 id="原子半径与离子半径">原子半径与离子半径</h4><p>根据波动力学，电子在原子核周围运动，形成一个电磁场，作用范围大致可以看作是球形的</p><p>这个球的范围被认为是原子或者离子的体积，半径为原子半径或者离子半径，不同晶体的有效半径表述不同</p><ul><li>离子晶体：一堆相邻接触的阴、阳离子的中心距，即为阴阳离子半径之和</li><li>共价晶体：两个相邻键合原子的中心距，即为两个原子的共价半径之和</li><li>金属晶体：两个相邻原子中心距的一半，即为金属原子半径</li></ul><h4 id="球体紧密堆积原理">球体紧密堆积原理</h4><p>若晶体中的原子或离子的最外层电子构型为<strong>惰性气体构型</strong>或者** <span class="math inline">\(18\)</span> 电子构型**，则其电子云呈球形，无对成型</p><p>这样的质点在空间的堆积可以近似看作是刚性球体的堆积，服从紧密堆积原理</p><p>球体紧密堆积有两种方式</p><h5 id="六方最密堆积hexagonal-close-packedhcp">六方最密堆积（hexagonal close-packed，HCP）</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200101666.png" alt="六方最密堆积的前视图" /><figcaption aria-hidden="true">六方最密堆积的前视图</figcaption></figure><p>每个原子的配位数都是 <span class="math inline">\(12\)</span>，堆积密度为 <span class="math inline">\(0.74\)</span></p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200105373.png" alt="六方密堆积的晶胞" /><figcaption aria-hidden="true">六方密堆积的晶胞</figcaption></figure><p>每个晶胞的原子数目为 <span class="math inline">\(6\)</span> 个</p><h5 id="面心立方最密堆积face-centered-cubic-fcc">面心立方最密堆积（Face Centered Cubic, FCC）</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200114045.png" alt="面心立方最密堆积模型" /><figcaption aria-hidden="true">面心立方最密堆积模型</figcaption></figure><p>每个原子的配位数为 <span class="math inline">\(12\)</span>，堆积密度为 <span class="math inline">\(0.74\)</span></p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509221624577.png" alt="面心立方晶胞" /><figcaption aria-hidden="true">面心立方晶胞</figcaption></figure><p>每个晶胞的原子数目为 <span class="math inline">\(4\)</span> 个</p><p>空间利用率（Atomic Packing Factor, APF）为</p><p><span class="math display">\[\nabla = \frac{4\times\frac{4}{3}\pi r^3}{(2\sqrt{2}r)^3}\approx 0.74\]</span></p><h5 id="体心立方堆积body-centered-cubicbcc">体心立方堆积（Body Centered Cubic，BCC）</h5><p>立方体的中心原子与 <span class="math inline">\(8\)</span> 个顶点原子相切，但是顶点原子互相不相切</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509200117079.png" alt="体心立方堆积模型" /><figcaption aria-hidden="true">体心立方堆积模型</figcaption></figure><h4 id="配位数与配位多面体">配位数与配位多面体</h4><h4 id="鲍林规则">鲍林规则</h4><h3 id="晶体的点阵和晶胞">晶体的点阵和晶胞</h3><h3 id="晶体的基本类型和特征">晶体的基本类型和特征</h3>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>化学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>能源化学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动控制原理B笔记</title>
    <link href="/2025/09/15/%E6%9C%AC%E7%A7%91/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <url>/2025/09/15/%E6%9C%AC%E7%A7%91/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="导论">导论</h2><h3 id="概述">概述</h3><p>自动控制的意义</p><ul><li>提高了劳动生产率</li><li>提高控制的准确性</li><li>可用于某些人们不能直接参与工作的场合</li></ul><p>判断一个系统是否为自动控制系统的标准：控制过程脱离人的控制</p><p>但是，自动控制系统中仍然有人参与，并非脱离人的设置</p><h3 id="自动控制理论的发展">自动控制理论的发展</h3><h4 id="胚芽期1945-年以前">胚芽期（1945 年以前）</h4><ul><li>18 世纪以后，蒸汽机的使用提出了调速稳定等问题<ul><li>1765 年，俄国人波尔祖诺夫发明了锅炉水位调节器</li><li>1784 年，英国人瓦特发明了调速器，蒸汽机离心式调速器</li><li>1877 年，产生了古氏判据和劳斯稳定判据</li></ul></li><li>19 世纪前半叶，动力使用了发电机、电动机<ul><li>促进了水利、水电站的遥控和程控的发展以及电压、电流的自动调节技术的发展</li></ul></li><li>19 世纪末，20 世纪初，使用内燃机<ul><li>促进了飞机、汽车、船舶、机器制造业和石油工业的发展，产生了伺服控制和过程控制</li></ul></li><li>20 世纪初第二次世界大战，军事工业发展很快<ul><li>飞机、雷达、火炮上的伺服机构，总结了自动调节技术及反馈放大器技术，搭起了经典控制理论的架子，但还没有形成学科</li></ul></li></ul><h4 id="经典控制理论">经典控制理论</h4><ul><li>1945 年 美国人 Bold 网络分析与放大器的设计 奠定了控制理论的基础</li><li>50 年代 趋于成熟</li><li>研究对象 单输入、单输出系统</li><li>描述方法 传递函数</li><li>研究方法 频率法、根轨迹法</li><li>研究内容 系统稳定性的代数和几何判据以及校正网络等</li><li>举例<ul><li>调节电压改变电机的速度</li><li>调整方向盘改变汽车的运动轨迹</li></ul></li></ul><h4 id="现代控制理论">现代控制理论</h4><ul><li>空间技术的发展提出了许多复杂控制问题</li><li>用于导弹、人造卫星和宇宙飞船上</li><li>Kalmann 控制系统一般理论 奠定了现代控制理论的基础</li><li>研究对象<ul><li>线性、非线性、定常、时变系统</li><li>多输入、多输出</li></ul></li><li>描述方法<ul><li>向量空间（状态空间）</li></ul></li><li>研究方法<ul><li>状态空间法</li></ul></li></ul><h4 id="大系统理论">大系统理论</h4><ul><li>一种过程控制与信息处理相结合的动态系统工程理论</li><li>研究对象<ul><li>规模庞大、结构复杂、功能综合、目标多样、因素众多</li><li>多输入、多输出、多干扰、多变量的系统</li></ul></li><li>举例<ul><li>人体大系统</li><li>三峡水利枢纽</li></ul></li></ul><h4 id="智能控制理论">智能控制理论</h4><ul><li>研究对象 模糊性、不确定性、不完整性、偶然性的系统</li><li>基础 人工智能理论</li><li>指导思想 依据人的思维方式和处理问题的技巧，解决哪些目前需要人的只能才能解决的问题</li></ul><h3 id="自动控制系统的分类">自动控制系统的分类</h3><h4 id="信号的传递路径">信号的传递路径</h4><h5 id="开环系统">开环系统</h5><p>作用信号由输入到输出单方向传递，系统的输出端与输入端不存在反馈回路</p><p>优点：</p><ol type="1"><li>结构简单，成本低廉，不存在稳定性问题</li><li>当输入信号和扰动能预先知道时，控制效果较好</li></ol><p>缺点：</p><ol type="1"><li>不具备自动修正能力</li><li>系统的元件参数变化以及未来的未知扰动对控制精度影响较大</li></ol><h5 id="闭环系统">闭环系统</h5><p>输出信号通过测量元件反馈到系统的输入端，通过比较、控制来减小系统误差</p><p>优点：</p><ol type="1"><li>具有自动修正被控制量出现偏离的能力</li><li>可修正元件参数变化以及外界扰动引起的误差</li><li>控制精度高</li></ol><p>缺点：</p><ul><li>被控量可能出现振荡，甚至发散</li></ul><h4 id="输入量的特点">输入量的特点</h4><h5 id="恒值控制系统">恒值控制系统</h5><p>也叫自动调节系统、自动镇定系统</p><ul><li>输入 恒定数值</li><li>任务 系统在任何扰动作用下，输出量以一定精度接近给定值</li></ul><h5 id="过程控制系统">过程控制系统</h5><p>也叫程序控制系统</p><ul><li>输入 已知函数</li><li>任务 系统的控制过程按预定的程序进行，要求被控量能迅速准确地复现输入</li></ul><h5 id="随动系统">随动系统</h5><p>也叫伺服系统</p><ul><li>输入 未知函数</li><li>任务 控制系统的输出量<strong>跟随</strong>输入信号变化</li></ul><h4 id="信号传输的性质">信号传输的性质</h4><p>分为连续系统和离散系统</p><h4 id="元部件的特性">元部件的特性</h4><p>分为线性系统和非线性系统</p><h3 id="反馈控制系统的基本组成">反馈控制系统的基本组成</h3><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509152359458.png" alt="基本组成" /><figcaption aria-hidden="true">基本组成</figcaption></figure><p>主要有三个部分</p><ol type="1"><li>输入信号 系统控制目标的反映，是人的意志的体现</li><li>控制系统 主要完成对有关信号的变换，处理，发出控制量，驱动执行机构完成控制功能</li><li>输出信号 系统的控制结果，反映了被控对象的运行状况</li></ol><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509160009862.png" alt="反馈系统组成部分" /><figcaption aria-hidden="true">反馈系统组成部分</figcaption></figure><p>对于其系统来说，有这些部分</p><ul><li>测量元件 用来测量被控量的实际值</li><li>比较元件 用来产生输入信号和主反馈信号的差值信号</li><li>放大元件 把误差信号放大并进行能量形式转换</li><li>执行元件 根据控制信号直接对控制对象进行操纵</li><li>被控对象 控制系统所要操纵的对象</li></ul><h3 id="对控制系统的基本要求">对控制系统的基本要求</h3><ol type="1"><li>稳定性<ul><li>保证控制系统正常工作的先决条件<ul><li>输入激励会使系统偏离平衡状态</li><li>激励消失后，经过一段过程，系统的状态恢复到平衡状态</li></ul></li><li>线性控制系统的稳定性由系统本身的结构与参数所决定的，与外部条件和初始状态无关</li></ul></li><li>稳态特性<ul><li>过渡过程结束后，系统的误差值，反映了系统的控制精度</li></ul></li><li>动态特性<ul><li>过渡过程 系统状态随时间变化的过程</li><li>产生原因 系统中储能元件的能量不可能突变</li><li>基本要求 时间短、平稳、振荡幅度小</li></ul></li></ol><h3 id="常用的典型测试信号">常用的典型测试信号</h3><p>我们在分析和设计系统时，常常需要一个对各种系统进行比较的基准，但是实际系统的输入信号具有不确定性，其函数形式难以使用解析法表示，所以我们用一些简单的测试信号对齐进行测试</p><p>系统对典型测试信号的相应与实际输入的相应之间应存在一定的关系，实际信号往往是多种典型测试信号的组合，典型测试信号是简单的时间函数</p><h4 id="脉冲信号pulse">脉冲信号（Pulse）</h4><ol type="1"><li><p>宽度（持续时间）为 <span class="math inline">\(h\)</span> 的矩形脉冲信号</p><p><span class="math display">\[r(t)=\left\{    \begin{aligned}    &amp;\frac{1}{h},\quad 0 \leq t \leq h \\    &amp;0, \quad t&lt;0.t&gt;h  \end{aligned}\right.\]</span></p></li><li><p>单位冲激信号（单位脉冲信号），这是宽度趋于零的矩形脉冲信号</p><p><span class="math display">\[r(t)=\delta(t)=\left\{    \begin{aligned}    &amp;\infty, \quad t=0 \\    &amp;0, \quad t\neq 0    \end{aligned}\right.\]</span></p><p>其中</p><p><span class="math display">\[\int_{-\infty}^{\infty} \delta(t) \,\mathrm{d}t = 1\]</span></p><p>对单位冲激信号做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} \delta(t) e^{-s t} \,\mathrm{d}t=1\]</span></p></li></ol><h4 id="阶跃信号step">阶跃信号（Step）</h4><ol type="1"><li><p>标准阶跃信号</p><p><span class="math display">\[r(t)=R\cdot u(t)=\left\{    \begin{aligned}    &amp;R, \quad t \geq 0 \\    &amp;0, \quad t&lt;0    \end{aligned}\right.\]</span></p><p>其中 <span class="math inline">\(u(t)\)</span> 是单位阶跃信号，<span class="math inline">\(R\)</span> 是阶跃高度 这表明在 <span class="math inline">\(t=0\)</span> 时，阶跃信号从 0 突然跃变到 <span class="math inline">\(R\)</span>，并在 <span class="math inline">\(t&gt;0\)</span> 时保持不变</p></li><li><p>延时阶跃信号</p><p><span class="math display">\[ r(t)=R\cdot u(t-\tau)= \left\{     \begin{aligned}     &amp;R, \quad t \geq \tau \\     &amp;0, \quad t&lt;\tau     \end{aligned} \right.\]</span></p><p>其中 <span class="math inline">\(\tau\)</span> 是延时时间</p></li></ol><p>对阶跃信号做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} R\cdot u(t) e^{-s t} \,\mathrm{d}t=\frac{R}{s}\]</span></p><p>如果对单位阶跃信号做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} u(t) e^{-s t} \,\mathrm{d}t=\frac{1}{s}\]</span></p><h3 id="斜坡信号ramp">斜坡信号（Ramp）</h3><p>也被称为速度信号</p><p><span class="math display">\[r(t)=\left\{    \begin{aligned}    &amp;R\cdot t, \quad t \geq 0 \\    &amp;0, \quad t&lt;0    \end{aligned}\right.\]</span></p><p>对其做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} R\cdot t e^{-s t} \,\mathrm{d}t=\frac{R}{s^{2}}\]</span></p><h3 id="抛物线信号parabolic">抛物线信号（Parabolic）</h3><p>也称匀加速信号</p><p><span class="math display">\[r(t)=\left\{    \begin{aligned}    &amp;\frac{1}{2}R\cdot t^2, \quad t \geq 0 \\    &amp;0, \quad t&lt;0    \end{aligned}\right.\]</span></p><p>对其做 Laplace 变换，得到</p><p><span class="math display">\[R(s)=\int_{0}^{\infty} \frac{1}{2}R\cdot t^2 e^{-s t} \,\mathrm{d}t=\frac{R}{s^{3}}\]</span></p><h3 id="正弦信号">正弦信号</h3><p><span class="math display">\[r(t)=R\sin(\omega t+\varphi)\]</span></p><p>其中</p><ul><li><span class="math inline">\(R\)</span> 是振幅</li><li><span class="math inline">\(\omega\)</span> 是振荡角频率</li><li><span class="math inline">\(\varphi\)</span> 是相位移</li></ul><h3 id="谐波信号">谐波信号</h3><p><span class="math display">\[r(t)=R\cos(\omega t+\varphi)\]</span></p><h3 id="指数信号">指数信号</h3><p><span class="math display">\[r(t)=R e^{a t}\]</span></p><h2 id="控制系统的数学模型">控制系统的数学模型</h2><h2 id="控制系统的时域分析">控制系统的时域分析</h2><h2 id="控制系统的复域分析">控制系统的复域分析</h2><h2 id="控制系统的频域分析">控制系统的频域分析</h2><h2 id="控制系统的设计">控制系统的设计</h2>]]></content>
    
    
    <categories>
      
      <category>专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>自动控制原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2025/09/11/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/09/11/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>参考</p><ol type="1"><li><a href="https://mini-pi.github.io/2024/02/28/how-to-make-blog-wedsite/">2024 年，如何使用 github pages + Hexo + Next 搭建个人博客</a></li><li><a href="https://hexo.io/zh-cn/docs/">Hexo 文档</a></li><li><a href="https://teruteru.space/">teru 姐姐的笔记</a></li><li><a href="https://github.com/dcldyhb/dcldyhb.github.io">fluid 主题</a></li><li><a href="https://zhuanlan.zhihu.com/p/405554589">Hexo 中支持 Mathjax –知乎</a></li></ol><p>使用 Github pages+Hexo 进行搭建</p><h2 id="第一步github-仓库准备">第一步：github 仓库准备</h2><p>新建立一个 Repo，名字为你的名字+github.io</p><h2 id="第二步本地化部署-hexo-环境">第二步，本地化部署 Hexo 环境</h2><ol type="1"><li><p>安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>在 MacOS 上，可能会出现权限问题，使用修改 npm 全局安装目录的方式解决</p><ol type="1"><li><p>创建新的全局安装目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.npm-global<br></code></pre></td></tr></table></figure></li><li><p>配置 npm 使用新的目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&#x27;~/.npm-global&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>更新环境变量 打开 shell 配置文件，对于 zsh 是 <code>~/.zshrc</code>，对于 bash 是 <code>~/.bash_profile</code> 或 <code>~/.bashrc</code>，以用 vim 打开 <code>~/.zshrc</code> 为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>在文件末尾添加以下行，以将新的 npm 全局目录添加到环境变量 <code>PATH</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/.npm-global/bin&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>保存并应用配置 保存文件，然后运行以下命令以使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc <span class="hljs-comment"># 或 source ~/.bash_profile</span><br></code></pre></td></tr></table></figure></li><li><p>验证安装 通过下面的命令来检查 PATH 变量是否包含了你新添加的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>如果输出的内容里包含了 <code>/Users/yourname/.npm-global/bin</code> (或者 <code>$HOME/.npm-global/bin</code>)，就说明配置成功了。</p></li></ol></li><li><p>初始化 Hexo 框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li><li><p>进入 blog 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;你的blog文件夹名字&gt;<br></code></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure></li><li><p>运行 Hexo 本地服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure></li></ol><h2 id="发布">发布</h2><ol type="1"><li><p>安装部署插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>配置站点文件</p><p>在博客目录下的 <code>_config.yml</code> 文件中，找到 <code>deploy</code> 部分，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;your_username&gt;/&lt;your_username&gt;.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>找到 <code>url</code> 部分，修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://&lt;your_username&gt;.github.io</span><br></code></pre></td></tr></table></figure></li><li><p>发布博客</p><ol type="1"><li><p>清理和生成静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br></code></pre></td></tr></table></figure></li><li><p>发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure></li></ol></li></ol><p>这样之后博客就搭建好了，访问 <code>https://&lt;your_username&gt;.github.io</code> 就可以看到博客了</p><h2 id="配置主题">配置主题</h2><p>这里以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a> 主题为例（看了<a href="https://teruteru.space/">teru 姐姐的笔记</a>，这个主题真的很好看）</p><ol type="1"><li><p>进入 blog 文件夹</p></li><li><p>安装主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在在博客目录下创建  <code>_config.fluid.yml</code>，将主题的  <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。</p></li><li><p>修改博客的 <code>_config.yml</code>，将 <code>theme</code> 字段修改为 <code>fluid</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure></li></ol><p>接下来的步骤可以按照 <a href="https://hexo.fluid-dev.com/docs/guide">Hexo Fluid 用户手册</a> 进行配置</p><p>仅作个人记录</p><h3 id="全局配置">全局配置</h3><h4 id="博客标题">博客标题</h4><p>页面左上角的博客标题，默认使用<strong>站点配置</strong>中的 <code>title</code>，这个配置同时控制着网页在浏览器标签中的标题。</p><h4 id="几个常用的引擎用于替换-marked">几个常用的引擎（用于替换 marked）</h4><ol type="1"><li>hexo-renderer-kramed</li><li>hexo-renderer-syzoj-renderer</li><li>hexo-renderer-pandoc</li></ol><h3 id="文章相关">文章相关</h3><h4 id="latex-支持"><span class="math inline">\(LaTeX\)</span> 支持</h4><ol type="1"><li><p>设置主题配置 在主题配置 <code>_config.fluid.yml</code> 中有代码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时 提高加载速度</span><br>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when  the page does not contain math</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># Options: mathjax | katex</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><p>其中</p><ul><li><code>enable</code>：开启后，文章默认可用</li><li><code>specific</code>：开启后，只有在文章 Front-matter 里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</li><li><code>engine</code>：引擎，MathJax 或 KaTeX<ul><li>MathJax 支持更全面的 <span class="math inline">\(LaTeX\)</span> 语法，但渲染速度较慢</li><li>KaTeX 更为轻量，渲染速度快，但不支持所有 <span class="math inline">\(LaTeX\)</span> 语法</li></ul></li></ul></li><li><p>更换 Markdown 渲染器 Hexo 默认使用 hexo-renderer-marked 作为 Markdown 渲染器，但 marked 对 <span class="math inline">\(LaTeX\)</span> 的支持很烂，更换为其他渲染器</p><p>我们需要先卸载 marked</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br></code></pre></td></tr></table></figure><p>接下来我以更加全面的 MathJax 为例，安装 hexo-renderer-pandoc（不要忘了主题配置中选择引擎为 MathjJax）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></li><li><p>下载 pandoc</p><p>按照官网 <a href="https://pandoc.org/installing.html">Pandoc</a> 说的做就行了</p></li><li><p>配置 mathjax 和 pandoc 在站点配置中加入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">pandoc:</span><br>  <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;--mathjax&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>宏包支持 （我还不会）</p></li></ol><p>这样就可以使用 MathJax 来渲染 <span class="math inline">\(LaTeX\)</span> 公式了</p>]]></content>
    
    
    <categories>
      
      <category>Web 开发</category>
      
      <category>建站</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>教程</tag>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2025/08/12/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/Git%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/08/12/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E5%B7%A5%E5%85%B7/Git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>本文参照了 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的 Git 教程</a> 和 <a href="https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Git/">CS 自学指南</a> 的内容</p><p>（学了好多才发现最好用的是 <a href="https://desktop.github.com/">GitHub Desktop</a> …）</p><h2 id="git-的安装和简单的配置">Git 的安装和简单的配置</h2><h3 id="安装-git">安装 Git</h3><h4 id="windows-系统">Windows 系统</h4><p>在 Windows 系统上安装 Git 有两种方法：</p><ol type="1"><li><p>在 <a href="https://git-scm.com/">Git 官网</a> 上直接下载 <a href="https://git-scm.com/downloads/win">Git 安装包</a> 之后按照安装向导进行安装；</p></li><li><p>使用包管理器，</p><p>先下载一个包管理器，这里使用 <a href="https://scoop.sh/">scoop</a> 作为示例，这里参考了 <a href="https://csdiy.wiki/%E5%BF%85%E5%AD%A6%E5%B7%A5%E5%85%B7/Scoop/#scoop_1">CS 自学指南</a>.</p><p>打开 power shell，执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 设置 PowerShell 执行策略</span><br><span class="hljs-built_in">Set-ExecutionPolicy</span> <span class="hljs-literal">-ExecutionPolicy</span> RemoteSigned <span class="hljs-literal">-Scope</span> CurrentUser<br><span class="hljs-comment"># 下载安装脚本</span><br><span class="hljs-built_in">irm</span> get.scoop.sh <span class="hljs-literal">-outfile</span> <span class="hljs-string">&#x27;install.ps1&#x27;</span><br><span class="hljs-comment"># 执行安装, --ScoopDir 参数指定 Scoop 安装路径</span><br>.\install.ps1 <span class="hljs-literal">-ScoopDir</span> <span class="hljs-string">&#x27;C:\Scoop&#x27;</span><br></code></pre></td></tr></table></figure><p>然后继续输入以下指令安装 Git：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">coop install git<br></code></pre></td></tr></table></figure></li></ol><p>安装完成后可以在终端中输入以下指令查看 Git 版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git <span class="hljs-literal">-v</span><br></code></pre></td></tr></table></figure><h4 id="在-macos-上安装-git">在 macOS 上安装 Git</h4><p>在 macOS 上安装 Git 有两种方法：</p><ol type="1"><li><p>使用 <a href="https://brew.sh/">Homebrew</a> 包管理器，打开终端，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure></li><li><p>使用 XCode， 内置 了 Git 工具 运行 XCode，选择菜单 “Xcode” -&gt; “Preferences” -&gt; “Downloads”，然后选择一个 Command Line Tools 版本，系统会提示你安装命令行工具，点击 “Instal” 安装即可.</p></li></ol><hr /><p>使用包管理器安装 Git 是最简单的方式，推荐使用这种方式.</p><p>同时使用包管理器更新 Git 也非常方便.</p><ul><li><code>scoop update git</code> (Windows)</li><li><code>brew upgrade git</code> (macOS)</li></ul><h3 id="配置-git">配置 Git</h3><p>安装完成之后对 Git 进行一些基本的配置</p><p>在命令行中输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>Your Name</code> 替换为你的名字，<code>email@example.com</code> 替换为你的邮箱地址.</p><p><code>--global</code> 参数表明这台机器上的所有仓库都会使用这个配置，如果你想为某个特定的仓库设置不同的名字和邮箱，可以进入该仓库目录，去掉 <code>--global</code> 参数，重新执行上述命令即可.</p><p>配置完之后可以使用以下命令查看配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config -l<br></code></pre></td></tr></table></figure><h2 id="创建版本库">创建版本库</h2><p>版本库也叫做仓库(repository)，是用于存储文件的地方，里面每个文件的变动 Git 都能记录.</p><p><code>cd</code> 到你<strong>需要创建版本库的目录下</strong>，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 <code>.git</code> 的隐藏目录，里面存储了 Git 需要的所有信息.</p><p>若此时使用 <code>ls</code> 命令查看当前的目录,看不到任何新建的文件夹，因为 <code>.git</code> 是一个隐藏目录.</p><h3 id="向版本库中添加文件">向版本库中添加文件</h3><p>首先创建一个 <code>Readme.md</code> 文件,内容为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Git 学习</span><br><br>Git is a version control system.<br><br>Git is free software.<br></code></pre></td></tr></table></figure><p>这个文件一定要在刚才创建的版本库的目录或子目录下</p><ol type="1"><li><p>在终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add Readme.md<br></code></pre></td></tr></table></figure><p>这里输入的是路径而不是文件名，可以选择相对路径或者绝对路径.</p><p>如果没有输出任何内容，说明添加成功了.</p></li><li><p>提交这些文件到版本库中，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Add Readme.md&quot;</span><br></code></pre></td></tr></table></figure><p><code>-m</code> 参数后面跟的是提交信息，描述了这次提交的内容,有助于其他人或者未来的自己理解这次提交的目的.</p><p>一些工具可以使用 ai 生成提交信息,如 Github Desktop,这个也是十分好用的 Git 的图形化客户端.</p></li></ol><h2 id="版本管理">版本管理</h2><ul><li>使用 <code>git status</code> 命令可以查看当前版本库的状态，显示哪些文件被修改了，哪些文件被添加了，哪些文件还没有被提交等信息.</li><li>使用 <code>git diff</code> 命令可以查看文件的具体修改内容，显示哪些行被添加了，哪些行被删除了等信息.</li></ul><h3 id="版本回退">版本回退</h3><ul><li>使用 <code>git log</code> 命令可以查看版本库的提交历史，显示每次提交的哈希值，作者，日期，提交信息等信息.</li></ul><p>以这个笔记的版本库为例，显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">commit 493bb5004ef68c281f0fbf7f22e60e9111c94a86 (HEAD -&gt; main, origin/main, origin/HEAD)<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:41:08 2025 +0800<br><br>    Update .gitignore and workspace layout settings<br><br>    Added duplicate entries <span class="hljs-keyword">for</span> .obsidian and workspace.json <span class="hljs-keyword">in</span> .gitignore. Modified workspace.json to <span class="hljs-built_in">set</span> the left pane as collapsed by default.<br><br>commit d63e6e188c19e1f13fbf38ec735125e7c22d5484<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Thu Aug 21 15:39:11 2025 +0800<br><br>    updated Git notes<br><br>commit 172fb0bb0c001e1451eab09d8abb04814c755d0d<br>Author: dcldyhb &lt;1343605393@qq.com&gt;<br>Date:   Fri Aug 15 01:06:28 2025 +0800<br><br>    Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure><p>在 powee shell 中</p><ul><li>使用 <kbd>j</kbd> 和 <kbd>k</kbd> 键可以上下移动查看提交记录.</li><li>使用 <kbd>q</kbd> 键可以退出日志查看.</li></ul><p>该命令会从最近到最远显示提交的记录，在这里我列出了最近的三个提交记录.</p><p>最近的一次是 <code>UUpdate .gitignore and workspace layout settings</code>，上一次是 <code>update Git notes</code>，再上一次是 <code>Update .gitignore and workspace settings</code>.</p><p>加上 <code>--pretty=oneline</code> 参数可以让输出显示为一行，方便查看.</p><p>形如 <code>493bb5004ef68c281f0fbf7f22e60e9111c94a86</code> 的是每次提交的版本号，git 会为每次提交生成一个唯一的哈希值，这个哈希值可以用来标识这次提交.</p><p>git 使用 <code>HEAD</code> 来标识当前版本库的最新提交，这里是 <code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>，上一个版本是 <code>HEAD^</code>，也就是 <code>d63e6e188c19e1f13fbf38ec735125e7c22d5484</code>，再上一个版本是 <code>HEAD^^</code>，也就是 <code>172fb0bb0c001e1451eab09d8abb04814c755d0d</code>.</p><p>我们使用 <code>git reset</code> 命令来回退到上一个版本.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><p><code>--hard</code> 参数表明回到上个版本的已提交状态，<code>--soft</code> 参数表明回到上个版本的未提交状态，<code>--mixed</code> 参数表明回到上个版本的已暂存状态.</p><p>我们同样可以使用该命令返回更晚的版本，只要记得版本号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 493bb5004ef68c281f0fbf7f22e60e9111c94a86<br></code></pre></td></tr></table></figure><p>这里的版本号不需要是完整的哈希值，只需要前几位就可以了，Git 会自动匹配到唯一的版本.</p><p>git 的版本回退很快，因为 Git 内部有一个指向当前版本的 <code>HEAD</code> 指针，回退只需要修改这个指针的指向即可.</p><p>如果找不到可以使用 <code>git reflog</code> 命令查看所有的提交记录，包括已经被回退的版本.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">172fb0b HEAD@&#123;1&#125;: reset: moving to HEAD^^<br>493bb50 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;2&#125;: commit: Update .gitignore and workspace layout settings<br>d63e6e1 HEAD@&#123;3&#125;: commit: updated Git notes<br>172fb0b HEAD@&#123;4&#125;: commit: Update .gitignore and workspace settings<br></code></pre></td></tr></table></figure><p>这里发现 Update .gitignore and workspace layout settings 的版本号是 <code>493bb50</code>，可以使用 <code>git reset --hard 493bb50</code> 命令回到这个版本.</p><h3 id="工作区和暂存区">工作区和暂存区</h3><h4 id="名词解释">名词解释</h4><ul><li><strong>工作区（Working Directory）：</strong> 电脑中的目录</li><li><strong>版本库（Repository）：</strong> 工作区中的 <code>.git</code> 目录，默认为隐藏 存储有所有的版本信息，其中最重要的就是称为 <code>stage</code> （或 <code>index</code>）的暂存区，还有 Git 为我们自动创建的第一个分支 <code>master</code> 分支，以及指向当前分支的 <code>HEAD</code> 指针.</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>版本控制</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML笔记</title>
    <link href="/2025/07/15/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/HTML%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/07/15/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/%E7%BD%91%E9%A1%B5/HTML%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="元素">元素</h2><ol type="1"><li>开始标签 （Opening tag）：<code>&lt;p&gt;</code></li><li>结束标签 （Closing tag）：<code>&lt;/p&gt;</code></li><li>内容（Content）：元素的内容，可以是输入的文本本身</li><li>元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素<ul><li>元素可以有属性，包含的是不想在真正的内容中出现的和元素有关的额外信息，有值的属性应该包含<ol type="1"><li>属性与元素名称（或上一个属性，如果元素有超过一个属性的话）之间的一个空格。</li><li>属性名，后接一个等号</li><li>一对引号包围的属性值</li></ol></li></ul></li></ol><h3 id="嵌套元素">嵌套元素</h3><p>元素可以嵌套在其他元素中。嵌套的元素必须正确地嵌套在开始标签和结束标签之间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>My cat is <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> cute.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="空元素">空元素</h3><p>空元素没有内容，只有开始标签，没有结束标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/firefox-icon.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;My test image&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="案例分析">案例分析</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My test page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/firefox-icon.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;My test image&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;!DOCTYPE html&gt;</code>：文档类型声明，告诉浏览器这是一个 HTML5 文档，现在用于保证文档能够正常读取</li><li><code>&lt;html&gt;&lt;/html&gt;</code>：HTML 元素，包含了整个文档的内容，有时也被称为根元素</li><li><code>&lt;head&gt;&lt;/head&gt;</code>：head 元素，该元素作为想在 HTML 页面中包含但不想向用户显示的内容的容器。包括想在搜索结果中显示的关键字和页面描述、用于设置页面样式的 CSS、字符集声明等等。</li><li><code>&lt;meta charset="utf-8"&gt;</code>：该元素指明文档使用 UTF-8 字符编码，UTF-8 包括世界绝大多数书写语言的字符。它基本上可以处理任何文本内容。以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。</li><li><code>&lt;meta name="viewport" content="width=device-width"&gt;</code>：视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器以比视口更宽的宽度渲染内容，导致内容缩小。</li><li><code>&lt;title&gt;&lt;/title&gt;</code>：<title>元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</li><li><code>&lt;body&gt;&lt;/body&gt;</code>：<body>元素。该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web 开发</category>
      
      <category>前端基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Web</tag>
      
      <tag>笔记</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毛概</title>
    <link href="/2025/06/11/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/"/>
    <url>/2025/06/11/%E6%9C%AC%E7%A7%91/%E7%BA%A2%E8%AF%BE/%E6%AF%9B%E6%A6%82/%E6%AF%9B%E6%A6%82/</url>
    
    <content type="html"><![CDATA[<h2 id="毛概是什么马克思主义中国化时代化的历史进程和理论结果">毛概是什么：马克思主义中国化时代化的历史进程和理论结果</h2><ul><li>什么是马克思主义中国化时代化：<ul><li>运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题。</li><li>总结和提炼中国革命、建设、改革的实践经验并将其上升为理论，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵。</li><li>用中国人民喜闻乐见的民族语言来阐述马克思主义理论，使之成为具有中国特色，中国风格，中国气派的马克思主义</li></ul></li><li>1938 党的六届六中全会上，《论新阶段》的报告，标志着“马克思主义的中国化”这一命题的正式提出</li><li>中共七大，刘少奇从理论上做出阐述</li><li>内涵：马克思主义中国化时代化，就是立足<em>中国国情</em>和<em>时代特点</em>，坚持把马克思主义基本原理同中国<em>具体实际</em>相结合、同中华优秀<em>传统文化</em>相结合，深入研究和解决中国革命、建设、改革不同历史时期的实际问题，真正搞懂面临的时代课题，不断吸收新的时代内容，科学回答时代提出的重大理论和实践课题，创造新的理论成果。</li></ul><h2 id="马克思主义中国化的理论成果">马克思主义中国化的理论成果</h2><ul><li>毛泽东思想</li><li>中国特色社会主义理论体系</li></ul><h2 id="马克思主义中国化理论成果的精髓实事求是">马克思主义中国化理论成果的精髓：实事求是</h2><h2 id="理论">理论</h2><h3 id="新民主主义革命理论">新民主主义革命理论</h3><ul><li>认清中国国情是解决中国革命问题的<em>基本前提</em></li><li>认清中国社会的性质，乃是认清一切革命问题的<em>基本的根据</em></li></ul><h4 id="何以形成">何以形成</h4><ul><li>国情依据：近代中国是一个半殖民地半封建性质的社会<ul><li>帝国主义列强进行政治，经济，文化的侵略，中国长期处于帝国主义国家的统治或半统治之下，没有完整的主权与国家的统一</li><li>前述侵略使得自给自足的封建经济基础解体，但封建制度的根基：地主阶级对农民的剥削仍然存在，而且同买办资本和高利贷资本的剥削结合在了一起。</li><li>主要矛盾：<strong>帝国主义和中华民族的矛盾</strong>（主要），封建主义和人民大众的矛盾</li><li>根本任务：推翻帝国主义，封建主义和官僚资本主义的统治，争取民族独立和人民解放</li></ul></li><li>时代背景<ul><li>1917 年十月革命，建立了第一个无产阶级专政的政权</li><li>五四运动，中国无产阶级作为独立的政治力量成为革命的领导力量，马克思列宁主义逐步成为中国革命的指导思想，进入新民主主义革命阶段</li></ul></li><li>实践基础<ul><li>旧民主主义革命的失败<ul><li>旧式的农民战争</li><li>不触动封建根基的自强运动和改良主义</li><li>照搬西方资本主义的方案</li></ul></li><li>包含对上述失败教训的深刻总结</li></ul></li></ul><h4 id="基本内容">基本内容</h4><ul><li>提出<ul><li>1939《中国革命和中国共产党》，第一次提出“新民主主义的革命”的概念</li><li>1948《在晋绥干部会议上的讲话》完整总结和概括了新民主主义革命总路线的内容</li></ul></li><li>总路线：<strong>无产阶级领导的，人民大众的，反对帝国主义，封建主义和官僚资本主义的革命</strong><ul><li>无产阶级的领导权是中国革命的中心问题，也是新民主主义革命理论的核心问题，也是新民主主义革命区别于旧民主主义革命的根本标志<ul><li>与先进的生产方式相联系，没有私人占有的生产资料，富有组织纪律性</li><li>受“三座大山”的压迫</li><li>集中分布在少数大城市和大企业，利于组织团结</li><li>成员与农民间有天然的联系</li></ul></li><li>革命的对象：分清敌友，是革命的<em>首要问题</em><ul><li>帝国主义（中国革命的首要对象）<ul><li>近代中国贫困落后和一切灾难祸害的总根源</li><li>推翻帝国主义的压迫是中国走向独立和富强的前提</li></ul></li><li>封建主义<ul><li>帝国主义统治中国和封建军阀实行专制统治的社会基础，是中国经济现代化和政治民主化的主要障碍</li></ul></li><li>官僚资本主义<ul><li>对劳动人民 / 民族工商业的巧取豪夺，严重束缚了中国社会生产力的发展。</li></ul></li></ul></li><li>革命的任务<ul><li>民族革命：对外推翻帝国主义的压迫</li><li>民主革命：对内推翻封建地主阶级和官僚资产阶级的压迫</li><li>相互区别，相互联系</li></ul></li><li>革命的动力<ul><li>无产阶级：中国革命<em>最基本的动力</em>，中国革命的领导力量</li><li>农民：中国革命的主力军，农民问题是中国革命的<em>基本问题</em>，<strong>新民主主义革命实质上就是党领导下的农民革命，中国革命战争实质上就是党领导下的农民战争</strong></li><li>城市小资产阶级：无产阶级的可靠同盟者（广大知识分子，小商人，手工业者和自由职业者）</li><li>民族资产阶级：带有两面性的阶级，一方面受压迫，一方面政治经济上又有联系，表现出明显的动摇性</li></ul></li></ul></li><li>纲领（总路线的展开）<ul><li>政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的，以工农联盟为基础的，<em>各革命阶级联合专政</em>（国体）的新民主主义的共和国。（不同于欧美，也不同于苏联）<ul><li>革命的根本问题是政权问题</li><li>政体：民主集中制的人民代表大会制度</li></ul></li><li>经济纲领：“两没收，一保护”<ul><li>没收封建地主阶级的土地归农民所有（进行土地革命，耕者有其田，扫除封建的剥削关系，解放农村生产力）</li><li>没收官僚资本归新民主主义国家所有（建立具有社会主义性质的国营经济，使它居于领导地位，为建立新民主主义的国家政权实现向社会主义过渡奠定坚实的基础）</li><li>保护民族工商业（保护，推动民族资本主义经济的发展，使它在发展现代技术，发展社会生产力，满足人民生活需要方面发挥作用，但不能让它操纵国计民生）</li></ul></li><li>文化纲领<ul><li><strong>“民族的”</strong>：<ul><li>内容上：反对帝国主义压迫，主张中华民族的尊严和独立</li><li>形式上：具有鲜明的民族风格，民族形式和民族特色</li></ul></li><li><strong>“科学的”</strong>：<ul><li>反对封建迷信，主张实事求是，客观真理，理论和实践的一致性</li><li>历史唯物主义的态度对待古今中外文化，发展民族新文化，提高民族自信</li></ul></li><li><strong>“大众的”</strong>：<ul><li>文化工作者要用革命文化教育和武装人民大众</li><li>以人民群众的实践作为创作的源泉</li><li>为人民大众服务</li></ul></li></ul></li></ul></li><li>道路：<strong>农村包围城市，武装夺取政权</strong><ul><li>成功原因<ul><li>近代中国的社会性质，社会政治经济发展极端不平衡</li><li>广大农村深受反动统治阶级的多重压迫和剥削，革命愿望强烈</li><li>革命形势的变动</li><li>正式红军的存在</li><li>党的领导</li></ul></li><li>土地革命：是中国革命的基本内容</li><li>农村革命根据地建设：是中国革命的战略阵地，进行武装斗争和土地革命的依托</li><li>武装斗争：中国革命的主要形式，是上述两者的有力保证</li></ul></li><li>基本经验：三大法宝：统一战线，武装斗争，党的建设<ul><li>统一战线和武装斗争：针对敌人，是武器<ul><li>统一战线：采取区别对待的方针，发展进步势力，争取中间势力，孤立顽固势力</li></ul></li><li>党的建设：针对党自身，是掌握武器的人<ul><li>思想建设放在首位</li><li>三大优良作风：理论联系实际，密切联系群众，批评与自我批评相结合</li></ul></li></ul></li></ul><h4 id="意义">意义</h4><ul><li>理论：极大地丰富了马克思主义的理论宝库，是马克思主义中国化时代化的重要理论成果，是对中国革命实际问题做出的分析和研究，是中国共产党集体智慧的结晶</li><li>实践：在新民主主义革命理论的指导下，党团结带领人民完成了新民主主义革命，实现了民族独立和人民解放</li><li>世界：极大改变了世界的政治格局，鼓舞了全世界人民争取解放，反对帝国主义斗争的信心，增强了世界人民争取和平的力量</li></ul><h3 id="社会主义改造理论">社会主义改造理论</h3><h4 id="过渡的依据">过渡的依据</h4><ul><li>新民主主义社会是一个过渡性的社会<ul><li>中华人民共和国成立 <span class="math inline">\(\to\)</span> 社会主义改造基本完成是我国从新民主主义到社会主义的过渡时期，性质是新民主主义社会</li><li>不是独立的社会形态，而是过渡性社会形态，由经济结构和社会主要矛盾决定</li><li>经济结构<ul><li>社会主义性质的国营经济</li><li>半社会主义性质的合作社经济（个体 <span class="math inline">\(\to\)</span> 国营）</li><li>农民和手工业者的个体经济</li><li>私人资本主义经济</li><li>国家资本主义经济（私人 <span class="math inline">\(\to\)</span> 国营）</li></ul></li><li>阶级构成<ul><li>社会主义 <span class="math inline">\(\leftrightarrow\)</span> 工人阶级</li><li>个体经济 <span class="math inline">\(\leftrightarrow\)</span> 农民阶级和其他小资产阶级</li><li>资本主义经济 <span class="math inline">\(\leftrightarrow\)</span> 民族资产阶级</li></ul></li><li>主要矛盾<ul><li>社会主义 <span class="math inline">\(\leftrightarrow\)</span> 资本主义</li><li>工人阶级 <span class="math inline">\(\leftrightarrow\)</span> 资产阶级</li></ul></li></ul></li><li>理论依据<ul><li>马克思 / 恩格斯：科学社会主义理论<ul><li>无产阶级利用自己的政治统治一步一步夺取资产阶级的全部资本，把一切生产工具集中在国家也即成为统治阶级的无产阶级手里，并尽可能增加生产力的宗量</li></ul></li><li>中国共产党人的理论：党的七届二中全会</li></ul></li><li>现实依据<ul><li>经济：1949-1952，已经拥有了相对强大和迅速发展的社会主义国营经济，国家掌握了重要工矿企业，铁路，银行等国民经济的命脉，体现了国营经济相比其他成分的优越性。</li><li>政治：新中国是工人阶级领导的以工农联盟为基础的人民民主专政的国家，马克思主义在思想文化领域处于指导地位，中国共产党执政并得到人民群众的广泛拥护</li><li>国际形势：经过二战，资本主义国家也很不景气，尽管帝国主义国家对我国实施了军事上侵略威胁，经济上严密封锁，政治上孤立遏制等策略，但社会主义国家正充满向上发展的活力</li></ul></li></ul><h4 id="如何过渡">如何过渡</h4><ul><li>总路线与总任务（1953.6）<ul><li>在一个相当长的时间内，逐步实现国家的社会主义工业化，并初步实现国家对农业、手工业和资本主义工商业的社会主义改造。</li><li>实质：把生产资料的资本主义私有制改变成生产资料的社会主义公有制</li></ul></li><li>核心内容：“一化三改”<ul><li>社会主义工业化</li><li>对个体农业、手工业和资本主义工商业进行社会主义改造。<ul><li>对农业的社会主义改造首先进行<ul><li>积极领导，稳步前进的方针，循序渐进的步骤</li><li>互助组（社会主义萌芽） <span class="math inline">\(\to\)</span> 初级农业生产合作社（半社会主义性质） <span class="math inline">\(\to\)</span> 高级农业生产合作社（完全社会主义性质）<ul><li>互助组：解决生产上的困难，自愿基础上建立，分为临时与常年</li><li>初级农业生产合作社：在互助组的基础上自愿组织，以土地入股，其他生产资料作价入社，实施统一经营，进行集体劳动，以按劳分配和土地入股分红相结合</li><li>高级农业生产合作社：由初级社发展而成，规模更大，生产资料归集体所有，取消了土地报酬，实行按劳分配</li></ul></li></ul></li><li>手工业的社会主义改造<ul><li>积极领导，稳步前进</li><li>通过合作化道路，把个体手工业经济改造为社会主义的集体所有制<ul><li>个体手工业经济：建立在生产资料私有制和个体劳动基础上</li></ul></li><li>手工业供销小组（社会主义萌芽） <span class="math inline">\(\to\)</span> 供销合作社（半社会主义性质） <span class="math inline">\(\to\)</span> 生产合作社（社会主义性质）<ul><li>手工业供销小组：独立手工业者 / 家庭手工业者由国营商业 / 供销合作社供给原料和包销产品 / 推销成品，通过加工订货方式组织起来</li><li>手工业供销合作社：随着供销业务的逐步扩大，手工业供销小组发展为合作社。</li><li>手工业生产合作社：社会主义性质的集体经济组织，生产资料归集体所有，在计划指导下，根据市场需要灵活安排，集中 / 分散生产，流动服务，独立核算，自负盈亏。</li></ul></li><li>采取说服教育，典型示范和国家帮助的方法</li></ul></li><li>资本主义工商业的社会主义改造<ul><li>和平赎买：国家有偿将私营企业变为国营企业（让企业家在一定年限内从企业经营所得中获取一部分利润）</li><li>从低级到高级的过渡形式<ul><li>具有社会主义因素的企业，实行初级形式的国家资本主义</li><li>半社会主义性质的企业，实行个别企业的公私合营</li><li>社会主义国营性质的企业，实现全行业的公私合营</li></ul></li><li>采取“包下来”的政策，把资本主义工商业者改造为自食其力的社会主义劳动者</li></ul></li></ul></li></ul></li><li>历史经验<ul><li>坚持社会主义工业化建设和社会主义改造同时并举</li><li>采取积极引导和逐步过渡的方式</li><li>用和平方法进行改造</li></ul></li></ul><h4 id="意义-1">意义</h4><ul><li>社会主义基本经济制度确立的标志：1956 年底，三大改造完成</li><li>社会主义基本制度确立的表现<ul><li>经济：社会主义公有制成为经济基础<ul><li>数千年的阶级剥削制度结束，社会主义制度确立</li></ul></li><li>政治：1954 年《宪法》<ul><li>根本政治制度：人民代表大会制度</li><li>基本政治制度：中国共产党领导的多党合作和政治协商制度</li><li>标志着中国从新民主主义国家转变为社会主义国家</li></ul></li><li>社会关系<ul><li>工人阶级成为国家的领导阶级</li><li>亿万农民和其他个体劳动者成为社会主义的集体劳动者</li></ul></li></ul></li><li>重大意义<ul><li>中国历史上最深刻最伟大的变革<ul><li>广大农民真正成为国家的主人</li><li>奠定我国社会主义工业化的初步基础</li></ul></li><li>为当代中国一切发展奠定了制度基础，社会生产力的发展，初步显示了社会主义的优越性</li><li>世界社会主义发展史上一个历史性的伟大胜利</li><li>丰富和发展社会主义理论</li></ul></li><li>经验<ul><li>实现伟大复兴，必须建立符合我国实际的先进生产制度</li></ul></li></ul><h3 id="社会主义建设道路初步探索的理论成果">社会主义建设道路初步探索的理论成果</h3><h4 id="理论成果">理论成果</h4><ul><li>调动一切积极因素为社会主义事业服务（《论十大关系》探索中国特色社会主义建设道路的基本方针）<ul><li>回答了如何建设和巩固社会主义的问题</li><li>有利于最大限度团结全国各族人民，为建设社会主义现代化国家而奋斗</li></ul></li><li>正确认识和处理社会主义社会矛盾的思想<ul><li>此时无产阶级同资产阶级之间的矛盾已基本解决，但仍面临着其他的矛盾</li><li>社会主义社会的基本矛盾<ul><li>生产力 <span class="math inline">\(\leftrightarrow\)</span> 生产关系</li><li>经济基础 <span class="math inline">\(\leftrightarrow\)</span> 上层建筑</li><li>与资本主义社会不同，两者的基本矛盾具有根本不同的性质与情况</li><li>“又相适应，又相矛盾”</li><li>非对抗性的矛盾</li></ul></li><li>社会主义社会的主要矛盾<ul><li>人民对于经济文化迅速发展的需要</li><li>当前经济文化不能满足人民需要的状况</li><li>主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质和文化需要</li></ul></li><li>两类不同性质的矛盾<ul><li>敌我矛盾<ul><li>对抗性矛盾，分清敌我</li><li>处理方法：专政</li></ul></li><li>人民内部矛盾<ul><li>非对抗性矛盾，分清是非</li><li>处理方法：民主</li><li>处理方针：<ul><li>政治思想领域 <span class="math inline">\(\leftrightarrow\)</span> “团结-批评-团结”</li><li>物质利益、分配 <span class="math inline">\(\leftrightarrow\)</span> “统筹兼顾，适当安排”</li><li>人民群众和政府机关 <span class="math inline">\(\leftrightarrow\)</span> 坚持民主集中制，克服政府机关的官僚主义，同时加强对群众的教育</li><li>科学文化领域 <span class="math inline">\(\leftrightarrow\)</span> “百花齐放，百家争鸣”</li><li>共产党和民主党派 <span class="math inline">\(\leftrightarrow\)</span> 在坚持社会主义道路和共产党领导的前提下“长期共存，互相监督”</li><li>民族矛盾 <span class="math inline">\(\leftrightarrow\)</span> 民族平等，团结互助</li></ul></li></ul></li></ul></li><li>意义：<ul><li>团结全国各族文明发展我们的经济，文化，巩固新制度，建设新国家</li></ul></li></ul></li><li>走中国工业化道路的思想<ul><li>为什么要<ul><li>实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件</li><li>中华人民共和国的成立，为我国实现工业化提供了根本的政治前提</li></ul></li><li>背景<ul><li>国内：工业基础薄弱</li><li>国际：受苏联工业化模式影响，比例失调</li></ul></li><li>总方针：<ul><li>以农业为基础，以工业为主导</li><li>以农、轻、重为序发展国民经济</li></ul></li><li>“两条腿走路”工业化发展思路<ul><li>重工业和轻工业同时并举</li><li>中央工业和地方工业同时并举</li><li>沿海工业和内地工业同时并举</li><li>大型企业和中小型企业同时并举</li></ul></li><li>“两步走”发展战略<ul><li>目标：把中国建设成为一个具有现代农业，现代工业，现代国防，现代国防技术的强国</li><li>战略步骤<ul><li>建成一个独立的比较完整的工业体系和国民经济体系</li><li>全面实现工业，农业，国防和科学技术现代化，使中国走在世界前列</li></ul></li></ul></li><li>要怎么做<ul><li>正确的经济建设方针<ul><li>党的八大：既反保守，又反冒进，坚持在综合平衡中稳步前进</li></ul></li><li>调整和完善所有制结构</li><li>探索适合我国情况的经济体制和运行机制</li></ul></li></ul></li><li>其他<ul><li>四个现代化：现代化的工业，现代化的农业，现代化的交通运输业和现代化的国防</li></ul></li></ul><h4 id="经验教训">经验教训</h4><ul><li>意义<ul><li>巩固和发展了我国的社会主义制度</li><li>为开创中国特色社会主义提供了宝贵经验，理论准备和物质基础</li><li>丰富了科学社会主义的理论和实践</li></ul></li><li>经验教训，“六个必须”<ul><li>把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路</li><li>正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力</li><li>从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成</li><li>发展社会主义民主，健全社会主义法治</li><li>坚持党的民主集中制和集体领导制度，加强执政党建设</li><li>坚持对外开放，借鉴和吸收人类文明成果建设社会主义</li></ul></li></ul><h2 id="历程">历程</h2><h3 id="毛泽东的思想历程-毛泽东思想的形成发展过程">毛泽东的思想历程 / 毛泽东思想的形成发展过程</h3><ul><li>19 世纪末 20 世纪初，战争与革命成为时代的主题</li><li>科学含义<ul><li>马列主义在中国的运用和发展</li><li>被实践证明了的关于中国革命建设的正确理论原则和经验总结</li><li>中国共产党集体智慧的结晶</li></ul></li><li>中国革命战胜敌人的三大法宝：统一战线，武装斗争，党的建设</li><li>主要内容与活的灵魂：==实事求是，群众路线，独立自主==<ul><li>实事求是<ul><li>从实际出发，把握客观规律</li><li>清醒认识和正确把握我国基本国情</li><li>推进实践基础上的理论创新</li></ul></li><li>群众路线<ul><li>将“人民群众是历史的创造者”（<em>本质</em>）的原理用在党的活动中</li><li>怎么做<ul><li>坚持人民是推动历史发展的根本力量</li><li>坚持全心全意为人民服务的根本宗旨</li><li>保持党同人民群众的血肉联系</li></ul></li></ul></li><li>独立自主（针对“左”倾教条主义倾向提出的）<ul><li>中华民族的优良传统</li><li>立党立国的重要原则</li><li>外交一以贯之的</li></ul></li></ul></li><li>形成和发展<ul><li>形成时期：<ul><li>第一次国内革命战争<ul><li>《中国社会各阶级的分析》/《湖南农民运动考察报告》</li><li>深刻分析中国社会各阶级在革命中的地位和作用</li><li>提出了新民主主义革命的基本思想</li></ul></li><li>土地革命战争初期<ul><li>《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》</li><li>农村包围城市，武装夺取政权，中国革命道路理论</li><li>毛泽东思想初步形成</li></ul></li></ul></li><li>成熟时期<ul><li>土地革命战争后期，抗日战争时期<ul><li>《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》</li><li>实现了马克思主义与中国革命实际相结合的历史性飞跃</li><li>毛泽东思想趋于成熟</li></ul></li><li>遵义会议，系统分析了党内左和右的思想根源</li><li>确立指导思想：1945 年 4-6 月召开的党的七大将毛泽东思想写入党章</li></ul></li><li>继续发展<ul><li>解放战争时期<ul><li>《在中国共产党第七届中央委员会第二次全体会议上的报告》《论人民民主专政》</li><li>人民民主专政理论</li></ul></li><li>新中国成立后<ul><li>《论十大关系》《关于正确处理人民内部矛盾的问题》</li><li>社会主义改造理论、建设理论</li></ul></li><li>毛泽东思想进一步丰富和发展</li></ul></li></ul></li><li>历史地位<ul><li>马克思主义中国化时代化的第一个重大理论成果</li><li>中国革命和建设的科学指南</li><li>中国共产党和中国人民宝贵的精神财富</li></ul></li><li>科学评价<ul><li>完整准确理解和掌握毛泽东思想的科学体系</li><li>坚持辩证唯物主义和历史唯物主义的原则和方法</li><li>在实践中坚持和发展毛泽东思想</li></ul></li><li>辨析：毛泽东思想 <span class="math inline">\(\neq\)</span> 毛泽东个人的思想<ul><li>被实践证明了的正确的理论原则和经验总结</li><li>中国共产党集体智慧的结晶</li><li>主要是“毛泽东同志的思想”，其他领导人也对毛泽东思想的形成和发展做出了重要贡献</li></ul></li></ul><h3 id="邓小平理论">邓小平理论</h3><ul><li><em>中国特色社会主义理论体系的开篇之作</em></li></ul><h4 id="邓小平理论的形成">邓小平理论的形成</h4><ul><li>时代背景：和平与发展<ul><li>和平：东西问题</li><li>发展：南北问题</li><li><strong>发展是核心问题</strong></li></ul></li><li>历史依据：社会主义建设的经验教训<ul><li>社会主义建设实践中的正确主张在改革开放后得到真正贯彻</li><li>社会主义建设经历的曲折和失误促使党和人民进行深刻反思</li></ul></li><li>现实依据：改革开放和现代化建设的实践</li><li>形成过程<ul><li>“文革”结束后，邓小平强调实事求是是毛泽东思想的精髓，旗帜鲜明反对“两个凡是”的错误观点，支持领导开展真理标准问题的打讨论，推进各方面的拨乱反正</li><li>1978，党的十一届三中全会确定了解放思想，实事求是的思想路线，停止“以阶级斗争为纲”的错误，将全党工作的重点转移到社会主义现代化建设上来，做出改革开放的重大决策，实现了党的历史上具有深远意义的伟大转折。</li><li>1982，党的“十二大”提出“中国特色社会主义”，并成为党的全部理论和实践创新的主题</li><li>1984，《中共中央关于经济体制改革的决定》——社会主义经济是在公有制基础上的有计划的商品经济</li><li>1987，党的十三大，系统论述了我国社会主义初级阶段理论，明确概括和全面阐发了党“一个中心，两个基本点”的基本路线，对中国特色社会主义理论的主要内容做了系统概括，标志着邓小平理论轮廓的形成</li><li>1992，南方谈话，重申深化改革、加速发展的必要性和重要性，从理论上解答了当时困扰和束缚人们思想的一系列重大问题，邓小平理论走向成熟；党的十四大强调中国特色社会主义理论第一次比较系统地初步回答了中国这样的社会经济文化比较落后的国家如何建设社会主义，如何巩固和发展社会主义的一系列基本问题，继承和发展了马克思主义</li><li>1997，十五大正式提出“邓小平理论”这一概念，确立为党的指导思想并写入党章</li><li>1999，宪法修正案正式将邓小平理论载入宪法</li></ul></li></ul><h4 id="理论问题">理论问题</h4><ul><li>首要、基本的理论问题：在中国这样一个经济文化比较落后的国家建设什么样的社会主义，怎样建设社会主义</li><li>社会主义本质<ul><li>解放生产力</li><li>发展生产力（社会主义的根本任务是发展生产力）</li><li>消灭剥削</li><li>消除两极分化</li><li>达到共同富裕</li></ul></li><li>包括了生产力和生产关系的问题</li></ul><h4 id="精髓">精髓</h4><ul><li><strong>解放思想，实事求是</strong></li></ul><h4 id="主要内容">主要内容</h4><ul><li>社会主义初级阶段（建设中国特色社会主义的总依据）理论<ul><li>一切从社会主义初级阶段的实际出发，将社会主义初级阶段作为事关全局的基本国情加以把握</li><li>含义<ul><li>我国社会已经是社会主义社会（社会性质）</li><li>我国的社会主义社会还处于初级阶段（发展程度）</li></ul></li><li>社会主义初级阶段具有长期性</li><li>基本特征<ul><li>以农业人口占多数的手工劳动为基础的农业国，逐步变为非农产业人口占多数的现代化的工业国的阶段</li><li>自然经济半自然经济占很大比重，变为商品经济高度发达的阶段</li><li>通过改革和探索建立和发展充满活力的社会主义经济、政治，文化体制的阶段</li><li>全民奋起，艰苦创业，实现中华民族伟大复兴的阶段</li></ul></li></ul></li><li>党在社会主义初级阶段的基本路线<ul><li><strong>领导和团结全国各族人民</strong>（<em>领导力量和依靠力量</em>），以<strong>经济建设为中心（根本任务），坚持四项基本原则（社会主义道路，人民民主专政，党的领导，马列毛思想）解放和发展生产力的政治保证），坚持改革开放（发展动力与外部条件）</strong>（<em>基本途径</em>），<strong>自力更生，艰苦创业</strong>（<em>实现目标的根本立足点</em>），为把我国建设成为<strong>富强（经济），民主（政治），文明（思想）的社会主义现代化国家</strong>（<em>奋斗目标</em>）而奋斗</li><li>“一个中心（经济建设），两个基本点（四项基本原则（立国之本），改革开放（强国之路））”</li></ul></li><li>社会主义的根本任务是发展生产力，党和国家的工作重点是经济建设<ul><li>发展生产力离不开科学技术</li><li>改革是动力，发展是目的，稳定是前提</li></ul></li><li>分“三步走”基本实现现代化[[Pasted image 20240612214124.png|300]]</li><li>社会主义改革开放理论与市场经济理论<ul><li>社会主义市场经济：在社会主义制度条件下，让市场在资源配置中起决定作用<ul><li>所有制结构：公有制为主体，多种所有制经济共同发展</li><li>宏观调控：市场在国家宏观调控下对资源配置起到决定性作用</li><li>分配制度：按劳分配为主体，多种分配形式并存</li></ul></li></ul></li><li>“两手抓，两手都要硬”（物质文明和精神文明）（建设和法治）（改革开放和惩治腐败）</li><li>“一国两制”与祖国统一</li><li>中国特色社会主义外交和国际战略<ul><li>基本目标：维护我国的独立和主权，促进世界的和平与发展</li><li>冷静观察，稳住阵脚，沉着应付</li></ul></li><li>党的建设<ul><li>重视马克思主义理论学习</li><li>加强组织建设</li><li>加强领导班子建设</li><li>打好党风建设</li><li>重视制度建设</li></ul></li><li>“三个有利于”：<ul><li>是否有利于发展社会主义社会的生产力</li><li>是否有利于增强社会主义国家的综合国力</li><li>是否有利于提高人民的生活水平</li></ul></li></ul><h4 id="重要意义">重要意义</h4><ul><li>马克思列宁主义，毛泽东思想的继承和发展</li><li>中国特色社会主义理论体系的开篇之作</li><li>改革开放和社会主义现代化建设的科学指南</li></ul><h3 id="三个代表重要思想形成背景与具体内容">“三个代表”重要思想形成背景与具体内容</h3><h4 id="背景与形成过程">背景与形成过程</h4><ul><li>社会历史条件<ul><li>国际背景：发生并经历重大变化，基于冷战结束后国际局势的科学判断<ul><li>国际共运遭受重大挫折</li><li>处于两种社会制度对立，斗争的最前沿</li></ul></li><li>历史条件（国内背景）：党的历史方位和党员队伍发生了深刻变化，基于科学判断党的历史方位和总结历史经验<ul><li>领导人民为夺取全国政权而奋斗 <span class="math inline">\(\to\)</span> 领导人民掌握全国政权并长期执政</li><li>受到外部封锁和实行计划经济条件下领导国家建设 <span class="math inline">\(\to\)</span> 对外开放和发展社会主义市场经济条件下领导国家建设</li><li>党员队伍进入整体性交接的关键时刻<ul><li>提高党的领导水平和执政水平</li><li>提高拒腐防变和抵御风险的能力</li><li>要求党从新的实际出发，以改革的精神加强和改进党的建设，使党在世界形势深刻变化的历史进程中始终走在时代前列</li></ul></li></ul></li><li>实践基础：在建设中国特色社会主义伟大实践的基础上形成的</li></ul></li><li>“三个代表”重要思想发展过程<ul><li>酝酿<ul><li>1989.6 / 8 提出大力加强党的建设，惩治腐败的要求，发布《关于加强党的建设的通知》</li><li>1991.7，中国共产党成立 70 周年大会上深刻论述了进一步加强党的建设的问题</li><li>1992.10，党的十四大系统论述了加强党的建设和改善党的领导的问题</li></ul></li><li>形成<ul><li>1994，十四届四中全会通过了《关于加强党的建设几个重大问题的决定》</li><li>1997，党的十五大，高度概括了新时期党的建设新的伟大工程的总目标</li><li>2000.2，在广东考察，首次对“三个代表”进行了比较全面的阐述</li><li>2000.6，在全国党校工作会议上指出，“三个代表”重要思想回答和解决的事“建设什么样的党，怎样建设党”的问题</li></ul></li><li>深度发展<ul><li>2000.10，就“改进党的作风”发表重要讲话</li><li>2001.7，庆祝中国共产党成立 80 周年大会上的讲话中全面阐述了“三个代表”重要思想的科学内涵和基本内容</li><li>2002.11，党的十六大确立为指导思想，写入党章</li></ul></li></ul></li></ul><h4 id="核心观点">核心观点</h4><ul><li>中国共产党始终代表中国先进生产力的发展要求</li><li>中国共产党始终代表中国先进文化的前进方向</li><li>中国共产党始终代表中国最广大人民的根本利益</li></ul><h4 id="主要内容-1">主要内容</h4><ul><li>发展是党执政兴国的第一要务</li><li>建立社会主义市场经济体制<ul><li>毫不动摇巩固发展公有制经济</li><li>毫不动摇鼓励、支持、引导非公有制经济</li><li>本质要求：发挥市场机制的作用和国家宏观调控</li></ul></li><li>全面建设小康社会<ul><li>两个百年奋斗目标</li></ul></li><li>建设社会主义政治文明</li><li>实施“引进来”和“走出去”的对外开放战略</li><li>推进党的建设新的伟大工程</li></ul><h4 id="历史地位">历史地位</h4><ul><li>中国特色社会主义理论体系的丰富发展</li><li>加强和改进党的建设，推进中国特色社会主义事业的强大理论武器</li></ul><h3 id="科学发展观的形成过程与具体内容">科学发展观的形成过程与具体内容</h3><h4 id="形成条件">形成条件</h4><ul><li>国际背景：<ul><li>深刻分析国际形势</li><li>顺应世界发展趋势</li><li>借鉴国外发展经验</li></ul></li><li>历史条件<ul><li>深刻把握我国国情和新的阶段性特征</li></ul></li><li>实践基础<ul><li>总结改革开放尤其是十六大以来实践经验的基础</li></ul></li></ul><h4 id="形成过程">形成过程</h4><ul><li>逐步形成：抗击非典疫情和探索未完善社会主义市场经济体制<ul><li>2003.7，总结非典经验：全面发展，协调发展，可持续发展</li><li>2003.10，科学发展观</li></ul></li><li>充实丰富：加强和改善宏观调控的时间<ul><li>十四届六中全会，树立和落实科学发展观作为提高党的执政能力的重要内容</li><li>十一五规划的建议 / 纲要：以科学发展观统领经济社会发展全局</li></ul></li><li>走向成熟</li><li>发展完善：十七大后，不断发展完善<ul><li>2008.12，在中央经济工作会议上强调，科学发展观第一要义是发展</li><li>十七届五中全会强调，坚持发展是硬道理的本质要求，就是坚持科学发展</li><li>2012，确立为指导思想</li></ul></li></ul><h4 id="内涵">内涵</h4><ul><li>推动经济社会<strong>发展</strong>是科学发展观的<em>第一要义</em> （为什么）</li><li><strong>以人为本</strong>是科学发展观的<em>核心立场</em> （为了谁和依靠谁）</li><li><strong>全面协调可持续</strong>是科学发展观的<em>基本要求</em> （实现什么样的发展）</li><li><strong>统筹兼顾</strong>是科学发展观的<em>根本方法</em> （怎么发展）</li></ul><h4 id="精神实质">精神实质</h4><ul><li>解放思想，实事求是，与时俱进，求真务实</li></ul><h4 id="内容">内容</h4><ul><li>转变经济发展方式<ul><li>持续健康发展</li><li>创新驱动发展战略</li><li>经济结构战略性调整</li><li>促进区域协调发展战略</li><li>城乡发展一体化</li></ul></li><li>发展社会主义民主政治<ul><li>社会主义核心价值体系</li><li>社会主义核心价值观</li></ul></li><li>推进社会主义文化强国建设</li><li>构建社会主义和谐社会</li><li>推进生态文明建设</li><li>全面提高党的建设科学化水平</li></ul><h4 id="历史地位-1">历史地位</h4><ul><li>中国特色社会主义理论体系在新世纪新阶段的接续发展</li><li>全面建设小康社会，加快推进社会主义现代化的根本指针</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>公共课程</category>
      
      <category>毛泽东思想与中国特色社会主义理论体系概论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>毛概</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理2笔记</title>
    <link href="/2025/04/10/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/04/10/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="真空中的静电场">真空中的静电场</h2><h3 id="电学基本概念">电学基本概念</h3><h4 id="电荷">电荷</h4><ul><li>代表物质间发生电离相互作用的物质的一种属性</li><li>一般用 <span class="math inline">\(q\)</span> 表示</li></ul><p>电荷的单位为 库伦 <span class="math inline">\(C\)</span>，<span class="math inline">\(1C = 1A\cdot s\)</span></p><h5 id="电荷的基本性质">电荷的基本性质</h5><h6 id="电荷的正负性">电荷的正负性</h6><ul><li>电荷有正负两种性质</li><li>同种电荷相互排斥，异种电荷相互吸引</li></ul><h5 id="电荷的量子化">电荷的量子化</h5><p>任何带电体的电量都是电子电量的整数倍</p><p><span class="math display">\[q = N\cdot e\quad (N=0,\pm 1,\pm 2,\ldots)\]</span></p><p>其中 <span class="math inline">\(e = 1.602\times 10^{-19}C\)</span> 为电子的电量</p><h6 id="电荷量子化的实验验证">电荷量子化的实验验证</h6><p>密立根的油滴实验</p><h5 id="电荷的守恒性">电荷的守恒性</h5><p>在一个和外界没有电荷交换的系统内，正负电荷的代数和在任意物理过程中保持不变</p><p><span class="math display">\[\sum Q_i =\text{const.}\]</span></p><p>可以通过法拉第冰桶实验证明</p><h5 id="电荷运动的不变性">电荷运动的不变性</h5><p>电荷电量与运动状态无关，具有相对论不变性</p><h4 id="点电荷">点电荷</h4><p>点电荷是一种可以忽略大小的带电体</p><p>带电体之间发生电路相互作用，如果它们之间的距离远远大于带电体本身的尺寸，那么带电体的尺寸和形状可以忽略不计，而将带电体看作是点电荷</p><h4 id="电荷之间的作用力">电荷之间的作用力</h4><p>库伦定律：在真空之中，两个静止点电荷之间的相互作用力大小，与它们的电量的乘积成正比，与它们之间距离的平方成反比；作用力的方向沿着它们的联线，同号电荷相斥，异号电荷相吸。</p><p><span class="math display">\[\vec{F} =\frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\vec{e_r}\]</span></p><p>我们可以令</p><p><span class="math display">\[k=\frac{1}{4\pi\varepsilon_0}=8.9875\times 10^9 N\cdot m^2/C^2\approx 9.0\times 10^9N\cdot m^2/C^2\]</span></p><p>其中 <span class="math inline">\(\varepsilon_0 = 8.854\times 10^{-12}C^2/(N\cdot m^2)\)</span> 为真空介电常数</p><h4 id="多个电荷间的作用力">多个电荷间的作用力</h4><p>遵循电力叠加原理</p><p>离散的点电荷</p><p><span class="math display">\[\vec{F}=\sum_i\vec{F_i}=\frac{1}{4\pi\varepsilon_0}\sum_i\frac{qq_i}{r_i^2}\vec{e_{r_i}}\]</span></p><h3 id="电场与电场强度">电场与电场强度</h3><h4 id="电场">电场</h4><p>是电荷周围存在的一种物理场</p><h4 id="电场强度">电场强度</h4><p><span class="math display">\[\vec{E}=\frac{\vec{F}}{q}=\frac{1}{4\pi\varepsilon_0}\frac{q_i}{r^2}\vec{e_r}\]</span></p><p>单位为 <span class="math inline">\(N/C\)</span> 或 <span class="math inline">\(V/m\)</span></p><p>方向为正电荷在该点所受力的方向</p><h4 id="电场强度的计算">电场强度的计算</h4><h5 id="点电荷的场强">点电荷的场强</h5><p><span class="math display">\[\vec{E}=\frac{1}{4\pi\varepsilon_0}\frac{q}{r^2}\vec{e_r}\]</span></p><h5 id="多个点电荷的场强">多个点电荷的场强</h5><p><span class="math display">\[\vec{E}=\sum_i\vec{E_i}=\frac{1}{4\pi\varepsilon_0}\sum_i\frac{q_i}{r_i^2}\vec{e_{r_i}}\]</span></p><h5 id="连续分布电荷的场强">连续分布电荷的场强</h5><p><span class="math display">\[\vec{E}=\frac{1}{4\pi\varepsilon_0}\int\frac{\mathrm{d}q}{r^2}\vec{e_r}\]</span></p><p>我们可以将 <span class="math inline">\(\mathrm{d}q\)</span> 表示为</p><ol type="1"><li>线电荷分布：<span class="math inline">\(\mathrm{d}q=\lambda\mathrm{d}l\)</span></li><li>面电荷分布：<span class="math inline">\(\mathrm{d}q=\sigma\mathrm{d}s\)</span></li><li>体电荷分布：<span class="math inline">\(\mathrm{d}q=\rho\mathrm{d}v\)</span></li></ol><h5 id="几种模型的场强">几种模型的场强</h5><h6 id="真空中有均匀带电直线电荷线密度为-lambda线外有一点-p离开直线的垂直距离为-ap-点和直线两端连线的夹角分别为-theta_1-和-theta_2求-p-点的场强">真空中有均匀带电直线，电荷线密度为 <span class="math inline">\(\lambda\)</span>。线外有一点 P，离开直线的垂直距离为 <span class="math inline">\(a\)</span>，P 点和直线两端连线的夹角分别为 <span class="math inline">\(\theta_1\)</span> 和 <span class="math inline">\(\theta_2\)</span>。求 P 点的场强</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180810166.png" alt="有限长带电直导线" /><figcaption aria-hidden="true">有限长带电直导线</figcaption></figure><ul><li><span class="math inline">\(\displaystyle E_x=\frac{\lambda}{4\pi\varepsilon_0a}(\sin\theta_2-\sin\theta_1)\)</span></li><li><span class="math inline">\(\displaystyle E_y=\frac{\lambda}{4\pi\varepsilon_0a}(\cos\theta_1-\cos\theta_2)\)</span></li></ul><p>当导线无限长时</p><ul><li><span class="math inline">\(\displaystyle E_x=0\)</span></li><li><span class="math inline">\(\displaystyle E_y=\frac{\lambda}{2\pi\varepsilon_0a}\)</span></li></ul><h6 id="电荷-q-均匀地分布在半径为-r-圆心角为-theta-的一段圆弧上计算圆弧圆心位置的场强">电荷 <span class="math inline">\(q\)</span> 均匀地分布在半径为 <span class="math inline">\(R\)</span> ，圆心角为 <span class="math inline">\(\theta\)</span> 的一段圆弧上，计算圆弧圆心位置的场强</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180832207.png" alt="带电圆弧" /><figcaption aria-hidden="true">带电圆弧</figcaption></figure><ul><li><span class="math inline">\(\displaystyle E_x=0\)</span></li><li><span class="math inline">\(\displaystyle E_y=-\frac{q}{2\pi\varepsilon_0R^2}\frac{\sin(\theta/2)}{\theta}\)</span></li></ul><h6 id="电荷-q-均匀地分布在一半径为-r-的圆环上计算在圆环的轴线上任一给定点-p-的场强">电荷 <span class="math inline">\(q\)</span> 均匀地分布在一半径为 <span class="math inline">\(r\)</span> 的圆环上。计算在圆环的轴线上任一给定点 P 的场强</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180835005.png" alt="带电圆环" /><figcaption aria-hidden="true">带电圆环</figcaption></figure><ul><li><span class="math inline">\(\displaystyle E_x=\frac{1}{4\pi\varepsilon_0}\frac{qx}{(x^2+r^2)^{3/2}}\)</span></li></ul><h6 id="均匀带电圆板半径为-r电荷面密度为-sigma求轴线上任一点-p-的电场强度">均匀带电圆板，半径为 <span class="math inline">\(R\)</span>，电荷面密度为 <span class="math inline">\(\sigma\)</span>。求轴线上任一点 P 的电场强度</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509180836392.png" alt="带电圆板" /><figcaption aria-hidden="true">带电圆板</figcaption></figure><p><span class="math display">\[E=\frac{\sigma}{2\varepsilon_0}\left[1-\frac{x}{\sqrt{x^2+R^2}}\right]\]</span></p><p>特别的，当 <span class="math inline">\(\displaystyle R\to\infty\)</span> 时，<span class="math inline">\(\displaystyle E=\frac{\sigma}{2\varepsilon_0}\)</span></p><h3 id="高斯定理">高斯定理</h3><h4 id="电场线">电场线</h4><p>电场线是描述电场分布情况的曲线</p><ul><li>电场线的切线方向与该点的电场强度方向相同</li><li>电场线的疏密程度表示该处电场强度的大小</li></ul><h4 id="电通量">电通量</h4><p>电通量 <span class="math inline">\(\Phi\)</span> 是电场通过某一面积的电场线的总数</p><p>电通量是标量</p><p>单位为 <span class="math inline">\(N\cdot m^2/C\)</span> 或 <span class="math inline">\(V\cdot m\)</span></p><p><span class="math display">\[\Phi=\int_SE\cos\theta\mathrm{d}S = \int_S\vec{E}\cdot\mathrm{d}\vec{S}\]</span></p><p>通过闭合曲面的电通量</p><p><span class="math display">\[\Phi=\oint_S\vec{E}\cdot\mathrm{d}\vec{S}\]</span></p><h4 id="高斯定理-1">高斯定理</h4><p>如果在真空中场源是若干个点电荷，则穿过任一闭合曲面的总电通量等于该闭合曲面包围的电荷电量的代数和（净电荷）的 <span class="math inline">\(\frac{1}{\varepsilon_0}\)</span> 倍</p><p><span class="math display">\[\Phi_e=\oint_S\vec{E}\cdot\mathrm{d}\vec{S}=\frac{\sum_{i=1}^nq_{i内}}{\varepsilon_0}\]</span></p><h3 id="环流定理和电势">环流定理和电势</h3>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>物理</tag>
      
      <tag>电磁学</tag>
      
      <tag>光学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理1笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%861%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%861%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="质点运动学">质点运动学</h2><h3 id="时间空间概念">时间、空间概念</h3><h3 id="质点">质点</h3><h4 id="牛顿的时空观">牛顿的时空观</h4><ul><li><p><strong>时间</strong><br />均匀流动的带子，与事件本身无关，事件是带子上的标记.</p></li><li><p><strong>空间</strong><br />好比建筑物，人的存在与否不影响它的存在.</p><p>时间、空间与事物及过程完全割裂，这就是“绝对时空观”.</p></li></ul><h4 id="研究对象的理想化">研究对象的理想化</h4><ol type="1"><li>把抽象的物质具体化，看得见，摸得着.</li><li>把研究的物质质点化.<br />(点：具有该物体相同的质量)<ul><li>物体的大小、形状可以忽略时</li><li>物体运动中，物体的各部分运动相同</li></ul></li></ol><h3 id="运动的绝对性和相对性">运动的绝对性和相对性</h3><h3 id="参考系">参考系</h3><h3 id="质点的位置坐标和位置矢量">质点的位置坐标和位置矢量</h3><h4 id="直角坐标系">直角坐标系</h4><p>质点位置<span class="math inline">\(P(x,y,z)\)</span> 位置矢量<span class="math inline">\(\vec{r}=\vec{oP}\)</span></p><h4 id="位移">位移</h4><h4 id="速度">速度</h4><ol type="1"><li>平均速度：<span class="math inline">\(\overline{\vec{v}} =\dfrac{\Delta \vec{r}}{\Delta t}\)</span></li><li>瞬时速度：<span class="math inline">\(\vec{v}=\dfrac{\mathrm{d}\vec{r}}{\mathrm{d}t}\)</span></li></ol><h4 id="直角坐标系中的速度加速度">直角坐标系中的速度、加速度</h4><h4 id="自然坐标系速度表示法">自然坐标系速度表示法</h4><h4 id="极坐标速度表示法">极坐标速度表示法</h4><h4 id="圆周运动">圆周运动</h4><h3 id="伽利略变换">伽利略变换</h3><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250225111725.png" alt="坐标系" /><figcaption aria-hidden="true">坐标系</figcaption></figure><p><span class="math inline">\(S&#39;\)</span> 相对于 <span class="math inline">\(S\)</span> 运动，速度为 <span class="math inline">\(u\)</span> ，则有</p><p><span class="math display">\[\begin{aligned}&amp;\vec{r} = \vec{r&#39;} + \vec{R},\quad dt=dt&#39;\\&amp;\frac{\mathrm{d}\vec{r}}{\mathrm{d}t} = \frac{\mathrm{d}\vec{r&#39;}}{\mathrm{d}t&#39;} + \frac{\mathrm{d}\vec{R}}{\mathrm{d}t&#39;}, \quad \vec{v} =\vec{u} +\vec{v&#39;}\\&amp;\frac{\mathrm{d}^2\vec{r}}{\mathrm{d}t^2} = \frac{\mathrm{d}^2\vec{r&#39;}}{\mathrm{d}t&#39;^2} + \frac{\mathrm{d}^2\vec{R}}{\mathrm{d}t^2}, \quad \vec{a} = \vec{a}_0 + \vec{a&#39;}\end{aligned}\]</span></p><h2 id="质点运动学-1">质点运动学</h2><h3 id="牛顿运动定律">牛顿运动定律</h3><h4 id="牛顿第一定律">牛顿第一定律</h4><h4 id="牛顿第二定律">牛顿第二定律</h4><h4 id="牛顿第三定律">牛顿第三定律</h4><h3 id="相互作用力">相互作用力</h3><h4 id="万有引力的计算">万有引力的计算</h4><h5 id="引力质量">引力质量</h5><h5 id="惯性质量和引力质量的联系">惯性质量和引力质量的联系</h5><h4 id="弹性力">弹性力</h4><h4 id="摩擦力">摩擦力</h4><h4 id="流体阻力">流体阻力</h4><h3 id="非惯性系惯性力">非惯性系、惯性力</h3><h4 id="惯性参考系">惯性参考系</h4><h4 id="惯性离心力">惯性离心力</h4><h3 id="惯性力与自然界的运动">惯性力与自然界的运动</h3><h4 id="太阳和地球引力失重">太阳和地球引力失重</h4><h4 id="潮汐力和潮汐">潮汐力和潮汐</h4><h3 id="科氏加速度和科氏力">科氏加速度和科氏力</h3><h4 id="科里奥利力的来源">科里奥利力的来源</h4><h3 id="质心和质心运动定律">质心和质心运动定律</h3><h4 id="质心">质心</h4><h4 id="质心坐标系">质心坐标系</h4><h2 id="功与能">功与能</h2><h3 id="功动能定理">功、动能定理</h3><h4 id="功的基本概念">功的基本概念</h4><h4 id="内力的功">内力的功</h4><h2 id="狭义相对论">狭义相对论</h2><h3 id="狭义相对论时空观">狭义相对论时空观</h3><h4 id="狭义相对性原理">狭义相对性原理</h4><p>物理学定律与惯性系的选择无关,所有惯性系是等价的</p><p><span class="math display">\[\left\{\begin{array}{ll}  &amp;S  &amp;&amp;m_1\vec{v_1} + m_2\vec{v_2} = m_1\vec{v_10} + m_2\vec{v_20}\\  &amp;S&#39; &amp;&amp;m&#39;_1\vec{v&#39;_1} + m&#39;_2\vec{v&#39;_2} = m&#39;_1\vec{v&#39;_10} + m&#39;_2\vec{v&#39;_20}\end{array}\right.\]</span></p><h4 id="光速不变原理">光速不变原理</h4><p>光速在任何惯性系中都是不变的,即光速是绝对的,与光源和观察者的运动状态无关 由 Maxwell 方程可以推出</p><h4 id="洛伦兹变换">洛伦兹变换</h4><p>设$ <span class="math inline">\(S&#39;\)</span> 系相对于 <span class="math inline">\(S\)</span> 系以速度 <span class="math inline">\(u\)</span> 沿 <span class="math inline">\(x\)</span> 轴正方向运动，两坐标轴原点 <span class="math inline">\(o\)</span> 与 <span class="math inline">\(o&#39;\)</span> 在 <span class="math inline">\(t=t&#39;=0\)</span> 时重合，则有</p><ul><li>正变换</li></ul><p><span class="math display">\[\begin{cases}  x&#39; = \frac{x-ut}{\sqrt{1-\frac{u^2}{c^2}}}\\  y = y&#39;\\  z = z&#39;\\  t&#39; = \frac{t-\frac{ux}{c^2}}{\sqrt{1-\frac{u^2}{c^2}}}\end{cases}\]</span></p><ul><li>逆变换</li></ul><p><span class="math display">\[\begin{cases}  x = \frac{x&#39;+ut&#39;}{\sqrt{1-\frac{u^2}{c^2}}}\\  y&#39; = y\\  z&#39; = z\\  t = \frac{t&#39;+\frac{ux&#39;}{c^2}}{\sqrt{1-\frac{u^2}{c^2}}}\end{cases}\]</span></p><p>若令 <span class="math inline">\(\gamma = \frac{1}{\sqrt{1-\frac{u^2}{c^2}}} &gt;1\)</span>，则有</p><ul><li>正变换</li></ul><p><span class="math display">\[\begin{cases}  x&#39; = \gamma(x-ut)\\  y&#39; = y\\  z&#39; = z\\  t&#39; = \gamma(t-\frac{ux}{c^2})\end{cases}\]</span></p><ul><li>逆变换</li></ul><p><span class="math display">\[\begin{cases}  x = \gamma(x&#39;+ut&#39;)\\  y = y&#39;\\  z = z&#39;\\  t = \gamma(t&#39;+\frac{ux&#39;}{c^2})\end{cases}\]</span></p><h3 id="狭义相对论的时空效应">狭义相对论的时空效应</h3><p>设在 <span class="math inline">\(S&#39;\)</span> 系中，质点的时空坐标为 <span class="math inline">\((x&#39;, t&#39;)\)</span>，在 <span class="math inline">\(S\)</span> 系中，质点的坐标为 <span class="math inline">\((x, t)\)</span>，系 <span class="math inline">\(S&#39;\)</span> 相对于系 <span class="math inline">\(S\)</span> 以速度 <span class="math inline">\(u\)</span> 沿 <span class="math inline">\(x\)</span> 轴正方向运动</p><p><span class="math display">\[\begin{cases}  \Delta x = \gamma \left(\Delta x -u\Delta t\right)\\  \Delta x&#39; = \gamma \left(\Delta x&#39; +u\Delta t&#39;\right)\\\end{cases}\]</span></p><p><span class="math display">\[\begin{cases}  \Delta t = \gamma \left(\Delta t -\frac{u\Delta x}{c^2}\right)\\  \Delta t&#39; = \gamma \left(\Delta t&#39; +\frac{u\Delta x&#39;}{c^2}\right)\\\end{cases}\]</span></p><p>明确这两组公式中的变量哪些是 <span class="math inline">\(0\)</span> ，哪些是已知量是解题的关键</p><h4 id="时间膨胀">时间膨胀</h4><p>物体在 <span class="math inline">\(S&#39;\)</span> 系中静止，则有</p><p><span class="math display">\[\Delta t = \gamma \Delta t&#39;\]</span></p><p>在 <span class="math inline">\(S&#39;\)</span> 系中同时不同地发生的两件事，<span class="math inline">\(S\)</span> 系中不同时发生，时间间隔为 <span class="math inline">\(\Delta t = \gamma \frac{u \Delta x&#39;}{c^2}\)</span></p><h4 id="长度收缩">长度收缩</h4><p>设在 <span class="math inline">\(S&#39;\)</span> 系中静止的物体的本征长度为 <span class="math inline">\(L&#39;\)</span>，在 <span class="math inline">\(S\)</span> 系中测得的长度 <span class="math inline">\(L\)</span> 为</p><p><span class="math display">\[L = \frac{L&#39;}{\gamma} = L&#39; \sqrt{1-\frac{u^2}{c^2}}\]</span></p><blockquote><p><strong>注意：</strong></p><p>在 <span class="math inline">\(S\)</span> 系测量则需要在 <span class="math inline">\(S\)</span> 系中同时确认两个点的空间坐标，<span class="math inline">\(\Delta t = 0\)</span></p></blockquote><h3 id="洛伦兹速度变换">洛伦兹速度变换</h3><ul><li>正变换</li></ul><p><span class="math display">\[\begin{cases}  v_x&#39; = \frac{v_x - u}{1-\frac{uv_x}{c^2}}\\  v_y&#39; = \frac{v_y}{\gamma(1-\frac{uv_x}{c^2})} = \frac{v_y\sqrt{1-\frac{u^2}{c^2}}}{\left(1-\frac{uv_x}{c^2}\right)}\\  v_z&#39; = \frac{v_z}{\gamma(1-\frac{uv_x}{c^2})} = \frac{v_z\sqrt{1-\frac{u^2}{c^2}}}{\left(1-\frac{uv_x}{c^2}\right)}\end{cases}\]</span></p><ul><li>逆变换</li></ul><p><span class="math display">\[\begin{cases}  v_x = \frac{v_x&#39; + u}{1+\frac{uv_x&#39;}{c^2}}\\  v_y = \frac{v_y&#39;}{\gamma(1+\frac{uv_x&#39;}{c^2})} = \frac{v_y&#39;\sqrt{1-\frac{u^2}{c^2}}}{\left(1+\frac{uv_x&#39;}{c^2}\right)}\\  v_z = \frac{v_z&#39;}{\gamma(1+\frac{uv_x&#39;}{c^2})} = \frac{v_z&#39;\sqrt{1-\frac{u^2}{c^2}}}{\left(1+\frac{uv_x&#39;}{c^2}\right)}\end{cases}\]</span></p><h3 id="相对论中的质量和动量">相对论中的质量和动量</h3><p>由实验研究表明，物体的质量随着速率增大而增大，记 <span class="math inline">\(m_0\)</span> 为物体在静止时的质量，称为静质量，<span class="math inline">\(m\)</span> 为物体在运动时的质量，称为动质量，则有</p><p><span class="math display">\[m = \frac{m_0}{\sqrt{1-\frac{v^2}{c^2}}}\]</span></p><p>其动量为</p><p><span class="math display">\[\vec{p} = m\vec{v} = \frac{m_0\vec{v}}{\sqrt{1-\frac{v^2}{c^2}}}\]</span></p><h3 id="相对论中的力学基本方程">相对论中的力学基本方程</h3><p><span class="math display">\[\begin{aligned}  &amp;\vec{p} = m\vec{u} = \frac{m_0\vec{u}}{\sqrt{1-\frac{u^2}{c^2}}}\\  &amp;\vec{p} = \vec{u} \mathrm{d}m + m\mathrm{d}\vec{u}\\  &amp;\vec{F}  = \frac{\mathrm{d}}{\mathrm{d}t} \left(\frac{m_0\vec{u}}{\sqrt{1-\frac{u^2}{c^2}}}\right)\end{aligned}\]</span></p><h3 id="相对论中的能量">相对论中的能量</h3><p><span class="math display">\[\begin{cases}  E_k = mc^2 - m_0c^2&amp;\text{动能}\\  E_0 = m_0c^2&amp;\text{静能}\\  E = mc^2 = E_0 +E_k&amp;\text{总能量}\end{cases}\]</span></p><p>质能关系</p><p><span class="math display">\[\Delta E = \Delta m c^2\]</span></p><p>能量与动量之间的关系</p><p><span class="math display">\[p = \frac{E}{c}\]</span></p><h2 id="振动力学">振动力学</h2><h3 id="简谐振动动力学">简谐振动动力学</h3><p>简谐运动定义：凡质点的运动遵从余弦（或正弦）规律时，其运动形式为简谐振动</p><p>其运动方程为</p><p><span class="math display">\[x(t) = A \cos(\omega t + \varphi)\]</span></p><p>简谐运动的动力学方程为</p><p><span class="math display">\[\frac{\mathrm{d}^2x}{\mathrm{d}t^2} + \omega^2 x = 0\]</span></p><p>其中 <span class="math inline">\(\omega = \sqrt{\frac{k}{m}}\)</span>，<span class="math inline">\(k\)</span> 为弹性系数，<span class="math inline">\(m\)</span> 为物体的质量</p><h3 id="简谐振动运动的物理量">简谐振动运动的物理量</h3><h4 id="周期频率和角频率">周期、频率和角频率</h4><ul><li><strong>角频率：</strong> <span class="math inline">\(\omega =\sqrt{\frac{k}{m}} = \frac{2\pi}{T} = 2\pi \nu\)</span></li><li><strong>周期：</strong> <span class="math inline">\(T = \frac{1}{\nu} = \frac{2\pi}{\omega} = 2\pi\sqrt{\frac{m}{k}}\)</span></li></ul><p>在 <span class="math inline">\(x =A \cos(\omega t + \varphi)\)</span> 中，<span class="math inline">\(A\)</span> 为振幅，<span class="math inline">\(\varphi\)</span> 为初相位</p><ul><li><span class="math inline">\(v = \frac{\mathrm{d}x}{\mathrm{d}t} = -A\omega \sin(\omega t + \varphi)\)</span></li><li><span class="math inline">\(v_0 = -A\omega\sin\varphi\)</span></li><li><span class="math inline">\(E = E_k + E_p = \frac{1}{2}mv^2 + \frac{1}{2}kx^2 = \frac{1}{2}kA^2\)</span></li><li><span class="math inline">\(A = \sqrt{x_0^2+\frac{v_0^2}{\omega^2}} = \sqrt{\frac{2E}{m\omega^2}}\)</span></li></ul><h4 id="相位">相位</h4><p><span class="math display">\[x = A\cos(\omega t + \varphi)\]</span></p><ul><li><span class="math inline">\(\left(\omega t+\varphi\right)\)</span> 是 <span class="math inline">\(t\)</span> 时刻的相位</li><li><span class="math inline">\(\varphi\)</span> 是 <span class="math inline">\(t=0\)</span> 时刻的相位</li><li><strong>相位差：</strong> <span class="math inline">\(\Delta \varphi =\left(\omega_2t+ \varphi_2\right)-\left(\omega_1t=\varphi_1\right)\)</span><ul><li>相位差为 <span class="math inline">\(\pm2k\pi(k = 0 , 1 , \ldots)\)</span> 时，两个简谐振动的相位相同</li><li>相位差为 <span class="math inline">\(\pm(2k+1)\pi(k = 0 , 1 , \ldots)\)</span> 时，两个简谐振动的相位相反</li><li>若 <span class="math inline">\(\Delta\varphi = \varphi_ -\varphi_1&gt;0\)</span>，则 <span class="math inline">\(x_2\)</span> 比 <span class="math inline">\(x_1\)</span> 较早到正最大，称 <span class="math inline">\(x_2\)</span> 比 <span class="math inline">\(x_1\)</span> 超前，或称 <span class="math inline">\(x_1\)</span> 比 <span class="math inline">\(x_2\)</span> 滞后<ul><li>超前和落后以小于 <span class="math inline">\(\pi\)</span> 的相位角来判断</li></ul></li></ul></li></ul><h4 id="振动状态和振动能量">振动状态和振动能量</h4><h5 id="振动速度">振动速度</h5><p><span class="math display">\[\begin{aligned}  v = \frac{\mathrm{d}x}{\mathrm{d}t} &amp;= -A\omega \sin(\omega t + \varphi)\\  &amp;= -v_m \cos(\omega t + \varphi + \frac{\pi}{2})\\\end{aligned}\]</span></p><p>其中 <span class="math inline">\(v_m = A\omega\)</span> 称为速度振幅</p><h5 id="振动加速度">振动加速度</h5><p><span class="math display">\[\begin{aligned}  a = \frac{\mathrm{d}^2x}{\mathrm{d}t^2} &amp;= -A\omega^2 \cos(\omega t + \varphi)\\  &amp;= -a_m \sin(\omega t + \varphi + \frac{\pi}{2})\\\end{aligned}\]</span></p><p>其中 <span class="math inline">\(a_m =A\omega^2\)</span> 称为加速度振幅</p><h5 id="振动系统的能量">振动系统的能量</h5><ul><li>振子动能</li></ul><p><span class="math display">\[E_k = \frac{1}{2}mv^2 = \frac{1}{2}mA^2\omega^2\sin^2(\omega t + \varphi)\]</span></p><ul><li>振子势能</li></ul><p><span class="math display">\[E_p = \frac{1}{2}kx^2 = \frac{1}{2}kA^2\cos^2(\omega t + \varphi)\]</span></p><ul><li>振子总能量</li></ul><p><span class="math display">\[E = E_k + E_p = \frac{1}{2}kA^2\]</span></p><h4 id="旋转振幅矢量">旋转振幅矢量</h4><p>旋转矢量 <span class="math inline">\(\vec{A}\)</span> 在 <span class="math inline">\(x\)</span> 轴上的投影点的运动规律为</p><p><span class="math display">\[x = A \cos(\omega t + \varphi)\]</span></p><h2 id="平衡态">平衡态</h2><h3 id="基本概念">基本概念</h3><ol type="1"><li>热力学系统<ul><li><strong>孤立系统：</strong> 与外界无能量和质量交换</li><li><strong>封闭系统：</strong> 与外界有能量无质量交换</li><li><strong>开放系统：</strong> 与外界由能量和质量交换</li><li><strong>外界：</strong> 处于系统之外的物体或物体组</li></ul></li><li>系统状态的描述<ul><li><strong>宏观参量：</strong> 可以直接测量的量，如压强 <span class="math inline">\(p\)</span>、温度 <span class="math inline">\(T\)</span> 等由宏观参量描述的系统状态称为宏观状态</li><li><strong>微观量：</strong> 描述系统内微观粒子的物理量，一般无法直接测量，如分子的质量 <span class="math inline">\(m\)</span>、直径 <span class="math inline">\(d\)</span>、位置、速度 <span class="math inline">\(v\)</span>、动量 <span class="math inline">\(p\)</span>、能量 <span class="math inline">\(\epsilon\)</span> 等。</li></ul></li><li>平衡态<ul><li>孤立系统达到的不随时间变化的状态称为热力学平衡态或平衡态</li><li>内部能量和质量没有宏观流动，达到同一温度的定态叫平衡态</li></ul></li><li>定态<ul><li>宏观性质不随时间变化的稳定状态称为定态</li></ul></li><li><strong>动态平衡：</strong> <strong>不受外界影响</strong>的条件下系统的宏观性质不随时间变化，此系统处在热力学平衡态</li><li>涨落：<ul><li>系统的宏观性质在平衡态下有微小的波动称为涨落</li><li>涨落是系统内微观粒子运动的结果</li></ul></li></ol><h3 id="热力学第一定律">热力学第一定律</h3><h4 id="温度">温度</h4><p>达到热平衡的系统具有共同的内部属性：温度</p><h4 id="热力学第零定律">热力学第零定律</h4><p>两个系统同时与第三个系统热平衡时，这两个物体之间也必达到热平衡</p><p>处于热平衡的多个系统具有相同的温度</p><h4 id="理想气体温标和状态方程">理想气体温标和状态方程</h4><h5 id="理想气体">理想气体</h5><ul><li>波义耳定律<ul><li>温度不变时没压强和体积的乘积是一个常数</li></ul></li><li>理想气体<ul><li>严格遵守波义耳定律的气体为理想气体</li></ul></li></ul><h5 id="热力学温标">热力学温标</h5><p>理论上存在一个与测温质、测温属性无关的温标：热力学温标</p><p>根据物理定律，温度为 <span class="math inline">\(0^\circ C\)</span> 是，每下降 <span class="math inline">\(1^\circ C\)</span>，体积减少 <span class="math inline">\(\frac{1}{273}\)</span>，则当处于 <span class="math inline">\(-273.15^\circ C\)</span> 时，体积为 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(0K\)</span>，称为绝对零度</p><p>摄氏温度 <span class="math inline">\(t\)</span> 与绝对温度 <span class="math inline">\(T\)</span> 的关系</p><p><span class="math display">\[T = t + 273.15\]</span></p><h5 id="理想气体状态方程">理想气体状态方程</h5><p><span class="math display">\[PV = nRT = \frac{m}{M}RT\]</span></p><p>其中 <span class="math inline">\(R=8.314J/(mol \cdot K)\)</span>，<span class="math inline">\(n\)</span> 为物质的量，<span class="math inline">\(P\)</span> 为压强，<span class="math inline">\(V\)</span> 为体积，<span class="math inline">\(T\)</span> 为绝对温度</p><h4 id="气体压强和温度的统计意义">气体压强和温度的统计意义</h4><h5 id="气体的特征">气体的特征</h5><ol type="1"><li>无一定形状、体积，能充满整个容器空间</li><li>气体分子间距远大于分子的线度 L&gt;&gt;d，分子间引力很小，故气体具有高压缩性、高热膨胀率及高扩散性</li><li>气体分子以高速向四方自由运动，具有高动能</li><li>气体分子无规则热运动，频繁碰撞必产生压力</li></ol><h5 id="理想气体分子运动模型">理想气体分子运动模型</h5><ol type="1"><li>大小不计</li><li>弹性碰撞</li><li>除碰撞外其他相互作用不计</li><li>不记重力</li></ol><p>两条统计假设</p><ol type="1"><li></li></ol><p><span class="math display">\[n_\text{单位体积的分子数} = \frac{\Delta N}{\Delta V} =\frac{\mathrm{d}N}{\mathrm{d}V} =\frac{N_\text{总分子数}}{V_\text{总容积}}\]</span></p><ol start="2" type="1"><li></li></ol><p><span class="math display">\[\vec{u}_{x\text{平均速度}} \left(\sum_i^N \frac{u_{ix}}{N}\right) = \bar{u}_{y\text{平均速度}} =\bar{u}_{z\text{平均速度}} =0\]</span></p><h5 id="理想气体压强公式">理想气体压强公式</h5><p><span class="math display">\[\begin{aligned}  p = \frac{1}{3}\sum_imn_iu_i^2 = \frac{1}{3}nm\bar{u}^2\end{aligned}\]</span></p><h5 id="溫度的统计意义">溫度的统计意义</h5><p>气体的平均动能</p><p><span class="math display">\[\bar{\varepsilon}_t = \frac{1}{2}m\bar{u}^2 =\frac{3}{2}kT\]</span></p><p>对于系统而言，表示分子热运动的激烈程度</p><h3 id="麦克斯韦速率分布">麦克斯韦速率分布</h3><ul><li>标量形式</li></ul><p><span class="math display">\[f(v)= 4\pi v^2 \left(\frac{m}{2\pi kT}\right)^{\frac{3}{2}} e^{-\frac{mv^2}{2kT}}\]</span></p><ul><li>矢量形式</li></ul><p><span class="math display">\[f(\vec{v})= \left(\frac{m}{2\pi kT}\right)^{\frac{3}{2}} e^{-\frac{m\vert \vec{v}\vert ^2}{2kT}}\]</span></p><p>其在三个方向上的分量为</p><p><span class="math display">\[\begin{cases}  f(v_x) = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_x^2}\\  f(v_y) = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_y^2}\\  f(v_z) = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_z^2}\end{cases}\]</span></p><p>可以推出</p><p><span class="math display">\[\begin{cases}  \frac{\mathrm{d}N_x}{N} = f(v_x)\mathrm{d}v_x = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_x^2}\mathrm{d}v_x\\  \frac{\mathrm{d}N_y}{N} = f(v_y)\mathrm{d}v_y = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_y^2}\mathrm{d}v_y\\  \frac{\mathrm{d}N_z}{N} = f(v_z)\mathrm{d}v_z = \left(\frac{m}{2\pi kT}\right)^{\frac{1}{2}} e^{-\frac{m}{2kT}v_z^2}\mathrm{d}v_z\end{cases}\]</span></p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221129410.png" alt="Mexwell V" /><figcaption aria-hidden="true">Mexwell V</figcaption></figure><h3 id="麦克斯韦速率分布应用">麦克斯韦速率分布应用</h3><h4 id="最可几速率">最可几速率</h4><p><span class="math display">\[\begin{aligned}  &amp;\frac{\mathrm{d}f(v)}{\mathrm{d}v} = 0\\  \Rightarrow &amp;v_p=\sqrt{\frac{2kT}{m}} = \sqrt{\frac{2RT}{M}}\end{aligned}\]</span></p><h4 id="平均速率">平均速率</h4><p><span class="math display">\[\bar{v} = \int_0^{\infty} v f(v) \mathrm{d}v = \sqrt{\frac{8kT}{\pi m}} = \sqrt{\frac{8RT}{\pi M}}\]</span></p><h4 id="均方根速率">均方根速率</h4><p><span class="math display">\[\sqrt{\bar{v}^2} = \sqrt{\int_0^{\infty} v^2 f(v) \mathrm{d}v} = \sqrt{\frac{3kT}{m}} = \sqrt{\frac{3RT}{M}}\]</span></p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505221314126.png" alt="MaxwellDistributionApplication" /><figcaption aria-hidden="true">MaxwellDistributionApplication</figcaption></figure><h4 id="一些应用">一些应用</h4><p>设箱体的分子密度为 <span class="math inline">\(n\)</span>，求单位时间内单位面积碰撞到墙体的分子数</p><p><span class="math display">\[\begin{aligned}  N&amp;=n\bar{v}S\\  &amp;=nS\int_0^\infty f(v_x)v_x\,\mathrm{d}v_x\\  &amp;=\boxed{\frac{1}{4}nS\bar{v}}\end{aligned}\]</span></p><h4 id="玻尔兹曼分布">玻尔兹曼分布</h4><p><span class="math display">\[\mathrm{d} N = n_0 e^{-\frac{\varepsilon_p}{k_BT}}\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><p><span class="math display">\[n_i = n_0 e^{-\frac{E_i}{kT}}\]</span></p><h6 id="空气中气体分子在重力场中的密度分布">空气中气体分子在重力场中的密度分布</h6><h4 id="能量均分定理">能量均分定理</h4><h5 id="分子的自由度">分子的自由度</h5><table><thead><tr class="header"><th style="text-align: center;">分子原子数</th><th style="text-align: center;">总自由度</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">多</td><td style="text-align: center;">6</td></tr></tbody></table><p>对于多原子分子，其内能为</p><p><span class="math display">\[U = \frac{f}{2}NkT = \frac{f}{2} PV\]</span></p><p>其中 <span class="math inline">\(f\)</span> 为分子的自由度，<span class="math inline">\(N\)</span> 为分子数</p><h2 id="热力学第一定律-1">热力学第一定律</h2><p><span class="math display">\[Q = \Delta E + W\]</span></p><h3 id="比热容">比热容</h3><h4 id="等容过程">等容过程</h4><p><span class="math display">\[\begin{align}  \Delta V &amp; = 0\\  A &amp; = 0\\  \Delta Q &amp;= \Delta E\\  C_V &amp;= \frac{\Delta Q}{\Delta T} = \frac{\mathrm{d}E}{\mathrm{d}T} = \frac{i}{2}R\end{align}\]</span></p><p><span class="math display">\[\Delta E = \frac{i}{2}R\Delta T = \frac{i}{2}V\Delta P\]</span></p><h4 id="等温过程">等温过程</h4><p><span class="math display">\[\begin{aligned}  \Delta T &amp; = 0\\  \Delta E &amp; = 0\\  \Delta Q &amp; = W \\  \mathrm{d}Q &amp;= \mathrm{d}A \\  &amp;= P\mathrm{d}V \\  &amp;= nRT \frac{1}{V}\,\mathrm{d}V\end{aligned}\]</span></p><p>则 <span class="math inline">\(Q = nRT \ln\frac{V_2}{V_1}\)</span></p><h4 id="等压过程">等压过程</h4><p><span class="math display">\[\begin{aligned}  \mathrm{d}Q_P &amp;= \mathrm{d}E + P\mathrm{d}V\\  Q_P &amp;= \Delta E + P\Delta V\\  &amp;= \frac{i}{2} nR\Delta T + nR\Delta V\\  &amp;= \frac{i+2}{2} nR\Delta T\\\end{aligned}\]</span></p><p><span class="math display">\[C_P = \frac{\Delta Q}{\Delta T} = \frac{i+2}{2}R = C_V +R\]</span></p><p>热容比</p><p><span class="math display">\[\gamma = \frac{C_P}{C_V} = 1+\frac{R}{C_P} = \frac{i+2}{i}\]</span></p><h4 id="绝热过程">绝热过程</h4><p>绝热过程是指系统与外界没有热量交换的过程</p><p>准静态绝热过程方程</p><p><span class="math display">\[PV^\gamma = \text{const}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>物理</tag>
      
      <tag>力学</tag>
      
      <tag>热力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理方法笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E6%95%B0%E7%90%86%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E6%95%B0%E7%90%86%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="几类偏微分方程的导出和定解问题">几类偏微分方程的导出和定解问题</h2><h3 id="偏微分方程的基本概念">偏微分方程的基本概念</h3><h4 id="什么是微分方程">什么是微分方程</h4><p>函数 <span class="math inline">\(u\)</span> 关于 <span class="math inline">\(t\)</span> 及 <span class="math inline">\((x,y,z)\)</span> 的各阶偏导数满足的关系式</p><p>一般形式：</p><p><span class="math display">\[F(x_1,x_2,\ldots,x_n,u,\mathrm{D}u,\mathrm{D}^2u,\ldots,\mathrm{D}^Nu)=0\]</span></p><p>其中</p><ul><li><span class="math inline">\(\displaystyle(x_1,x_2,\ldots,x_n)\)</span> 为自变量</li><li><span class="math inline">\(\displaystyle u=u(x_1,x_2,\ldots,x_n)\)</span> 为未知函数</li><li><span class="math inline">\(\displaystyle \mathrm{D}u=\left(\frac{\partial u}{\partial x_1},\frac{\partial u}{\partial x_2},\ldots,\frac{\partial u}{\partial x_n}\right)\)</span></li><li><span class="math inline">\(\displaystyle\mathrm{D}^ku=\left(\frac{\partial^ku}{\partial x_1^{k_1}\partial x_2^{k_2}\ldots\partial x_n^{k_n}},k_1+k_2+\ldots+k_n=k\right)\)</span>，其中 <span class="math inline">\(k=1,2,\ldots,N\)</span></li></ul><h4 id="相关基本概念">相关基本概念</h4><ul><li>阶：未知函数偏导数的最高阶数</li><li>维数：空间变量的个数</li><li>发展型方程：包含时间变量 <span class="math inline">\(t\)</span> 的偏微分方程的统称</li><li>对于非发展型方程，维数等于自变量个数</li><li>解： 在求解区域 <span class="math inline">\((x_1,x_2,\ldots,x_n)\in\Omega\)</span> 中，称 <span class="math inline">\(u=\varphi(x_1,x_2,\ldots,x_n)\)</span> 是方程的经典解 在 <span class="math inline">\(\Omega\)</span> 内，方程出现的个街道数都存在且连续，并且能满足方程<ul><li>间断解：本身或者导数有跳跃</li></ul></li><li>自由项：方程中不含未知函数及其导数的项</li><li>齐次方程：自由项为 <span class="math inline">\(0\)</span> 的方程</li><li>非齐次方程：自由项不为 <span class="math inline">\(0\)</span> 的方程</li></ul><h5 id="按照是否线性对方程进行分类">按照是否线性对方程进行分类</h5><h6 id="线性方程">线性方程</h6><p>方程中未知函数及其各阶导数均以一次幂出现，且各项系数仅为自变量的函数</p><p><span class="math display">\[\hat{G}u=g(x_1,x_2,\ldots,x_n)\Rightarrow\hat{G}(au+bv)=a\hat{G}u+b\hat{G}v\]</span></p><p>其基本形式为</p><p><span class="math display">\[\sum_{\sum a_i\leq N}A_{a_i}(x)D^a u = g(x)\]</span></p><h6 id="非线形方程">非线形方程</h6><p><strong>半线性</strong></p><p>含有最高阶导数的部分线性</p><p><span class="math display">\[\sum_{\sum a_i= N}A_{a_i}(x)D^a u + A_0(x,u,\mathrm{D}u,\ldots,\mathrm{D}^{N-1}u)=g(x)\]</span></p><p><strong>拟线性</strong></p><p>最高阶导数本身是线性的，也就是说最高阶导数的系数可以含有未知函数及其低阶导数</p><p><span class="math display">\[\sum_{\sum a_i= N}A_{a_i}(x,u,Du,\ldots,D^{N-1}u)D^a u +A_0(x,u,\mathrm{D}u,\ldots,\mathrm{D}^{N-1}u) = g(x)\]</span></p><p><strong>完全非线性</strong></p><p>最高阶导数部分也是非线性的</p><h3 id="三类偏微分方程的导出和定解问题">三类偏微分方程的导出和定解问题</h3><h4 id="弦振动热传导调和方程的导出定解问题">弦振动、热传导、调和方程的导出，定解问题</h4><h5 id="弦振动方程">弦振动方程</h5><p>一条弦固定在区间 <span class="math inline">\([0,L]\)</span> 上，密度为 <span class="math inline">\(\rho\)</span>，在平衡处附近做微小的振动，记 <span class="math inline">\(u(t,x)\)</span> 为弦在时刻 <span class="math inline">\(t\)</span> 处于位置 <span class="math inline">\(x\)</span> 的位移，满足以下的微分方程</p><p><span class="math display">\[\begin{equation}u_{tt} -a^2u_{xx}=F(t,x), \quad 0 &lt; x &lt; L, \quad t &gt; 0\end{equation}\]</span></p><p>其中 <span class="math inline">\(a\)</span> 为待定的弦的波速</p><p>在弦振动方程中，若 <span class="math inline">\(F\equiv 0\)</span>，则称为其次方程，否则为非齐次方程</p><h6 id="弦振动方程的证明">弦振动方程的证明</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202509190831381.png" alt="微小的弦" /><figcaption aria-hidden="true">微小的弦</figcaption></figure><p>任取一段弦 <span class="math inline">\([x,x+\Delta x]\)</span>，这段弦的长度为</p><p><span class="math display">\[\Delta s = \int_x^{x+\Delta x}\sqrt{1+\left(\frac{\partial u}{\partial x}\right)^2}\,\mathrm{d}x.\]</span></p><p>其中 <span class="math inline">\(\left\vert\frac{\partial u}{\partial x}\right\vert\ll 1\)</span>，则 <span class="math inline">\(\Delta s \approx \Delta x\)</span>，则其弹力与时间无关，设为 <span class="math inline">\(T(x)\)</span></p><p>我们分别在水平方向和竖直方向上对这段弦进行受力分析</p><ol type="1"><li><p>水平方向上速度为 <span class="math inline">\(0\)</span>，则其受力平衡</p><p><span class="math display">\[T(x+\Delta x)\cos\beta - T(x)\cos\alpha = 0\]</span></p><p>其中 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 分别为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(x+\Delta x\)</span> 处的切线与水平线的夹角，由于假设弦在平衡位置附近做微小振动，则 <span class="math inline">\(\cos\alpha \approx 1\)</span>， <span class="math inline">\(\cos\beta \approx 1\)</span>，则可以得到弹力为恒定的，计为 <span class="math inline">\(T\)</span></p></li><li><p>在竖直方向( <span class="math inline">\(u^+\)</span> )上进行受力分析，受到的力有</p><ul><li>重力 <span class="math inline">\(\rho\Delta s g\)</span>，方向向下</li><li>弹力 <span class="math inline">\(T(x)\sin\theta\)</span>，默认方向向上</li><li>外力 <span class="math inline">\(F(t,x)\Delta s\)</span></li></ul><p><span class="math display">\[\rho\Delta s \frac{\partial^2u}{\partial x^2}=T(\sin\beta - \sin\alpha) + F(t,x)\Delta s - \rho\Delta s g\]</span></p><p>其中 <span class="math inline">\(\displaystyle\lim_{\theta\to 0}\sin\theta = \lim_{\theta\to 0}\tan\theta\)</span>，再将 <span class="math inline">\(\Delta s = \Delta x\)</span> 代入上式，得到</p><p><span class="math display">\[\rho\Delta x \frac{\partial^2u}{\partial t^2}=T(\frac{\partial u}{\partial x}(x+\Delta x) - \frac{\partial u}{\partial x}(x)) + F(t,x)\Delta x - \rho\Delta x g\]</span></p><p>再令 <span class="math inline">\(\Delta x \to 0\)</span>，得到</p><p><span class="math display">\[\rho \frac{\partial^2u}{\partial t^2} = T\frac{\partial^2u}{\partial x^2} + F(t,x)-\rho g\]</span></p><p>我们令 <span class="math inline">\(a^2 = \frac{T}{\rho},F(t,x)=\frac{f(t,x)}{\rho}\)</span>，并且忽略 <span class="math inline">\(g\)</span> 则得到 <span class="math inline">\(\boxed{弦振动方程}\)</span></p><p><span class="math display">\[u_{tt} -a^2u_{xx}=F(t,x), \quad 0 &lt; x &lt; L, \quad t &gt; 0\]</span></p></li></ol><h6 id="弦振动方程的定解问题">弦振动方程的定解问题</h6><p><strong>初值条件</strong></p><p>当一条弦足够长并且需要研究远离两端的点的振动情况时，可以假设弦无限长</p><p><span class="math display">\[\left\{    \begin{aligned}        &amp;u_{tt}-a^2u_{xx}=F(t,x),\\        &amp;u(0,x)=\varphi(x),\\        &amp;u_t(0,x)=\psi(x).    \end{aligned}\right.\]</span></p><p>这三个条件分别表示了方程本身、初始位移和初始速度</p><p>这个问题被称为弦振动方程的 <strong>初值问题</strong>或者 <strong>Cauchy 问题</strong></p><p><strong>边界条件</strong></p><p>当我们要考虑的弦在一个有限的区间 <span class="math inline">\(I=[0,L]\)</span> 上的振动情况时，需要给出边界条件，即弦在端点处的条件</p><p>我们以一个端点 <span class="math inline">\(x=a\)</span> 为例，常见的边界条件有以下三种</p><ol type="1"><li><p>Dirichlet 边界条件：</p><p><span class="math display">\[u(t,a)=\varphi(t),\forall t&gt; 0\]</span></p></li><li><p>Neumann 边界条件：</p><p><span class="math display">\[u_x(t,a)=\mu(t),\forall t&gt; 0\]</span></p><p>这表示了端点处的力。特别的，当 <span class="math inline">\(\mu(t)= 0\)</span> 时，表示端点处没有力的作用，称为自由条件</p></li><li><p>Robin 边界条件：</p><p><span class="math display">\[\begin{aligned} &amp;T\frac{\partial u}{\partial x}(t,a)-ku(t,a)=0\\ \Rightarrow &amp;\left(\frac{\partial u}{\partial x}-\sigma u\right)|_{x=a}=0\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\sigma = \frac{k}{T}\)</span> 表示弦的一端与一线性弹簧连接</p><p>若弹簧为非线性的，则有</p><p><span class="math display">\[\left(\frac{\partial u}{\partial x}-\sigma (u)\right)|_{x=a}=0\]</span></p></li></ol><h5 id="热传导方程">热传导方程</h5><p>温度分布与时间的关系为热传导方程，同样的物质的浓度分布与时间的关系也满足热传导方程。</p><p>物体的温度为 <span class="math inline">\(u(t,x)\)</span>，则热传导方程为：</p><p><span class="math display">\[u_t-a^2\Delta u=\tilde{f}\]</span></p><p>其中 <span class="math inline">\(\displaystyle\Delta=\nabla^2=\sum\frac{\partial^2}{\partial {x_i}^2}\)</span> 为 Laplace 算子</p><h6 id="热传导方程的证明">热传导方程的证明</h6><p>三维空间 <span class="math inline">\(\mathbb{R}^3\)</span> 中的物体 <span class="math inline">\(\Omega\)</span>，设其温度分布函数为 <span class="math inline">\(u(t,x_1,x_2,x_3)\)</span>，比热容均匀为 <span class="math inline">\(c\)</span></p><p>我们取 <span class="math inline">\(\Omega\)</span> 上的一个子区域 <span class="math inline">\(D\)</span>，分析其在时间 <span class="math inline">\(t_1\)</span> 到 <span class="math inline">\(t_2\)</span> 之间的热量变化</p><p><span class="math inline">\(D\)</span> 上温度变化需要的热量为</p><p><span class="math display">\[Q=\int_D c\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\,\mathrm{d}V\]</span></p><p><span class="math inline">\(Q\)</span> 的来源有两个</p><ol type="1"><li><span class="math inline">\(D\)</span> 的边界 <span class="math inline">\(\partial D\)</span> 处流入的热量 <span class="math inline">\(Q_1\)</span></li><li><span class="math inline">\(D\)</span> 内部的热源提供的热量 <span class="math inline">\(Q_2\)</span></li></ol><p>热量的传导满足 Fourier 实验定律：对给定 <span class="math inline">\(\Omega\)</span> 内的任意一个界面，从界面的一侧传导到另一侧的热量与温度沿该界面的法向的导数大小、界面的面积、传导的时间段成正比</p><p><span class="math display">\[\mathrm{d}Q=-k\frac{\partial u}{\partial \vec{n}}\mathrm{d}s\mathrm{d}t.\]</span></p><p>则 <span class="math inline">\(D\)</span> 的边界 <span class="math inline">\(\partial D\)</span> 处流入的热量 <span class="math inline">\(Q_1\)</span> 为</p><p><span class="math display">\[Q_1=\int_{t_1}^{t_2}\int_{\partial D}k\frac{\partial u}{\partial \vec{n}}\,\mathrm{d}S\mathrm{d}t\]</span></p><p>物体内部热源产热量 <span class="math inline">\(Q_2\)</span> 为</p><p><span class="math display">\[Q_2=\int_{t_1}^{t_2}\int_D f(t,x_1,x_2,x_3)\,\mathrm{d}V\mathrm{d}ts\]</span></p><p>其中 <span class="math inline">\(f(t,x_1,x_2,x_3)\)</span> 为单位体积在单位时间内产生的热量</p><p>在 <span class="math inline">\(t_1\)</span> 到 <span class="math inline">\(t_2\)</span> 之间，热量守恒定律告诉我们</p><p><span class="math display">\[Q=Q_1+Q_2\]</span></p><p>即</p><p><span class="math display">\[\int_D c\rho(u(t_2,x_1,x_2,x_3)-u(t_1,x_1,x_2,x_3))\,\mathrm{d}V=\int_{t_1}^{t_2}\int_{\partial D}k\frac{\partial u}{\partial \vec{n}}\,\mathrm{d}S\mathrm{d}t+\int_{t_1}^{t_2}\int_D f(t,x_1,x_2,x_3)\,\mathrm{d}V\mathrm{d}t\]</span></p><p>变换得到</p><p><span class="math display">\[\int_{t_1}^{t_2}\int_D c\rho\frac{\partial u}{\partial t}\,\mathrm{d}V\mathrm{d}t=\int_{t_1}^{t_2}\int_{D}\operatorname{div}(k\cdot\nabla u)\,\mathrm{d}V\mathrm{d}t+\int_{t_1}^{t_2}\int_D f(t,x_1,x_2,x_3)\,\mathrm{d}V\mathrm{d}t\]</span></p><p>即</p><p><span class="math display">\[c\rho\frac{\partial u}{\partial t}=k\nabla^2 u+f(t,x_1,x_2,x_3)\]</span></p><p>令 <span class="math inline">\(a^2=\frac{k}{c\rho},\tilde{f}=\frac{f}{c\rho}\)</span>，并用 Laplace 算子代替 <span class="math inline">\(\nabla^2\)</span> 则得到热传导方程</p><p><span class="math display">\[u_t-a^2\Delta u=\tilde{f}\]</span></p><h6 id="热传导方程的定解问题">热传导方程的定解问题</h6><p><strong>初值条件</strong></p><p>只需要给出初始的温度分布</p><p><span class="math display">\[u(0,x_1,x_2,x_3)=\varphi(x_1,x_2,x_3)\]</span></p><p><strong>边界条件</strong></p><p>为了由热传导方程及其初值条件得到温度分布函数，还需要给定在边界 <span class="math inline">\(\partial\Omega\)</span> 上的边界条件</p><ol type="1"><li><p>Dirichlet 边界条件：</p><p><span class="math display">\[u(t,x_1,x_2,x_3)|_{\partial\Omega}=\varphi(t,x_1,x_2,x_3),\forall t&gt;0,x\in\partial\Omega,\]</span></p><p>这表明了边界上的温度变化情况</p></li><li><p>Neumann 边界条件：</p><p><span class="math display">\[\frac{\partial u}{\partial \vec{n}}(t,x_1,x_2,x_3)|_{\partial\Omega}=\mu(t,x_1,x_2,x_3),\forall t&gt;0,x\in\partial\Omega,\]</span></p><p>这表明了边界上热量的传递情况</p><p>特别的，当 <span class="math inline">\(\mu(t,x_1,x_2,x_3)\equiv 0\)</span> 时，表示边界上没有热量传递，称为绝热条件</p></li><li><p>Robin 边界条件：当物体处在一个温度为 <span class="math inline">\(u_0\)</span> 的介质中，物体与介质的热传导符合 Newton 交换律，物体 <span class="math inline">\(\Omega\)</span> 在边界与介质交换的热流量与物体表面的温度 <span class="math inline">\(u\)</span> 与介质在物面的温度 <span class="math inline">\(u_0\)</span> 之差成正比，也与物面面积及交换的时间成正比，从物体表面流出的热量是</p><p><span class="math display">\[\mathrm{d}Q=-k_1(u-u_0)\mathrm{d}s\mathrm{d}t.\]</span></p><p>在边界上流入的热量必须等于流出的热量，则</p><p><span class="math display">\[-k\frac{\partial u}{\partial \vec{n}}=k_1(u-u_0)\]</span></p><p>整理得到</p><p><span class="math display">\[\left(\frac{\partial u}{\partial \vec{n}}+\sigma u\right)\vert_{\partial \Omega}=\varphi(t,x_1,x_2,x_3)\]</span></p></li></ol><h5 id="调和方程">调和方程</h5><p>调和方程常用于描述保守力场中的势函数</p><p><span class="math display">\[\Delta u = \phi\]</span></p><p>当 <span class="math inline">\(\phi \equiv 0\)</span> 时，称为 Laplace 方程，否则称为 Poisson 方程</p><h6 id="调和方程的证明">调和方程的证明</h6><p><strong>Laplace 方程</strong></p><p>在空间 <span class="math inline">\(\mathbb{R}^3\)</span> 中，有一物体 <span class="math inline">\(D\)</span>，其密度为 <span class="math inline">\(\rho(x,y,z)\)</span>，在 <span class="math inline">\(D\)</span> 外有一点 <span class="math inline">\(P(x,y,z)\)</span> 有一单位质量的物体</p><p>物体中质心在 <span class="math inline">\((\varepsilon,\eta,\zeta)\)</span> 的一微元对 <span class="math inline">\(P\)</span> 处物体的引力为</p><p><span class="math display">\[\mathrm{d}\vec{F}=k\int_D\frac{\rho}{r^2}\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta\]</span></p><p>但是不推导这个好像对最终结果没有什么影响，不管了</p><p>引力势能为</p><p><span class="math display">\[u(x,y,z)=int_D\frac{\rho}{r}\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta\]</span></p><p>则</p><p><span class="math display">\[\Delta u = \Delta\left(\int_D\frac{\rho}{r}\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta\right) = \int_D\rho\Delta\left(\frac{1}{r}\right)\,\mathrm{d}\varepsilon\mathrm{d}\eta\mathrm{d}\zeta= 0\]</span></p><p><strong>Poisson 方程</strong></p><p>我们考虑真空中的静电场，这是由一个电荷分布为 <span class="math inline">\(\rho(x,y,z)\)</span> 的物体 <span class="math inline">\(D\)</span> 产生的</p><p>我们由 Gauss 定律可得</p><p><span class="math display">\[\int_s\vec{E}\mathrm{d}S=\frac{1}{\varepsilon_0}\iiint_V\rho\,\mathrm{d}V\]</span></p><p>由 Green 定理可得</p><p><span class="math display">\[\int_s\vec{E}\mathrm{d}S=\iiint_V\vec{\nabla}\cdot\vec{E}\,\mathrm{d}V=\frac{1}{\varepsilon_0}\iiint_V\rho\,\mathrm{d}V\]</span></p><p>则</p><p><span class="math display">\[\iiint_V\vec{\nabla}\cdot\vec{E}\,\mathrm{d}V=\frac{1}{\varepsilon_0}\iiint_V\rho\,\mathrm{d}V\]</span></p><p>我们去掉积分号，得到</p><p><span class="math display">\[\vec{\nabla}\cdot\vec{E}=\frac{\rho}{\varepsilon_0}\]</span></p><p>由电场的保守性可知，存在一个电势函数 <span class="math inline">\(u\)</span>，使得 <span class="math inline">\(\vec{E}=-\vec{\nabla}u\)</span>，则</p><p><span class="math display">\[\vec{\nabla}\cdot\vec{E}=-\vec{\nabla}\cdot\vec{\nabla}u=-\Delta u=\]</span></p><p>所以我们得到 Poisson 方程</p><p><span class="math display">\[\Delta u = -\frac{\rho}{\varepsilon_0}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学 2 笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B02%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B02%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="重积分">重积分</h2><h3 id="重积分的概念和性质">重积分的概念和性质</h3><h4 id="二重积分的概念">二重积分的概念</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(D\)</span> 是平面上的有界闭区域，<span class="math inline">\(f(x,y)\)</span> 为 <span class="math inline">\(D\)</span> 上的有界函数，<span class="math inline">\(I\)</span> 为实数.若对 <span class="math inline">\(D\)</span> 的任意分割 <span class="math inline">\(\Delta D_1 , \Delta D_2 , \cdots , \Delta D_n\)</span> ，任取 <span class="math inline">\((\xi_i , \eta_i)\in\Delta D_i(i=1,\ldots,n)\)</span>，作和 <span class="math inline">\(\displaystyle\sum_{i=1}^nf(\xi_i,\eta_i)\Delta \sigma_i\)</span> （<span class="math inline">\(\Delta \sigma_i\)</span> 为 <span class="math inline">\(D_i\)</span> 的面积），总有</p><p><span class="math display">\[\lim_{\lambda\to 0}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta \sigma_i = I\]</span></p><p>其中 <span class="math inline">\(\displaystyle\lambda = \max_{1\leq i\leq d} \{d_i\}\)</span>，<span class="math inline">\(d_i\)</span> 是小区域 <span class="math inline">\(\Delta D_i\)</span> 的直径，则称函数 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\(D\)</span> 上<strong>可积</strong>，记为 <span class="math inline">\(f\in R(D)\)</span>；极限值 <span class="math inline">\(I\)</span> 称为 <span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\(D\)</span> 上的<strong>二重积分</strong>，记作</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma.\]</span></p><ul><li><p><span class="math inline">\(\displaystyle \iint\)</span> 积分号</p></li><li><p><span class="math inline">\(D\)</span> 积分区域</p></li><li><p><span class="math inline">\(f(x,y)\)</span> 被积函数</p></li><li><p><span class="math inline">\(\mathrm{d}\sigma\)</span> 面积元素（微元）</p></li><li><p>二重积分的几何意义</p><ul><li>当被积函数大于 <span class="math inline">\(0\)</span> 时，二重积分是柱体体积</li><li>当被积函数小于 <span class="math inline">\(0\)</span> 时，二重积分是柱体体积的负值</li><li>一般的，为曲顶柱体体积的代数和</li></ul></li><li><p>可积的充分条件</p><ul><li><strong>定理：</strong> 若函数 <span class="math inline">\(f(x,y)\)</span> 在区域 <span class="math inline">\(D\)</span> 上连续，则 <span class="math inline">\(f(x,y)\in D\)</span>.</li></ul></li><li><p><span class="math inline">\(f(x,y)\)</span> 在 <span class="math inline">\(D\)</span> 上的可积性及积分值与其在 <span class="math inline">\(D\)</span> 内<strong>有限条光滑曲线</strong>上的定义无关</p></li></ul><h3 id="二重积分的性质">二重积分的性质</h3><ol type="1"><li><p><span class="math inline">\(\displaystyle\iint_D\,\mathrm{d}\sigma = \iint_D 1\,\mathrm{d}\sigma = A_D \quad\left(\text{D 的面积}\right)\)</span>.</p></li><li><p><strong>线性性：</strong> 设 <span class="math inline">\(f,g\in R(D)\)</span>，<span class="math inline">\(\alpha , \beta\)</span>，是任意常数，则 <span class="math inline">\(\alpha f +\beta g \in R(D)\)</span>，且</p><p><span class="math display">\[\iint_D (\alpha f +\beta g)\,\mathrm{d}\sigma = \alpha \iint_D f\,\mathrm{d}\sigma + \beta \iint_D g\,\mathrm{d}\sigma\]</span></p></li><li><p><strong>区域可加性：</strong> 若 <span class="math inline">\(f\in R(D)\)</span> 且积分区域 <span class="math inline">\(D\)</span> 分为内部不相交的子区域 <span class="math inline">\(D_1 , D_2\)</span>，则</p><p><span class="math display">\[\iint_D f(x,y) \,\mathrm{d}\sigma = \iint_{D_1} f(x,y)\,\mathrm{d}\sigma + \iint_{D_2} f(x,y)\,\mathrm{d}\sigma\]</span></p></li><li><p><strong>保序性：</strong> 若 <span class="math inline">\(f,g\in R(D)\)</span>，且当 <span class="math inline">\((x,y)\in D\)</span> 时，<span class="math inline">\(f(x,y)\leq g(x,y)\)</span>，则</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma \leq \iint_D g(x,y)\,\mathrm{d}\sigma\]</span></p><ul><li><strong>推论 1：</strong> 若 <span class="math inline">\(f\in R(D)\)</span> ,则 <span class="math inline">\(\vert f(x,y) \vert \in R(D)\)</span>，且</li></ul><p><span class="math display">\[ \left\vert \iint_D f(x,y)\,\mathrm{d}\sigma \right\vert \leq \iint_D \vert f(x,y) \vert \,\mathrm{d}\sigma\]</span></p><ul><li><strong>推论 2：</strong> 若 <span class="math inline">\(f\in R(D)\)</span>，且当 <span class="math inline">\((x,y)\in D\)</span> 时， <span class="math inline">\(m\leq f(x,y) \leq M\)</span>，则</li></ul><p><span class="math display">\[ mA_D \leq \iint_D f(x,y)\,\mathrm{d}\sigma \leq MA_D\]</span></p><ul><li><strong>推论 3：</strong> 若 <span class="math inline">\(f\in R(D)\)</span>，且当 <span class="math inline">\((x,y)\in D\)</span> 时，<span class="math inline">\(f(x,y) \geq 0\)</span>，则</li></ul><p><span class="math display">\[ \iint_D f(x,y)\,\mathrm{d}\sigma \geq 0\]</span></p></li><li><p><strong>积分中值定理：</strong> 若 <span class="math inline">\(f(x,y)\in C(D)\)</span> ，<span class="math inline">\(g(x,y)\in R(D)\)</span>，且 <span class="math inline">\(g\)</span> 在 <span class="math inline">\(D\)</span> 上不变号，则 <span class="math inline">\(\exists \xi , \eta \in D\)</span>，使得</p><p><span class="math display">\[\iint_D f(x,y)g(x,y)\,\mathrm{d}\sigma = f(\xi ,\eta )\iint_D g(x,y)\,\mathrm{d}\sigma\]</span></p><ul><li><strong>推论：</strong> 若 <span class="math inline">\(f(x,y)\in C(D)\)</span>，则存在 <span class="math inline">\((\xi , \eta )\in D\)</span>，使得</li></ul><p><span class="math display">\[ \iint_D f(x,y)\,\mathrm{d}\sigma = f(\xi ,\eta )A_D\]</span></p><p>称 <span class="math inline">\(f(\xi,\eta) = \frac{\iint_D f\,\mathrm{d}\sigma}{A_D}\)</span> 为函数 <span class="math inline">\(f(x,y)\)</span> 在有界闭区域 <span class="math inline">\(D\)</span> 上的<strong>平均值</strong></p></li></ol><h3 id="二重积分的计算">二重积分的计算</h3><h4 id="直角坐标系下的计算">直角坐标系下的计算</h4><p>当二重积分存在时，可利用平行于坐标轴的直线来划分积分区域 <span class="math inline">\(D\)</span>，此时，面积元素</p><p><span class="math display">\[\mathrm{d}\sigma = \mathrm{d}x\mathrm{d}y\]</span></p><p>故二重积分在直角坐标系下可表示为</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \iint_D f(x,y)\,\mathrm{d}x\mathrm{d}y\]</span></p><h5 id="x-型正则区域"><span class="math inline">\(x\)</span> 型正则区域</h5><p><span class="math display">\[D = \left\{(x,y)\bigg| \varphi_1(x)\leq y\leq \varphi_2(x),a\leq x\leq b\right\}\]</span></p><p>化为先 <span class="math inline">\(y\)</span> 后 <span class="math inline">\(x\)</span> 的二次积分</p><p><span class="math display">\[\begin{aligned}    \iint_D f(x,y)\,\mathrm{d}x\mathrm{d}y &amp;= \int_a^b\left[\int_{\varphi_1(x)}^{\varphi_2(x)} f(x,y)\,\mathrm{d}y\right]\mathrm{d}x \\    &amp;\equiv \int_a^b f(x,y)\,\mathrm{d}x\mathrm{d}y\end{aligned}\]</span></p><h5 id="y-型正则区域"><span class="math inline">\(y\)</span> 型正则区域</h5><p><span class="math display">\[D = \left\{(x,y)\bigg| \varphi_1(y)\leq x\leq \varphi_2(y),c\leq y\leq d\right\}\]</span></p><p>化为先 <span class="math inline">\(x\)</span> 后 <span class="math inline">\(y\)</span> 的二次积分</p><p><span class="math display">\[\begin{aligned}    \iint_D f(x,y)\,\mathrm{d}x\mathrm{d}y &amp;= \int_c^d\left[\int_{\varphi_1(y)}^{\varphi_2(y)} f(x,y)\,\mathrm{d}x\right]\mathrm{d}y \\    &amp;\equiv \int_c^d f(x,y)\,\mathrm{d}x\mathrm{d}y\end{aligned}\]</span></p><h5 id="一般区域的二重积分">一般区域的二重积分</h5><p>分割成若干个正则子区域，利用积分区域可加性，分别在子区域上积分后求和</p><blockquote><p>直角坐标计算二重积分的步骤</p><ol type="1"><li><strong>画出积分区域</strong> <span class="math inline">\(D\)</span> 的草图，并<strong>确定类型</strong></li><li>按照所确定的类型<strong>表示区域</strong> <span class="math inline">\(D\)</span></li><li><strong>化二重积分为二次积分</strong>（注意上下限）</li><li><strong>计算</strong>二重积分</li></ol></blockquote><h4 id="极坐标系下的计算">极坐标系下的计算</h4><p>当积分区域的边界曲线或被积函数用极坐标表示较为简单时，可用极坐标来计算二重积分.</p><p>面积元素 <span class="math inline">\(\Delta \sigma\)</span> 在极坐标下为</p><p><span class="math display">\[\boxed{\Delta\sigma= r\mathrm{d}r\mathrm{d}\theta}\]</span></p><p>从直角坐标到极坐标时的二重积分变换公式为</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \iint_D f(r\cos\theta,r\sin\theta)r\,\mathrm{d}r\mathrm{d}\theta\]</span></p><p><span class="math display">\[\left\{\left(r,\theta\right)\left \vert r_1(\theta)\leq r \leq r_2(\theta) , \alpha \leq \theta \leq \beta \right.\right\}\]</span></p><p>则</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \int_\alpha^\beta\, \mathrm{d}\theta\int_{r_1(\theta)}^{r_2(\theta)} f(r\cos\theta,r\sin\theta)r\,\mathrm{d}r\]</span></p><h4 id="二重积分的变量代换">二重积分的变量代换</h4><p><strong>定理：</strong></p><p>设变换 <span class="math inline">\(\displaystyle T :\begin{cases}x=x(u,v)\\y=y(u,v)\end{cases}\)</span> 有连续偏导数，且满足 <span class="math inline">\(\displaystyle J = \frac{\partial (x,y)}{\partial (u,v)}\coloneqq \begin{vmatrix}x_u ,x_v\newline y_u,y_v\end{vmatrix} \left(\text{Jacobi 行列式}\right)\neq 0\)</span>，而 <span class="math inline">\(f(x,y)\in C(D)\)</span>，则</p><p><span class="math display">\[\iint_D f(x,y)\,\mathrm{d}\sigma = \iint_{D^*} f(x(u,v),y(u,v))\left\vert J \right\vert \,\mathrm{d}u\mathrm{d}v\]</span></p><ul><li><p>在定理条件下，变换 <span class="math inline">\(T\)</span> 一定存在逆变换 <span class="math inline">\(T^{-1}:\begin{cases}u=u(x,y)\\v=v(x,y)\end{cases}\)</span>，且 <span class="math inline">\(\frac{\partial (u,v)}{\partial (x,y)}\cdot \frac{\partial (x,y)}{\partial (u,v)} = 1\)</span></p><p>有时，借助此式求 <span class="math inline">\(J\)</span> 较为简单</p></li><li><p>当 Jacobi 行列式仅在区域 <span class="math inline">\(D^*\)</span> 内个别点上或个别曲线上为 <span class="math inline">\(0\)</span> 时，定理结论仍成立</p></li><li><p>在广义极坐标 <span class="math inline">\(\begin{cases}x=ar\cos\theta\\y=br\sin\theta\end{cases}\)</span> 下，<span class="math inline">\(J = abr\)</span></p></li></ul><h3 id="三重积分">三重积分</h3><h4 id="三重积分的定义">三重积分的定义</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(\Omega\)</span> 是 <span class="math inline">\(\mathbb{R}^3\)</span> 中的有界闭区域，三元函数 <span class="math inline">\(f(x,y,z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上有界，<span class="math inline">\(I\)</span> 为实数. 若将 <span class="math inline">\(\Omega\)</span> 任意分割成 <span class="math inline">\(n\)</span> 个小区域 <span class="math inline">\(\Delta \Omega_1,\Delta\Omega_2,\ldots,\Delta\Omega_n\)</span>，任取 <span class="math inline">\(\left(\varepsilon_i,\eta_i,\xi_i \right)\in\Delta\Omega_i\left(i=1,2,\ldotp,n\right)\)</span>，作和 <span class="math inline">\(\displaystyle\sum_{i=1}^nf\left(\varepsilon_i,\eta_i,\xi_i \right)\Delta V_i\)</span>，（<span class="math inline">\(\Delta V_i\)</span> 是 <span class="math inline">\(\Delta\Omega_i\)</span> 的体积），总有</p><p><span class="math display">\[\lim_{\lambda\to 0}\sum_{i=1}^nf\left(\varepsilon_i,\eta_i,\xi_i \right)\Delta V_i = I\]</span></p><p>其中 <span class="math inline">\(\lambda = \max_{1\leq i\leq n}\{d_i\}\)</span>，<span class="math inline">\(d_i\)</span> 是 <span class="math inline">\(\Delta\Omega_i\)</span> 的直径，则称函数 <span class="math inline">\(f(x,y,z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上<strong>可积</strong>，记为 <span class="math inline">\(f\in R(\Omega)\)</span>； <span class="math inline">\(I\)</span> 称为 <span class="math inline">\(f(x,y,z)\)</span> 在 <span class="math inline">\(\Omega\)</span> 上的<strong>三重积分</strong>，记作</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V\]</span></p><p>其中 <span class="math inline">\(V_\Omega\)</span> 是区域 <span class="math inline">\(\Omega\)</span> 的体积</p><ul><li>若 <span class="math inline">\(f(x,y,z)\)</span> 表示占有三维空间区域 <span class="math inline">\(\Omega\)</span> 的物体的体密度函数，则 <span class="math inline">\(\displaystyle\iiint_\Omega f(x,y,z)\,\mathrm{d}V\)</span> 给出了物体的<strong>质量</strong></li><li>类似二重积分，三重积分具有线性性，区域可加性，保序性以及推论和积分中值定理，并且有 <span class="math inline">\(\displaystyle\iiint_\Omega \,\mathrm{d}V = V_\Omega\)</span></li></ul><h4 id="直角坐标系下的计算-1">直角坐标系下的计算</h4><p>直角坐标系下，由于 <span class="math inline">\(\mathrm{d}V=\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span>，故</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_\Omega f(x,y,z)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><h5 id="柱线法坐标面投影法">柱线法（坐标面投影法）</h5><p>设 <span class="math inline">\(\Omega\)</span> 是以曲面 <span class="math inline">\(z=z_1(x,y)\)</span> 为底，曲面 <span class="math inline">\(x=x_2(x,y)\)</span>，而侧面是母线平行于 <span class="math inline">\(z\)</span> 轴的柱体所围成的区域</p><p>设 <span class="math inline">\(\Omega\)</span> 在 <span class="math inline">\(xOy\)</span> 面上的投影区域为 <span class="math inline">\(D_1\)</span> ，则 <span class="math inline">\(\Omega\)</span> 可表示为</p><p><span class="math display">\[\Omega = \left\{(x,y,z)\bigg| (x,y)\in D_1 , z_1(x,y)\leq z\leq z_2(x,y)(x,y)\in D\right\}\]</span></p><p>则物体总质量为</p><p><span class="math display">\[\iint_D\left(\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)\,\mathrm{d}z\right) \,\mathrm{d}x\mathrm{d}y\]</span></p><p>故有</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iint_{D_1} \,\mathrm{d}x\mathrm{d}y\int_{z_1(x,y)}^{z_2(x,y)} f(x,y,z)\,\mathrm{d}z\]</span></p><h5 id="截面法坐标轴投影法">截面法（坐标轴投影法）</h5><p>设区域 <span class="math inline">\(\Omega\)</span> 在 <span class="math inline">\(z\)</span> 轴上的投影区间为 <span class="math inline">\([h_1,h_2]\)</span>，即 <span class="math inline">\(\Omega\)</span> 介于平面 <span class="math inline">\(z=h_1\)</span> 和 <span class="math inline">\(z=h_2\)</span> 之间，过 <span class="math inline">\(z\)</span> 处且垂直于 <span class="math inline">\(z\)</span> 轴的平面截 <span class="math inline">\(\Omega\)</span> 得截面区域 <span class="math inline">\(D_z\)</span>，则 <span class="math inline">\(\Omega\)</span> 可表示为</p><p><span class="math display">\[\Omega = \left\{(x,y,z)\bigg| h_1\leq z\leq h_2 , (x,y)\in D_z\right\}\]</span></p><p>物体总质量为</p><p><span class="math display">\[\int_{h_1}^{h_2}\left(\iint_{D_z} f(x,y,z)\,\mathrm{d}x\mathrm{d}y\right) \,\mathrm{d}z\]</span></p><p>故有</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \int_{h_1}^{h_2}\,\mathrm{d}z\iint_{D_z} f(x,y,z)\,\mathrm{d}x\mathrm{d}y\]</span></p><h4 id="三重积分的变量代换">三重积分的变量代换</h4><p><strong>定理：</strong></p><p>设变换 <span class="math inline">\(T:\begin{cases}x=x(u,v,w)\\y=y(u,v,w)\\z=z(u,v,w)\end{cases}\)</span> 有连续偏导数，且满足 <span class="math inline">\(J=\frac{\partial (x,y,z)}{\partial (u,v,w)}\neq 0\)</span>，而 <span class="math inline">\(f(x,y,z)\in C(\Omega)\)</span>，则</p><p><span class="math display">\[  \iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_{\Omega^*} f(x(u,v,w),y(u,v,w),z(u,v,w))\left\vert J \right\vert \,\mathrm{d}u\mathrm{d}v\mathrm{d}w\]</span></p><h5 id="柱面坐标系下的计算">柱面坐标系下的计算</h5><p>柱面坐标系，实际上就是将 <span class="math inline">\(x,y\)</span> 坐标转换为极坐标</p><p><span class="math display">\[\begin{cases}x = r\cos\theta\\y = r\sin\theta\\z = z\end{cases}\]</span></p><p>其 Jacobi 行列式为</p><p><span class="math display">\[J = \frac{\partial (x,y,z)}{\partial (r,\theta,z)} = \begin{vmatrix}\cos\theta &amp; -r\sin\theta &amp; 0\\\sin\theta &amp; r\cos\theta &amp; 0\\0 &amp; 0 &amp; 1\end{vmatrix} = r\]</span></p><p>则柱面积分积分公式为</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_{\Omega^*} f(r\cos\theta,r\sin\theta,z)r\,\mathrm{d}r\mathrm{d}\theta\mathrm{d}z\]</span></p><h5 id="球面坐标系下的计算">球面坐标系下的计算</h5><p>球面坐标系，实际上就是将 <span class="math inline">\(x,y,z\)</span> 坐标转换为球坐标</p><p><span class="math display">\[\begin{cases}x = \rho\sin\varphi\cos\theta\\y = \rho\sin\varphi\sin\theta\\z = \rho\cos\varphi\end{cases}\]</span></p><p>其 Jacobi 行列式为</p><p><span class="math display">\[J = \frac{\partial (x,y,z)}{\partial (\rho,\varphi,\theta)} = \begin{vmatrix}\sin\varphi\cos\theta &amp; \rho\cos\varphi\cos\theta &amp; -\rho\sin\varphi\sin\theta\\\sin\varphi\sin\theta &amp; \rho\cos\varphi\sin\theta &amp; \rho\sin\varphi\cos\theta\\\cos\varphi &amp; -\rho\sin\varphi &amp; 0\end{vmatrix} = \rho^2\sin\varphi\]</span></p><p>则球面积分积分公式为</p><p><span class="math display">\[\iiint_\Omega f(x,y,z)\,\mathrm{d}V = \iiint_{\Omega^*} f(\rho\sin\varphi\cos\theta,\rho\sin\varphi\sin\theta,\rho\cos\varphi)\rho^2\sin\varphi\,\mathrm{d}\rho\mathrm{d}\varphi\mathrm{d}\theta\]</span></p><h3 id="重积分的应用">重积分的应用</h3><h4 id="重积分的几何应用">重积分的几何应用</h4><h5 id="平面图形的面积">平面图形的面积</h5><p><span class="math display">\[A(D) = \iint_D \,\mathrm{d}\sigma = \iint_D \,\mathrm{d}x\mathrm{d}y\]</span></p><h5 id="立体的体积">立体的体积</h5><p><span class="math display">\[V(\Omega) = \iiint_\Omega \,\mathrm{d}V = \iiint_\Omega \,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><h5 id="曲面的面积">曲面的面积</h5><p>设空间曲面 <span class="math inline">\(S:z=f(x,y),(x,y)\in D\)</span>.</p><p>则曲面 <span class="math inline">\(S\)</span> 的面积为</p><p><span class="math display">\[A(S) = \iint_D \sqrt{1+z_x^2+z_y^2}\,\mathrm{d}x\mathrm{d}y\]</span></p><h4 id="重积分的物理应用">重积分的物理应用</h4><h6 id="质心">质心</h6><p>体密度为 <span class="math inline">\(\rho(x, y)\)</span> 的物体占据空间 <span class="math inline">\(\Omega\)</span>，其质心坐标为</p><p><span class="math display">\[\begin{cases}  \displaystyle\bar{x} = \frac{\iiint_\Omega x\rho(x,y,z)\,\mathrm{d}V}{\iiint_\Omega\mu(x,y,z)\,\mathrm{d}V} \\  \displaystyle\bar{y} = \frac{\iiint_\Omega y\rho(x,y,z)\,\mathrm{d}V}{\iiint_\Omega\mu(x,y,z)\,\mathrm{d}V}\\  \displaystyle\bar{z} = \frac{\iiint_\Omega z\rho(x,y,z)\,\mathrm{d}V}{\iiint_\Omega\mu(x,y,z)\,\mathrm{d}V}\end{cases}\]</span></p><h5 id="转动惯量">转动惯量</h5><p>设物体的密度为 <span class="math inline">\(\rho(x,y,z)\)</span>，则物体分别关于 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，<span class="math inline">\(z\)</span> 轴的转动惯量为</p><p><span class="math display">\[\begin{cases}  I_x = \iiint_\Omega \rho(x,y,z)(y^2+z^2)\,\mathrm{d}V\\  I_y = \iiint_\Omega \rho(x,y,z)(x^2+z^2)\,\mathrm{d}V\\  I_z = \iiint_\Omega \rho(x,y,z)(x^2+y^2)\,\mathrm{d}V\end{cases}\]</span></p><h5 id="引力">引力</h5><p><span class="math display">\[\begin{aligned}  &amp;\mathrm{d}\vec{F} = G\frac{m_0\mathrm{d}m}{r^3}\vec{r}\\  =&amp; G\frac{m_0\rho(x,y,z)\mathrm{d}V}{r^3}\cdot\left(x-x_0,y-y_0,z-z_0\right)\\  =&amp;\left(\mathrm{d}F_x,\mathrm{d}F_y,\mathrm{d}F_z\right)\end{aligned}\]</span></p><h2 id="曲线积分和曲面积分">曲线积分和曲面积分</h2><h3 id="第一类曲线积分和曲面积分">第一类曲线积分和曲面积分</h3><h4 id="第一类曲线积分的概念">第一类曲线积分的概念</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(xOy\)</span> 面上的一条光滑曲线弧，函数 <span class="math inline">\(f(x,y)\)</span> 是定义在 <span class="math inline">\(C\)</span> 上的有界函数，在 <span class="math inline">\(C\)</span> 上任意插入分点 <span class="math inline">\(A = A_0,A_1,\ldots,A_{n-1},A_n=B\)</span>，将其分成 <span class="math inline">\(n\)</span> 个小弧段，记第 <span class="math inline">\(i\)</span> 个小弧段的弧长为 <span class="math inline">\(\Delta s_i\)</span>，在第 <span class="math inline">\(i\)</span> 个小段上任取点 <span class="math inline">\((\epsilon_i,\eta_i)\)</span>，和式 <span class="math inline">\(\displaystyle\sum_{i=1}^{+\infty}f(\epsilon_i,\eta_i)\Delta s_i\)</span>，当 <span class="math inline">\(\displaystyle\lambda=\max_{1\leq i\leq n}\{\Delta s_i\}\to 0\)</span> 时，有确定的极限值 <span class="math inline">\(I\)</span>，即</p><p><span class="math display">\[\lim_{\lambda\to 0}\sum_{i=1}^nf(\epsilon_i,\eta_i)\Delta s_i = I\]</span></p><p>则称函数 <span class="math inline">\(f(x,y)\)</span> 在曲线 <span class="math inline">\(C\)</span> 上<strong>可积</strong>，并将此极限值 <span class="math inline">\(I\)</span> 称为函数 <span class="math inline">\(f(x,y)\)</span> 在曲线 <span class="math inline">\(C\)</span> 上的<strong>第一类曲线积分</strong>，记作 <span class="math inline">\(\displaystyle\int_Cf(x,y)\,\mathrm{d}s\)</span>，即</p><p><span class="math display">\[I = \int_C f(x,y)\,\mathrm{d}s = \lim_{\lambda\to 0}\sum_{i=1}^nf(\epsilon_i,\eta_i)\Delta s_i\]</span></p><ul><li>第一类曲线积分的几何含义为柱面的面积</li><li><span class="math inline">\(\displaystyle\int_C\,\mathrm{d}s = \displaystyle\int_c1\,\mathrm{d}s=s_C\)</span></li><li>若 <span class="math inline">\(C\)</span> 是封闭曲线，即 <span class="math inline">\(C\)</span> 的二端点重合，则记第一类曲线积分为 <span class="math inline">\(\displaystyle\oint_Cf(x,y)\,\mathrm{d}s\)</span></li></ul><h4 id="第一类曲线积分的性质">第一类曲线积分的性质</h4><h5 id="与曲线方向无关">与曲线方向无关</h5><p>若曲线 <span class="math inline">\(C\)</span> 的端点为 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>，<span class="math inline">\(f(x,y)\)</span> 在曲线 <span class="math inline">\(C\)</span> 上可积，则</p><p><span class="math display">\[\int_{\widehat{AB}} f(x,y)\,\mathrm{d}s=\oint_{\widehat{BA}} f(x,y)\,\mathrm{d}s\]</span></p><h5 id="线性性">线性性</h5><p>若 <span class="math inline">\(f,g\)</span> 在曲线 <span class="math inline">\(C\)</span> 上可积，<span class="math inline">\(\alpha , \beta\)</span> 是任意常数，则 <span class="math inline">\(\alpha f + \beta g\)</span> 在曲线 <span class="math inline">\(C\)</span> 上可积，且</p><p><span class="math display">\[\int_C (\alpha f + \beta g)\,\mathrm{d}s = \alpha \int_C f(x,y)\,\mathrm{d}s + \beta \int_C g(x,y)\,\mathrm{d}s\]</span></p><h5 id="路径可加性">路径可加性</h5><p>若曲线 <span class="math inline">\(C\)</span> 由两段光滑曲线 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> 首尾连接而成，则 <span class="math inline">\(f(x,y)\)</span> 在曲线 <span class="math inline">\(C\)</span> 上可积，等价于 <span class="math inline">\(f(x,y)\)</span> 在曲线 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> 上均可积，且</p><p><span class="math display">\[\int_C f(x,y)\,\mathrm{d}s = \int_{C_1} f(x,y)\,\mathrm{d}s + \int_{C_2} f(x,y)\,\mathrm{d}s\]</span></p><h5 id="中值定理">中值定理</h5><p>设函数 <span class="math inline">\(f\)</span> 在光滑曲线 <span class="math inline">\(C\)</span> 上连续，则 <span class="math inline">\(\exists (\epsilon,\eta)\in C\)</span>，使得</p><p><span class="math display">\[\int_C f(x,y)\,\mathrm{d}s = f(\epsilon,\eta)\cdot s_C\]</span></p><p>其中 <span class="math inline">\(s_C\)</span> 是曲线段 <span class="math inline">\(C\)</span> 的长度</p><h4 id="第一类曲线积分的计算">第一类曲线积分的计算</h4><p>设函数 <span class="math inline">\(f(x,y)\)</span> 在光滑曲线 <span class="math inline">\(C\)</span> 上连续，<span class="math inline">\(C\)</span> 的参数方程为 <span class="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>，<span class="math inline">\(t\in [a,b]\)</span>，满足 <span class="math inline">\(x&#39;(t)\)</span>，<span class="math inline">\(y&#39;(t)\)</span> 连续，且 <span class="math inline">\(x&#39;(t)^2 + y&#39;(t)^2 \neq 0\)</span>，则</p><p><span class="math display">\[\int_C f(x,y)\,\mathrm{d}s = \int_\alpha^\beta f(x(t),y(t))\sqrt{x&#39;(t)^2 + y&#39;(t)^2}\,\mathrm{d}t\]</span></p><ul><li>右端积分限应 <span class="math inline">\(\alpha &lt; \beta\)</span></li><li>当曲线 <span class="math inline">\(C\)</span> 形式为 <span class="math inline">\(y=y(x)\)</span>，<span class="math inline">\(x\in [a,b]\)</span> 时，则 <span class="math inline">\(\displaystyle\int_Cf(x,y)\,\mathrm{d}s =\int_a^bf(x,y(x))\sqrt{1+y&#39;^2(x)}\,\mathrm{d}x\)</span></li><li>当曲线 <span class="math inline">\(C\)</span> 为极坐标 <span class="math inline">\(r=r(\theta)\)</span>，<span class="math inline">\(\theta\in [\alpha,\beta]\)</span> 时，则 <span class="math inline">\(\displaystyle\int_Cf(x,y)\,\mathrm{d}s = \int_\alpha^\beta f(r(\theta)\cos\theta,r(\theta)\sin\theta)\sqrt{r(\theta)^2+r&#39;^2(\theta)}\,\mathrm{d}\theta\)</span></li></ul><h3 id="第二类曲线积分与曲面积分">第二类曲线积分与曲面积分</h3><h4 id="第二类曲线积分的概念">第二类曲线积分的概念</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(C\)</span> 为平面光滑定向曲线(<span class="math inline">\(A\rightarrow B\)</span>)，且向量值函数 <span class="math inline">\(\vec{F}(x,y) = R(x,y)\vec{i}+Q(x,y)\vec{j}\)</span> 在 <span class="math inline">\(C\)</span> 上有界，<span class="math inline">\(\vec{e}_\tau\)</span> 为 <span class="math inline">\(C\)</span> 上点 <span class="math inline">\((x,y)\)</span> 处于定向一致的单位切向量，若</p><p><span class="math display">\[\int_C \vec{F}(x,y) \cdot \vec{e}_\tau \,\mathrm{d}s\]</span></p><p>存在，则称为<strong>向量值函数 <span class="math inline">\(\vec{F}\)</span> 在定向曲线 <span class="math inline">\(C\)</span> 上的曲线积分或第二类曲线积分</strong></p><p>若 <span class="math inline">\(\vec{e}_\tau(x,y) = (\cos\alpha,\cos\beta)\)</span>，则</p><p><span class="math display">\[\begin{aligned}  \int_C \vec{F}(x,y) \cdot \vec{e}_\tau \,\mathrm{d}s &amp;= \int_C P(x,y)\cos\alpha + Q(x,y)\cos\beta \,\mathrm{d}s \\  &amp;= \int_C P(x,y)\cos\alpha \,\mathrm{d}s + \int_C Q(x,y)\cos\beta \,\mathrm{d}s \\  &amp;= \int_C P(x,y)\,\mathrm{d}x +  Q(x,y)\,\mathrm{d}y\end{aligned}\]</span></p><p>这是对坐标的曲线积分</p><p>记 <span class="math inline">\(\vec{r} = (x,y)\)</span>，则 <span class="math inline">\(\mathrm{d}\vec{e} = \vec{e}_\tau \,\mathrm{d}s\)</span> 称为<strong>定向弧微分</strong></p><p>从而有向量形式的第一类曲线积分</p><p><span class="math display">\[\int_C \vec{F}(x,y) \cdot \mathrm{d}\vec{e} = \int_C \vec{F}\cdot \mathrm{d}\vec{r}\]</span></p><h5 id="第二类曲线积分的性质">第二类曲线积分的性质</h5><p>第二类曲线积分与<strong>曲线方向有关</strong>，即</p><p><span class="math display">\[\int_{\widehat{AB}} \vec{F}(x,y) \cdot \mathrm{d}\vec{r} = -\oint_{\widehat{BA}} \vec{F}(x,y) \cdot \mathrm{d}\vec{r}\]</span></p><p>此外线性性与对定向积分路径的可加性等仍然成立</p><h5 id="第二类曲线积分的计算">第二类曲线积分的计算</h5><p>若曲线 <span class="math inline">\(C\)</span> 为 <span class="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>，<span class="math inline">\(t:\alpha\rightarrow \beta\)</span></p><p>起点 <span class="math inline">\(A\)</span> 对应 <span class="math inline">\(\alpha\)</span>，终点 <span class="math inline">\(B\)</span> 对应 <span class="math inline">\(\beta\)</span></p><p>考察 <span class="math inline">\(\displaystyle\int_C P\,\mathrm{d}x + Q\,\mathrm{d}y = \int_C \vec{F}\cdot\vec{e}_\tau \,\mathrm{d}s\)</span>，沿曲线 <span class="math inline">\(C\)</span> 有 <span class="math inline">\(\vec{F} = \left(P\left(x(t),y(t)\right),Q\left(x(t),y(t)\right)\right)\)</span>，则</p><p><span class="math display">\[\int_C P\,\mathrm{d}x + Q\,\mathrm{d}y = \int_\alpha^\beta P\left(x(t),y(t)\right)\,\mathrm{d}x(t) + Q\left(x(t),y(t)\right)\,\mathrm{d}y(t)\]</span></p><h4 id="第二类曲面积分的概念">第二类曲面积分的概念</h4><h5 id="双侧曲面">双侧曲面</h5><p><strong>定义：</strong></p><p>若点 <span class="math inline">\(P\)</span> 沿曲面 <span class="math inline">\(S\)</span> 上任何不越过曲面边界的连续闭曲线移动后回到起始位置时，法向量 <span class="math inline">\(\vec{n}\)</span> 保持原来的指向，则称 <span class="math inline">\(S\)</span> 为<strong>双侧曲面</strong></p><p>典型的，Mobius 面不是双侧曲面</p><p>选定双侧曲面 <span class="math inline">\(S\)</span> 一侧为正向，称为<strong>正侧</strong>，记为 <span class="math inline">\(S^+\)</span> ，其相反测记作 <span class="math inline">\(S^-\)</span></p><h5 id="双侧曲面定侧">双侧曲面定侧</h5><p>若 <span class="math inline">\(S:z=z(x,y)\)</span>，<span class="math inline">\((x,y)\in D_{xy}\)</span>，<span class="math inline">\(\vec{n}_0=\left(\cos\alpha,\cos\beta,\cos\gamma\right)=\pm\frac{\left(-z_x,-z_y,1\right)}{\sqrt{1+z_x^2+z_y^2}}\)</span></p><p>若选取 <span class="math inline">\(\vec{n}_0=\left(\cos\alpha,\cos\beta,\cos\gamma\right)=\frac{\left(-z_x,-z_y,1\right)}{\sqrt{1+z_x^2+z_y^2}}\)</span>，则说明 <span class="math inline">\(\cos\gamma &gt; 0\)</span>，选取了曲面的上侧</p><p>一般的</p><p><span class="math display">\[\begin{cases}  \cos\alpha &gt;0 \Leftrightarrow \text{前侧}，\cos\alpha &lt; 0 \Leftrightarrow \text{后侧}\\  \cos\beta &gt;0 \Leftrightarrow \text{右侧}，\cos\beta &lt; 0 \Leftrightarrow \text{左侧}\\  \cos\gamma &gt;0 \Leftrightarrow \text{上侧}，\cos\gamma &lt; 0 \Leftrightarrow \text{下侧}\end{cases}\]</span></p><p>习惯上选取曲面片的上侧为 <span class="math inline">\(S^+\)</span>；对于封闭曲面，选取外侧为 <span class="math inline">\(S^+\)</span></p><p>对于向量值函数 <span class="math inline">\(\vec{F} = (P,Q,R)\)</span></p><p><span class="math display">\[\int_C \vec{F}\cdot\,\mathrm{d}S = \int_c P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x\]</span></p><h5 id="第二类曲面积分的性质">第二类曲面积分的性质</h5><p>第二类曲面积分与在曲面的哪一侧积分有关</p><p><span class="math display">\[\iint_{S^+}P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x = -\iint_{S^-}P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x\]</span></p><p>此外第二类曲面积分也具有线性性和可加性等性质</p><h4 id="第二类曲面积分的计算">第二类曲面积分的计算</h4><h5 id="合一投影法">合一投影法</h5><p><span class="math display">\[\iint_{S^+}P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x = \iint_{D_{xy}} \left(-Pz_x-Qz_y+R\right)\,\mathrm{d}x\mathrm{d}y\]</span></p><h5 id="分面投影法">分面投影法</h5><p>分 <span class="math inline">\(P\,\mathrm{d}x\mathrm{d}y\)</span>，<span class="math inline">\(Q\,\mathrm{d}y\mathrm{d}z\)</span>，<span class="math inline">\(R\,\mathrm{d}z\mathrm{d}x\)</span> 三个部分进行积分</p><p>常在部分曲面垂直坐标轴时进行</p><h5 id="公式法">公式法</h5><p>常用于参数方程确定的曲面</p><p>设 <span class="math inline">\(S:\vec{r} = \left(x(u,v),y(u,v),z(u,v)\right)\)</span>，其中 <span class="math inline">\((u,v)\in D_{xy}\)</span>，则</p><p><span class="math display">\[\iint_{S^+}\vec{F}\cdot\,\mathrm{d}\vec{S} = \iint_{D_{uv}}\vec{F}\cdot\left(\vec{r}_u\times\vec{r_v}\right)\,\mathrm{d}u\mathrm{d}v\]</span></p><h3 id="green-公式及其应用">Green 公式及其应用</h3><h4 id="green-公式">Green 公式</h4><h5 id="连通区域及其边界方向">连通区域及其边界方向</h5><p>设 <span class="math inline">\(D\)</span> 为平面区域, 若 <span class="math inline">\(D\)</span> 内的任意一条闭曲线所围的区域都落在 <span class="math inline">\(D\)</span> 内, 则称 <span class="math inline">\(D\)</span> 是单连通的, 否则称 <span class="math inline">\(D\)</span> 为复连通的</p><p>当点沿区域边界朝一个方向前进时, 区域总在它的左侧, 则将此方向规定为边界曲线 <span class="math inline">\(C\)</span> 的正向,记为 <span class="math inline">\(C^+\)</span>, 与 <span class="math inline">\(C^+\)</span> 相反方向为 <span class="math inline">\(C^−\)</span></p><h5 id="green-公式-1">Green 公式</h5><p><strong>定理：</strong></p><p>设有界闭区域 <span class="math inline">\(D\)</span> 由分段光滑曲线 <span class="math inline">\(C\)</span> 围成，函数 <span class="math inline">\(P(x, y)\)</span>, <span class="math inline">\(Q(x, y)\)</span> 在 <span class="math inline">\(D\)</span> 上有一阶连续偏导数, 则</p><p><span class="math display">\[\oint_{C^+} P\,\mathrm{d}x + Q\,\mathrm{d}y = \iint_D \left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}\right)\,\mathrm{d}x\mathrm{d}y\]</span></p><ul><li>对于复连通区域 <span class="math inline">\(D\)</span>，Green 公式仍然成立，但需将 <span class="math inline">\(C\)</span> 分成若干个单连通区域 <span class="math inline">\(D_i\)</span>，并对每个区域应用 Green 公式</li><li>公式也可以记为 <span class="math inline">\(\displaystyle\oint_{C^+} P\,\mathrm{d}x + Q\,\mathrm{d}y = \iint_D \begin{vmatrix}\frac{\partial}{\partial x}&amp;\frac{\partial}{\partial y}\newline P&amp;Q\end{vmatrix}\,\mathrm{d}x\mathrm{d}y\)</span></li></ul><h5 id="green-公式的向量形式">Green 公式的向量形式</h5><p><span class="math display">\[\oint_{C^+} \vec{F}\cdot\,\mathrm{d}\vec{r} = \iint_D \nabla\times\vec{F}\,\mathrm{d}x\mathrm{d}y\]</span></p><h4 id="曲线积分与路径无关的条件">曲线积分与路径无关的条件</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(P(x,y)\)</span>，<span class="math inline">\(Q(x,y)\)</span> 在区域 <span class="math inline">\(D\)</span> 内连续，若对 <span class="math inline">\(D\)</span> 内任意两点 <span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span> 以及 <span class="math inline">\(D\)</span> 内连接 <span class="math inline">\(A,B\)</span> 的任意二分段光滑曲线 <span class="math inline">\(C_1\)</span>，<span class="math inline">\(C_2\)</span>，均有</p><p><span class="math display">\[\int_{C_1} P\,\mathrm{d}x +Q\,\mathrm{d}y = \int_{C_2} P\,\mathrm{d}x +Q\,\mathrm{d}y\]</span></p><p>则称曲线积分 <span class="math inline">\(\displaystyle\int_C P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 在 <span class="math inline">\(D\)</span> 内<strong>与路径无关</strong></p><p><strong>定理：</strong></p><p>设函数 <span class="math inline">\(P\)</span>，<span class="math inline">\(Q\)</span> 在<strong>单连通</strong>区域 <span class="math inline">\(D\)</span> 上有连续偏导数，则下述四命题等价</p><ol type="1"><li>在 <span class="math inline">\(D\)</span> 内的任一条分段光滑闭曲线 <span class="math inline">\(C\)</span> 上，有 <span class="math inline">\(\displaystyle \int_C P\,\mathrm{d}x +Q\,\mathrm{d}y = 0\)</span></li><li>曲线积分 <span class="math inline">\(\displaystyle \int_C P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 在 <span class="math inline">\(D\)</span> 内与路径无关</li><li>存在 <span class="math inline">\(D\)</span> 上的可微函数 <span class="math inline">\(u(x,y)\)</span> 使得 <span class="math inline">\(\displaystyle \mathrm{d}u = P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span>，此时称 <span class="math inline">\(u(x,y)\)</span> 为 <span class="math inline">\(\displaystyle P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 的一个<strong>原函数</strong></li><li><span class="math inline">\(\displaystyle \frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}\)</span> 在 <span class="math inline">\(D\)</span> 内恒成立</li></ol><h4 id="全微分求积与全微分方程">全微分求积与全微分方程</h4><p>设函数 <span class="math inline">\(P\)</span>，<span class="math inline">\(Q\)</span> 在单连通区域 <span class="math inline">\(D\)</span> 上有连续偏导数，且 <span class="math inline">\(\displaystyle \frac{\partial Q}{\partial x} = \frac{\partial P}{\partial y}\)</span> ，则 <span class="math inline">\(\displaystyle P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 为某函数 <span class="math inline">\(u\)</span> 的全微分，且取定 <span class="math inline">\((x_0,y_0)\in D\)</span></p><p><span class="math display">\[u(x,y) = u(x_0,y_0) + \int_{(x_0,y_0)}^{(x,y)} P\,\mathrm{d}x +Q\,\mathrm{d}y,\quad (x,y)\in D\]</span></p><p>从而全体函数为 <span class="math inline">\(u(x,y) + C\)</span></p><p>称求 <span class="math inline">\(P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 的原函数的过程为<strong>全微分求积</strong></p><p>若 <span class="math inline">\(P\,\mathrm{d}x +Q\,\mathrm{d}y\)</span> 是某二元函数的全微分，称方程</p><p><span class="math display">\[P(x,y)\,\mathrm{d}x +Q(x,y)\,\mathrm{d}y = 0\]</span></p><p>为<strong>全微分方程</strong></p><p>求出一个原函数 <span class="math inline">\(u(x,y)\)</span>，则方程的通解为 <span class="math inline">\(u(x,y) = C\)</span>，其中 <span class="math inline">\(C\)</span> 是任意常数</p><h3 id="gauss-公式和-strokes-公式">Gauss 公式和 Strokes 公式</h3><h4 id="gauss-公式">Gauss 公式</h4><p><strong>定理：</strong></p><p>设函数 <span class="math inline">\(P(x,y,z)\)</span>，<span class="math inline">\(Q(x,y,z)\)</span>，<span class="math inline">\(R(x,y,z)\)</span> 在空间有界闭区域 <span class="math inline">\(\Omega\)</span> 上有连续偏导数，<span class="math inline">\(\Omega\)</span> 的边界时光滑或分片光滑的闭曲面 <span class="math inline">\(\Sigma\)</span>，则</p><p><span class="math display">\[\oiint_{\Sigma^+} P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x = \iiint_\Omega \left(\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}\right)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><ul><li>令 <span class="math inline">\(P=\frac{x}{3}\)</span>，<span class="math inline">\(Q=\frac{y}{3}\)</span>，<span class="math inline">\(R=\frac{z}{3}\)</span>，则可导出 <span class="math inline">\(\displaystyle V_\Omega = \frac{1}{3}\oiint_{\Sigma^+} x\,\mathrm{d}y\mathrm{d}z + y\,\mathrm{d}z\mathrm{d}x + z\,\mathrm{d}x\mathrm{d}y\)</span>，即体积公式</li><li>使用 Gauss 公式时，注意 <span class="math inline">\(\Sigma^+\)</span> 的方向应与 <span class="math inline">\(\Omega\)</span> 的外侧一致</li></ul><h5 id="向量形式的-gauss-公式">向量形式的 Gauss 公式</h5><p><span class="math display">\[\oiint_{\Sigma^+} \vec{F}\cdot\,\mathrm{d}\vec{S} = \iiint_\Omega \nabla\cdot\vec{F}\,\mathrm{d}x\mathrm{d}y\mathrm{d}z\]</span></p><h4 id="通量和散度">通量和散度</h4><h5 id="通量">通量</h5><p>若给定向量场</p><p><span class="math display">\[\vec{F} = \left(P(x,y,z),Q(x,y,z),R(x,y,z)\right)\]</span></p><p>则称曲面积分</p><p><span class="math display">\[\Phi = \oiint_{\Sigma^+} \vec{F}\cdot\,\mathrm{d}\vec{S} = \oiint_{\Sigma^+} P\,\mathrm{d}x\mathrm{d}y + Q\,\mathrm{d}y\mathrm{d}z + R\,\mathrm{d}z\mathrm{d}x\]</span></p><p>为向量场 <span class="math inline">\(\vec{F}\)</span> 在通过定侧曲面 <span class="math inline">\(\Sigma^+\)</span> 的<strong>通量</strong></p><h5 id="散度">散度</h5><p>称</p><p><span class="math display">\[\mathrm{div}\vec{F} = \nabla\cdot\vec{F}=\frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}\]</span></p><p>为向量场 <span class="math inline">\(\vec{F}\)</span> 的<strong>散度</strong></p><p>则 Gauss 公式可写为</p><p><span class="math display">\[\Phi =\oiint_{\Sigma^+} \vec{F}\cdot\,\mathrm{d}\vec{S} = \iiint_\Omega \mathrm{div}\vec{F}\,\mathrm{d}V\]</span></p><h2 id="级数">级数</h2><h3 id="数项级数">数项级数</h3><h4 id="数项级数的概念">数项级数的概念</h4><p><strong>定义：</strong></p><p>给定数列 <span class="math inline">\(\{a_n\}\)</span> ，和式</p><p><span class="math display">\[\sum_{n=1}^{\infty} a_n = a_1 + a_2 + \cdots + a_n + \cdots\]</span></p><p>称为 <strong>（无穷）极数</strong> ，<span class="math inline">\(a_n\)</span> 称为级数的<strong>通项</strong>（或<strong>一般项</strong>）</p><ul><li><span class="math inline">\(\displaystyle S_n = \sum_{k=1}^n a_k\)</span> 称为级数 <span class="math inline">\(\displaystyle \sum_{n=1} a_n\)</span> 的前 <span class="math inline">\(n\)</span> 项<strong>部分和</strong></li><li><span class="math inline">\(\displaystyle\sum_{k=n+1}^\infty a_k\)</span> 称为级数 <span class="math inline">\(\displaystyle \sum_{n=1} a_n\)</span> 的<strong>余项级数</strong></li></ul><p><strong>定义：</strong></p><ul><li>若级数 <span class="math inline">\(\displaystyle\sum_{n=1}^\infty a_n\)</span> 的部分和数列 <span class="math inline">\(\{S_n\}\)</span> 收敛，且 <span class="math inline">\(\displaystyle \lim_{n\to\infty}S_n = S\)</span>，则称级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> <strong>收敛</strong>，<span class="math inline">\(S\)</span> 称为级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 的<strong>和</strong>，记作 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n = S\)</span></li><li>若部分和数列 <span class="math inline">\(\{S_n\}\)</span> 发散，则称级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> <strong>发散</strong></li></ul><blockquote><p>常用结论：</p><p><strong>等比数列</strong> <span class="math inline">\(\displaystyle \sum_{n=1}^\infty aq^{n-1}\begin{cases}\text{收敛于}\frac{a}{1-q} &amp; ,\vert q \vert &lt; 1\newline \text{发散} &amp; ,\vert q \vert \geq 1\end{cases}\)</span></p></blockquote><h4 id="数项级数的基本性质">数项级数的基本性质</h4><h5 id="基本性质">基本性质</h5><ol type="1"><li>若常数 <span class="math inline">\(\alpha \neq 0\)</span>，则级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 与级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty \alpha a_n\)</span> 有相同敛散性</li><li><strong>线性性：</strong> 若级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n = S\)</span>，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n = T\)</span>，则 <span class="math inline">\(\forall \alpha , \beta\in \mathbb{R}\)</span>，有 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty (\alpha a_n + \beta b_n) = \alpha S + \beta T\)</span></li><li><strong>可加性：</strong> 将级数增加、删减或改换<strong>有限项</strong>，不改变级数的<strong>敛散性</strong></li><li><strong>结合律：</strong> 若级数收敛于 <span class="math inline">\(S\)</span>，则将相邻若干项添加括号所成新级数仍收敛于 <span class="math inline">\(S\)</span><ul><li>其本质是部分和数列收敛于 <span class="math inline">\(S\)</span>，则子列均收敛于 <span class="math inline">\(S\)</span></li><li>加括号后级数收敛 <span class="math inline">\(\nRightarrow\)</span> 原级数收敛</li><li>加括号后级数发散 <span class="math inline">\(\Rightarrow\)</span> 原级数发散</li></ul></li></ol><h5 id="级数收敛的必要条件">级数收敛的必要条件</h5><p><strong>定理：</strong></p><p>若 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛，则 <span class="math inline">\(\displaystyle \lim_{n\to\infty} a_n = 0\)</span></p><ul><li>若 <span class="math inline">\(\displaystyle \lim_{n\to\infty} a_n \neq 0 \nRightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span> 发散</li><li>若 <span class="math inline">\(\displaystyle \lim_{n\to\infty} a_n = 0 \nRightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛，比如调和级数</li></ul><h3 id="正项级数敛散性">正项级数敛散性</h3><h4 id="正项级数">正项级数</h4><p><strong>定义：</strong></p><p>若级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 满足 <span class="math inline">\(a_n &gt;0 \quad \left(n\in\mathbb{N}^+\right)\)</span>，则称此级数为<strong>正项级数</strong></p><p><strong>定理：（收敛原理）</strong></p><p>正项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛 <span class="math inline">\(\Leftrightarrow\)</span> 是其部分和数列 <span class="math inline">\(\{S_n\}\)</span> 有上界，即 <span class="math inline">\(\exists M\in\mathbb{R},\forall n \in \mathbb{N}^+:S_n \leq M\)</span></p><blockquote><p><span class="math inline">\(p\)</span> 级数</p><p><span class="math inline">\(\displaystyle \sum_{n=1}^\infty \frac{1}{n^p} \begin{cases}\text{收敛} &amp; ,p&gt;1\newline \text{发散} &amp; ,p\leq 1\end{cases}\)</span></p></blockquote><h4 id="正项级数敛散性判别法">正项级数敛散性判别法</h4><h5 id="比较判别法">比较判别法</h5><p><strong>定理：</strong></p><p>设正项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 满足 <span class="math inline">\(a_n \leq b_n \quad (\forall n \in \mathbb{N}^+)\)</span> ，则 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 收敛 <span class="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 发散 <span class="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\infty b_n\)</span> 发散</p><ul><li>条件 <span class="math inline">\(\forall n \in \mathbb{N}^+，a_n \leq b_n\)</span> 可改为 <span class="math inline">\(\exists N,C &gt;0 ,\forall n\in \mathbb{N}^+，\forall n \geq N，a_n \leq Cb_n\)</span></li><li>使用该判别法时需要有参照级数，常选<strong>等比级数</strong>或 <strong><span class="math inline">\(p\)</span> 级数</strong>作参照</li></ul><h5 id="比较判别法极限形式">比较判别法（极限形式）</h5><p><strong>定理：</strong></p><p>正项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span>，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 满足 <span class="math inline">\(\displaystyle \lim_{n\to\infty} \frac{a_n}{b_n} = l\)</span></p><ul><li>当 <span class="math inline">\(0 &lt;l&lt;+\infty\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 与 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 同敛散</li><li>当 <span class="math inline">\(l=0\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 收敛 <span class="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛</li><li>当 <span class="math inline">\(l=+\infty\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 发散 <span class="math inline">\(\Rightarrow \displaystyle \sum_{n=1}^\infty a_n\)</span> 发散</li></ul><blockquote><p>通常使用 <span class="math inline">\(b_n = \frac{1}{n^p}\)</span> 作为参照物，因为我们此时在分析无穷小 <span class="math inline">\(a_n\)</span> 的阶</p></blockquote><h5 id="比值判别法dalembert-判别法">比值判别法（d’Alembert 判别法）</h5><p><strong>定理：</strong></p><p>若<strong>正项级数</strong> <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 满足 <span class="math inline">\(\displaystyle \lim_{n\to\infty} \frac{a_{n+1}}{a_n} = l\)</span>，则</p><ul><li>当 <span class="math inline">\(0\leq l&lt;1\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛</li><li>当 <span class="math inline">\(l&gt;1\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 发散</li><li>当 <span class="math inline">\(l=1\)</span> 时，判别法失效</li></ul><blockquote><p>Stirling 公式： <span class="math inline">\(n! \sim \left(\frac{n}{e}\right)^n \sqrt{2n\pi} \quad (n\to\infty)\)</span></p></blockquote><blockquote><p>当 <span class="math inline">\(a_n\)</span> 是一些乘积构成或含 <span class="math inline">\(n!\)</span> 时，可以考虑比值法</p></blockquote><h5 id="根值判别法cauchy-判别法">根值判别法（Cauchy 判别法）</h5><p><strong>定理：</strong></p><p>若正项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 满足 <span class="math inline">\(\displaystyle \lim_{n\to\infty} \sqrt[n]{a_n} = l\)</span>，则</p><ol type="1"><li>当 <span class="math inline">\(0\leq l&lt;1\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛</li><li>当 <span class="math inline">\(1 &lt; l \leq +\infty\)</span> 时，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 发散</li><li>当 <span class="math inline">\(l=1\)</span> 时，判别法失效</li></ol><blockquote><p>当 <span class="math inline">\(a_n\)</span> 中含有 <span class="math inline">\(n\)</span> 次方时，可以考虑使用根值法</p></blockquote><blockquote><p>比值法和根值法实际上可看作是在将级数与等比级数作比较，均智能判断收敛速度不满与等比级数的级数.当所求级数存在时，可称级数为<strong>拟等比级数</strong></p></blockquote><blockquote><p>根值法优于比值法</p><ul><li><span class="math inline">\(\displaystyle\lim_{n\to\infty}\frac{a_{n+1}}{a_n} = l \Rightarrow \displaystyle \sqrt[n]{a_n} = l\)</span></li><li><span class="math inline">\(\displaystyle \sqrt[n]{a_n} =l \nRightarrow \displaystyle\lim_{n\to\infty}\frac{a_{n+1}}{a_n} = l\)</span></li></ul></blockquote><h5 id="积分判别法">积分判别法</h5><p><strong>定理：</strong></p><p>设 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 为<strong>正项级数</strong>，若非负函数 <span class="math inline">\(f(X)\)</span> 在 <span class="math inline">\([1,+\infty)\)</span> 上<strong>单调递减</strong>，且 <span class="math inline">\(a_n = f(n)\quad \left(\forall n \in \mathbb{N}^+\right)\)</span>，则级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 与反常积分 <span class="math inline">\(\displaystyle \int_1^{+\infty} f(x)\,\mathrm{d}x\)</span> 有相同的敛散性</p><ul><li>条件 <span class="math inline">\(\left[1,+\infty\right)\)</span> 可改为 <span class="math inline">\(\left[a,+\infty\right)，(a&gt;1)\)</span></li></ul><h3 id="任意项级数的敛散性">任意项级数的敛散性</h3><p><strong>任意项级数</strong></p><p>正负项分布是任意的级数</p><h4 id="交错级数敛散性的判别法">交错级数敛散性的判别法</h4><h5 id="交错级数">交错级数</h5><p><strong>定义：</strong></p><p>各项正负相间的级数称为<strong>交错级数</strong>，其形式为</p><p><span class="math display">\[\pm\sum_{n=1}^\infty {-1}^{n-1}a_n \quad \left(\text{其中}a_n &gt; 0\right)\]</span></p><h5 id="leibniz-判别法">Leibniz 判别法</h5><p><strong>定理：</strong></p><p>若交错级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty (-1)^{n-1}a_n \,\left(a_n&gt;0\right)\)</span> 满足:</p><ol type="1"><li><span class="math inline">\(a_{n+1} \leq a_n \quad \left(n = 1 ,2 ,\ldots\right)\)</span></li><li><span class="math inline">\(\displaystyle\lim_{n\to\infty}a_n =0\)</span></li></ol><p>则级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty (-1)^{n-1}a_n\)</span> 收敛，且其余项级数满足</p><p><span class="math display">\[\left\vert \sum_{k=n+1}^\infty a_k \right\vert \leq a_{n+1}\]</span></p><blockquote><p>我们称满足定理条件的级数为 <strong>leibniz 型级数</strong></p></blockquote><h4 id="abel-判别法和-dirichlet-判别法">Abel 判别法和 Dirichlet 判别法</h4><p><strong>定理：（Abel 判别法）</strong></p><p>若 <span class="math inline">\(\{a_n\}\)</span> 单调且有界，<span class="math inline">\(\displaystyle\sum_{n=1}^\infty b_n\)</span> 收敛，则 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_nb_n\)</span> 收敛</p><p><strong>定理：（Dirichlet 判别法）</strong></p><p>若 <span class="math inline">\(\{a_n\}\)</span> 单调趋于 <span class="math inline">\(0\)</span>，<span class="math inline">\(\displaystyle \sum_{n=1}^\infty b_n\)</span> 的部分和数列有界，则 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_nb_n\)</span> 收敛</p><h4 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h4><p><strong>定义：</strong></p><p>设 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 为任意项级数</p><ol type="1"><li>若级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty \vert a_n \vert\)</span> 收敛，则称级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 为<strong>绝对收敛</strong></li><li>若 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty \vert a_n \vert\)</span> 发散，而 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛，但 ，则称 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> <strong>条件收敛</strong></li></ol><p><strong>定理：</strong></p><p>若 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 绝对收敛，则 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_n\)</span> 收敛</p><blockquote><p><strong>常用结论：</strong></p><p><span class="math display">\[\displaystyle \sum_{n=1}^\infty \frac{(-1)^{n}}{n^p}\begin{cases}\text{绝对收敛} &amp; ,p&gt;1\\ \text{条件收敛} &amp; , 0 &lt; p\leq 1 \end{cases}\]</span></p></blockquote><p><strong>定理：（绝对收敛与条件收敛的本质）</strong></p><ol type="1"><li>绝对收敛的级数，可以改变任意项的顺序，其收敛性与和均不变（即满足加法交换律）</li><li>条件收敛的级数，总可以适当改变项的顺序，使其按照任意预定的方式收敛或者发散</li></ol><h3 id="函数项级数">函数项级数</h3><p><strong>定义：</strong></p><p>设函数列 <span class="math inline">\(\{u_n{x}\} (n=1,2,\ldots)\)</span> 在数集 <span class="math inline">\(X\)</span> 上有定义，则称形式和</p><p><span class="math display">\[\sum_{n=1}^\infty u_n(x)= u_1(x) + u_2(x) + \cdots + u_n(x) + \cdots\]</span></p><p>为<strong>函数项级数</strong>，其中 <span class="math inline">\(u_n(x)\)</span> 称为<strong>通项</strong></p><p><strong>定义：</strong></p><p>若数项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x_0)\)</span> 收敛，则 <span class="math inline">\(x_0\)</span> 为函数项级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span> 的一个<strong>收敛点</strong>，否则称为<strong>发散点</strong>，全体收敛点所组成的集合 <span class="math inline">\(I\)</span> 称为<strong>收敛域</strong></p><p><strong>定义</strong></p><p>记 <span class="math inline">\(\displaystyle S_n(x) =\sum_{k=1}^\infty u_k(x)\)</span>,为 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span> 的前 <span class="math inline">\(n\)</span> 项<strong>部分和(函数)</strong>，记 <span class="math inline">\(\displaystyle r_n(x) = \sum_{k=n+1}^\infty u_k(x)\)</span> 为<strong>余和</strong></p><p><strong>定义：</strong></p><p>对于收敛域 <span class="math inline">\(I\)</span> 中的任意一点 <span class="math inline">\(x\)</span>，记 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span> 的和为 <span class="math inline">\(S(x)\)</span>，称此函数 <span class="math inline">\(S(x)\)</span> 为 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty u_n(x)\)</span> 的<strong>和函数</strong></p><p>显然，<span class="math inline">\(\forall x\in I\)</span>，<span class="math inline">\(\displaystyle \lim_{n\to +\infty}S_n(x) =S(x)\)</span>，<span class="math inline">\(\displaystyle \lim_{n\to +\infty}r_n(x)=0\)</span></p><h3 id="幂级数">幂级数</h3><h4 id="幂级数及其收敛半径">幂级数及其收敛半径</h4><p>在函数项级数中，最简单及最重要的级数形如</p><p><span class="math display">\[\sum_{n=0}^\infty a_n(x-x_0)^n = a_0 +a_1x + a_2(x-x_0)^2 + \ldots + a_n(x-x_0)^n + \ldots\]</span></p><p>称为<strong>幂级数</strong>，其中常数项 <span class="math inline">\(a_0,a_1,\ldots,a_n,\ldots\)</span> 称为幂级数的<strong>系数</strong></p><p>幂级数更加一半的形式为 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_n(x-x_0)^n\)</span></p><h5 id="abel-定理"><strong>Abel 定理</strong></h5><ol type="1"><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_n(x-x_0)^n\)</span> 在 <span class="math inline">\(x=x_0(x\neq 0)\)</span> 收敛，则当 <span class="math inline">\(\vert x \vert &lt;\vert x_0\vert\)</span>，时，幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_n(x-x_0)^n\)</span> 绝对收敛</li><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 在 <span class="math inline">\(x=x_1\)</span> 发散，则当 <span class="math inline">\(\vert x \vert &gt;\vert x_1\vert\)</span> 时，幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 发散</li></ol><h6 id="推论幂级数收敛域的情况">推论（幂级数收敛域的情况）</h6><p>幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_n(x-x_0)^n\)</span> 的收敛域 <span class="math inline">\(I\)</span> 仅有以下几种情况：</p><ol type="1"><li>仅在 <span class="math inline">\(x=0\)</span> 的情况收敛（<span class="math inline">\(R=0\)</span>）</li><li>在区间 <span class="math inline">\((-R,R)(R&gt;0)\)</span> 内绝对收敛，在 <span class="math inline">\((-\infty ,-R)\bigcup(R,+\infty)\)</span> 发散</li><li>在区间 <span class="math inline">\((-R,R)\)</span> 内绝对收敛（<span class="math inline">\(R=+\infty\)</span>）</li></ol><h3 id="幂级数收敛半径的求法">幂级数收敛半径的求法</h3><h4 id="系数模比值法">系数模比值法</h4><p><strong>定理：</strong></p><p>对幂级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_nx^n\)</span>，若 <span class="math inline">\(\displaystyle \lim_{n\to+\infty}\left\vert\frac{a_{n+1}}{a_n}\right\vert = \rho\)</span>，则收敛半径 <span class="math inline">\(\displaystyle R=\begin{cases}&amp;0,&amp;&amp;\rho=+\infty\newline &amp; \frac{1}{\rho},&amp;&amp; 0&lt;\rho&lt;+\infty\newline &amp;+\infty ,&amp;&amp;\rho=0\end{cases}\)</span></p><h4 id="系数模根值法">系数模根值法</h4><p><strong>定理：</strong></p><p>对幂级数 <span class="math inline">\(\displaystyle \sum_{n=1}^\infty a_nx^n\)</span>，若 <span class="math inline">\(\displaystyle \lim_{n\to+\infty}\sqrt[n]{\left\vert a_n\right\vert} = \rho\)</span>，则收敛半径 <span class="math inline">\(\displaystyle R=\begin{cases}&amp;0,&amp;&amp;\rho=+\infty\newline &amp; \frac{1}{\rho},&amp;&amp; 0&lt;\rho&lt;+\infty\newline &amp;+\infty ,&amp;&amp;\rho=0\end{cases}\)</span></p><h3 id="幂级数的性质">幂级数的性质</h3><ol type="1"><li>设幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 和 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty b_nx^n\)</span> 的收敛半径分别为 <span class="math inline">\(R_1\)</span> 和 <span class="math inline">\(R_2\)</span>，则 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty (a_n+b_n)x^n\)</span> 的收敛半径为 <span class="math inline">\(R=\min\{R_1,R_2\}\)</span></li><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 的收敛半径 <span class="math inline">\(R&gt;0\)</span>，在收敛区间 <span class="math inline">\((-R,R)\)</span> 内的和函数为 <span class="math inline">\(S(n)\)</span>，则 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\((-R,R)\)</span> 上连续；若 <span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_nx^n\)</span> 在 <span class="math inline">\(x=R\)</span> 或 <span class="math inline">\(x=-R\)</span> 收敛，则和函数 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\(x=R\)</span> 左连续或 <span class="math inline">\(x=-R\)</span> 处右连续，即 <span class="math inline">\(\displaystyle \lim_{x\to R^-}S(x)=S(R)=\sum_{n=0}^\infty a_nR^n\)</span></li><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 的收敛半径 <span class="math inline">\(R&gt;0\)</span>，在收敛区间 <span class="math inline">\((-R,R)\)</span> 内的和函数为 <span class="math inline">\(S(n)\)</span>，则 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\((-R,R)\)</span> 上可导，且有<strong>逐项求导公式</strong></li></ol><p><span class="math display">\[  \begin{aligned}  S&#39;(x) = &amp;\left(\sum_{n=0}^\infty a_nx^n\right)&#39;\\    = &amp;\sum_{n=0}^\infty \left(a_nx^n\right)&#39;\\    = &amp;\sum_{n=0}^\infty na_nx^{n-1}\\  \end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty na_nx^{n-1}\)</span> 的收敛半径仍为 <span class="math inline">\(R\)</span></p><ol start="4" type="1"><li>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 的收敛半径 <span class="math inline">\(R&gt;0\)</span>，在收敛区间 <span class="math inline">\((-R,R)\)</span> 内的和函数为 <span class="math inline">\(S(n)\)</span>，则 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\((-R,R)\)</span> 上可导，且有<strong>逐项求积公式</strong></li></ol><p><span class="math display">\[  \begin{aligned}  \int_0^xS(t)\,\mathrm{d}t = &amp;\int_0^x\left(\sum_{n=0}^\infty a_nt^n\right)\,\mathrm{d}t\\    = &amp;\sum_{n=0}^\infty \int_0^x a_nt^n\,\mathrm{d}t\\    = &amp;\sum_{n=0}^\infty \frac{a_n}{n+1}x^{n+1}\\  \end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nt^n\)</span> 的收敛半径仍为 <span class="math inline">\(R\)</span></p><h4 id="幂级数的分析性质">幂级数的分析性质</h4><p><strong>性质：</strong></p><p>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 的收敛半径为 <span class="math inline">\(R&gt;0\)</span>，在收敛区间 <span class="math inline">\((-R,R)\)</span> 上连续；若 <span class="math inline">\(\displaystyle\sum_{n=0}^\infty a_nx^n\)</span> 在 <span class="math inline">\(x=R\)</span> 或 <span class="math inline">\(x=-R\)</span> 收敛，则和函数 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\(x=R\)</span> 左连续或 <span class="math inline">\(x=-R\)</span> 处右连续，即</p><p><span class="math display">\[\displaystyle \lim_{x\to R^-}S(x)=S(R)=\sum_{n=0}^\infty a_nR^n\]</span></p><p><strong>性质：</strong></p><p>若幂函数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 的收敛半径为 <span class="math inline">\(R&gt;0\)</span>，在收敛区间 <span class="math inline">\((-R,R)\)</span> 上的和函数为 <span class="math inline">\(S(n)\)</span>，则 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\((-R,R)\)</span> 上可导，且有<strong>逐项求导公式</strong></p><p><span class="math display">\[\begin{aligned}S&#39;(x) = &amp;\left(\sum_{n=0}^\infty a_nx^n\right)&#39;\\  = &amp;\sum_{n=0}^\infty \left(a_nx^n\right)&#39;\\  = &amp;\sum_{n=0}^\infty na_nx^{n-1}\\\end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty na_nx^{n-1}\)</span> 的收敛半径仍为 <span class="math inline">\(R\)</span></p><p><strong>性质：</strong></p><p>若幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nx^n\)</span> 的收敛半径为 <span class="math inline">\(R&gt;0\)</span>，在收敛区间 <span class="math inline">\((-R,R)\)</span> 上的和函数为 <span class="math inline">\(S(n)\)</span>，则 <span class="math inline">\(S(n)\)</span> 在 <span class="math inline">\((-R,R)\)</span> 上可导，且有<strong>逐项求积公式</strong></p><p><span class="math display">\[\begin{aligned}\int_0^xS(t)\,\mathrm{d}t = &amp;\int_0^x\left(\sum_{n=0}^\infty a_nt^n\right)\,\mathrm{d}t\\  = &amp;\sum_{n=0}^\infty \int_0^x a_nt^n\,\mathrm{d}t\\  = &amp;\sum_{n=0}^\infty \frac{a_n}{n+1}x^{n+1}\\\end{aligned}\]</span></p><p>且幂级数 <span class="math inline">\(\displaystyle \sum_{n=0}^\infty a_nt^n\)</span> 的收敛半径仍为 <span class="math inline">\(R\)</span></p><blockquote><ol type="1"><li>幂函数逐项求导，逐项积分后，收敛半径不变，但是收敛域可能改变</li><li>幂函数在收敛区间内具有任意阶导数</li></ol></blockquote><h4 id="taylor-级数">Taylor 级数</h4><p><strong>定义：</strong></p><p>设函数 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 的某领域内有任意阶导数，称幂级数</p><p><span class="math display">\[\sum_{n=0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</span></p><p>为 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 处的 <strong>Taylor</strong> 级数，记为</p><p><span class="math display">\[f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</span></p><p><span class="math inline">\(x_0=0\)</span> 是，称为 <strong>Maclaurin 级数</strong></p><p><strong>定理（唯一性）</strong></p><p>若 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 可展开为幂级数，则展开式唯一，且恰为 Taylor 级数</p><p><strong>定理</strong></p><p>设 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\(x_0\)</span> 的某领域 <span class="math inline">\(I\)</span> 内任意阶可导，则在 <span class="math inline">\(I\)</span> 内</p><p><span class="math display">\[f(x) = \sum_{n=0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \Leftrightarrow \lim_{n\to\infty}R_n(x) =0\]</span></p><h4 id="常用的初等函数的幂级数展开式">常用的初等函数的幂级数展开式</h4><ol type="1"><li><span class="math inline">\(\displaystyle e^x = \sum_{n=0}^\infty \frac{x^n}{n!} \quad (x\in\mathbb{R})\)</span></li><li><span class="math inline">\(\displaystyle \sin x = \sum_{n=0}^\infty \frac{(-1)^nx^{2n+1}}{(2n+1)!} \quad (x\in\mathbb{R})\)</span></li><li><span class="math inline">\(\displaystyle \cos x = \sum_{n=0}^\infty \frac{(-1)^nx^{2n}}{(2n)!} \quad (x\in\mathbb{R})\)</span></li><li><span class="math inline">\(\displaystyle \ln(1+x) = \sum_{n=1}^\infty \frac{(-1)^{n-1}x^n}{n} \quad (\left\vert x \right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle (1+x)^\alpha = \sum_{n=0}^\infty \frac{\alpha(\alpha-1)\cdots(\alpha-n+1)}{n!}x^n \quad (\left\vert x\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle \frac{1}{1-x} = \sum_{n=0}^\infty x^n \quad (\left\vert x\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle \frac{1}{1+x} = \sum_{n=0}^\infty (-1)^nx^n \quad (\left\vert x\right\vert&lt;1)\)</span></li><li><span class="math inline">\(\displaystyle \arctan{x} = \sum_{n=0}^\infty \frac{(-1)^n x^{2n+1}}{2n+1} \quad (\left\vert x\right\vert\leq 1)\)</span></li></ol><h4 id="正弦级数和余弦级数">正弦级数和余弦级数</h4><p>若周期为 <span class="math inline">\(2\pi\)</span> 的函数 <span class="math inline">\(f(x)\)</span> 是奇函数时，其 Fourier 系数 <span class="math inline">\(a_n=0\)</span>，从而</p><p><span class="math display">\[f(x) \sim \sum_{n=1}^{+\infty}b_n\sin(nx)\quad\text{正弦级数}\]</span></p><p>其中 <span class="math inline">\(\displaystyle b_n =\frac{2}{\pi}\int_0^\pi f(x)\sin(nx) \,\mathrm{d}x\)</span></p><p>若周期为 <span class="math inline">\(2\pi\)</span> 的函数 <span class="math inline">\(f(x)\)</span> 是偶函数，其 Fourier 系数 <span class="math inline">\(b_n=0\)</span>，从而</p><p><span class="math display">\[f(x) \sim \frac{a_0}{2}+\sum_{n=0}^{+\infty}a_n\cos(nx)\quad\text{余弦级数}\]</span></p><p>其中 <span class="math inline">\(\displaystyle a_n =\frac{1}{\pi}\int_0^\pi f(x)\cos(nx) \,\mathrm{d}x\)</span></p><p>若函数 <span class="math inline">\(f(x)\)</span> 定义在 <span class="math inline">\([0,\pi]\)</span> 上，可作奇延拓</p><p><span class="math display">\[F(x)=\begin{cases}  f(x), &amp; 0&lt; x&lt; \pi\\  -f(-x), &amp; -\pi &lt; x &lt; 0\\  0, &amp; x=0,\pm\pi\\\end{cases}\]</span></p><p>使得 <span class="math inline">\(F(x)\)</span> 为 <span class="math inline">\([-\pi,\pi]\)</span> 上的奇函数</p><p>也可作偶延拓</p><p><span class="math display">\[G(x)=\begin{cases}  f(x), &amp; 0&lt; x&lt; \pi\\  f(-x), &amp; -\pi &lt; x &lt; 0\\  0, &amp; x=0,\pm\pi\\\end{cases}\]</span></p><p>使得函数 <span class="math inline">\(G(x)\)</span> 为 <span class="math inline">\([-\pi,\pi]\)</span> 上的偶函数</p><p>对于一定义在 <span class="math inline">\([0,\pi]\)</span> 上的函数 <span class="math inline">\(f(x)\)</span>，可以对其先做奇延拓或者偶延拓，再将其展开为 正弦级数或者余弦级数</p><h4 id="周期为-2l-的-fourier-级数">周期为 <span class="math inline">\(2l\)</span> 的 Fourier 级数</h4><p>设函数 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\([-l,l]\)</span> 上可积，作代换 <span class="math inline">\(x =\frac{l}{\pi}t\)</span>，使得 <span class="math inline">\(F(t) = f\left(\frac{l}{\pi}t\right)\)</span> 为 <span class="math inline">\([-\pi,\pi]\)</span> 上的可积函数，从而</p><p><span class="math display">\[F(t) \sim \frac{a_0}{2}+\sum_{n=1}^{+\infty}a_n\cos(nt)+\sum_{n=1}^{+\infty}b_n\sin(nt)\]</span></p><p>其中</p><p><span class="math display">\[\begin{aligned}a_n &amp;= \frac{1}{\pi}\int_{-\pi}^{\pi}F(t)\cos(nt)\,\mathrm{d}t = \frac{1}{l}\int_{-l}^{l}f(x)\cos\left(\frac{\pi n}{l}x\right)\,\mathrm{d}x\\b_n &amp;= \frac{1}{\pi}\int_{-\pi}^{\pi}F(t)\sin(nt)\,\mathrm{d}t = \frac{1}{l}\int_{-l}^{l}f(x)\sin\left(\frac{\pi n}{l}x\right)\,\mathrm{d}x\end{aligned}\]</span></p><p>故</p><p><span class="math display">\[f(x) \sim \frac{a_0}{2}+\sum_{n=1}^{+\infty}\left(a_n\cos\left(\frac{\pi n}{l}x\right)+b_n\sin\left(\frac{\pi n}{l}x\right)\right)\]</span></p><p>其中</p><p><span class="math display">\[\begin{aligned}a_n &amp;= \frac{1}{l}\int_{-l}^{l}f(x)\cos\left(\frac{\pi n}{l}x\right)\,\mathrm{d}x\\b_n &amp;= \frac{1}{l}\int_{-l}^{l}f(x)\sin\left(\frac{\pi n}{l}x\right)\,\mathrm{d}x\end{aligned}\]</span></p><p><strong>定理：</strong></p><p>若 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([-l,l]\)</span> 上满足 Dirichlet 条件，则 Fourier 级数</p><p><span class="math display">\[\frac{a_0}{2}+\sum_{n=1}^{+\infty}\left(a_n\cos\left(\frac{\pi n}{l}x\right)+b_n\sin\left(\frac{\pi n}{l}x\right)\right)\]</span></p><p>收敛到</p><p><span class="math display">\[S(n) =\begin{cases}  f(x), &amp; x \text{为} f(x) \text{的连续点}\\  \frac{f(x^+)+f(x^-)}{2}, &amp; x \text{为} f(x) \text{的间断点}\\  \frac{f(l^-)+f(-l^+)}{2} ,&amp; x=\pm l\end{cases}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>高数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学物理3笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%89%A9%E7%90%86/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%863%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="基本常数">基本常数</h2><table><thead><tr class="header"><th>名称</th><th>符号</th><th>数值</th><th>单位</th></tr></thead><tbody><tr class="odd"><td>斯特番常数</td><td><span class="math inline">\(\sigma\)</span></td><td><span class="math inline">\(5.67\times 10^{-8}\)</span></td><td><span class="math inline">\(W\cdot m^{-2}\cdot K^{-4}\)</span></td></tr><tr class="even"><td>维恩常数</td><td><span class="math inline">\(b\)</span></td><td><span class="math inline">\(2.898\times 10^{-3}\)</span></td><td><span class="math inline">\(m\cdot K\)</span></td></tr><tr class="odd"><td>玻尔兹曼常数</td><td><span class="math inline">\(k\)</span></td><td><span class="math inline">\(1.38\times 10^{-23}\)</span></td><td><span class="math inline">\(J\cdot K^{-1}\)</span></td></tr><tr class="even"><td>普朗克常数</td><td><span class="math inline">\(h\)</span></td><td><span class="math inline">\(6.63\times 10^{-34}\)</span></td><td><span class="math inline">\(J\cdot s\)</span></td></tr><tr class="odd"><td>康普顿波长</td><td><span class="math inline">\(\lambda_c\)</span></td><td><span class="math inline">\(0.02426\)</span></td><td><span class="math inline">\(\text{Å}\)</span></td></tr><tr class="even"><td>里德伯常数</td><td><span class="math inline">\(R\)</span></td><td><span class="math inline">\(1.097\times 10^{7}\)</span></td><td><span class="math inline">\(m^{-1}\)</span></td></tr></tbody></table><h2 id="算符">算符</h2><table><thead><tr class="header"><th>名称</th><th>表达式</th></tr></thead><tbody><tr class="odd"><td>能量算符</td><td><span class="math inline">\(\hat{E} = i\hbar\frac{\partial}{\partial t}\)</span></td></tr><tr class="even"><td>动量算符</td><td><span class="math inline">\(\hat{p} = -i\hbar\nabla\)</span></td></tr><tr class="odd"><td>哈密顿算符</td><td><span class="math inline">\(\hat{H} = -\frac{\hbar^2}{2m}\nabla ^2 + U(\boldsymbol{r},t)\)</span></td></tr><tr class="even"><td>角动量算符</td><td><span class="math inline">\(\hat{L} = \hat{r}\times \hat{p}\)</span></td></tr></tbody></table><h2 id="量子物理基础">量子物理基础</h2><h3 id="黑体辐射">黑体辐射</h3><h4 id="热辐射的基本概念">热辐射的基本概念</h4><ul><li>所有物在有限体温度下都会发射电磁波，这种与温度有关的辐射称为热辐射 (heat radiation).</li><li>热辐射是连续谱.</li><li>基本性质：温度越高，发射的能量越大，电磁波的短波成分能量越大.</li><li>平衡热辐射：热辐射是热平衡状态下的辐射.</li></ul><h5 id="热辐射基本参数">热辐射基本参数</h5><p><strong>单色辐出度 <span class="math inline">\(M_{\lambda}(W/m^3)\)</span></strong></p><p>物体单位表面在单位时间内发出的波长在 <span class="math inline">\(\lambda\)</span> 附近单位波长间隔内的电磁波的能量，用于描述物体辐射能量的能力</p><p><span class="math display">\[M_{\lambda}(T)=\frac{\mathrm{d}E_{\lambda}}{\mathrm{d}\lambda}\]</span></p><p><strong>辐出度 <span class="math inline">\(M(T)(W/m^2)\)</span></strong></p><p>物体从单位面积上发射的所有波长的辐射总功率</p><p><span class="math display">\[M(t)=\int _0^{+\infty}M_{\lambda}(T)\,\mathrm{d}\lambda\]</span></p><p><strong>吸收比 <span class="math inline">\(\alpha(T)\)</span> 和反射比 <span class="math inline">\(r(T)\)</span></strong></p><ul><li><strong>吸收比</strong>：辐射从外界入射到物体表面时，吸收的能量和入射的能量之比，是吸收能力的量度.</li></ul><p><span class="math display">\[\alpha(T)=\frac{E^\text{吸收}}{E^\text{入射}}\]</span></p><ul><li><strong>反射比</strong>：辐射从外界入射到物体表面时，反射的能量和入射的能量之比，是反射能力的量度.</li></ul><p><span class="math display">\[r(T)=\frac{E^\text{反射}}{E^\text{入射}}\]</span></p><p><strong>单色吸收比 <span class="math inline">\(\alpha(\lambda,T)\)</span> 和单色反射比 <span class="math inline">\(r(\lambda,T)\)</span></strong></p><ul><li><strong>单色吸收比</strong>：当辐射从外界入射到物体表面时，吸收的波长从 <span class="math inline">\(\lambda\)</span> 到 <span class="math inline">\(\lambda +\mathrm{d}\lambda\)</span> 波长间隔内的能量 <span class="math inline">\(E_\lambda^\text{吸收}\mathrm{d}\lambda\)</span> 和入射的能量 <span class="math inline">\(E_\lambda^\text{入射}\mathrm{d}\lambda\)</span> 之比.</li></ul><p><span class="math display">\[\alpha(\lambda,T)=\frac{E_\lambda^\text{吸收}}{E_\lambda^\text{入射}}\]</span></p><ul><li><strong>单色反射比</strong>：当辐射从外界入射到物体表面时，反射的波长从 <span class="math inline">\(\lambda\)</span> 到 <span class="math inline">\(\lambda +\mathrm{d}\lambda\)</span> 波长间隔内的能量 <span class="math inline">\(E_\lambda^\text{反射}\mathrm{d}\lambda\)</span> 和入射的能量 <span class="math inline">\(E_\lambda^\text{入射}\mathrm{d}\lambda\)</span> 之比.</li></ul><p><span class="math display">\[r(\lambda,T)=\frac{E_\lambda^\text{反射}}{E_\lambda^\text{入射}}\]</span></p><p>对于不透明物体，有 <span class="math inline">\(\alpha(\lambda,T)+r(\lambda,T)=1\)</span>.</p><h5 id="基尔霍夫定律">基尔霍夫定律</h5><p>一个好的发射体一定是个好的吸收体（黑白盘子实验） <img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E7%99%BD%E7%9B%98%E5%AE%9E%E9%AA%8C.png" alt="黑白盘实验" /></p><p>温度一定时物体在某波长处的单色辐出度与单色吸收比的比值与物体及物体表面的性质无关，即</p><p><span class="math display">\[\frac{M_1(\lambda,T)}{\alpha_1(\lambda,T)} = \frac{M_2(\lambda,T)}{\alpha_2(\lambda,T)}=\ldots=M_0(\lambda,T).\]</span></p><p>其中 <span class="math inline">\(M_0(\lambda,T)\)</span> 是一个只与波长和温度有关，与物体材料、表面状态无关的函数，称为黑体辐射强度，是黑体的单色辐出度.</p><h5 id="黑体">黑体</h5><p>能完全吸收各种波长电磁波而无反射的物体是黑体 黑体是理想模型，可以建立只有小孔的空腔，小孔是黑体，空腔内的辐射是黑体辐射</p><h6 id="黑体辐射的基本规律">黑体辐射的基本规律</h6><p>温度一定时，黑体辐射的强度与波长有关，存在一定的波长 <span class="math inline">\(\lambda _{\max}\)</span> 使得辐射强度最大，称为黑体辐射的主波长. <img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/%E9%BB%91%E4%BD%93%E8%BE%90%E5%B0%84%E5%9B%BE.png" alt="黑体辐射图" /></p><ul><li><strong>斯特番-玻尔兹曼定律(J. Stefan, L. Boltzmann)</strong> 实验证明，黑体的总辐出度 <span class="math inline">\(M_0(T)\)</span> 与温度 <span class="math inline">\(T\)</span> 的四次方成正比</li></ul><p><span class="math display">\[M_0(T)=\sigma T^4\]</span></p><p>其中 <span class="math inline">\(\sigma = 5.67\times 10^{-8} W\cdot m^{-2}\cdot K^{-4}\)</span>，称为斯特番常数. 1879 年斯特番实验总结得到，1884 年玻尔兹曼理论证明. 表明热辐射对温度的敏感性 <span class="math inline">\(\propto T^4\)</span>.</p><ul><li>维恩位移定律(W. Wien) 黑体辐射中单色辐出值的极值波长 <span class="math inline">\(\lambda_m\)</span> 与黑体温度 <span class="math inline">\(T\)</span> 之积为常数</li></ul><p><span class="math display">\[\lambda_mT=b\]</span></p><p>其中 <span class="math inline">\(b=2.898\times 10^{-3}m\cdot K\)</span> ，为 Wien 常数.</p><h5 id="普朗克的能量子假说和黑体辐射公式">普朗克的能量子假说和黑体辐射公式</h5><h6 id="维恩公式">维恩公式</h6><p><span class="math display">\[M_0(\nu,T)=\alpha\nu^3e^{-\beta/T}\]</span></p><ul><li>在高频段与实验符合得很好，但是在低频段明显偏离实验曲线</li></ul><h6 id="瑞利-金斯公式">瑞利-金斯公式</h6><p><span class="math display">\[M_0(\nu,T)=\frac{2\pi \nu^2}{c^2}kT\]</span></p><ul><li>其中 <span class="math inline">\(k=1.38\times 10^{-23} J\cdot K^{-1}\)</span> ，为玻尔兹曼常数.</li><li>低频段与实验符合得很好，但是在高频段明显偏离实验曲线.</li><li>且当 <span class="math inline">\(\nu\to\infty\)</span> 时，<span class="math inline">\(M_0(\nu,T)\to \infty\)</span>，称为紫外灾难.</li></ul><h6 id="普朗克公式">普朗克公式</h6><p>普朗克以适用于高频段的维恩公式和适用于低频段的瑞利-金斯公式为基础，提出了<strong>普朗克黑体辐射公式</strong>，是一个半经验公式.</p><p><span class="math display">\[M_0(\nu,T)=\frac{2\pi\nu^2}{c^2}\frac{h\nu}{e^{\frac{h\nu}{kT}}-1}\]</span></p><ul><li><p>其中 <span class="math inline">\(h=6.63\times 10^{-34}J\cdot s\)</span> 为普朗克常量.</p></li><li><p>普朗克公式在整个频段都符合实验结果.</p></li><li><p>普朗克认为：空腔内壁的分子、原子的振动可以看成是许多带电的简谐振子，这些简谐振子可以辐射和吸收能量，并与空腔内的辐射达到平衡。从空腔小孔辐射出的电磁波，就是由这些空腔内壁的简谐振子辐射出的。他假定对于频率为 <span class="math inline">\(\nu\)</span> 的振子，振子能量不是连续的，而是分立的，它的取值是某一最小能量 <span class="math inline">\(h\)</span> 的整数倍，即<strong>当振子吸收或放出能量时，以 <span class="math inline">\(h\nu\)</span> 为单位.</strong></p></li><li><p>我们计 <span class="math inline">\(\varepsilon =h\nu\)</span> ，称为<strong>能量子（quanta of enmergy）</strong></p></li><li><p>由普朗克公式可以推出其他热辐射公式</p><p><span class="math display">\[M_0(\nu,T)=\frac{2\pi\nu^2}{c^2}\frac{h\nu}{e^{\frac{h\nu}{kT}}-1}\ \\left\{  \begin{aligned}  &amp;\text{积分} \rightarrow M=\sigma T^4, \ \ \text{斯特番-玻尔兹曼定律}\\  &amp;\text{求导} \rightarrow \lambda_mT=b. \ \ \text{维恩位移定律}\\  &amp;\text{低频极限} \rightarrow M_0(\nu,T)=\frac{2\pi\nu^2}{c^2}kT, \ \ \text{瑞利-金斯公式}\\  &amp;\text{高频极限} \rightarrow M_0(\nu,T)=\alpha\nu^3e^{-\beta/T}, \ \ \text{维恩公式}  \end{aligned}\right.\]</span></p></li></ul><h3 id="光电效应photoelectric-effect">光电效应（Photoelectric effect）</h3><h4 id="实验模型">实验模型</h4><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250228160736.png" alt="实验装置" /><figcaption aria-hidden="true">实验装置</figcaption></figure><p>当光照在金属表面，电子从金属中脱出的现象，称为光电效应</p><h4 id="基本参数">基本参数</h4><h4 id="饱和电流">饱和电流</h4><p>实验表明，当入射光强度不变，加速电势差 <span class="math inline">\(U\)</span> 越大，光电流 <span class="math inline">\(I\)</span> 也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为<strong>饱和电流</strong>。若改变入射光强，<strong>饱和电流的大小与入射光强成正比</strong>，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比.</p><h4 id="遏制电压差">遏制电压差</h4><p>改变阴极与阳极之间的电压，当电压增大到一定值时，光电流减小到零，此时的电压差称为<strong>遏制电压差</strong>。遏制电压差的大小与入射光的频率有关，与光强无关. 光电子从表面逸出的最大初速度 <span class="math inline">\(v_m\)</span> 满足：</p><p><span class="math display">\[\frac{1}{2} m v_m^2 = eU_0\]</span></p><h4 id="爱因斯坦的光量子论">爱因斯坦的光量子论</h4><p>电子辐射由以光速 <span class="math inline">\(c\)</span> 运动的局限于空间某小范围的光量子（光子），即光子流组成 光子的能量为 <span class="math inline">\(\varepsilon = h\nu\)</span> ，动量为 <span class="math inline">\(p = \frac{h}{\lambda}\)</span></p><ul><li>光电效应的基本方程</li></ul><p><span class="math display">\[h \nu=\frac{1}{2} m v_{\mathrm{m}}^{2}+A\]</span></p><p>其中 <span class="math inline">\(\frac{1}{2}mv_{\mathrm{m}}^{2}\)</span> 是光电子的最大初动能.</p><p><strong>解释：</strong> 光照射金属时，电子吸收光子，能量增加，一部分用于克服金属脱出功，一部分增加电子的初动能</p><h4 id="光的波粒二象性">光的波粒二象性</h4><ul><li>一些情况下，光的波动性表现得很明显，如干涉、衍射、偏振等现象.</li><li>一些情况下，光的粒子性表现得很明显，如光电效应、康普顿散射等现象.</li></ul><p>这被称为光的波粒二象性</p><ul><li>光不是牛顿经典粒子，也不是康普顿的经典波</li></ul><p>基本关系式</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;\varepsilon = h\nu \quad \text{粒子性}\\    &amp;p = \frac{\varepsilon}{c}=\frac{h}{\lambda} \quad \text{波动性}  \end{aligned}\right.\]</span></p><h3 id="康普顿散射">康普顿散射</h3><p>在散射的 X 射线中，存在与入射光波长相等的波，也存在波长比入射光波长大的波，这种现象称为<strong>康普顿散射</strong> .</p><h4 id="特点">特点</h4><p><span class="math display">\[\Delta \lambda = \lambda&#39; - \lambda = \lambda _{c} (1-\cos\theta)\]</span></p><p>其中</p><ul><li><span class="math inline">\(\lambda_c =\frac{h}{m_{0}c}= 0.02426 \text{Å}\)</span> 被称为康普顿波长. 当光子的波长等于 <span class="math inline">\(\lambda_c\)</span> 时，其能量等于电子的能量 <span class="math inline">\(m_{c}c^{2} =1.511 \text{MeV}\)</span> .</li><li><span class="math inline">\(\theta\)</span> 为散射角.</li></ul><ol type="1"><li>波长改变量随散射角 <span class="math inline">\(\theta\)</span> 的增大而增大</li><li>新成分的相对强度随散射角 <span class="math inline">\(\theta\)</span> 的增大而增大</li><li>同一个散射角下，所有散射物质的波长差相等</li><li>随着原子序数的增加，原波长成分的相对强度增大，即对对于轻元素康普顿散射更为明显.</li></ol><p>其中 3、4 是由吴有训发现的</p><h4 id="推导">推导</h4><p>使用动量守恒和能量守恒进行推导（X 射线光子与静止的自由电子的碰撞）</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250302131054.png" alt="康普顿散射推导" /><figcaption aria-hidden="true">康普顿散射推导</figcaption></figure><p>由能量守恒：</p><p><span class="math display">\[\begin{equation}  h\nu + m_{e}c^{2} = h\nu&#39; +mc^{2}\end{equation}\]</span></p><p>其中 <span class="math inline">\(m=\frac{m_{e}}{\sqrt{1-\frac{v^2}{c^2}}}\)</span></p><p>由 <span class="math inline">\(x\)</span> 方向上的动量守恒</p><p><span class="math display">\[\begin{equation}  \frac{h\nu _0}{c} = \frac{h\nu}{c} \cos{\theta} + mv\cos{\varphi}\end{equation}\]</span></p><p>由 <span class="math inline">\(y\)</span> 方向上的动量守恒</p><p><span class="math display">\[\begin{equation}  0 = \frac{h\nu}{c} \sin{\theta} - mv\sin{\varphi}\end{equation}\]</span></p><p>解方程组即可得到康普顿散射的公式</p><p><span class="math display">\[\Delta \lambda = \lambda _{0} -\lambda =\frac{h}{m_{e}c} (1-\cos{\theta})\]</span></p><h3 id="波尔氢原子理论">波尔氢原子理论</h3><h4 id="原子模型的发展">原子模型的发展</h4><ol type="1"><li>汤姆逊的面包夹葡萄干模型</li><li>卢瑟福的 <span class="math inline">\(\alpha\)</span> 粒子散射实验和原子的核结构模型</li></ol><h4 id="氢原子光谱">氢原子光谱</h4><h5 id="公式">公式</h5><h6 id="里德伯公式">里德伯公式</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right) \quad(m=1,2,3,\cdots;n=m+1,m+2,m+3,\cdots)\]</span></p><p>其中：</p><ul><li><span class="math inline">\(\widetilde{\nu} = \frac{1}{\lambda}\)</span> 为波长的倒数，即波数</li><li><span class="math inline">\(R=1.097\times 10^{7}m^{-1}\)</span> 为里德伯常数</li></ul><h6 id="赖曼系-m1-紫外区">赖曼系（ <span class="math inline">\(m=1\)</span> ，紫外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{1^{2}}-\frac{1}{n^{2}}\right) \quad(n=2,3,4,\cdots)\]</span></p><h6 id="巴尔末系-m2">巴尔末系（ <span class="math inline">\(m=2\)</span> ）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{2^{2}}-\frac{1}{n^{2}}\right) \quad(n=3,4,5,\cdots)\]</span></p><h6 id="帕邢系-m3-红外区">帕邢系（ <span class="math inline">\(m=3\)</span> ，红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{3^{2}}-\frac{1}{n^{2}}\right) \quad(n=4,5,6,\cdots)\]</span></p><h6 id="布拉开系-m4-近红外区">布拉开系 （ <span class="math inline">\(m=4\)</span> ，近红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{4^{2}}-\frac{1}{n^{2}}\right) \quad(n=5,6,7,\cdots)\]</span></p><h6 id="普丰德系-m5-远红外区">普丰德系（ <span class="math inline">\(m=5\)</span> ，远红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{5^{2}}-\frac{1}{n^{2}}\right) \quad(n=6,7,8,\cdots)\]</span></p><h6 id="汉弗莱系-m6-远红外区">汉弗莱系 （ <span class="math inline">\(m=6\)</span> ，远红外区）</h6><p><span class="math display">\[\widetilde{\nu}=R\left(\frac{1}{6^{2}}-\frac{1}{n^{2}}\right) \quad(n=7,8,9,\cdots)\]</span></p><h5 id="波尔的氢原子模型">波尔的氢原子模型</h5><h5 id="波尔假设">波尔假设</h5><ol type="1"><li><p>原子中的电子只能在一些分离的轨道上运行，在每一个轨道上运动的电子处于不稳定的能量状态（定态 <span class="math inline">\(EW_{n}\)</span> ），不向外辐射能量</p></li><li><p><strong>频率条件：</strong> 当电子从一个定态跃迁另一个定态时，发射或吸收一个光子， $h_{nm}=E_n-E_m$</p></li><li><p><strong>结论：</strong></p><p><span class="math display">\[\nu=\frac{E_{n}-E_{m}}{h}=\frac{m e^{4}}{8 \varepsilon _{0}^{2} h^{3}}\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)\]</span></p></li></ol><h5 id="波尔角动量量子化条件">波尔角动量量子化条件</h5><p><span class="math display">\[L=n \frac{h}{2 \pi}=n \hbar,n=1,2,3,\cdots\]</span></p><p>其中， <span class="math inline">\(n\)</span> 为量子数， <span class="math inline">\(\hbar=\frac{h}{2\pi}\)</span> 为约化普朗克常数. <strong>定量计算：</strong> 由电子的向心力和轨道角动量的量子化得到</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;m\frac{v^{2}}{r}=\frac{1}{4\pi \varepsilon _{0}}\cdot \frac{e^2}{r^2}\\    &amp;L=mvr=n\hbar  \end{aligned}\right.\]</span></p><p>解得：</p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;r_n=n^2\frac{4\pi \varepsilon _{0} \hbar^{2}}{m e^{2}}=n^2r_1\\    &amp;v_n=\frac{e^{2}}{4\pi \varepsilon _{0} n \hbar}=\alpha \frac{c}{n}  \end{aligned}\right.\]</span></p><p>其中 <span class="math inline">\(r_1 = \frac{4\pi \varepsilon _{0} \hbar^{2}}{m e^{2}} = 0.529\text{Å}\)</span> 为氢原子中电子的最小轨道</p><p><strong>轨道能量：</strong></p><p><span class="math display">\[E_n =\frac{1}{2}mv_n^2 + (-\frac{1}{4\pi \varepsilon _0}\cdot \frac{e^2}{r_n^2}) = -\frac{me^4}{8\varepsilon_0^2h^2n^2}=-\frac{1}{n^2}E_1\]</span></p><p>其中 <span class="math inline">\(E_1 = 13.6eV\)</span> 为氢原子基态能量</p><h5 id="波尔的对应原理">波尔的对应原理</h5><p>当 <span class="math inline">\(n\rightarrow +\infty\)</span> 时，<span class="math inline">\(r_n \rightarrow 0\)</span> ，<span class="math inline">\(E_n \rightarrow 0\)</span> ，<span class="math inline">\(\displaystyle \Delta E = E_n - E_{n+1} = \frac{me^4}{4 \varepsilon _0h^2n^3}\rightarrow 0\)</span> ，即能级间距趋于零，能级连续，形成连续谱.</p><h2 id="量子动力学入门">量子动力学入门</h2><p>量子力学的两条路线</p><ol type="1"><li>波动力学 普朗克、爱因斯坦、德布罗意、薛定谔</li><li>矩阵力学 普朗克、波尔、海森堡</li></ol><ul><li>最后由玻恩给出统计解释</li><li>波动力学和矩阵力学完全等价</li></ul><h3 id="物质波">物质波</h3><h4 id="德布罗意假说">德布罗意假说</h4><p>德布罗意假设：实物具有波粒二象性</p><table><thead><tr class="header"><th>量</th><th>粒子性</th><th>波动性</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(E\)</span></td><td><span class="math inline">\(mc^2\)</span></td><td><span class="math inline">\(h\nu\)</span></td></tr><tr class="even"><td><span class="math inline">\(p\)</span></td><td><span class="math inline">\(mv\)</span></td><td><span class="math inline">\(\frac{h}{\lambda}\)</span></td></tr></tbody></table><h4 id="德布罗意原子稳定性驻波思想">德布罗意原子稳定性驻波思想</h4><p>原子中的电子在原子核库仑场中运动表现得波动性具有驻波得特征，驻波的稳定性使得电子不会坠落到原子核内</p><h5 id="能量的量子化">能量的量子化</h5><ul><li><span class="math inline">\(\lambda = \frac{2L}{n}\)</span></li><li><span class="math inline">\(p=\frac{h}{2L}n\)</span></li><li><span class="math inline">\(E = \frac{p^2}{2m} = \frac{h^2}{8mL^2}n^2\)</span></li></ul><h5 id="物质波的概念对波尔轨道角动量量子化条件的解释">物质波的概念对波尔轨道角动量量子化条件的解释</h5><p>德布罗意认为电子在经典的圆轨道上运动，形成一个环形驻波</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308170617.png" alt="电子驻波" /><figcaption aria-hidden="true">电子驻波</figcaption></figure><p>电子绕行原子一周，圆周长应等于波长的整数倍</p><p><span class="math display">\[2\pi r = n\lambda\]</span></p><p><span class="math display">\[L = rmv = \frac{n\lambda}{2\pi} \cdot \frac{h}{\lambda} = n\hbar\]</span></p><h4 id="物质波的实验验证">物质波的实验验证</h4><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/20250308171040.png" alt="物质波的实验验证" /><figcaption aria-hidden="true">物质波的实验验证</figcaption></figure><h5 id="布拉格公式">布拉格公式</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503151817449.png" alt="布拉格公式推导" /><figcaption aria-hidden="true">布拉格公式推导</figcaption></figure><p><span class="math display">\[\delta = 2d\sin\theta = n\lambda \quad (n=1,2,3,\cdots)\]</span></p><h4 id="微观粒子波动性的应用">微观粒子波动性的应用</h4><ul><li>显微镜使用电子波提大大提高了分辨率</li></ul><h3 id="波函数的统计解释">波函数的统计解释</h3><h4 id="对电子是什么的两种经典观点">对电子是什么的两种经典观点</h4><ol type="1"><li>电子是波包<ul><li>由两种不同频率的波合成一个波包</li><li>这种观点夸大了波动性，忽略了粒子性<ol type="1"><li>不同频率波在媒质中传播速度不同，波包会逐步扩展而消失，但是实际粒子并没有消失 说明波包是电子的某种实际结果</li><li>在媒质界面上一部分反射，一部分折射，但实际例子或整个反射，或整个折射</li></ol></li></ul></li><li>经典粒子<ul><li>粒子是基本的，波动性源于粒子与粒子的相互作用，或者粒子与狭缝周围原子的相互作用。</li><li>这种观点夸大了粒子性，抹杀了波动性<ol type="1"><li>电子的双缝衍射实验表明电子具有波动性</li><li>电子的波动性并不是很多电子在空间聚集在一起时的相互作用的结果，而是单个电子就具有波动性，是电子自己和自己的干涉</li></ol></li></ul></li></ol><h4 id="对波函数的统计解释">对波函数的统计解释</h4><p>1926 年，玻恩提出了对波函数 <span class="math inline">\(\Psi(\boldsymbol{r},t)\)</span> 的统计解释，将实物粒子的波动性和粒子性有机地结合在一起。</p><h5 id="对亮度的解释">对亮度的解释</h5><ol type="1"><li>波的观点 亮度是该点德布罗意波强度的大小</li><li>粒子的观点 亮度与该点附近出现的感光点的数目成正比，即与该点附近电子的数目成正比，即与该点附近电子的概率成正比</li></ol><h5 id="玻恩对波函数的统计解释">玻恩对波函数的统计解释</h5><p>波函数 <span class="math inline">\(\Psi\)</span> 是描述粒子在空间概率分布的<strong>概率振幅</strong>，其模的平方 <span class="math inline">\(\vert \Psi(\boldsymbol{r},t)\vert ^2 = \Psi(\boldsymbol{r},t) ^{*} \Psi(\boldsymbol{r},t)\)</span> 表示 <span class="math inline">\(t\)</span> 时刻，在坐标 <span class="math inline">\(\boldsymbol{r}\)</span> 附近单位体积中发现一个粒子的概率，被称为<strong>概率密度</strong></p><ul><li>目前对波函数最好的解释是概率波</li><li><span class="math inline">\(t\)</span> 时刻，一个粒子处于 <span class="math inline">\(x\rightarrow x+\mathrm{d}x\)</span> ，<span class="math inline">\(y\rightarrow y+\mathrm{d}y\)</span> ，<span class="math inline">\(z\rightarrow z+\mathrm{d}z\)</span> 的概率为 <span class="math inline">\(\vert \Psi(x,y,z,t)\vert ^2\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span>，记 <span class="math inline">\(\rho(x,y,z,t)=\vert \Psi(x,y,z,t)\vert ^2\)</span> 为概率密度.</li><li>在空间 <span class="math inline">\(\Omega\)</span> 中发现粒子的概率为 <span class="math inline">\(\displaystyle \int_{\Omega}\rho(x,y,z,t) \,\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span></li></ul><h4 id="波函数满足的条件">波函数满足的条件</h4><ol type="1"><li>单值性<ul><li>在空间的任何地方，概率密度只能有一个，所以一般波函数在任何地方都是单值的；</li></ul></li><li>有限性<ul><li>粒子必然在空间的某处出现，概率综合为 1，所以在空间的任何有限体积元 <span class="math inline">\(\mathrm{d}V\)</span> 中，概率密度 <span class="math inline">\(\rho(x,y,z,t)\)</span> 有限；</li><li><strong>归一化条件</strong>：<span class="math inline">\(\displaystyle \int_\Omega \vert \Psi(\boldsymbol{r},t)\vert ^{2}\,\mathrm{d} V =1\)</span> ，其中 <span class="math inline">\(\Omega\)</span> 为全空间；</li><li>归一化条件并不能排除在某些孤立奇点上 <span class="math inline">\(\vert \Psi(\boldsymbol{r},t)\vert ^2 \rightarrow \infty\)</span></li></ul></li><li>连续性<ul><li>波函数一阶导数连续（即使在势能函数有限大小间断点处）</li></ul></li></ol><h3 id="不确定度关系">不确定度关系</h3><h4 id="形式-1位置-动量不确定关系">形式 1（位置-动量不确定关系）</h4><p>当粒子处在 <span class="math inline">\(x\)</span> 方向的一个有限范围 <span class="math inline">\(\Delta x\)</span> 内时，其动量 <span class="math inline">\(p_x\)</span> 的有一个不完全确定的数值范围 <span class="math inline">\(\Delta p_x\)</span> ，两者的乘积满足：</p><p><span class="math display">\[\Delta x \Delta p \geq \frac{\hbar}{2}\]</span></p><p>若记 <span class="math inline">\(k=\frac{2\pi}{\lambda}\)</span> ，则</p><p><span class="math display">\[\Delta x \Delta k \geq \frac{1}{2}\]</span></p><ul><li><strong>含义</strong>：微观粒子的位置和动量不能同时准确地测定</li><li>规律<ol type="1"><li>当 <span class="math inline">\(\Delta x\)</span> 越小，<span class="math inline">\(\Delta p\)</span> 越大</li><li>当 <span class="math inline">\(\Delta p\)</span> 越小，<span class="math inline">\(\Delta x\)</span> 越大</li></ol></li></ul><p>电子的单缝衍射为例</p><ul><li>进入单缝之前的 <span class="math inline">\(\Delta x\)</span> 趋向无穷大</li></ul><h4 id="形式-2">形式 2</h4><p>若粒子在能量状态 <span class="math inline">\(E\)</span> 附近停留时间 <span class="math inline">\(\Delta t\)</span> ，则其能量 <span class="math inline">\(E\)</span> 有一个不完全确定的数值范围 <span class="math inline">\(\Delta E\)</span> ，两者的乘积满足：</p><p><span class="math display">\[\Delta t \Delta E \geq \frac{\hbar}{2}\]</span></p><p>只有当粒子的停留时间为无穷大（定态）时，其能量才是确定的（<span class="math inline">\(\Delta E = 0\)</span> ）</p><h4 id="电子单缝衍射的结论">电子单缝衍射的结论</h4><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281611015.png" alt="电子单缝衍射实验示意图" /><figcaption aria-hidden="true">电子单缝衍射实验示意图</figcaption></figure><ul><li>电子通过单缝之后，动量在 <span class="math inline">\(x\)</span> 方向上的分量 <span class="math inline">\(P_x\)</span> 的大小为</li></ul><p><span class="math display">\[- p \cdot \sin{\theta_1} \leq p_x = p \cdot \sin{\theta} \leq p \cdot \sin{\theta_1}\]</span></p><ul><li>电子通过单缝后，动量在 <span class="math inline">\(x\)</span> 方向分量的不确定量为</li></ul><p><span class="math display">\[\Delta p_x = 2p \cdot \sin{\theta_1} =\frac{2p\lambda}{\Delta x}\]</span></p><p>带入德布罗意关系 <span class="math inline">\(p\lambda =h\)</span>，得到</p><p><span class="math display">\[\Delta x \cdot \Delta p_x =2h\]</span></p><p>这里的讨论只反映不确定度关系的实质，并不表示准确的量值关系</p><h2 id="量子力学">量子力学</h2><h3 id="薛定谔方程">薛定谔方程</h3><ul><li>建立的是描写波函数随时间变化的方程，它必须是波函数应满足的含有对时间微商的微分方程</li><li>是一个假设，无法被推导出来</li></ul><h4 id="满足的条件">满足的条件</h4><ol type="1"><li>方程是线性的 如果 <span class="math inline">\(\Psi_1\)</span> 和 <span class="math inline">\(\Psi_2\)</span> 是薛定谔方程的解，则 <span class="math inline">\(a\Psi_1 + b\Psi_2\)</span> 也是薛定谔方程的解 这是由态叠加原理决定的</li><li>方程的系数不应当包含状态参量，如动量、能量等 否则这个方程只能被粒子的部分状态满足</li></ol><h4 id="自由粒子的薛定谔方程">自由粒子的薛定谔方程</h4><p>动量为 <span class="math inline">\(p\)</span> 、质量为 <span class="math inline">\(m\)</span> 、能量为 <span class="math inline">\(E\)</span> 的粒子在 <span class="math inline">\(x\)</span> 方向上自由运动的薛定谔方程为</p><p><span class="math display">\[\Psi \left(x,t\right) =\Psi _0 e^{-\frac{i}{\hbar}\left(Et-px\right)}\]</span></p><p><strong>对时间求偏导</strong></p><p><span class="math display">\[\frac{\partial \Psi (x,t)}{\partial t} = -\frac{i}{\hbar}E\Psi (x,t)\]</span></p><p>左右两边同乘 <span class="math inline">\(i\hbar\)</span></p><p><span class="math display">\[i\hbar \frac{\partial \Psi (x,t)}{\partial t} = E\Psi (x,t)\]</span></p><p>我们记算符 <span class="math inline">\(\hat{E}\)</span> 为能量算符</p><p><span class="math display">\[\boxed{\hat{E} \equiv i\hbar \frac{\partial}{\partial t}}\]</span></p><p>则</p><p><span class="math display">\[\hat{E} \Psi (x,t) = E\Psi (x,t)\]</span></p><p><strong>对 <span class="math inline">\(x\)</span> 求偏导</strong></p><p><span class="math display">\[\frac{\partial \Psi (x,t)}{\partial x} = \frac{i}{\hbar}p_x\Psi (x,t)\]</span></p><p>左右两边同乘 <span class="math inline">\(-i\hbar\)</span></p><p><span class="math display">\[-i\hbar \frac{\partial \Psi (x,t)}{\partial x} = p_x\Psi (x,t)\]</span></p><p>我们记算符 <span class="math inline">\(\hat{p_x}\)</span> 为动量算符</p><p><span class="math display">\[\boxed{\hat{p_x} \equiv -i\hbar \frac{\partial}{\partial x}}\]</span></p><p>则</p><p><span class="math display">\[\hat{p_x} \Psi (x,t) = p_x\Psi (x,t)\]</span></p><p><strong>对 <span class="math inline">\(x\)</span> 做二次偏导</strong></p><p><span class="math display">\[\frac{\partial^2 \Psi (x,t)}{\partial x^2} = -\frac{p_x^2}{\hbar^2}\Psi (x,t)\]</span></p><p><strong>综合考虑</strong></p><p><span class="math display">\[\left\{  \begin{aligned}    &amp;i\hbar \frac{\partial \Psi (x,t)}{\partial t} = E\Psi (x,t)\\    &amp;\frac{\partial ^2 \Psi (x,t)}{\partial x^2} = -\frac{p_x^2}{\hbar^2}\Psi (x,t)    \end{aligned}\right.\]</span></p><p>由 <span class="math inline">\(E = \frac{p_x^2}{2m}\)</span>，有</p><p><span class="math display">\[i\hbar \frac{\partial \Psi (x,t)}{\partial t} = E\Psi (x,t) = -\frac{p_x^2}{2m}\Psi (x,t)=-\frac{\hbar^2}{2m}\frac{\partial^2 \Psi (x,t)}{\partial x^2}\]</span></p><p><strong>即</strong></p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (x,t)}{\partial t} = -\frac{\hbar^2}{2m}\frac{\partial^2 \Psi (x,t)}{\partial x^2}}\]</span></p><p>这就是自由粒子的薛定谔方程</p><h4 id="薛定谔方程的一般形式">薛定谔方程的一般形式</h4><p>将自由粒子运动算符推广到非自由粒子运动，粒子所处的势场为 <span class="math inline">\(U(x,t)\)</span> 对于保守系统，其能量等于<strong>哈密顿量</strong></p><p><span class="math display">\[E = H = \frac{p^2}{2m} + U(x,t)\]</span></p><p>哈密顿量算符化，称为<strong>哈密顿算符</strong></p><p><span class="math display">\[\hat{H} = \frac{\hat p_x^2}{2m} + U(x,t)=\frac{-\hbar^2}{2m}\frac{\partial^2}{\partial x^2} + U(x,t)\]</span></p><p><strong>薛定谔方程</strong>：对于保守系统，其能量算符作用在波函数上，等于哈密顿算符作用在波函数上</p><p><span class="math display">\[\boxed{\hat{E} \Psi (x,t) = \hat{H} \Psi (x,t)}\]</span></p><p>将其展开</p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (x,t)}{\partial t} = \left(\frac{-\hbar^2}{2m}\frac{\partial ^2}{\partial x^2} + U(x,t)\right) \Psi (x,t)}\]</span></p><p>推广到三维势场</p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (\boldsymbol{r},t)}{\partial t} = \left(-\frac{\hbar^2}{2m}\nabla^2 + U(\boldsymbol{r},t)\right) \Psi (\boldsymbol{r},t)}\]</span></p><h4 id="定态薛定谔方程">定态薛定谔方程</h4><p>若微观粒子在稳定的势场中，则其势能函数 <span class="math inline">\(U\)</span> 与时间无关，称这类问题为定态问题</p><p><span class="math display">\[\hat{H} = -\frac{\hbar^2}{2m}\nabla^2 + U(\boldsymbol{r})\]</span></p><p><span class="math display">\[\i\hbar \frac{\partial}{\partial t}\Psi (\boldsymbol{r},t) = \hat{H} \Psi (\boldsymbol{r},t)\]</span></p><p>此时哈密顿算符与时间无关，薛定谔方程可以用分离变量法求解，波函数 <span class="math inline">\(\Psi\)</span> 分解为空间函数和时间函数的乘积</p><p>设 <span class="math inline">\(\Psi (\boldsymbol{r},t) = \Phi(\boldsymbol{r})T(t)\)</span></p><p><span class="math display">\[i\hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}\Phi(\boldsymbol{r}) = \left[\hat{H} \Phi(\boldsymbol{r})\right] T(t)\]</span></p><p><span class="math display">\[i\hbar \frac{1}{T(t)}\mathrm{d} t = \frac{1}{\Phi(\boldsymbol{r})}\hat{H} \Phi(\boldsymbol{r}) = const = E\]</span></p><p>其中 <span class="math inline">\(E\)</span> 为本征值，<span class="math inline">\(\Phi\)</span> 为本征函数 得到分别只含有变量 <span class="math inline">\(t\)</span> 和 <span class="math inline">\(\boldsymbol{r}\)</span> 的两个方程</p><p><span class="math display">\[\left\{\begin{aligned}  &amp;i \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t} = ET(t)  &amp;&amp;\text{(1)}\\  &amp;\hat{H} \Phi(\boldsymbol{r}) = E\Phi(\boldsymbol{r})  &amp;&amp;\text{(2)}\end{aligned}\right.\]</span></p><p>方程(1)的解为</p><p><span class="math display">\[T(t) = e^{-\frac{i}{\hbar}Et}\]</span></p><p>方程(2)是关于变量 <span class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>、<span class="math inline">\(z\)</span> 的微分方程，称为<strong>定态薛定谔方程</strong>，又称为哈密顿算符的本征方程</p><p><span class="math display">\[\boxed{\left[-\frac{\hbar^2}{2m}\nabla^2 + U(x,y,z)\right] \Phi(x,y,z) = E\Phi(x,y,z)}\]</span></p><p>其解与外力场 <span class="math inline">\(U\)</span> 和边界条件有关 波函数是两者的乘积</p><p><span class="math display">\[\boxed{\Psi (\boldsymbol{r},t) = \Phi(\boldsymbol{r})e^{-i\frac{1}{\hbar}Et}}\]</span></p><ul><li>粒子在空间中出现的几率密度与时间无关——<strong>定态</strong></li></ul><p><span class="math display">\[\vert\Psi (\boldsymbol{r},t)\vert^2 =\vert\Phi(\boldsymbol{r}) e^{-i\frac{1}{\hbar}Et}\vert^2 = \vert\Phi(\boldsymbol{r})\vert^2\]</span></p><h4 id="薛定谔方程的应用">薛定谔方程的应用</h4><h5 id="一维无限深方势阱">一维无限深方势阱</h5><p>金属中的电子由于金属表面势能（能垒）的束缚而被限制在一个有限的空间范围内运动 如果金属表面的能垒很高，可以将金属表面看成一个刚性的盒子。若只考虑一维运动，则其势能函数为</p><p><span class="math display">\[U(x) =\left\{  \begin{aligned}    &amp;0 \quad (0 \leq x \leq L)\\    &amp;\infty \quad (x &lt; 0 \text{ or } x &gt; L)  \end{aligned}\right.\]</span></p><p>称为<strong>一维无限深方势阱</strong></p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504111721435.png" alt="无限深方势阱" /><figcaption aria-hidden="true">无限深方势阱</figcaption></figure><ul><li>势阱内</li></ul><p><span class="math display">\[-\frac{\hbar^2}{2m}\frac{\mathrm{d}^2}{\mathrm{d} x^2} \Phi_i(x) = E\Phi_i(x)\]</span></p><p>令 <span class="math inline">\(k =\sqrt{\frac{2mE}{\hbar^2}}\)</span>，得</p><p><span class="math display">\[\frac{\mathrm{d}^2\Phi_i}{\mathrm{d} x^2} + k^2\Phi_i = 0\]</span></p><p>其解为</p><p><span class="math display">\[\Phi_i(x)=C\sin(kx+\delta)\]</span></p><p>其中 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(\delta\)</span> 为常数，由波函数的自然条件确定</p><ul><li>势阱外</li></ul><p><span class="math display">\[-\frac{\hbar^2}{2m}(\frac{\mathrm{d}^2}{\mathrm{d}x^2}+\infty)\Phi_e(x) = E\Phi_e(x)\]</span></p><p>其解为</p><p><span class="math display">\[\Phi_e(x)=0\]</span></p><ul><li>波函数在肼壁上连续的条件为</li></ul><p><span class="math display">\[\left\{  \begin{aligned}    &amp;\Phi_i(0) = \Phi_e(0) \\    &amp;\Phi_i(L) = \Phi_e(L) \\  \end{aligned}\right.\]</span></p><p>由边界条件可得</p><p><span class="math display">\[\begin{cases}  \Phi_i(0)= 0 &amp;&amp; \text{(1)}\\  \Phi_i(L) = 0 &amp;&amp; \text{(2)}\end{cases}\]</span></p><p>由 <span class="math inline">\((1)\)</span> 可得 <span class="math inline">\(\delta = 0\)</span>、</p><p>由 <span class="math inline">\((2)\)</span> 可得 <span class="math inline">\(kL = n\pi\)</span>，其中 <span class="math inline">\(n\in \mathbb{N}^*\)</span>，即 <span class="math inline">\(k = \frac{n\pi}{L}\)</span></p><p><span class="math display">\[\Phi(x) =\sqrt{\frac{2}{L}}\sin\left(\frac{n\pi}{L}x\right)\]</span></p><ul><li><strong>粒子的能量:</strong> <span class="math inline">\(E = \frac{\hbar^2k^2}{2m} = \frac{n^2\pi^2\hbar^2}{2mL^2}\)</span>，<span class="math inline">\(n\)</span> 为能量量子数<ul><li>能量取分立值（能级），这是<strong>能量量子化</strong>的表现</li></ul></li></ul><p><span class="math display">\[\Delta E = E_{n+1} - E_n = \frac{\hbar^2}{2m}\left(\left(\frac{(n+1)\pi}{L}\right)^2 - \left(\frac{n\pi}{L}\right)^2\right) = (2n+1)\frac{\hbar^2\pi^2}{2mL^2}\]</span></p><ul><li>当 <span class="math inline">\(a\uparrow\)</span> 时 <span class="math inline">\(\Delta E \downarrow\)</span>，并且当 <span class="math inline">\(n \rightarrow \infty\)</span> 时， <span class="math inline">\(\Delta E \rightarrow 0\)</span>，即能级间隔趋于零，能级连续，形成连续谱</li><li>最低能量（零点能）<span class="math inline">\(E_1=\frac{\pi^2\hbar^2}{amL^2}&gt;0\)</span>，具有波动性</li><li>在势阱中形成驻波</li></ul><p><span class="math display">\[\Phi(x) =C\sin\left(\frac{n\pi}{L}x\right)\]</span></p><p>由归一化条件</p><p><span class="math display">\[\int_{-\infty}^{+\infty} \vert \Phi(x) \vert^2\,\mathrm{d}x = \int_{0}^{L} C^2\sin^2\left(\frac{n\pi}{L}x\right)\,\mathrm{d}x = C^2 \cdot \frac{L}{2} = 1\]</span></p><p>解得</p><p><span class="math display">\[C = \sqrt{\frac{2}{L}}\]</span></p><p>故定态波函数为</p><p><span class="math display">\[\Phi(x) =\left\{  \begin{aligned}    &amp;\sqrt{\frac{2}{L}}\sin\left(\frac{n\pi}{L}x\right) &amp;&amp; (0 \leq x \leq L)\\    &amp;0 &amp;&amp; (x &lt; 0 \text{ or } x &gt; L)  \end{aligned}\right.\]</span></p><h6 id="一维无线深方势阱中粒子的波函数和概率密度">一维无线深方势阱中粒子的波函数和概率密度</h6><p><span class="math display">\[\Phi (x,t) = \sqrt{\frac{2}{L}} \sin\left(\frac{n\pi}{L}x\right), \quad (0 \leq x \leq L)\]</span></p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504131458204.png" alt="波函数和概率密度" /><figcaption aria-hidden="true">波函数和概率密度</figcaption></figure><p>可以看出</p><ul><li>势阱中的粒子波函数为驻波</li><li>基态 <span class="math inline">\(n=1\)</span> 除了 <span class="math inline">\(x=0\)</span> 和 <span class="math inline">\(x=L\)</span> 处为节点外，其余无节点</li><li>第 <span class="math inline">\(n\)</span> 量子态有 <span class="math inline">\(n-1\)</span> 个 node</li></ul><h6 id="一维无限深势阱中粒子的波函数是正交归一的">一维无限深势阱中粒子的波函数是正交归一的</h6><p>设不同能级的波函数为 <span class="math inline">\(\Phi_n(x)\)</span> 和 <span class="math inline">\(\Phi_m(x)\)</span></p><ul><li>正交性</li></ul><p><span class="math display">\[\int_{-\infty}^{+\infty} \Phi_n(x) \Phi_m(x)\,\mathrm{d}x = \int _{-\infty }^{+\infty }\sqrt{\frac{2}{L}}\sin\frac{m\pi }{L} x\cdot \sqrt{\frac{2}{L}}\sin\frac{n\pi }{L}\,\mathrm{d} x=\frac{1}{L}\int _{0}^{L}\left(\cos\frac{m-n}{L} -\cos\frac{m+n}{L}\right)\,\mathrm{d} x=0\]</span></p><ul><li>归一性</li></ul><p><span class="math display">\[\int_{-\infty}^{+\infty} \Phi_n(x) \Phi_n(x)\,\mathrm{d}x = \int _{-\infty }^{+\infty }\sqrt{\frac{2}{L}}\sin\frac{n\pi }{L} x\cdot \sqrt{\frac{2}{L}}\sin\frac{n\pi }{L}\,\mathrm{d} x=\frac{1}{L}\int _{0}^{L}\left(\cos 0 -\cos\frac{2n\pi }{L}\right)\,\mathrm{d} x=1\]</span></p><h5 id="波尔对应原理">波尔对应原理</h5><ul><li>在大量子数极限下，量子规律必须转化为经典规律，这也被称为<strong>量子物理的对应原理</strong></li></ul><p>比如</p><ul><li>本征能量</li></ul><p><span class="math display">\[E = E_n = \frac{\hbar^2 \pi^2 n^2}{2mL^2} = n^2 \frac{h^2}{8mL^2}\]</span></p><ul><li>相邻能级的间隔为</li></ul><p><span class="math display">\[\Delta E_n = (2n+1)\frac{h^2}{8mL^2}\]</span></p><ul><li>相对能级间隔</li></ul><p><span class="math display">\[\frac{\Delta E_n}{E_n} = \frac{2n+1}{n^2}\]</span></p><ul><li>当 <span class="math inline">\(n\rightarrow \infty\)</span> 时， <span class="math inline">\(\Delta E_n \rightarrow 0\)</span> ，即能级间隔趋于零，能级连续，形成连续谱</li></ul><p>粒子在势阱中的概率分布为</p><p><span class="math display">\[\rho(x) = \vert \Phi(x) \vert^2 =\left\{  \begin{aligned}    &amp;\frac{2}{L}\sin^2(\frac{n\pi}{L}x) &amp;&amp; (0 \leq x \leq L)\\    &amp;0 &amp;&amp; (x &lt; 0 \text{ or } x &gt; L)  \end{aligned}\right.\]</span></p><h5 id="德布罗意的驻波思想">德布罗意的驻波思想</h5><ul><li>一个频率为 <span class="math inline">\(\nu\)</span> 、波长 <span class="math inline">\(\lambda\)</span> 沿 <span class="math inline">\(x\)</span> 方向传播的单色平面波的表达式为</li></ul><p><span class="math display">\[\Psi(x,t) = \Psi_0 e^{-i \frac{2\pi}{h}(Et -Px)}\]</span></p><ul><li>全波函数为</li></ul><p><span class="math display">\[\begin{aligned}\Psi ( x,t) =\Phi ( x) e^{-\frac{i}{\hbar } Et} &amp;=\sqrt{\frac{2}{L}} e^{-i\frac{Et}{\hbar }}\sin\frac{n\pi }{L} x\\&amp;=\frac{1}{2i}\sqrt{\frac{2}{L}} e^{-i\frac{Et}{\hbar }}\left( e^{i\frac{n\pi }{L} x} -e^{-i\frac{n\pi }{L} x}\right)\\&amp;=\frac{1}{2i}\sqrt{\frac{2}{L}} e^{-i\frac{Et}{\hbar }}\left( e^{i\frac{p_{n}}{\hbar }} -e^{-i\frac{p_{n}}{\hbar } x}\right)\end{aligned}\]</span></p><p>可以将波函数视为频率相同、波长相同、传播方向相反的两单色平面波的叠加</p><p>则由德布罗意的物质波理论，一个动量为 <span class="math inline">\(p\)</span>、质量为 <span class="math inline">\(m\)</span>、能量为 <span class="math inline">\(E\)</span> 的自由粒子，沿着 <span class="math inline">\(x\)</span> 轴运动的波函数为</p><p><span class="math display">\[\Psi ( x,t) =\Psi _{0} e^{-\frac{i}{\hbar }( Et-px)}\]</span></p><p>波函数也为频率相同、波长相同、传播方向相反的两单色平面波的叠加形成驻波</p><ul><li>势阱中粒子的动量和波长<ul><li>动量：<span class="math inline">\(p_n =\sqrt{2mE_n} = \pm\frac{n\hbar}{2L} = \pm n \frac{ h}{2L}\)</span></li><li>波长：<span class="math inline">\(\lambda_n = \frac{\hbar}{p_n}=\frac{2L}{n}\)</span> 说明势阱中粒子的每一个能量本征态正好对应德布罗意波的一个特征波长的驻波</li></ul></li><li>符合德布罗意的驻波理论</li></ul><h5 id="一维方势垒和隧穿效应">一维方势垒和隧穿效应</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504181642705.png" alt="Tunel effect" /><figcaption aria-hidden="true">Tunel effect</figcaption></figure><p>设</p><p><span class="math display">\[V(x)=\begin{cases}    0, &amp; x &lt; x_1 \quad \text{or} \quad x &gt; x_2 \\    V_0, &amp; x_1 &lt; x &lt; x_2\end{cases}\]</span></p><p>称为方势垒</p><p>现有一能量为 <span class="math inline">\(E\)</span> 的粒子从左向右入射</p><p>在经典力学中，若 <span class="math inline">\(E &lt; V_0\)</span>，则粒子无法穿过势垒，<span class="math inline">\(E &gt; V_0\)</span> 时，粒子能够完全穿过势垒</p><p>但是在量子力学中，粒子是一种物质波，情况完全不一样，需要通过求解薛定谔方程来确定</p><p><span class="math display">\[\frac{d^2\psi(x)}{dx^2}=\frac{2m}{\hbar^2}(V_0-E)\psi(x)\]</span></p><p>在这里我们设 <span class="math inline">\(V_0&gt;E\)</span>，令 <span class="math inline">\(k=\sqrt{\frac{2mE}{\hbar^2}}\)</span> 和 <span class="math inline">\(k&#39; = \sqrt{\frac{2m(V_0-E)}{\hbar^2}}\)</span></p><p>则薛定谔方程可化为</p><p><span class="math display">\[\begin{cases}  \frac{d^2\psi_1(x)}{dx^2} = -k^2\psi_1(x), &amp; x &lt; x_1 \\  \frac{d^2\psi_2(x)}{dx^2} = k&#39;^2\psi_2(x), &amp; x_1 &lt; x &lt; x_2 \\  \frac{d^2\psi_3(x)}{dx^2} = -k^2\psi_3(x), &amp; x &gt; x_2\end{cases}\]</span></p><p>解得</p><p><span class="math display">\[\begin{cases}  \psi_1 = A e^{ikx} + A&#39; e^{-ikx}, &amp; x &lt; x_1 \\  \psi_2 = B e^{k&#39;x} + B&#39; e^{-k&#39;x}, &amp; x_1 &lt; x &lt; x_2 \\  \psi_3 = C e^{ikx} , &amp; x &gt; x_2\end{cases}\]</span></p><p>由连续性（在这里我们令 <span class="math inline">\(x_1=0\)</span>，<span class="math inline">\(x_2=a\)</span>）</p><p><span class="math display">\[\begin{cases}  \psi_1(0) = \psi_2(0) \rightarrow A + A&#39; = B + B&#39; \\  \psi_1&#39;(0) = \psi_2&#39;(0) \rightarrow ik(A - A&#39;) = k&#39; (B - B&#39;) \\  \psi_2(a) = \psi_3(a) \rightarrow B e^{k&#39;a} + B&#39; e^{-k&#39;a} = C e^{ika} \\  \psi_2&#39;(a) = \psi_3&#39;(a) \rightarrow k&#39; B e^{k&#39;a} - k&#39; B&#39; e^{-k&#39;a} = ikC e^{ika}\end{cases}\]</span></p><p>求解并经过计算得到</p><ul><li><strong>反射系数：</strong> <span class="math inline">\(\displaystyle R =\frac{\vert A&#39;\vert^2}{\vert A\vert^2} =\frac{(k^2+k&#39;^2)^2\sinh^2(k&#39;a)}{\left(k^2+k&#39;^2\right)\sinh^2(k&#39;a) + 4k^2k&#39;^2}\)</span></li><li><strong>透射系数：</strong> <span class="math inline">\(\displaystyle T =\frac{\vert C\vert^2}{\vert A\vert^2} =\frac{4k^2k&#39;^2}{\left(k^2+k&#39;^2\right)\sinh^2(k&#39;a) + 4k^2k&#39;^2}\)</span></li></ul><p>显然有 <span class="math inline">\(\boxed{T+R=1}\)</span></p><h2 id="定态问题">定态问题</h2><h2 id="量子力学的基本假设">量子力学的基本假设</h2><h3 id="波函数假设">波函数假设</h3><p>微观粒子的状态可以被一个波函数完全描述，从这个波函数可以得到体系的所有性质</p><p>波函数一般满足连续性、有限性和单值性三个条件</p><ol type="1"><li>物质波可以用一个随时间、空间变化的波函数 <span class="math inline">\(\Psi(\boldsymbol{r},t)\)</span> 来描述</li><li>自由粒子的波函数是单色平面波 <span class="math inline">\(\Psi(x,t) = \Psi_0 e^{-i\frac{2\pi}{h}(Et - Px)} = \Psi_0 e^{-i\frac{1}{\hbar}(Et - Px)}\)</span></li><li>波恩：德布罗意波是描述粒子在空间概率分布的概率波 波函数的模的平方 <span class="math inline">\(\vert \Psi(\boldsymbol{r},t)\vert^2\)</span> 表示 <span class="math inline">\(t\)</span> 时刻，在坐标 <span class="math inline">\(\boldsymbol{r}\)</span> 处粒子出现的概率密度</li><li>波函数满足<strong>单值、有限、连续</strong>的条件，称为<strong>波函数的标准条件</strong></li><li><strong>归一化条件：</strong> 在整个空间中发现粒子的概率为 <span class="math inline">\(1\)</span>，即 <span class="math inline">\(\displaystyle \int_{\Omega} \vert \Psi(\boldsymbol{r},t)\vert^2\,\mathrm{d}V = 1\)</span>，其中 <span class="math inline">\(\Omega\)</span> 为全空间</li></ol><h3 id="力学算符假设">力学算符假设</h3><p>量子力学中的力学量用线性厄米（Hermite）算符表示。如果经典力学中有相关的力学量，则在量子力学中也有相应表示这个力学量的算符</p><p>算符能将波函数变换为另一个波函数</p><ul><li>动量算符 <span class="math inline">\(\hat{p} = -i\hbar \nabla\)</span></li><li>位置算符 <span class="math inline">\(\hat{\boldsymbol{r}} = \boldsymbol{r}\)</span></li><li>能量算符 <span class="math inline">\(\hat{H} = \frac{\hat{p}^2}{2m} + U(\boldsymbol{r}) = -\frac{\hbar ^2}{2m}\nabla ^2 + U(\boldsymbol{r})\)</span></li><li>角动量算符 <span class="math inline">\(\hat{\boldsymbol{L}} =\hat{\boldsymbol{r}} \times \hat{\boldsymbol{p}} =\left\vert\begin{smallmatrix}\boldsymbol{i} &amp; \boldsymbol{j} &amp; \boldsymbol{k} \newline x &amp; y &amp; z \newline p_x &amp; p_y &amp; p_z \end{smallmatrix}\right\vert\)</span><ul><li><span class="math inline">\(\hat{L}_x = y\hat{p}_z-z\hat{p}_y\)</span></li><li><span class="math inline">\(\hat{L}_y = z\hat{p}_x-x\hat{p}_z\)</span></li><li><span class="math inline">\(\hat{L}_z = x\hat{p}_y-y\hat{p}_x\)</span></li></ul></li></ul><h4 id="厄米hermite算符">厄米（Hermite）算符</h4><p><span class="math inline">\(\hat{A}\)</span> 是厄米算符的充分必要条件是</p><p><span class="math display">\[\int \Psi^* \hat{A} \varphi \,\mathrm{d}V = \int \Psi \left(\hat{A} \Psi^* \right) \,\mathrm{d}V\]</span></p><p>其中 <span class="math inline">\(\Psi\)</span> 和 <span class="math inline">\(\varphi\)</span> 是在无穷远处趋向 <span class="math inline">\(0\)</span> 的任意函数</p><ul><li>如果 <span class="math inline">\(\hat{A}\)</span> 和 <span class="math inline">\(\hat{B}\)</span> 都是厄米算符，则 <span class="math inline">\(\hat{A}\hat{B} + \hat{B}\hat{A}\)</span> 也是厄米算符</li></ul><p><strong>证明：</strong></p><p><span class="math display">\[\begin{aligned}&amp;\int _{-\infty }^{+\infty }\Psi ^{*}\left(\hat{A}\hat{B} + \hat{B}\hat{A}\right)\varphi\,\mathrm{d}x \\= &amp;\int _{-\infty }^{+\infty }\Psi ^{*}\hat{A}(\hat{B}\varphi)\,\mathrm{d}x + \int _{-\infty }^{+\infty }\Psi ^{*}\hat{B}(\hat{A}\varphi)\,\mathrm{d}x\\= &amp;\int _{-\infty }^{+\infty }(\hat{A}\Psi) ^{*}(\hat{B}\varphi)\,\mathrm{d}x + \int _{-\infty }^{+\infty }(\hat{B}\Psi) ^{*}(\hat{A}\varphi)\,\mathrm{d}x\\= &amp;\int _{-\infty}^{+\infty}\left[\varphi\left(\hat{B}\hat{A}\Psi\right)^*+\varphi\left(\hat{A}\hat{B}\Psi\right)^*\right]\\= &amp;\int _{-\infty}^{+\infty}\varphi\left[\left(\hat{A}\hat{B}+\hat{B}\hat{A}\right) \Psi\right]^*\,\mathrm{d}x\end{aligned}\]</span></p><ul><li>如果 <span class="math inline">\(\hat{A}\)</span> 和 <span class="math inline">\(\hat{B}\)</span> 都是厄米算符，则 <span class="math inline">\(i\left(\hat{A}\hat{B} -\hat{B}\hat{A}\right)\)</span> 也是厄米算符</li></ul><h5 id="厄米算符的性质">厄米算符的性质</h5><ol type="1"><li>对于系统的任何量子态，其厄米算符的平均值 <span class="math inline">\(\bar{F}=\displaystyle\int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi \,\mathrm{d}V\)</span> 是实数</li><li><strong>厄米算符的本征值是实数</strong>，所以量子力学中的任何力学算符都是厄米算符</li><li><strong>厄米算符属于不同本征值的本征函数彼此正交</strong><ul><li><strong>厄米算符的本征函数是正交统一的完全集</strong></li><li>任何物理上合理的波函数都可以用这个正交统一的完全集展开</li></ul></li></ol><p><strong>证明：</strong></p><ul><li>平均值为实数</li></ul><p><span class="math display">\[\bar{F} = \int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi \,\mathrm{d}V = \int _{-\infty}^{+\infty} \left(\hat{F}\Psi\right)^* \Psi \,\mathrm{d}V = \left(\int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi \,\mathrm{d}V\right)^* = \bar{F}^*\]</span></p><p>故 <span class="math inline">\(\bar{F}\)</span> 是实数</p><ul><li><p>本征值是实数</p><p>由厄米算符的定义</p></li></ul><p><span class="math display">\[\int _{-\infty}^{+\infty} \Psi ^*\hat{F}\Psi_n \,\mathrm{d}V = \int _{-\infty}^{+\infty} \left(\hat{F}\Psi\right)^* \Psi \,\mathrm{d}V\]</span></p><p>设 <span class="math inline">\(\hat{F}\Psi= F\Psi\)</span>，则</p><p><span class="math display">\[\begin{aligned}    \int _{-\infty} ^{+\infty} \Psi ^*F\Psi\mathrm{d}\,V &amp;= \int _{-\infty}^{+\infty} \left(F\Psi\right)^* \Psi\,\mathrm{d}V\\    \Rightarrow F\int _{-\infty} ^{+\infty} \Psi ^*\Psi\mathrm{d}\,V &amp;= F^*\int _{-\infty}^{+\infty} \Psi^* \Psi\,\mathrm{d}V\end{aligned}\]</span></p><p>则 <span class="math inline">\(F=F^*\)</span>，故本征值为实数</p><ul><li><p>属于不同本征值的本征函数正交</p><p>由厄米算符的定义</p></li></ul><p><span class="math display">\[\begin{aligned}  \int \Psi _{m}^{*}\hat{F} \Psi _{n} \, \mathrm{d}V&amp;=\int (\hat{F} \Psi _{m})^{*} \Psi _{n} \, \mathrm{d} V\\F_{n}\int \Psi m^{*} \Psi _{n}\,\mathrm{d} V&amp;=F_{m}^{*}\int \Psi _{m}^{*} \Psi _{n} \, \mathrm{d} V\\( F_{n} -F_{m})\int \Psi _{m}^{*} \Psi _{n} \,\mathrm{d} V&amp;=0\end{aligned}\]</span></p><p><span class="math inline">\(\displaystyle m\neq n\)</span>，则 <span class="math inline">\(\displaystyle \int \Psi _m^n \Psi _n \, \mathrm{d} V=1\)</span>，则 <span class="math inline">\(\displaystyle F_n =F_m\)</span></p><p>这里有 <span class="math inline">\(\displaystyle \int \Psi _m^*\Psi _n \, \mathrm{d}V = \delta _{nm} =\begin{cases} 0 &amp;,n\neq m\\ 1 &amp;,n=m\end{cases}\)</span></p><ul><li><p>波函数可以用正交统一的完全集展开 <span class="math inline">\(\displaystyle\Psi = \sum _n c_n\Psi _n\)</span></p><p>使用数学归纳法，假设当 <span class="math inline">\(n\)</span> 时成立</p></li></ul><p><span class="math display">\[\begin{aligned}  &amp; \Psi &amp;&amp;= \sum _{n} c_n\Psi _n \\  &amp; \Psi _m^*\Psi &amp;&amp;= \sum _{n} c_n\Psi _m^*\Psi _n\\  &amp; \int\Psi _m^*\Psi \,\mathrm{d}V &amp;&amp;= \sum _{n} c_n\int \Psi _m^*\Psi _n \,\mathrm{d}V \\  &amp;                                   &amp;&amp;= \sum _n c_n \delta _{mn}\\  &amp;                                  &amp;&amp;= c_m\\\end{aligned}\]</span></p><p>可以得到 <span class="math inline">\(\displaystyle c_m = \int \Psi _m^*\Psi \,\mathrm{d}V\)</span> ，当 <span class="math inline">\(m\)</span> 时成立</p><h3 id="测量假设">测量假设</h3><p>当一个量子系统处于量子态 <span class="math inline">\(\Psi\)</span> 时，对力学量 <span class="math inline">\(\hat{F}\)</span> 的测量结果一定是该力学算符的本征值之一，结果为 <span class="math inline">\(F_n\)</span> 的概率为 <span class="math inline">\(\left\vert c_n\right\vert ^2 = \left\vert\int \phi_n^*\Psi\,\mathrm{d}V\right\vert^2\)</span></p><p>这里 <span class="math inline">\(\hat{F}\varphi _n = F_n\varphi _n\)</span> 是力学量 <span class="math inline">\(\hat{F}\)</span> 的本征方程，测量完成后，该量子系统坍缩至 <span class="math inline">\(\varphi _n\)</span></p><p><strong>结论</strong></p><ul><li>根据测量假设，当一个量子系统处在量子态 <span class="math inline">\(\Psi\)</span> 时，对力学量 <span class="math inline">\(\hat{F}\)</span> 的测量结果的统计平均值为</li></ul><p><span class="math display">\[\bar{F} = \sum _n F_n \left\vert c_n \right\vert ^2 = \sum _n F_n \left\vert \int\phi_n^*\Psi\,\mathrm{d}V\right\vert ^2 =\boxed{\int \Psi^* \hat{F} \Psi\,\mathrm{d}V}\]</span></p><p><strong>证明：</strong></p><p><span class="math display">\[\begin{aligned}   &amp;\int \Psi ^* \hat{F} \Psi \mathrm{d}V\\   =&amp;\int \left(\sum_m c_m\Psi_m\right)^*\hat{F}\left(\sum_n c_n\Psi_n\right)\mathrm{d}V\\   =&amp;\int \left(\sum_m c_m\Psi_m\right)^*\left(\sum_n c_n \hat{F}\Psi_n\right)\mathrm{d}V\\   =&amp;\int \left(\sum_m c_m\Psi_m\right)^*\left(\sum_n c_n F_n\Psi_n\right)\mathrm{d}V\\   =&amp;\sum_{mn}c_m c_n F_n \int \left(\Psi_m^*\Psi_n\right)\mathrm{d}V\\   =&amp;\sum_{mn}c_m c_n F_n \delta _{mn}\\   =&amp;\sum_n\left\vert c_n \right\vert ^2 F_n\end{aligned}\]</span></p><ul><li>测量假设推论：当一个量子系统处于量子态 <span class="math inline">\(\Psi\)</span> 时，且满足 <span class="math inline">\(\displaystyle \sum _n \vert c_n\vert^2=1\)</span> 时，对力学量的测量结果一定是该力学算符的本征值之一，测量结果为 <span class="math inline">\(F_n\)</span> 的概率为 <span class="math inline">\(\vert c_n \vert^2\)</span>，测量完成之后，该量子系统探索至 <span class="math inline">\(\phi_n\)</span></li></ul><h4 id="动量本征方程">动量本征方程</h4><p><span class="math display">\[-i\hbar\nabla\Phi _{\boldsymbol{r}}(\boldsymbol{r}) = \hat{p}\Phi _{\boldsymbol{r}}(\boldsymbol{r}) = p\Phi _{\boldsymbol{r}}(\boldsymbol{r})\]</span></p><p>其在三个坐标轴上的分量为</p><p><span class="math display">\[\begin{cases}  -i\hbar \frac{\partial \Phi _{\boldsymbol{r}}}{\partial x} = p_x\Phi _{\boldsymbol{r}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{r}}}{\partial y} = p_y\Phi _{\boldsymbol{r}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{r}}}{\partial z} = p_z\Phi _{\boldsymbol{r}}\end{cases}\]</span></p><p>其解为</p><p><span class="math display">\[\Phi _{\boldsymbol{p}}(\boldsymbol{r}) = \frac{1}{(2\pi\hbar)^\frac{3}{2}}e^{\frac{i}{\hbar}\boldsymbol{p}\cdot \boldsymbol{r}}\]</span></p><p>测量结果为 <span class="math inline">\(p\)</span> 的概率密度为</p><p><span class="math display">\[\vert c_p \vert^2 = \left\vert \int \Phi_p^*\Psi\,\mathrm{d}v\right\vert^2 = \left\vert \int \frac{1}{(2\pi\hbar)^\frac{3}{2}}e^{-\frac{i}{\hbar}\boldsymbol{p}\cdot \boldsymbol{r}}\Psi\,\mathrm{d}v\right\vert^2\]</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{p} = \sum_{n} p_i\vert c_{p_i} \vert ^2\]</span></p><h4 id="动能本征方程">动能本征方程</h4><p><span class="math display">\[-i\hbar \nabla \Phi _{\boldsymbol{p}}(\boldsymbol{r}) = \hat{p}\Phi _{\boldsymbol{p}}(\boldsymbol{r})\]</span></p><p>其在三个坐标轴的分量为</p><p><span class="math display">\[\begin{cases}  -i\hbar \frac{\partial \Phi _{\boldsymbol{p}}}{\partial x} = p_x\Phi _{\boldsymbol{p}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{p}}}{\partial y} = p_y\Phi _{\boldsymbol{p}}\\  -i\hbar \frac{\partial \Phi _{\boldsymbol{p}}}{\partial z} = p_z\Phi _{\boldsymbol{p}}\end{cases}\]</span></p><p>记动能算符为 <span class="math inline">\(\hat{T}\)</span></p><p><span class="math display">\[\hat{T}\Phi _{\boldsymbol{p}}(\boldsymbol{r}) = -\frac{\hbar^2}{2m}\nabla ^2\Phi _{\boldsymbol{p}}(\boldsymbol{r})= \frac{\hat{p}^2}{2m}\Phi _{\boldsymbol{p}}(\boldsymbol{r})\]</span></p><p>所以<strong>动量的本征函数等于动能的本征函数</strong></p><p>同样当一个量子系统处于量子态 <span class="math inline">\(\Psi\)</span> 时，测量动能为 <span class="math inline">\(\frac{p^2}{2m}\)</span> 的概率为</p><p><span class="math display">\[\vert c_{\frac{p^2}{2m}} \vert^2 = \left\vert \int \Phi_{\frac{p^2}{2m}}^*\Psi\,\mathrm{d}v\right\vert^2 = \left\vert \int \frac{1}{(2\pi\hbar)^\frac{3}{2}}e^{-\frac{i}{\hbar}\boldsymbol{p}\cdot \boldsymbol{r}}\Psi\,\mathrm{d}v\right\vert^2\]</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{\frac{p^2}{2m}} = \sum_{n} \frac{p_i^2}{2m}\vert c_{\frac{p_i^2}{2m}} \vert ^2\]</span></p><h3 id="态叠加原理">态叠加原理</h3><p>如果 <span class="math inline">\(\Psi_1 , \Psi_2 \ldots\)</span> 是体系的一系列可能的状，则 <span class="math inline">\(\displaystyle\Psi = \sum _i ^n c_n\Psi_n\)</span> 也是体系的一个可能的状态。对于处于 <span class="math inline">\(\Psi\)</span> 态的体系，该体系分别部分地处在 <span class="math inline">\(\Psi_1 , \Psi_2 \ldots \Psi_n \ldots\)</span> 态中</p><h3 id="薛定谔方程-1">薛定谔方程</h3><p>波函数随时间演化满足<strong>薛定谔方程</strong></p><p><span class="math display">\[\boxed{i\hbar \frac{\partial \Psi (\boldsymbol{r},t)}{\partial t} = \hat{H} \Psi (\boldsymbol{r},t)}\]</span></p><h4 id="定态问题-1">定态问题</h4><p>若粒子处于稳定的势场中，则势能函数 <span class="math inline">\(U\)</span> 与时间无关，称这类问题为定态问题</p><p><span class="math display">\[\Psi(\boldsymbol{r} , t) = \Phi(\boldsymbol{r})e^{-i\frac{1}{\hbar}Et}\]</span></p><p><span class="math display">\[\left[ -\frac{\hbar^2}{2m}\nabla^2   + U(\boldsymbol{r})\right] \Phi(\boldsymbol{r}) = E\Phi(\boldsymbol{r})\]</span></p><p>也称为哈密顿算符的本征方程</p><h3 id="同类粒子的不可分辨性原理">同类粒子的不可分辨性原理</h3><p>在量子力学中，内禀属行完全相同的粒子是<strong>不可分辨</strong>的，对任意这两个粒子进行交换，不会改变系统的状态</p><p>经典力学中，能够得到粒子的运动方程和轨道方程 <span class="math inline">\(\vec{r} = \vec{r}(t)\)</span>，然而在量子力学中，只能得到粒子在空间中分布的概率密度 <span class="math inline">\(\rho=\vert\Psi(\boldsymbol{r},t)\vert^2\)</span>，而不能得到粒子在空间中的轨道方程，因此得不到粒子的轨道方程</p><p>对于内禀性相同的粒子，因为没有轨道方程，所以无法分辨，对于任意的两个这样的粒子进行交换，不会改变系统的状态，即粒子在空间中出现的概率密度不会改变</p><p><span class="math display">\[\begin{aligned}  &amp;&amp;\left\vert\Psi(1,\ldots , i , \ldots , j \ldots n)\right\vert &amp;= \left\vert\Psi(1,\ldots , j , \ldots , i \ldots n)\right\vert\\  \Rightarrow&amp;&amp;\Psi(1,\ldots , i , \ldots , j \ldots n) &amp;= e^{i\theta}\Psi(1,\ldots , j , \ldots , i \ldots n)\end{aligned}\]</span></p><p>实验表明，所有粒子可以分为两类</p><ol type="1"><li><strong>玻色子：</strong> <span class="math inline">\(\theta=0\)</span>，交换粒子后波函数不变</li><li><strong>费米子：</strong> <span class="math inline">\(\theta=\pi\)</span>，交换粒子后波函数反对称</li></ol><h3 id="算符之间的对易关系">算符之间的对易关系</h3><p>两个算符 <span class="math inline">\(\hat{A}\)</span> 和 <span class="math inline">\(\hat{B}\)</span> 的对易子记为 <span class="math inline">\(\left[\hat{A} , \hat{B}\right] = \hat{A}\hat{B}-\hat{B}\hat{A}\)</span></p><h4 id="动量算符和坐标算符之间的对易关系">动量算符和坐标算符之间的对易关系</h4><p><span class="math display">\[\left[x,\hat{p}_{x}\right] = -i\hbar\]</span></p><p><strong>证明：</strong></p><p>将 <span class="math inline">\(\left[x,\hat{p}_x\right] = x\hat{p}_X - \hat{p}_x x\)</span> 作用于任意波函数 <span class="math inline">\(\Psi\)</span> 上</p><p><span class="math display">\[\begin{aligned}  \left[x,\hat{p}_{x}\right]\Psi &amp;= \left(x\hat{p}_{x} - \hat{p}_x x\right)\Psi\\  &amp;=-i\hbar\left(x\frac{\partial}{\partial x} - \frac{\partial}{\partial x}x\right)\Psi\\  &amp;=-i\hbar\left[x\frac{\partial \Psi}{\partial x}-\frac{\partial}{\partial x}\left(x\Psi\right)\right]\\  &amp;=i\hbar\Psi\end{aligned}\]</span></p><p>故 <span class="math inline">\(\left[x,\hat{p}_{x}\right] = -i\hbar\)</span></p><h3 id="共同本征函数">共同本征函数</h3><h4 id="两个算符对易">两个算符对易</h4><p>如果两个算符 <span class="math inline">\(\hat{A}\)</span> 和 <span class="math inline">\(\hat{B}\)</span> 满足对易子为 <span class="math inline">\(0\)</span> ，即 <span class="math inline">\(\left[\hat{A},\hat{B}\right] = \hat{A}\hat{B} - \hat{B}\hat{A} = 0\)</span>，则称这两个算符<strong>对易</strong></p><h4 id="对易的一个定理">对易的一个定理</h4><p>若两个力学量算符有一组共同完备的本征函数系，则二算符对易</p><p><strong>证明：</strong></p><p>假设</p><p><span class="math display">\[\begin{cases}  \hat{F}\varphi _n = F_n \varphi _n\\  \hat{G}\varphi _n = G_n \varphi _n\end{cases}\]</span></p><p><span class="math inline">\(\varphi\)</span> 组成完备系，则任意量子态 <span class="math inline">\(\Phi(x)\)</span> 可以按其展开为 <span class="math inline">\(\Phi(x) = \sum _n c_i \varphi _i (x)\)</span></p><p>则</p><p><span class="math display">\[\begin{aligned}  \left(\hat{F}\hat{G}-\hat{G}\hat{F}\right)\Psi(x)  &amp;= \left(\hat{F}\hat{G}-\hat{G}\hat{F}\right)\sum _n c_n \varphi _n (x)\\  &amp;= \sum _n c_n \left(\hat{F}\hat{G}-\hat{G}\hat{F}\right)\varphi _n (x)\\  &amp;= \sum _n c_n \left(F_nG_n - G_nF_n\right)\varphi _n (x)\\  &amp; = 0\end{aligned}\]</span></p><p>由于 <span class="math inline">\(\Psi(x)\)</span> 是任意的函数，则 <span class="math inline">\(\hat{F}\hat{G} = \hat{G}\hat{F}\)</span></p><ul><li><strong>其逆定理：</strong> 若两个力学算符对易，则这两个算符有组成完备系的共同本征函数</li></ul><p><strong>证明：</strong></p><p>已知 <span class="math inline">\(\hat{F}\hat{G} = \hat{G}\hat{F}\)</span>，<span class="math inline">\(\hat{F}\phi_n=F\phi_n\)</span></p><p><span class="math display">\[\hat{F}\hat{G}\varphi _n = \hat{G}\hat{F}\varphi _n= F\hat{G}\varphi _n\]</span></p><p>即</p><p><span class="math display">\[\hat{F}\left(\hat{G}\varphi _n\right) = F\left(\hat{G}\varphi _n\right)\]</span></p><p>说明 <span class="math inline">\(\hat{G}\varphi _n\)</span> 也是 <span class="math inline">\(\hat{F}\)</span> 的本征函数，本征值为 <span class="math inline">\(F\)</span> 故 <span class="math inline">\(\hat{G}\varphi _n\)</span> 和 <span class="math inline">\(\varphi _n\)</span> 表示统一个量子态，<span class="math inline">\(\hat{G}\varphi _n = G\varphi\)</span></p><h3 id="力学量完全集合">力学量完全集合</h3><ul><li><strong>定义：</strong>能够完全确定状态的一组两两对易的力学量算符的最小（数目）集称为<strong>力学量完全集</strong></li><li>力学量完全集中的力学量数目一般与体系自由度数相同</li><li>由力学量的完全集所确定的本征函数系构成该体系态空间的一组完备的本征函数，即体系中的任何状态均可用它展开</li></ul><h3 id="角动量算符之间的对易关系">角动量算符之间的对易关系</h3><h4 id="角动量算符">角动量算符</h4><ul><li><span class="math inline">\(\displaystyle \left[\hat{L}_{x} , \hat{L}_y\right] = i\hbar \hat{L}_z\)</span></li><li><span class="math inline">\(\displaystyle \left[\hat{L}_{y} , \hat{L}_z\right] = i\hbar \hat{L}_x\)</span></li><li><span class="math inline">\(\displaystyle \left[\hat{L}_{z} , \hat{L}_x\right] = i\hbar \hat{L}_y\)</span></li></ul><h4 id="角动量平方算符">角动量平方算符</h4><p><span class="math display">\[\begin{aligned}\hat{L} ^2 =\hat{L} \cdot \hat{L} &amp;= \hat{L}_x^2 + \hat{L}_y^2 + \hat{L}_z^2\\  &amp;= -\hbar ^2 \left[ \frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial}{\partial\theta}\right)+\frac{1}{\sin\theta^2}\frac{\partial^2}{\partial \varphi^2}\right]\end{aligned}\]</span></p><p><span class="math display">\[\left[\hat{L}^2 , \hat{L}_x\right] = \left[\hat{L}^2 , \hat{L}_y\right] = \left[\hat{L}^2 , \hat{L}_z\right] = 0\]</span></p><h5 id="角动量算符的本征方程">角动量算符的本征方程</h5><p><span class="math display">\[\begin{aligned}  &amp;&amp;-\hbar ^2 \left[ \frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial}{\partial\theta}\right)+\frac{1}{\sin^2\theta}\frac{\partial^2}{\partial \varphi^2}\right]Y &amp;= \mu \hbar ^2 Y\\  \Rightarrow &amp;&amp;\frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial Y}{\partial\theta}\right)+\frac{1}{\sin^2\theta}\frac{\partial^2}{\partial \varphi^2}Y +\mu Y &amp;= 0\end{aligned}\]</span></p><p>令 <span class="math inline">\(Y(\theta , \varphi) =\Theta(\theta) f(\varphi)\)</span>，得到</p><p><span class="math display">\[\begin{aligned}  &amp;\frac{sin\theta}{\Theta}\frac{\partial}{\partial \theta}\left(\sin\theta\frac{\partial\Theta}{\partial \theta }\right) + \mu\sin^2\theta = -\frac{1}{f}\frac{\partial ^2 f}{\partial\varphi ^2} = const = \lambda\\  \Rightarrow &amp;  \begin{cases}    \frac{1}{\sin\theta}\frac{\mathrm d}{\mathrm{d}\theta}\left(\sin\theta\frac{\mathrm{d}\Theta}{\mathrm{d}\theta}\right) +\left(\mu -\frac{\lambda}{\sin^2\theta}\right)\Theta = 0\\    \frac{\mathrm{d}^2 f}{\mathrm{d}\varphi ^2} +\lambda f = 0  \end{cases}\end{aligned}\]</span></p><p>先处理关于 <span class="math inline">\(\varphi\)</span> 的方程</p><p>令 <span class="math inline">\(\lambda = m_l ^2 , m_l = 0, \pm 1, \pm 2, \ldots\)</span>，则</p><p><span class="math display">\[f(\varphi) = A\cos(m_l \varphi) + B\sin(m_l \varphi)\]</span></p><p>再处理关于 <span class="math inline">\(\theta\)</span> 的方程</p><p><span class="math display">\[\begin{aligned}  &amp;\frac{1}{\sin\theta}\frac{\mathrm d}{\mathrm{d}\theta}\left(\sin\theta\frac{\mathrm{d}\Theta}{\mathrm{d}\theta}\right) +\left(\mu -\frac{\lambda}{\sin^2\theta}\right)\Theta = 0\\  \Rightarrow &amp; \frac{1}{\sin\theta}\frac{\mathrm d}{\mathrm{d}\theta}\left(\sin\theta\frac{\mathrm{d}\Theta}{\mathrm{d}\theta}\right) +\left(\mu -\frac{m_l^2}{\sin^2\theta}\right)\Theta = 0\\\end{aligned}\]</span></p><p>令 <span class="math inline">\(x = \cos \theta ,y(x) = \Theta(\theta)\)</span>，则</p><p><span class="math display">\[\frac{1}{1-x^2}\frac{\mathrm{d}^2y}{\mathrm{d}x^2} -2x\frac{\mathrm{d}y}{\mathrm{d}x}+ \left(\mu -\frac{m_l^2}{1-x^2}\right)y = 0 \quad\left(\text{连带勒让德方程}\right)\]</span></p><ul><li><strong>本征值：</strong><span class="math inline">\(\mu = l(l+1)\)</span>，<span class="math inline">\(l=0,1,2,\ldots\)</span></li><li><span class="math inline">\(\Theta(\theta) = P_l^m\left(\theta\right)\)</span></li></ul><p>则角动量平方算符的本征方程变为</p><p><span class="math display">\[\hat{L}^2 Y_{l,m_l} = -\hbar ^2 \left[\frac{1}{\sin\theta}\frac{\partial}{\partial\theta}\left(\sin\theta\frac{\partial}{\partial\theta}\right)+\frac{1}{\sin^2\theta}\frac{\partial^2}{\partial \varphi^2}\right]Y_{l,m_l} = l(l+1)\hbar ^2 Y_{l,m_l}\]</span></p><p>其解为</p><p><span class="math display">\[Y_{L,m_l}(\theta , \varphi) = (-1)^{m_l}\sqrt{\frac{(2l+1)(l-\vert m_l\vert)!}{4\pi (l+\vert m_l\vert)!}}P_l^{m_l}(\cos\theta)e^{im_l\varphi}\]</span></p><p>其中 <span class="math inline">\(l = 0 , 1 , 2 , \ldots\)</span> ，<span class="math inline">\(m_l = -l , -l +1 , \ldots , l\)</span> 该函数同时也为角动量算符 <span class="math inline">\(\hat{L}_z\)</span> 的本征函数</p><h5 id="统计平均值">统计平均值</h5><p>当一个量子系统处于量子态 <span class="math inline">\(\Psi\)</span> 时，且满足 <span class="math inline">\(\displaystyle \Psi\left(\theta , \varphi\right) = \sum_{l}\sum_{m_l=-1}^l c_{l,m_l}Y_{l,m_l}\left(\theta , \varphi\right)\)</span> ，<span class="math inline">\(\sum_{l}\sum_{m_l = -1}^l =\left\vert c_{l,l_m}\right\vert^2 = 1\)</span> 时，对测量结果为 <span class="math inline">\(l(l+1)\hbar ^2\)</span> 的概率为 <span class="math inline">\(\left\vert c_{l,m_l}\right\vert^2\)</span>，测量完成之后，该量子系统坍缩至 <span class="math inline">\(Y_{l,m_l}\)</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{L}^2 = \sum_{l}l(l+1)\hbar ^2 \sum_{m_l=-l}^{l} \left\vert c_{l,m_l}\right\vert^2\]</span></p><p>对角动量 <span class="math inline">\(z\)</span> 分量进行测量的结果一定是该力学量算符的本征值之一，测量结果为 <span class="math inline">\(m_l\hbar\)</span> 的概率为 <span class="math inline">\(\left\vert c_{l,m_l}\right\vert^2\)</span> ，测量完成之后，该量子系统坍缩至 <span class="math inline">\(Y_{l,m_l}\)</span></p><p>统计平均值为</p><p><span class="math display">\[\bar{L}_z = \sum_{l}  \sum_{m_l=-l}^{l} m_l\hbar\left\vert c_{l,m_l}\right\vert^2\]</span></p><p>这里角动量平方算符和角动量算符的本征方程分别为</p><p><span class="math display">\[\hat{L}^2 Y_{l,m_l} = l(l+1)\hbar ^2 Y_{l,m_l}\]</span></p><p><span class="math display">\[\hat{L}_z Y_{l,m_l} = m_l\hbar Y_{l,m_l}\]</span></p><h2 id="算符与电子自旋">算符与电子自旋</h2><h3 id="未归一化的量子态下的算符平均值">未归一化的量子态下的算符平均值</h3><p><span class="math display">\[\bar{A} = \frac{\iiint \Psi^*(x,y,z)\hat{A}\Psi(x,y,z)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z}{\iiint \Psi^*(x,y,z)\Psi(x,y,z)\,\mathrm{d}x\mathrm{d}y\mathrm{d}z}\]</span></p><h3 id="线性算符">线性算符</h3><p>线性算符 <span class="math inline">\(\hat{F}\)</span> 满足</p><p><span class="math display">\[\hat{F}\left(a\Psi_1 + b\Psi_2\right) = a\hat{F}\Psi_1 + b\hat{F}\Psi_2\]</span></p><p>位置算符 <span class="math inline">\(\hat{x} = x\)</span> 和动量算符 <span class="math inline">\(\hat{p_x} = -i\hbar\frac{\partial}{\partial x}\)</span> 均为线性算符</p><p>由于态叠加原理，哈密顿算符 <span class="math inline">\(\hat{H}\)</span> 也是线性算符，薛定谔方程是线性微分方程，则若 <span class="math inline">\(\Psi_1\)</span> 和 <span class="math inline">\(\Psi_2\)</span> 是薛定谔方程的解，则 <span class="math inline">\(c_1\Psi_1 + c_2\Psi_2\)</span> 也是薛定谔方程的解</p><p>对于定态薛定谔方程也满足这个条件</p><p>态叠加原理要求算符是线性的厄米算符</p><h3 id="厄米算符">厄米算符</h3><h4 id="厄米算符的本征值是实数">厄米算符的本征值是实数</h4><h4 id="厄米算符的平均值是实数">厄米算符的平均值是实数</h4><h4 id="厄米算符本征值具有正交性">厄米算符本征值具有正交性</h4><p>当两个函数 <span class="math inline">\(\Psi_q\)</span> 和 <span class="math inline">\(\Psi_2\)</span> 满足下列关系</p><p><span class="math display">\[\int \Psi_1^*\Psi_2\,\mathrm{d}x \equiv \int \left\langle\Psi_1\vert\Psi_2\right\rangle =0\]</span></p><p>则我们称这两个函数相互正交，<span class="math inline">\(\left\langle\Psi_1\vert\Psi_2\right\rangle\)</span> 称为内积</p><p>厄米算符两个不同本征值的本征函数总是正交的</p><p><strong>证明：</strong></p><p>（待补充 o_O）</p><p>将这些正交的本征函数归一化，<span class="math inline">\(\displaystyle \int \Psi_1^*\Psi_2\,\mathrm{d}x = 1\)</span>，所以<strong>厄米算符</strong>有一组正交化的本征函数</p><p><span class="math display">\[\int \Psi_k^*\Psi_l\,\mathrm{d}x =\delta_{kl} =\begin{cases}  0 &amp;,k\neq l\\  1 &amp;,k=l\end{cases}\]</span></p><p>所以厄米算符的分立谱的所有本征函数都是正交归一化的</p><h3 id="动量算符的厄米性">动量算符的厄米性</h3><p><strong>证明：</strong></p><p>（待补充）</p><h3 id="算符运算初步">算符运算初步</h3><h4 id="算符之和">算符之和</h4><p><span class="math display">\[\hat{A} + \hat{B} = \hat{C}\]</span></p><p><span class="math display">\[\hat{C}\Psi = \left(\hat{A}+\hat{B}\right)\Psi=\hat{A}\Psi + \hat{B}\Psi\]</span></p><h4 id="算符之积">算符之积</h4><p><span class="math display">\[\hat{A}\hat{B} = \hat{C}\]</span></p><p><span class="math display">\[\hat{C}\Psi = \hat{A}\left(\hat{B}\Psi\right)\]</span></p><p>一般情况下，算符之积<strong>不满足</strong>交换律，即</p><p><span class="math display">\[\hat{A}\hat{B} \neq \hat{B}\hat{A}\]</span></p><h4 id="算符的对易性">算符的对易性</h4><p>如果 <span class="math inline">\(\hat{A}\hat{B} = \hat{B}\hat{A}\)</span>，则称 <span class="math inline">\(\hat{A}\)</span> 和 <span class="math inline">\(\hat{B}\)</span> 是<strong>对易的</strong></p><p>记为 <span class="math inline">\(\left[\hat{A},\hat{B}\right] \equiv \hat{A}\hat{B} - \hat{B}\hat{A} = 0\)</span>，称 <span class="math inline">\(\left[\hat{A},\hat{B}\right]\)</span> 为 <span class="math inline">\(\hat{A}\)</span> 和 <span class="math inline">\(\hat{B}\)</span> 的<strong>对易子</strong></p><h3 id="电子自旋">电子自旋</h3><h4 id="电子自旋角动量及其空间量子化">电子自旋角动量及其空间量子化</h4><h5 id="斯特恩-盖拉赫实验">斯特恩-盖拉赫实验</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192235176.png" alt="Stern-Garlach experiment" /><figcaption aria-hidden="true">Stern-Garlach experiment</figcaption></figure><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192240318.png" alt="磁力线" /><figcaption aria-hidden="true">磁力线</figcaption></figure><p>磁铁的特殊形状使得磁极之间的磁力线不是均匀的，从而产生非匀强磁场</p><p>在非匀强磁场之中，银原子和磁场的相互作用能为</p><p><span class="math display">\[W = -\boldsymbol{M}\cdot\boldsymbol{B}\]</span></p><p>对 <span class="math inline">\(z\)</span> 方向求微分</p><p><span class="math display">\[F_z = -\frac{\partial W}{\partial z} = M_z \frac{\partial B}{\partial z}\]</span></p><p>实验结果为</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192317946.png" alt="result" /><figcaption aria-hidden="true">result</figcaption></figure><p>加入磁场之后，银原子分裂为两束。银原子的角动量数 <span class="math inline">\(l=0\)</span>，且最外层为 <span class="math inline">\(s\)</span> 电子，无轨道角动量，说明会银原子有自由度，且有两个取值</p><h6 id="斯特恩-盖拉赫实验的意义">斯特恩-盖拉赫实验的意义</h6><ol type="1"><li>证明了角动量空间量子化的存在<ul><li>原子沉积层不是连续的一片，而是分开的线，说明了角动量空间量子化的存在</li></ul></li><li>发现了新的矛盾<ul><li><span class="math inline">\(l=0\)</span>，应当有一条沉积线，但是实验结果却又两条沉积线，这说明原来对原子中的电子运动的描述是不完全的</li></ul></li><li>提供了原子的“态分离”技术</li></ol><h6 id="理论解释">理论解释</h6><p>1925 年乌伦贝克和古兹米特根据斯特恩-盖拉赫实验的结果，<strong>提出了电子不是指点，具有固有的自旋角动量 <span class="math inline">\(\boldsymbol{S}\)</span> 和相应的自旋磁矩 <span class="math inline">\(\boldsymbol{\mu_s}\)</span></strong> 的观点</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505192340149.png" alt="电子自旋角动量和磁矩" /><figcaption aria-hidden="true">电子自旋角动量和磁矩</figcaption></figure><p>由于电子带负电，其自旋磁矩和根据右手螺旋定律得到的方向相反</p><p>相对于外磁场方向，<span class="math inline">\(\boldsymbol{B}\)</span> 有朝上和朝下两种取向</p><p>但是若将电子视为 <span class="math inline">\(r=10^{-16}m\)</span> 的小球，按照 <span class="math inline">\(\boldsymbol{S}\sim\hbar\)</span> 估计得到的电子表面速度 <span class="math inline">\(&gt;c\)</span></p><p>电子在任意一个方向测量其自旋角动量的结果都是 <span class="math inline">\(\pm\hbar\)</span></p><h5 id="泡利不相容原理">泡利不相容原理</h5><ol type="1"><li>费米子和玻色子<ol type="1"><li><strong>费米子：</strong> 自旋量子数为半奇数的粒子</li><li><strong>玻色子：</strong> 自旋量子数为整数的粒子</li></ol></li><li>泡利不相容原理<ul><li>不能有两个电子具有相同的 <span class="math inline">\(n,m,l,m_l,m_s\)</span></li></ul></li><li>玻色凝聚<ul><li>玻色子不受泡利不相容原理的限制，一个单粒子态可容纳多个玻色子</li></ul></li></ol><h5 id="电子的自旋算符和自旋波函数">电子的自旋算符和自旋波函数</h5><h6 id="自旋算符">自旋算符</h6><p>自旋角动量是纯量子概念，但也是一个力学量</p><p>自旋角动量与电子的坐标和动量无关，是电子内部状态的表征，是描述电子状态的第四个自由度</p><p>自旋算符记为 <span class="math inline">\(\hat{S}\)</span></p><ul><li><span class="math inline">\(\hat{\boldsymbol{S}}\times\hat{\boldsymbol{S}} =i\hbar\hat{\boldsymbol{S}}\)</span></li><li><span class="math inline">\([\hat{\boldsymbol{S}_x},\hat{\boldsymbol{S}}_y] = i\hbar \hat{\boldsymbol{S}}_z\)</span></li><li><span class="math inline">\([\hat{\boldsymbol{S}}_y,\hat{\boldsymbol{S}}_z] = i\hbar \hat{\boldsymbol{S}}_x\)</span></li><li><span class="math inline">\([\hat{\boldsymbol{S}}_z,\hat{\boldsymbol{S}}_x] = i\hbar \hat{\boldsymbol{S}}_y\)</span></li></ul><p>由于<strong>自旋角动量</strong>在空间任意方向上的投影都只能取 <span class="math inline">\(\pm\frac{\hbar}{2}\)</span>，则 <span class="math inline">\(\hat{\boldsymbol{S}}_x\)</span>，<span class="math inline">\(\hat{\boldsymbol{S}}_y\)</span> 和 <span class="math inline">\(\hat{\boldsymbol{S}}_z\)</span> 的本征值都是 <span class="math inline">\(\pm\frac{\hbar}{2}\)</span>，其平方为 <span class="math inline">\(\frac{\hbar}{2}^2\)</span></p><h6 id="含自旋的状态波函数">含自旋的状态波函数</h6><p>电子的含自旋的波函数为</p><p><span class="math display">\[\Psi =\Psi(x,y,z,S_z,t)\]</span></p><p>由于 <span class="math inline">\(S_z\)</span> 只有两个取值 <span class="math inline">\(\pm\frac{\hbar}{2}\)</span>，所以可以写为两个分量</p><p><span class="math display">\[\begin{cases}  \psi_1=\psi(x,y,z,\frac{\hbar}{2},t)\\  \psi_2=\psi(x,y,z,-\frac{\hbar}{2},t)\end{cases}\]</span></p><p>写作列矩阵</p><p><span class="math display">\[\Psi = \begin{pmatrix}  \psi_1(\boldsymbol{r},t)\\  \psi_2(\boldsymbol{r},t)\end{pmatrix}\]</span></p><p>这里的正负号是规定好的</p><p>若已知电子处于 <span class="math inline">\(S_z = \frac{\hbar}{2}\)</span> 或 <span class="math inline">\(S_z = -\frac{\hbar}{2}\)</span> 的状态，则其波函数分别可以写为：</p><p><span class="math display">\[\Psi = \begin{pmatrix}  \psi_1(\boldsymbol{r},t)\\  0\end{pmatrix}\qquad\Psi = \begin{pmatrix}  0\\  \psi_2(\boldsymbol{r},t)\end{pmatrix}\]</span></p><h6 id="自旋算符的矩阵表示pauli-矩阵">自旋算符的矩阵表示，Pauli 矩阵</h6><p><strong><span class="math inline">\(\hat{S}_z\)</span> 的矩阵形式</strong></p><p><span class="math display">\[\hat{S}_z = \frac{\hbar}{2}\begin{pmatrix}  1 &amp; 0\\  0 &amp; -1\end{pmatrix}\]</span></p><p><strong>Pauli 算符</strong></p><p>对于 <span class="math inline">\(\hat{S}_z\)</span> 的矩阵形式，我们定义 Pauli 算符，使得</p><p><span class="math display">\[\hat{S}_z = \frac{\hbar}{2}\hat{\sigma}\]</span></p><p>从自旋算符与 Pauli 矩阵之间的关系，可以得到自旋算符的矩阵表示</p><p><span class="math display">\[\hat{S}_x = \frac{\hbar}{2}\begin{pmatrix}  0 &amp; 1\\  1 &amp; 0\end{pmatrix}\quad\hat{S}_y = \frac{\hbar}{2}\begin{pmatrix}  0 &amp; -i\\  i &amp; 0\end{pmatrix}\quad\hat{S}_z = \frac{\hbar}{2}\begin{pmatrix}  1 &amp; 0\\  0 &amp; -1\end{pmatrix}\]</span></p><h6 id="自旋波函数">自旋波函数</h6><p>波函数 <span class="math inline">\(\Psi = \begin{pmatrix}\psi_1\newline \psi_2\end{pmatrix}\)</span> 中，一般情况下，<span class="math inline">\(\Psi_1\neq\Psi_2\)</span>，两者对 <span class="math inline">\((x,y,z)\)</span> 的依赖是不相同的，因为自旋对轨道运动有一定的影响，但是当影响足够小时，可以忽略，此时认为 <span class="math inline">\(\Psi_1\)</span> 和 <span class="math inline">\(\Psi_2\)</span> 的函数形式相同，<span class="math inline">\(\Psi\)</span> 可以写作如下的形式</p><p><span class="math display">\[\Psi(\boldsymbol{r},S_z,t) =\psi(\boldsymbol{r},t)\chi(S_z)\]</span></p><p>其中 <span class="math inline">\(\chi(S_z)\)</span> 是 <span class="math inline">\(\hat{S}_z\)</span> 的本征函数，称为自旋波函数</p><p><span class="math display">\[\chi_{\frac{1}{2}}(S_z) = \begin{pmatrix}  1\\  0\end{pmatrix}\quad\chi_{-\frac{1}{2}}(S_z) = \begin{pmatrix}  0\\  1\end{pmatrix}\]</span></p><p>这两个自旋波函数相互正交</p><h3 id="无限深势阱">无限深势阱</h3><h3 id="谐振子">谐振子</h3><h4 id="势能">势能</h4><p>若先择线性谐振子平衡位置为坐标原点和势能零点，则一维线性谐振子得到势能可以表示为</p><p><span class="math display">\[U(x) = \frac{1}{2}kx^2 = \frac{1}{2}m\omega^2x^2\]</span></p><h5 id="谐振子的定态薛定谔方程">谐振子的定态薛定谔方程</h5><p>一维谐振子的哈密顿量为</p><p><span class="math display">\[\hat{H} = -\frac{\hbar^2}{2m}\frac{\partial^2}{\partial x^2} + \frac{1}{2}m\omega^2x^2\]</span></p><p>满足的定态薛定谔方程为</p><p><span class="math display">\[\left[-\frac{\hbar^2}{2m}\frac{\partial^2}{\partial x^2} + \frac{1}{2}m\omega^2x^2\right]\Phi(x) = E\Phi(x)\]</span></p><p>一维谐振子的能量是量子化的</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>物理</tag>
      
      <tag>量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记</title>
    <link href="/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/30/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://oi-wiki.org/ds">oiWiki 中的数据结构</a></p><h2 id="引言">引言</h2><h3 id="算法与数据结构">算法与数据结构</h3><p>数据结构的研究内容</p><ol type="1"><li>数据之间的<strong>逻辑关系</strong>，以及这种关系对应的操作</li><li><strong>储存实现</strong>：数据及逻辑关系的存储</li><li><strong>运算实现</strong>：具体存储模式下，运算的实现，即<strong>算法</strong></li></ol><h4 id="数据的逻辑结构">数据的逻辑结构</h4><ul><li><strong>集合结构</strong> 次序任意，元素之间除了<strong>同处于一个集合内</strong>之外没有任意其他的关系.</li><li><strong>线性结构</strong> 数据元素的<strong>有序</strong>排列，除了头尾的元素外其余元素都有一个前趋和一个后继.</li><li><strong>树形结构</strong> 除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.</li><li><strong>图形结构</strong> 每个元素的前趋和后继数量都不限 <img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png" alt="FourLogicalDataStructures" /></li></ul><h4 id="数据结构的操作">数据结构的操作</h4><ul><li><strong>创造</strong></li><li><strong>清除</strong></li><li><strong>插入</strong></li><li><strong>删除</strong></li><li><strong>更新</strong></li><li><strong>搜索</strong></li><li><strong>访问</strong></li><li><strong>遍历（traverse）</strong>：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次</li><li>每一种数据结构的特定操作</li></ul><p>数据结构的<strong>五大类</strong>：构建类、属性类、数据操纵类、遍历类、特定类</p><h3 id="存储实现">存储实现</h3><h3 id="算法分析">算法分析</h3><h4 id="时间复杂度的概念">时间复杂度的概念</h4><ul><li>是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，<span class="math inline">\(T(n)\)</span></li><li>算法的时间复杂度也与被处理的数据分布有关</li><li>算法的时间复杂度分为三种<ul><li>最好的</li><li>最坏的</li><li>平均</li></ul></li></ul><h4 id="算法运算量的计算">算法运算量的计算</h4><h4 id="渐进时间复杂度">渐进时间复杂度</h4><h4 id="算法的优化">算法的优化</h4><h4 id="空间复杂度的概念">空间复杂度的概念</h4><ul><li>渐进的空间复杂度</li><li>一般只考虑<strong>辅助</strong>空间的占用情况</li><li>空间复杂度一般按照最坏情况处理</li><li>空间复杂度的计算、表示方法与时间复杂度相同</li></ul><h3 id="面向对象方法">面向对象方法</h3><h4 id="类模板的定义">类模板的定义</h4><p>类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型</p><h5 id="定义格式">定义格式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 标识符&gt;<br><span class="hljs-keyword">class</span> 类名<br>&#123;<br>    <span class="hljs-comment">// 类成员声明</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="类定义的一般格式">类定义的一般格式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 类名<br>&#123;<br>  [<span class="hljs-keyword">private</span>:]<br>    <span class="hljs-comment">// 私有数据成员和成员函数声明</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公有数据成员和成员函数声明</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="虚函数">虚函数</h4><ul><li><p>在基类中用关键词 <code>virtual</code> 声明的成员函数，并在派生类中重新定义的函数称为虚函数</p></li><li><p>虚函数的一般格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> 返回类型 函数名(参数表)<br>&#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（<strong>继承</strong>）</p></li><li><p>当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数</p></li><li><p>虚函数在基类中有默认实现，派生类可以选择性地对其进行重写</p></li></ul><h4 id="纯虚函数">纯虚函数</h4><ul><li><p>是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数</p></li><li><p>纯虚函数的一般形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> 返回类型 函数名(参数表) = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>纯虚函数在基类中无实现，只有函数原型，派生类必须实现</p></li></ul><h4 id="抽象类">抽象类</h4><ul><li>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类就是抽象类</li><li>抽象类只能作为其他类的基类，不能建立抽象类的对象</li></ul><h4 id="继承">继承</h4><ul><li>在已有类的基础上建立新的类</li><li>基类（父类）和派生类（子类）</li><li>继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题</li></ul><h5 id="派生类">派生类</h5><ul><li><p>一般格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 派生类名 : [派生方式] 基类名<br>&#123;<br>  <span class="hljs-comment">// 派生类新增的数据成员和成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>派生方法</p><ul><li>公有派生：<code>public</code></li><li>私有派生：<code>protected</code></li><li>保护派生：<code>private</code></li></ul></li><li><p><code>class</code> 默认是 <code>private</code> 继承， <code>struct</code> 默认是 <code>public</code> 继承</p></li></ul><h6 id="派生类对基类成员的访问性">派生类对基类成员的访问性</h6><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><code>public</code> 继承</th><th style="text-align: center;"><code>protected</code> 继承</th><th style="text-align: center;"><code>private</code> 继承</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>public</code> 成员</td><td style="text-align: center;">public</td><td style="text-align: center;">protected</td><td style="text-align: center;">private</td></tr><tr class="even"><td style="text-align: center;"><code>protected</code> 成员</td><td style="text-align: center;">protected</td><td style="text-align: center;">protected</td><td style="text-align: center;">private</td></tr><tr class="odd"><td style="text-align: center;"><code>private</code> 成员</td><td style="text-align: center;">不可访问</td><td style="text-align: center;">不可访问</td><td style="text-align: center;">不可访问</td></tr></tbody></table><h4 id="类定义时常见的两种const用法">类定义时常见的两种<code>const</code>用法</h4><p>以函数 <code>int search(constelemType&amp;x) const</code> 为例</p><ol type="1"><li>修饰参数 <code>x</code> 的 <code>const</code> 和 <code>&amp;</code> 组合<ul><li><code>const</code> 修饰参数 <code>x</code>，表示函数 <code>search</code> 不会修改参数 <code>x</code> 的值</li><li>参数加了 <code>const</code> 之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数 <code>x</code> 的修改操作，若有则会报错</li><li><strong>如果确认函数实现中不准备改变 <code>x</code> 的值，养成加 <code>const</code>的习惯</strong></li><li><code>&amp;</code> 修饰参数 <code>x</code>，表示参数 <code>x</code> 是引用传递，即传递的是实参的地址，而不是实参的值</li></ul></li><li>修饰函数 <code>search</code> 的 <code>const</code><ul><li>参数表后的 <code>const</code> 保护调用对象的值不被修改</li><li>如果没有 <code>const</code> 修饰，那么在调用对象为 <code>const</code> 类型时，不能调用该函数 常量对象只能调用参数表后带 <code>const</code> 的常量成员函数</li></ul></li></ol><h2 id="线性表">线性表</h2><h3 id="线性表的定义">线性表的定义</h3><h4 id="线性表的概念">线性表的概念</h4><ul><li><p>是一种<strong>线性结构</strong>，是由 <span class="math inline">\(n(n\geq0)\)</span> 个数据元素组成的有限序列</p></li><li><p>除了首节点 <span class="math inline">\(A_0\)</span> 和尾节点 <span class="math inline">\(A_{n-1}\)</span> 之外，每个节点 <span class="math inline">\(A_i\)</span> 有且仅有一个前趋 <span class="math inline">\(A_{i-1}\)</span> 和一个后继 <span class="math inline">\(A_{i+1}\)</span></p></li><li><p><span class="math inline">\(A_0\)</span> 只有后趋，<span class="math inline">\(A_{n-1}\)</span> 只有前趋</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png" alt="线性表" /><figcaption aria-hidden="true">线性表</figcaption></figure></li></ul><h4 id="表的基本操作">表的基本操作</h4><ul><li><strong>创建 <code>create()</code></strong>：创建一个空的线性表</li><li><strong>清除 <code>clear()</code></strong>：删除线性表中的所有数据元素</li><li><strong>长度 <code>length()</code></strong>：返回线性表的长度</li><li><strong>插入 <code>insert(i,x)</code></strong>：在线性表的第 <span class="math inline">\(i\)</span> 个位置插入一个新元素 <code>x</code></li><li><strong>删除 <code>remove(i)</code></strong>：删除线性表中第 <span class="math inline">\(i\)</span> 个位置的元素</li><li><strong>搜索 <code>search(x)</code></strong>：在线性表中搜索元素 <code>x</code>，返回其位置</li><li><strong>访问 <code>visit(i)</code></strong>：返回线性表中第 <span class="math inline">\(i\)</span> 个位置的元素</li><li><strong>遍历 <code>traverse()</code></strong>：依次访问线性表中的每个元素</li></ul><h4 id="线性表的抽象类">线性表的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                           <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 返回长度</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 访问</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">list</span>() &#123;&#125;                                  <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现</li><li><strong>抽象类无构造函数</strong></li></ul><h3 id="线性表的顺序实现">线性表的顺序实现</h3><h4 id="顺序存储结构">顺序存储结构</h4><ul><li>节点存储在存储器的一块<strong>连续</strong>的空间中</li><li>节点依照逻辑顺序依次<strong>存放</strong></li><li>节点存放的物理位置和逻辑顺序是对应的</li><li>线性表的顺序实现通常被称为<strong>顺序表</strong></li></ul><h4 id="顺序表类的定义">顺序表类的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqList</span> : <span class="hljs-keyword">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *data;<br>    <span class="hljs-type">int</span> currentLength;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);             <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqList</span>()                              <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>                            <span class="hljs-comment">//清空</span></span><br><span class="hljs-function">    </span>&#123;<br>      currentLength = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                      <span class="hljs-comment">// 返回长度</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> elemType &amp;x)</span></span>;  <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;                     <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                  <span class="hljs-comment">// 遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="函数实现">函数实现</h4><h5 id="构造函数">构造函数</h5><ul><li>定义对象时自动调用，用于初始化对象的数据成员</li><li><strong>函数名与类名相同</strong></li><li>可以有任何类型的参数，也可以没有参数，但是<strong>不能有返回类型</strong>，所以定义时不能说明类型</li><li>若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqList&lt;elemType&gt;::<span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  data = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png" alt="seqList" /><figcaption aria-hidden="true">seqList</figcaption></figure><h5 id="析构函数">析构函数</h5><ul><li>用于释放对象所占用的内存空间，由编译系统自动调用</li><li><strong>函数名与类名相同，前面加 <code>~</code></strong></li><li>不能有参数，也不能有返回类型</li><li>若没有给出析构函数，编译器会自动生成一个默认的析构函数</li><li>不是所有类都要由析构函数</li><li>一般在构造函数中动态申请内存的，必须有析构函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">seqList</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] data;<br>&#125;  <span class="hljs-comment">//在线性表的类中已经实现了，不用到类外定义</span><br></code></pre></td></tr></table></figure><h5 id="顺序表的运算实现">顺序表的运算实现</h5><h6 id="search"><code>search</code></h6><p>从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到 <code>x</code> 或找到表尾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">int</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> elemType &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> i ;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; currentLength &amp;&amp; data[i] != x ; ++i);<br>  <span class="hljs-keyword">if</span> (i == currentLength)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="traverse"><code>traverse</code></h6><p>从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemtype</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; currentLength ; ++i)<br>  &#123;<br>    cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="insert"><code>insert</code></h6><ul><li>在第 <code>i</code> 个位置插入元素 <code>x</code></li><li>若插入后表长超过 <code>maxSize</code>，则将 <code>maxSize</code> 扩大一倍</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png" alt="seqList::insert" /><figcaption aria-hidden="true">seqList::insert</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (currentSize = maxSize)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = currentLength ; j &gt; i ; --j)<br>  &#123;<br>    data[j] = data[j - <span class="hljs-number">1</span>];<br>  &#125;<br>  data[i] = x;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="doublespace-操作的实现"><code>doubleSpace</code> 操作的实现</h6><ul><li>重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png" alt="seqList::doublespace" /><figcaption aria-hidden="true">seqList::doublespace</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">doublespace</span>()<br>&#123;<br>  elemtype *tmp = data;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  data = <span class="hljs-keyword">new</span> elemtype[maxSize];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; currentLength ; +<span class="hljs-number">+1</span>)<br>  &#123;<br>    data[i] = tmp[i];<br>  &#125;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="remove"><code>remove</code></h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png" alt="seqlist::remove" /><figcaption aria-hidden="true">seqlist::remove</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> ||i &gt; currentlength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i ; j &lt; currentlength <span class="hljs-number">-1</span> ; ++j)<br>  &#123;<br>    data[j] = data[j + <span class="hljs-number">1</span>];<br>  &#125;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性表的链接存储">线性表的链接存储</h3><h4 id="单链表">单链表</h4><ul><li>每个节点附加指针字段，如 <code>next</code>，指向直接后继节点，最后一个节点的 <code>next</code> 指向 <code>nullptr</code></li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png" alt="单链表" /><figcaption aria-hidden="true">单链表</figcaption></figure><h5 id="头节点头指针">头节点、头指针</h5><ul><li>在表头额外增加一个相同类型的特殊结点</li><li>不是线性表中的组成部分</li><li>头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png" alt="带头节点的单链表" /><figcaption aria-hidden="true">带头节点的单链表</figcaption></figure><h5 id="结点及其组成">结点及其组成</h5><ul><li>链表的节点包含两个部分<ul><li>数据字段<ul><li>可以存储任何类型的数据，仍然使用 <code>elemType</code> 表示</li></ul></li><li>指针字段<ul><li>用于存储<strong>后继节点</strong>的地址值</li></ul></li><li>结点类型是链表专用的，可以设为内嵌类</li><li>将节点类定义为 <code>struct</code> 方便链表类访问</li></ul></li></ul><h5 id="单链表类的定义">单链表类的定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sLinkList</span>:<span class="hljs-keyword">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>                                    <span class="hljs-comment">// 节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br><br>    node *head;<br>    <span class="hljs-type">int</span> currentLength;<br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sLinkList</span>();<br>    ~<span class="hljs-built_in">sLinkList</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-1">构造函数</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png" alt="sLinklist" /><figcaption aria-hidden="true">sLinklist</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>sLinkList&lt;elemType&gt;::<span class="hljs-built_in">sLinkList</span>()<br>&#123;<br>  head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="clear"><code>clear</code></h5><ul><li>将单链表变成一个空表</li><li>回收节点空间</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png" alt="sLinkList::clear" /><figcaption aria-hidden="true">sLinkList::clear</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>  node *p = head-&gt;next , *q;<br><br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)        <span class="hljs-comment">// 删除节点</span><br>  &#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="move"><code>move</code></h5><ul><li>返回第 <span class="math inline">\(i\)</span> 个元素的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sLinkList</span>&lt;elemType&gt;::node *sLinkList&lt;elemType&gt;::<span class="hljs-built_in">move</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>  node *p = head;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; ++j)<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="insert-1"><code>insert</code></h5><ol type="1"><li>指针 <code>p</code> 指向要插入的位置 <code>i</code> 的前一个节点</li><li>申请一个新节点 <code>s</code></li><li>将 <code>s</code> 的 <code>next</code> 指向 <code>p</code> 的 <code>next</code></li><li>将 <code>p</code> 的 <code>next</code> 指向 <code>s</code></li></ol><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png" alt="sLinkList::insert" /><figcaption aria-hidden="true">sLinkList::insert</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sinkList&lt;elemtype&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  node *p = <span class="hljs-built_in">move</span>(i<span class="hljs-number">-1</span>);<br>  node *s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x , p-&gt;next);<br>  p-&gt;next = s;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="remove-1"><code>remove</code></h5><ol type="1"><li>找到被删除节点的前一个节点 <code>pos</code></li><li>让 <code>delp</code> 指向被删除节点</li><li>让 <code>pos</code> 的 <code>next</code> 指向 <code>delp</code> 的 <code>next</code></li><li>释放 <code>delp</code> 的空间</li></ol><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png" alt="sLinkList::remove" /><figcaption aria-hidden="true">sLinkList::remove</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  node *pos = <span class="hljs-built_in">move</span>(i<span class="hljs-number">-1</span>);<br>  node *delp = pos-&gt;next;<br>  pos-&gt;next = delp-&gt;next;<br>  <span class="hljs-keyword">delete</span> delp;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="search-1"><code>search</code></h5><ul><li>从头节点开始，依次访问每个节点，直到找到 <code>x</code> 或到达表尾</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">int</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> elemtype <span class="hljs-number">7</span>x) <span class="hljs-type">const</span><br>&#123;<br>  node *p = head -&gt; next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data != x) <span class="hljs-comment">// 访问每个节点，条件的顺序不能交换</span><br>  &#123;<br>    p = p-&gt;next;<br>    ++i;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果判定条件改为 <code>p-&gt;data != x &amp;&amp; p != nullptr</code>，会在 <code>p</code> 为空时试图访问 <code>p-&gt;data</code>，导致访问空指针，从而产生未定义行为</li></ul><h5 id="visit"><code>visit</code></h5><ol type="1"><li>找到第 <code>i</code> 个节点</li><li>返回 <code>p-&gt;data</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType sLinkList&lt;elemType&gt;::<span class="hljs-built_in">visit</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">move</span>(i)-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="traverse-1"><code>traverse</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>  node *p = head-&gt;next;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    p = p-&gt;next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双链表">双链表</h4><ul><li>每个节点有两个指针字段<ul><li><code>next</code> 指向直接后继节点</li><li><code>prev</code> 指向直接前驱节点</li></ul></li></ul><h5 id="双链表的头尾节点">双链表的头尾节点</h5><ul><li>头节点<ul><li><code>prev</code> 指向 <code>nullptr</code></li><li><code>next</code> 指向首节点</li></ul></li><li>尾节点 <code>tail</code><ul><li><code>prev</code> 指向最后一个节点</li><li><code>next</code> 指向 <code>nullptr</code></li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png" alt="双链表" /><figcaption aria-hidden="true">双链表</figcaption></figure><h5 id="双链表类的定义">双链表类的定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dLinkList</span>:<span class="hljs-keyword">public</span> list&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>                                                         <span class="hljs-comment">// 双链表中的节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      node *prev;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *p = <span class="hljs-literal">nullptr</span> , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        prev = p;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *head , *tail;                                                  <span class="hljs-comment">// 头节点和尾节点</span><br>    <span class="hljs-type">int</span> currentLength;                                                   <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;                                             <span class="hljs-comment">// 返回第 i 个节点的指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">dLinkList</span>();<br>    ~<span class="hljs-built_in">dLinkList</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-2">构造函数</h5><ul><li>申请头节点和尾节点</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png" alt="dLinkList" /><figcaption aria-hidden="true">dLinkList</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>dLinkList&lt;elemType&gt;::<span class="hljs-built_in">dLinkList</span>()<br>&#123;<br>  head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  head-&gt;next = tail;<br>  tail-&gt;prev = head;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="insert-2"><code>insert</code></h5><ol type="1"><li>申请一个新节点 <code>tmp</code>，找到要插入的位置 <code>pos</code></li><li>将 <code>tmp</code> 的 <code>prev</code> 指向 <code>pos</code> 的 <code>prev</code>，<code>tmp</code> 的 <code>next</code> 指向 <code>pos</code></li><li>将 <code>pos</code> 的前一个结点的 <code>next</code> 指向 <code>tmp</code></li><li>将 <code>pos</code> 的 <code>prev</code> 指向 <code>tmp</code></li></ol><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png" alt="dLinkList::insert" /><figcaption aria-hidden="true">dLinkList::insert</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> dLinkList&lt;elemtype&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i ,<span class="hljs-type">const</span> elemTypr &amp;x)<br>[<br>  node *pos , *tmp;<br><br>  pos = <span class="hljs-built_in">move</span>(i);<br>  temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x,pos -&gt; prev , pos);<br>  pos-&gt;prev-&gt;next = tmp;<br>  pos-&gt;prev = tmp;<br><br>  ++currentLength;<br>]<br></code></pre></td></tr></table></figure><h5 id="remove-2"><code>remove</code></h5><ol type="1"><li>找到要删除的节点 <code>pos</code></li><li>将 <code>pos</code> 的前一个节点的 <code>next</code> 指向 <code>pos</code> 的后一个节点</li><li>将 <code>pos</code> 的后一个节点的 <code>prev</code> 指向 <code>pos</code> 的前一个节点</li></ol><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png" alt="dLinkList::remove" /><figcaption aria-hidden="true">dLinkList::remove</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> dLinkList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  node *pos = <span class="hljs-built_in">move</span>(i);<br><br>  pos-&gt;prev-&gt;next = pos-&gt;next;<br>  pos-&gt;next-&gt;prev = pos-&gt;prev;<br><br>  <span class="hljs-keyword">delete</span> pos;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单循环链表">单循环链表</h4><ul><li>一般单循环链表不带头节点</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png" alt="单循环链表" /><figcaption aria-hidden="true">单循环链表</figcaption></figure><h4 id="双循环链表">双循环链表</h4><ul><li>头结点中 <code>prev</code> 字段给出尾结点的地址，尾结点中 <code>next</code> 字段给出头结点的地址</li><li>一般也不设置头尾节点</li></ul><h2 id="栈">栈</h2><h3 id="栈的定义">栈的定义</h3><ul><li>栈是一种特殊的线性表</li><li>只允许在一段进行插入和删除操作</li><li>先进后出（LIFO，Last In First Out）</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png" alt="栈" /><figcaption aria-hidden="true">栈</figcaption></figure><h4 id="栈的基本操作">栈的基本操作</h4><ul><li><strong>创建 <code>create()</code></strong>：创建一个空栈</li><li><strong>进栈 <code>push(x)</code></strong>：将元素 <code>x</code> 压入栈顶</li><li><strong>出栈 <code>pop()</code></strong>：删除栈顶元素并返回其值</li><li><strong>访问栈顶元素 <code>top()</code></strong>：返回栈顶元素的值但是不删除</li><li><strong>判断是否为空 <code>isEmpty()</code></strong>：若栈空返回 <code>true</code>，否则返回 <code>false</code></li></ul><h4 id="栈的抽象类">栈的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stack</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;       <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 访问栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">stack</span>() &#123;&#125;                             <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="栈的顺序实现">栈的顺序实现</h3><ul><li>使用数组储存栈中的节点</li><li>进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png" alt="顺序栈" /><figcaption aria-hidden="true">顺序栈</figcaption></figure><h4 id="顺序栈类">顺序栈类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *data;                     <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-type">int</span> top_p;                          <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> maxSize;                        <span class="hljs-comment">// 栈的最大容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);        <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqStack</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;       <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="顺序存储的运算实现">顺序存储的运算实现</h4><h5 id="构造函数-3">构造函数</h5><ul><li>按照用户估计的栈的规模申请一个动态数组，将数组地址保存在 <code>elem</code> 中，数组规模保存在 <code>maxSize</code> 中，并设 <code>top_p</code> 的值为 <span class="math inline">\(-1\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::<span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  elem = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  top_p = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="push"><code>push</code></h4><ul><li>先判断栈是否已满，若满则调用 <code>doubleSpace</code> 扩大栈的容量</li><li>将 <code>top_p</code> 加 1，指向栈顶元素</li><li>将 <code>x</code> 压入栈顶</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (top_p == maxSize - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  elem[++top_p] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doublespace"><code>doubleSpace</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class="hljs-keyword">new</span> elemType[maxSize * <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[i];<br>  &#125;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pop"><code>pop</code></h5><ul><li>返回 <code>top_p</code> 指向的元素</li><li>将 <code>top_p</code> 减 1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> elem[top_p--];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="top"><code>top</code></h5><ul><li>返回 <code>top_p</code> 指向的元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty"><code>isEmpty</code></h5><ul><li>判断 <code>top_p</code> 是否为 <span class="math inline">\(-1\)</span>，若是则栈空</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="析构函数-1">析构函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::~<span class="hljs-built_in">seqStack</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="性能分析">性能分析</h4><ul><li>所有运算实现的时间复杂度都为 <span class="math inline">\(O(1)\)</span></li><li>进栈运算在最坏的情况下的时间复杂度为 <span class="math inline">\(O(n)\)</span> （需要 <code>doublespace</code> 时）</li></ul><h3 id="栈的链接实现">栈的链接实现</h3><ul><li>使用<strong>不含头结点的单链表</strong>实现栈</li><li>从使用方便性上看，将单链表的头指针指向栈顶</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png" alt="链接栈" /><figcaption aria-hidden="true">链接栈</figcaption></figure><h4 id="链接栈类">链接栈类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *top_p;                       <span class="hljs-comment">// 栈顶指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedStack</span>();                    <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">LinkedStack</span>();                   <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;     <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="链接存储的运算实现">链接存储的运算实现</h4><h5 id="构造函数-4">构造函数</h5><ul><li>将 <code>top_p</code> 初始化为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br>  top_p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-2">析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>LinkStack&lt;elemType&gt;::~<span class="hljs-built_in">LinkStack</span>()<br>&#123;<br>  node *tmp;<br>  <span class="hljs-keyword">while</span> (top_p != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    tmp = top_p;<br>    top_p = top_p-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="push-1"><code>push</code></h5><ul><li>在表头插入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  top_p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x , top_p);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pop-1"><code>pop</code></h5><ul><li>删除表头节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>  node *tmp = top_p;<br>  elemType x = top_p-&gt;data;<br>  top_p = top_p-&gt;next;<br>  <span class="hljs-keyword">delete</span> tmp;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="top-1"><code>top</code></h5><ul><li>返回 <code>top_p</code> 指向的节点的 <code>data</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-1"><code>isEmpty</code></h5><ul><li>判断 <code>top_p</code> 是否为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1">性能分析</h4><ul><li>所有运算实现的时间复杂度都为 <span class="math inline">\(O(1)\)</span>，因为都是对栈顶进行操作</li></ul><h3 id="栈的应用">栈的应用</h3><h4 id="递归函数的非递归实现">递归函数的非递归实现</h4><h5 id="函数调用">函数调用</h5><ul><li>递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  r1:<span class="hljs-built_in">f1</span>();<br>  r2:<br>  ..<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  t1:<span class="hljs-built_in">f2</span>();<br>  t2:<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png" alt="函数执行过程" /><figcaption aria-hidden="true">函数执行过程</figcaption></figure><ul><li>设置一个栈模拟函数调用，当调用发生时，将函数压入栈中</li><li>函数返回时，将栈顶元素弹出</li></ul><h6 id="递归算法的例子">递归算法的例子</h6><p>hanoi 塔算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">int</span> Height , <span class="hljs-type">int</span> FromNeedle ,<span class="hljs-type">int</span> ToNeedle ,<span class="hljs-type">int</span> UsingNeedle)</span> <span class="hljs-comment">// FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (Height &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">Move</span>(Height - <span class="hljs-number">1</span>，FromNeedle , UsingNeeedle,ToNeedle); <span class="hljs-comment">// 将上面n-1个盘子从FromNeedle移动到UsingNeedle</span><br>    cout &lt;&lt; FromNeedle &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; ToNeedle &lt;&lt; endl; <span class="hljs-comment">// 将最底下的盘子从FromNeedle移动到ToNeedle&gt;</span><br>    <span class="hljs-built_in">Move</span>(Height - <span class="hljs-number">1</span>,UsingNeedle , ToNeedle , FromNeedle); <span class="hljs-comment">// 将上面的盘子从UsingNeedle移动到ToNeedle</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="递归算法的时间复杂度">递归算法的时间复杂度</h5><h6 id="数学归纳法">数学归纳法</h6><p>以 Hanio 塔问题为例</p><p><span class="math display">\[\begin{dcases}T(n) = 2T(n-1) + 1 &amp;\\T(1) = 1 &amp;\end{dcases}\]</span></p><p>可以使用数学归纳法证明 <span class="math inline">\(T(n) = 2^n - 1\)</span></p><h6 id="递归方程">递归方程</h6><p><strong>主定理</strong>：设 <span class="math inline">\(a \geq 1\)</span>，<span class="math inline">\(b &gt; 1\)</span> 为常数，<span class="math inline">\(f(n)\)</span> 是一个函数，则递归方程</p><p><span class="math display">\[T(n) = aT(\frac{n}{b}) + f(n) \quad (n &gt; 1)\]</span></p><p>的解为</p><ol type="1"><li>若 <span class="math inline">\(f(n) &lt; O\left(n^{\log_{b}a}\right)\)</span>，则 <span class="math inline">\(T(n)=O\left(n^{\log_{b}a}\right)\)</span></li><li>若 <span class="math inline">\(f(n) = O\left(n^{\log_{b}a}\right)\)</span>，则 <span class="math inline">\(T(n)=O\left(n^{\log_{b}a}\log_{2}n\right)\)</span></li><li>若 <span class="math inline">\(f(n) &gt; O\left(n^{\log_{b}a}\right)\)</span>，则 <span class="math inline">\(T(n)=O\left(f(n)\right)\)</span></li></ol><h6 id="生成函数">生成函数</h6><p><strong>定义</strong>：设 <span class="math inline">\(u_0 , u_1 , u_2 , \ldots , u_n ,\ldots\)</span> 是一无穷序列，称形式幂级数 <span class="math inline">\(\displaystyle G(t) = \sum_{i\geq0}u_it^i\)</span> 为其生成函数</p><p>利用生成函数求通项的方法</p><ol type="1"><li>按照递归关系式消去无限延长的部分</li><li>展开为 <span class="math inline">\(t\)</span> 的幂级数求通项</li></ol><p>以 Fibonacci 数列为例</p><p><span class="math display">\[\begin{dcases}F_{0} =0 &amp; \\F_{1} =1 &amp; \\F_{n} =F_{n-1} +F_{n-2} &amp;\end{dcases}\]</span></p><p><span class="math display">\[\begin{aligned}  &amp;G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \cdots \\  &amp;G(t) = t + t^2 + t^3 + \cdots \\  &amp;tG(t)=t^2 + t^3 + t^4 + \cdots \\  &amp;t^2G(t)=t^3 + t^4 + t^5 + \cdots \\  &amp;(1-t-t^2)G(t) = t \\  &amp;G(t) = \frac{t}{1-t-t^2} = \frac{1}{\sqrt{5}} \left(\frac{1}{1-\frac{1+\sqrt{5}}{2}t} - \frac{1}{1-\frac{1-\sqrt{5}}{2}t}\right) \\\end{aligned}\]</span></p><p>令 <span class="math inline">\(\Phi = \frac{1}{2}(1+\sqrt{5})\)</span>，<span class="math inline">\(\hat{\Phi}=\frac{1}{2}(1-\sqrt{5})\)</span></p><p><span class="math display">\[G(t) =\frac{1}{\sqrt{5}}(\frac{1}{1-\Phi t} - \frac{1}{1-\hat{\Phi}t})\]</span></p><p>有 <span class="math inline">\(\displaystyle\frac{1}{1-\Phi t} = \sum_{n=0}^{\infty} \Phi^n t^n\)</span></p><p><span class="math display">\[G(t) = \frac{1}{\sqrt{5}} \sum_{n=0}^{\infty} (\Phi^n t^n - \hat{\Phi}^n t^n)\]</span></p><p>则</p><p><span class="math display">\[F_n = \frac{1}{\sqrt{5}}(\Phi^n - \hat{\Phi}^n)\]</span></p><h4 id="递归消除">递归消除</h4><p>以打印正整数为例</p><h5 id="递归实现">递归实现</h5><h6 id="代码">代码</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">10</span>)<br>  &#123;<br>    <span class="hljs-built_in">printNum</span>(num / <span class="hljs-number">10</span>);<br>    cout.<span class="hljs-built_in">put</span>(num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout.<span class="hljs-built_in">put</span>(num + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="代码运行过程中栈的变化">代码运行过程中栈的变化</h6><ol type="1"><li><code>push(1234)</code></li><li><code>pop(1234)</code>，<code>push(4)</code>，<code>push(123)</code></li><li><code>pop(123)</code>，<code>push(3)</code>，<code>push(12)</code></li><li><code>pop(12)</code>，<code>push(2)</code>，<code>push(1)</code></li><li><code>pop(1)</code>，<code>pop(2)</code>，<code>pop(3)</code>，<code>pop(4)</code></li></ol><h5 id="非递归实现">非递归实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkStack&lt;<span class="hljs-type">int</span>&gt; s;<br>  <span class="hljs-type">int</span> tmp;<br>  s.<span class="hljs-built_in">push</span>(num);<br>  <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">9</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp % <span class="hljs-number">10</span>);<br>      s.<span class="hljs-built_in">push</span>(tmp / <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      cout.<span class="hljs-built_in">put</span>(tmp + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="括号匹配">括号匹配</h3><ul><li>判断一个表达式中的括号是否匹配</li><li>遇到左括号就入栈，遇到右括号就出栈</li></ul><p>判断错误的原则</p><ol type="1"><li>栈空时遇到右括号</li><li>出栈时遇到不匹配的括号</li><li>栈不空时结束</li></ol><h3 id="简单的计算数学表达式">简单的计算数学表达式</h3><h4 id="前缀式中缀式和后缀式">前缀式、中缀式和后缀式</h4><p>对于一个表达式 <span class="math inline">\(a+b\)</span></p><ul><li>前缀式 <code>+ab</code>，波兰式</li><li>中缀式 <code>a+b</code></li><li>后缀式 <code>ab+</code>，逆波兰式</li></ul><h4 id="后缀式的优点">后缀式的优点</h4><ul><li>不需要括号</li><li>不需要考虑运算符的优先级</li><li>计算机容易处理</li></ul><h4 id="后缀式的计算">后缀式的计算</h4><ul><li>使用栈来存储操作数</li><li>遇到操作数就入栈</li><li>遇到操作符就出栈两个操作数，进行计算，将结果入栈</li><li>最后栈中只剩下一个元素，就是结果</li></ul><h4 id="中缀式转换为后缀式的算法">中缀式转换为后缀式的算法</h4><p>操作方法见<a href="/本科/编程/数据结构/中缀计算式转换为后缀计算式.md">中缀计算式转换为后缀计算式</a></p><h2 id="队列">队列</h2><ul><li><p>队列的定义</p></li><li><p>先进先出（FIFO，First In First Out）</p></li><li><p>只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作</p></li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png" alt="队列" /><figcaption aria-hidden="true">队列</figcaption></figure><h4 id="队列的基本操作">队列的基本操作</h4><ul><li><strong>创建 <code>create()</code></strong>：创建一个空队列</li><li><strong>入队 <code>enQueue(x)</code></strong>：将元素 <code>x</code> 入队</li><li><strong>出队 <code>deQueue()</code></strong>：删除队首元素并返回其值</li><li><strong>访问队首元素 <code>getHead()</code></strong>：返回队首元素的值但不删除</li><li><strong>判断是否为空 <code>isEmpty()</code></strong>：若队列空返回 <code>true</code>，否则返回 <code>false</code></li></ul><h4 id="队列的抽象类">队列的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;       <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;              <span class="hljs-comment">// 访问队首元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>() &#123;&#125;                                 <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="队列的顺序实现">队列的顺序实现</h3><ul><li>使用数组来存储队列中的元素</li><li>元素下标的范围为 <span class="math inline">\(0\)</span> 到 <code>maxSize - 1</code></li><li>存储队里的三种组织方法<ol type="1"><li>队头位置固定</li><li>队头位置不固定</li><li>循环队列</li></ol></li></ul><h4 id="队头位置固定">队头位置固定</h4><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png" alt="队头位置固定" /><figcaption aria-hidden="true">队头位置固定</figcaption></figure><p><strong>缺点</strong>：出队的时间复杂度为 <span class="math inline">\(O(n)\)</span>，因为出队时需要将所有元素向前移动一位</p><h4 id="队头位置不固定">队头位置不固定</h4><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png" alt="队头位置不固定" /><figcaption aria-hidden="true">队头位置不固定</figcaption></figure><p><strong>优点</strong>：所有操作的时间复杂度均为 <span class="math inline">\(O(1)\)</span> <strong>缺点</strong>：浪费大量的空间</p><h4 id="循环队列">循环队列</h4><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png" alt="循环队列" /><figcaption aria-hidden="true">循环队列</figcaption></figure><ul><li>入队<ul><li><code>rear = (rear + 1) % maxSize</code>; <code>elem[rear] = x</code></li></ul></li><li>出队<ul><li><code>front = (front + 1) % maxSize</code>; <code>return elem[front]</code></li></ul></li></ul><p>为了解决队列空和队列满的判断问题，令 <code>front</code> 指向的单元不能存储队列元素，只能起到标志作用</p><ul><li>队列空：<code>front == rear</code></li><li>队列满：<code>(rear + 1) % maxSize == front</code></li></ul><h6 id="循环队列类的定义">循环队列类的定义</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span>:<span class="hljs-keyword">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *elem;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-type">int</span> front , rear;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);        <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqQueue</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-5">构造函数</h5><ul><li>申请一块空间，将 <code>front</code> 和 <code>rear</code> 初始化为 <span class="math inline">\(0\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::<span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  elem = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  front = rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-3">析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::~<span class="hljs-built_in">seqQueue</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="enqueue"><code>enQueue</code></h5><ul><li>先判断队列是否已满，若满则调用 <code>doubleSpace</code> 扩大队列的容量</li><li>将 <code>rear</code> 加 1，指向队尾元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> ((rear + <span class="hljs-number">1</span>) % maxSize == front)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  rear = (rear + <span class="hljs-number">1</span>) % maxSize;<br>  elem[rear] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="doublespace-1"><code>doubleSpace</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class="hljs-keyword">new</span> elemType[maxSize * <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[(front + i) % maxSize];<br>  &#125;<br>  front = <span class="hljs-number">0</span>;<br>  rear = maxSize - <span class="hljs-number">1</span>;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dequeue"><code>deQueue</code></h5><ul><li>将 <code>front</code> 加 1，指向队首元素</li><li>返回 <code>elem[front]</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  front = (front + <span class="hljs-number">1</span>) % maxSize;<br>  <span class="hljs-keyword">return</span> elem[front];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gethead"><code>getHead</code></h5><ul><li>返回 <code>elem[(front + 1) % maxSize]</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">getHead</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> elem[(front + <span class="hljs-number">1</span>) % maxSize];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-2"><code>isEmpty</code></h5><ul><li>判断 <code>front</code> 是否等于 <code>rear</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> front == rear;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列的链接实现">队列的链接实现</h3><ul><li>为了方便操作，使用含头节点和尾节点的单链表实现</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png" alt="链接队列" /><figcaption aria-hidden="true">链接队列</figcaption></figure><p><strong>链接队列的特点</strong></p><ul><li>不会出现队列满的情况，但是会出现队列空的情况</li><li>队列为空时，单链表中没有节点存在，即头尾指针都为 <code>nullptr</code></li><li>保存一个链接队列只需要两个分别指向单链表节点的指针 <code>front</code> 和 <code>rear</code><ul><li><code>front</code> 指向队首元素</li><li><code>rear</code> 指向队尾元素</li></ul></li></ul><h4 id="连接队列类">连接队列类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkQueue</span>:<span class="hljs-keyword">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *front , *rear;                <span class="hljs-comment">// 队头和队尾指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">linkQueue</span>();                       <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">linkQueue</span>();                      <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>;              <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;   <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;                <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-6">构造函数</h5><ul><li>将 <code>front</code> 和 <code>rear</code> 初始化为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::<span class="hljs-built_in">linkQueue</span>()<br>&#123;<br>  front = rear = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="enqueue-1"><code>enQueue</code></h5><ol type="1"><li>申请一个节点空间 <code>x</code></li><li>将 <code>rear</code> 指向的节点的 <code>next</code> 指向 <code>x</code></li><li>将 <code>rear</code> 指向 <code>x</code></li></ol><p><strong>注意</strong>：存在队列为空的情况，此时我们只需要将 <code>front</code> 和 <code>rear</code> 都指向 <code>x</code> 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> linkQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (rear == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    front = rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    rear = rear-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dequeue-1"><code>deQueue</code></h5><ol type="1"><li>返回 <code>front</code> 指向的节点的 <code>data</code></li><li>将 <code>front</code> 指向的节点从链表中摘下</li><li>释放空间</li></ol><p><strong>注意</strong>：当队列中只有一个元素时，删除后队列为空，此时需要将 <code>front</code> 和 <code>rear</code> 都置为 <code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> LinkQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  node *tmp = front;<br>  <span class="hljs-keyword">if</span> (front)<br>  &#123;<br>    emelType value = front-&gt;data;<br>    front = front-&gt;next;<br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      rear = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> tmp;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gethead-1"><code>getHead</code></h5><ul><li>返回 <code>front</code> 指向的节点的 <code>data</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType linkQueue&lt;elemType&gt;::<span class="hljs-built_in">getHead</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> front-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-3"><code>isEmpty</code></h5><ul><li>判断 <code>front</code> 或 <code>rear</code> 是否为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> linkQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> front == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-4">析构函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::~<span class="hljs-built_in">linkQueue</span>()<br>&#123;<br>  node *tmp;<br>  <span class="hljs-keyword">while</span> (front != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    tmp = front;<br>    front = front-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树">树</h2><h3 id="树的定义">树的定义</h3><h4 id="树的递归定义">树的递归定义</h4><ul><li>树是 <span class="math inline">\(n\)</span> 个节点的有限集合，它或者是空集，或者满足<ul><li>有一个特殊的节点称为根节点</li><li>除根节点外，其他节点分为 <span class="math inline">\(m\)</span> 个互不相交的有限集合 <span class="math inline">\(T_1 , T_2 , \ldots , T_m\)</span>，每个集合都是一棵树</li></ul></li></ul><h4 id="树的术语">树的术语</h4><ul><li><strong>根节点、叶节点、内部节点</strong>：<ul><li>根节点：没有父节点的节点</li><li>叶节点：没有子节点的节点</li><li>内部节点：有子节点的节点</li></ul></li><li><strong>节点的度和树的度</strong>：<ul><li>节点的度：节点的子树个数</li><li>树的度：树中所有节点的度的最大值</li></ul></li><li><strong>儿子节点</strong></li><li><strong>父亲节点</strong></li><li><strong>兄弟节点</strong></li><li><strong>祖先节点</strong></li><li><strong>子孙节点</strong></li><li><strong>节点所处层次</strong></li><li><strong>树的高度</strong></li><li><strong>有序树</strong></li><li><strong>无序树</strong></li><li><strong>森林</strong></li></ul><h4 id="树的运算">树的运算</h4><ul><li><strong>建树 <code>create()</code></strong>：创建一个空树</li><li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li><li><strong>判空 <code>IsEmpty()</code></strong>：判断是否为空树</li><li><strong>找根节点 <code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li><li><strong>找父节点 <code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li><li><strong>找子节点 <code>child()</code></strong>：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值</li><li><strong>剪枝 <code>remove()</code></strong>：删除节点的某棵子树</li><li><strong>遍历 <code>traverse()</code></strong>：访问树上的每个节点</li></ul><h4 id="树的抽象类">树的抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tree</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">child</span><span class="hljs-params">(T x , <span class="hljs-type">int</span> i , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树">二叉树</h3><h4 id="二叉树的定义">二叉树的定义</h4><ul><li>二叉树（Binary Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树</li></ul><p><strong>注意</strong>：二叉树是<strong>有序树</strong>，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树</p><p>二叉树有五种基本形态</p><ol type="1"><li>空树</li><li>只有一个节点的树</li><li>只有左子树的树</li><li>只有右子树的树</li><li>左右子树都有的树</li></ol><h5 id="满二叉树">满二叉树</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png" alt="满二叉树" /><figcaption aria-hidden="true">满二叉树</figcaption></figure><ul><li>每个节点的度都为 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(2\)</span> 的二叉树称为满二叉树</li><li>性质<ul><li>高度为 <span class="math inline">\(h\)</span> 的满二叉树有 <span class="math inline">\(2^h - 1\)</span> 个节点</li><li>任意一层的节点个数达到了上限 <span class="math inline">\(2^{n-1}\)</span></li></ul></li></ul><h5 id="完全二叉树">完全二叉树</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png" alt="完全二叉树" /><figcaption aria-hidden="true">完全二叉树</figcaption></figure><ul><li>在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树</li><li>满二叉树是完全二叉树，完全二叉树不一定是满二叉树</li><li>性质<ul><li>所有的叶节点都出现在最低的两层生</li><li>对于任意节点，如果其右子树的高度为 <span class="math inline">\(h\)</span>，则其左子树的高度为 <span class="math inline">\(h\)</span> 或 <span class="math inline">\(h+1\)</span></li></ul></li></ul><h4 id="二叉树的性质">二叉树的性质</h4><ol type="1"><li>二叉树的第 <span class="math inline">\(i\)</span> 层最多有 <span class="math inline">\(2^{i-1}\)</span> 个节点</li><li>二叉树的深度为 <span class="math inline">\(h\)</span>，则最多有 <span class="math inline">\(2^h - 1\)</span> 个节点</li><li>对于一棵非空二叉树，若其叶节点个数为 <span class="math inline">\(n_0\)</span>，则其度为 <span class="math inline">\(2\)</span> 的节点个数为 <span class="math inline">\(n_2\)</span>，则有 <span class="math inline">\(n_0 = n_2 + 1\)</span></li><li>具有 <span class="math inline">\(n\)</span> 个节点的二叉树的高度为 <span class="math inline">\(h\)</span>，则 <span class="math inline">\(h = \lfloor \log_2n \rfloor +1\)</span></li><li>对于一棵具有 <span class="math inline">\(n\)</span> 个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为 <span class="math inline">\(1\)</span>，则对任一编号为 <span class="math inline">\(u\)</span> 的节点，有<ol type="1"><li>如果 <span class="math inline">\(i=1\)</span>，则 <span class="math inline">\(u\)</span> 为根节点</li><li>如果 <span class="math inline">\(i&gt;1\)</span>，则 <span class="math inline">\(u\)</span> 的父节点编号为 <span class="math inline">\(\lfloor \frac{u}{2} \rfloor\)</span></li><li>如果 <span class="math inline">\(2i \geq n\)</span>，则编号为 <span class="math inline">\(i\)</span> 的节点为叶子节点，没有儿子；否则，其左子编号为 <span class="math inline">\(2i\)</span></li><li>如果 <span class="math inline">\(2i+1 \geq n\)</span>，则编号为 <span class="math inline">\(i\)</span> 的节点无右儿子；否则，其右子编号为 <span class="math inline">\(2i+1\)</span></li></ol></li></ol><h4 id="二叉树的基本运算">二叉树的基本运算</h4><ul><li><strong>建树 <code>create()</code></strong>：创建一棵空树</li><li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li><li><strong>判空 <code>isEmpty()</code></strong>：判断是否为空树</li><li><strong>找根节点 <code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li><li><strong>找父节点 <code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li><li><strong>找左子节点 <code>lchild()</code></strong>：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值</li><li><strong>找右子节点 <code>rchild()</code></strong>：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值</li><li><strong>删除左子树 <code>delLeft()</code></strong>：删除节点的左子树</li><li><strong>删除右子树 <code>delRight()</code></strong>：删除节点的右子树</li><li><strong>遍历 <code>traverse()</code></strong>：访问树上的每个节点</li></ul><h4 id="二叉树的遍历">二叉树的遍历</h4><h5 id="前序遍历">前序遍历</h5><ul><li>如果树为空，则操作为空</li><li>如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树</li></ul><h5 id="中序遍历">中序遍历</h5><ul><li>如果树为空，则操作为空</li><li>如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树</li></ul><h5 id="后序遍历">后序遍历</h5><ul><li>如果树为空，则操作为空</li><li>如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点</li></ul><h5 id="层次遍历">层次遍历</h5><ul><li>从上到下，从左到右访问树的每个节点</li></ul><h5 id="性质">性质</h5><ul><li>由前序遍历和中序遍历可以唯一确定一棵二叉树</li><li>由中序遍历和后序遍历可以唯一确定一棵二叉树</li><li>由前序遍历和后序遍历<strong>不能</strong>唯一确定一棵二叉树</li></ul><h4 id="二叉树抽象类">二叉树抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 找根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找父节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">lchild</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找左子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">rchild</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找右子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;                <span class="hljs-comment">// 删除左子树</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 删除右子树</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;           <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;          <span class="hljs-comment">// 层次遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉树的实现">二叉树的实现</h4><h5 id="二叉树的顺序实现">二叉树的顺序实现</h5><ul><li>使用数组来存储二叉树中的节点</li><li>将二叉树补全为完全二叉树再进行存储</li><li>会导致空间浪费</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png" alt="顺序二叉树" /><figcaption aria-hidden="true">顺序二叉树</figcaption></figure><h5 id="二叉树的链接实现">二叉树的链接实现</h5><ul><li>使用链表来存储二叉树中的节点<ul><li>标准形式：<code>left</code>，<code>data</code>，<code>right</code></li></ul></li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png" alt="标准形式" /><figcaption aria-hidden="true">标准形式</figcaption></figure><ul><li>广义标准形式：<code>data</code>，<code>left</code>，<code>parent</code>，<code>right</code></li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png" alt="广义标准形式" /><figcaption aria-hidden="true">广义标准形式</figcaption></figure><h4 id="二叉树类">二叉树类</h4><h5 id="节点类">节点类</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    Node *left *right;                                                                <span class="hljs-comment">// 左右子树指针</span><br>    T data;                                                                           <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;                                             <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(T item , Node *L = <span class="hljs-literal">nullptr</span>,Node *R = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(item),<span class="hljs-built_in">left</span>(L),<span class="hljs-built_in">right</span>(R)&#123;&#125;  <span class="hljs-comment">// 带参数的构造函数</span><br>    ~<span class="hljs-built_in">Node</span>()&#123;&#125;                                                                         <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="二叉树类-1">二叉树类</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span>:<span class="hljs-keyword">public</span> tree&lt;T&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(<span class="hljs-type">const</span> binaryTree &amp;t, t flag)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>      <span class="hljs-keyword">public</span>:<br>        Node *left *right;<br>        T data;<br>        <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(T item , Node *L = <span class="hljs-literal">nullptr</span>,Node *R = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(item),<span class="hljs-built_in">left</span>(L),<span class="hljs-built_in">right</span>(R)&#123;&#125;<br>        ~<span class="hljs-built_in">Node</span>()&#123;&#125;<br>    &#125;<br>    Node *root;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">binaryTree</span>():<span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;                    <span class="hljs-comment">// 构造函数,创建空树</span><br>    <span class="hljs-built_in">binaryTree</span>(T x):<span class="hljs-built_in">root</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x))&#123;&#125;             <span class="hljs-comment">// 构造函数,创建只有根节点的树</span><br>    ~<span class="hljs-built_in">binaryTree</span>()&#123;&#125;                                 <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;                                   <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                           <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function">T <span class="hljs-title">Root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span></span>;                           <span class="hljs-comment">// 找根节点</span><br>    <span class="hljs-function">T <span class="hljs-title">lchild</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 找左子节点</span><br>    <span class="hljs-function">T <span class="hljs-title">rchild</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 找右子节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;                       <span class="hljs-comment">// 删除左子树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;                      <span class="hljs-comment">// 删除右子树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                          <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                          <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                         <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                        <span class="hljs-comment">// 层次遍历</span><br>    <span class="hljs-function">coid <span class="hljs-title">creatTree</span><span class="hljs-params">(T flag)</span></span>;                         <span class="hljs-comment">// 创建树</span><br>    <span class="hljs-function">T <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span>             <span class="hljs-comment">// 找父节点</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x, Node *t)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 查找节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *&amp;x)</span></span>;                             <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                     <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                     <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                    <span class="hljs-comment">// 后序遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-7">构造函数</h5><p>将 <code>root</code> 初始化为 <code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>binaryTree&lt;T&gt;::<span class="hljs-built_in">binaryTree</span>()<br>&#123;<br>  root = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="isempty-4"><code>isEmpty</code></h5><ul><li>判断 <code>root</code> 是否为 <code>nullptr</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">bool</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> root == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="root"><code>Root</code></h5><p>返回 <code>Root</code> 指向的节点的数据，若为空树则返回特殊值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">Root</span>(T flag)<span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> root-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二叉树的遍历-1">二叉树的遍历</h5><h6 id="前序遍历-1">前序遍历</h6><ol type="1"><li>访问根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(t -&gt; left);<br>    <span class="hljs-built_in">preorder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n前序遍历：&quot;</span><br>  <span class="hljs-built_in">preOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="中序遍历-1">中序遍历</h6><ol type="1"><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">midOrder</span>(t -&gt; left);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">midOrder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n中序遍历：&quot;</span><br>  <span class="hljs-built_in">midOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="后序遍历-1">后序遍历</h6><ol type="1"><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">postOrder</span>(t -&gt; left);<br>    <span class="hljs-built_in">postOrder</span>(t -&gt; right);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n后序遍历：&quot;</span><br>  <span class="hljs-built_in">postOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="size"><code>size</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;t&gt;::<span class="hljs-built_in">size</span>(binarytree&lt;t&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t = <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">sizze</span>(t -&gt; left)+<span class="hljs-built_in">size</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="height"><code>height</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">size</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-type">int</span> lt = <span class="hljs-built_in">height</span>(t -&gt; left);<br>    <span class="hljs-type">int</span> rt = <span class="hljs-built_in">height</span>(t -&gt; right);<br>    <span class="hljs-keyword">return</span> (lt &gt; rt ? lt : rt) + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">height</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="层次遍历-1">层次遍历</h5><ul><li>使用链接队列实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">levelOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n层次遍历：&quot;</span>;<br>  que.<span class="hljs-built_in">enQueue</span>(root);<br>  <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = que.<span class="hljs-built_in">deQueue</span>();<br>    cout &lt;&lt; tmp -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span> (tmp.left)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp.right)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="clear-1"><code>clear</code></h5><ul><li>递归删除树中所有节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">clear</span>(Node *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">clear</span>(t -&gt; left);<br>    <span class="hljs-built_in">clear</span>(t -&gt; right);<br>    <span class="hljs-keyword">delete</span> t;<br>    t = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>  <span class="hljs-built_in">clear</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="析构函数-5">析构函数</h5><ul><li>调用 <code>clear</code> 函数删除树中所有节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>binaryTree&lt;T&gt;::~<span class="hljs-built_in">binaryTree</span>()<br>&#123;<br>  <span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="find"><code>Find</code></h5><ul><li>使用前序遍历查找 <code>x</code> 节点</li><li>首先检查根节点是否存放 <code>x</code> 的值，若是则返回根节点地址</li><li>对左子树递归调用 <code>Find</code> 函数，若返回空指针则说明 <code>x</code> 不在左子树中</li><li>对右子树递归调用 <code>Find</code> 函数，若返回空指针则说明 <code>x</code> 不在右子树中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binaryTree</span>&lt;T&gt;:: Node *binaryTree&lt;T&gt;::<span class="hljs-built_in">Find</span>(<span class="hljs-type">const</span> T &amp;x ,binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t -&gt; data == x)<br>  &#123;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (tmp = <span class="hljs-built_in">Find</span>(x,t-&gt;left))<br>    &#123;<br>      <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(x,t-&gt;right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="delleft"><code>delLeft</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">delLeft</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root);<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">clear</span>(tmp -&gt; left);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="delright"><code>delRight</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">delRight</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root);<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">clear</span>(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="lchild"><code>lchild</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">lchild</span>(<span class="hljs-type">const</span> T &amp;x ,T flag) <span class="hljs-type">const</span><br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root)<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span> || tmp -&gt; left ==<span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> tmp -&gt; left;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="rchild"><code>rchild</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">rchild</span>(<span class="hljs-type">const</span> T &amp;x ,T flag) <span class="hljs-type">const</span><br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root)<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span> || tmp -&gt; right ==<span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> tmp -&gt; right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="createtree"><code>createTree</code></h5><ul><li>创建过程（类似层次遍历？）<ol type="1"><li>输入根节点的值，创建根节点</li><li>对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入 <code>flag</code></li></ol></li><li>实现过程<ul><li>使用队列，将新加入到书中的节点添加到队列中</li><li>依次出队，对每个出队的元素输入它的儿子</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">createTree</span>(T flag)<br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  T x , ldata , rdata;<br><br>  <span class="hljs-comment">// 创建树，flag表示空</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n输入根节点：&quot;</span><br>  cin &gt;&gt; x;<br>  root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x);<br>  que.<span class="hljs-built_in">enQueue</span>(root);<br>  <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = que,<span class="hljs-built_in">deQueue</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入&quot;</span> &lt;&lt; tmp -&gt; data &lt;&lt; <span class="hljs-string">&quot;的两个儿子（&quot;</span>&lt;&lt;flag&lt;&lt;<span class="hljs-string">&quot;表示空节点）：&quot;</span>;<br>    cin &gt;&gt; ldata &gt;&gt; rdata;<br>    <span class="hljs-keyword">if</span> (ldata != flag)<br>    &#123;<br>      tmp -&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(ldata);<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rdata != flag)<br>    &#123;<br>      tmp -&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(rdata);<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;that&#x27;s good!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="printtree"><code>printTree</code></h5><ul><li>层次遍历输出每个节点和它的左右孩子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(<span class="hljs-type">const</span> binaryTree&lt;T&gt; &amp;t,T flag)</span></span><br><span class="hljs-function"></span>&#123;<br>  linkQueue&lt;T&gt; que;<br>  que.<span class="hljs-built_in">enQueue</span>(t.<span class="hljs-built_in">root</span>());<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    T tmp = que.<span class="hljs-built_in">deQueue</span>();<br>    T l = tmp.<span class="hljs-built_in">lchild</span>(tmp , flag);<br>    T r = tmp.<span class="hljs-built_in">rchild</span>(tmp , flag);<br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (l != flag)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(l);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r != flag)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(r);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉树遍历的非递归实现">二叉树遍历的非递归实现</h4><h5 id="前序遍历-2">前序遍历</h5><ol type="1"><li>将根节点入栈</li><li>栈顶元素出栈并输出值</li><li>将左右子树入栈（先右后左，以便输出时先输出左子树）</li><li>循环直至栈为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  Node *tmp = t;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n前序遍历：&quot;</span>;<br>  <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class="hljs-built_in">pop</span>();<br>    cout &lt;&lt; tm -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span> (tmp -&gt; right != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp -&gt; right);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp -&gt; left != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp -&gt; left);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="中序遍历-2">中序遍历</h5><ol type="1"><li>根节点入栈</li><li>左子树入栈</li><li>栈顶元素出栈并输出值</li><li>左子树出栈完成之后根节点出栈</li><li>右子树入栈</li><li>循环直至栈为空</li></ol><p>栈的设计</p><ul><li>根节点入栈出栈两次<ul><li>第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈</li><li>第二次出栈后返回值，并且将右子树入栈</li></ul></li><li>对于根节点要记住<ul><li>在哪棵树上</li><li>第几次出栈</li></ul></li><li>每个节点在某种意义上都是根节点</li></ul><h6 id="stnode-类定义"><code>StNode</code> 类定义</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StNode</span><br>&#123;<br>  Node *node;<br>  <span class="hljs-type">int</span> TimesPop;<br>  <span class="hljs-built_in">StNode</span>(Node *N=<span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">node</span>(N),<span class="hljs-built_in">TimesPop</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="中序遍历的非递归实现">中序遍历的非递归实现</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *t&gt; s;<br>  <span class="hljs-function">StNode <span class="hljs-title">current</span><span class="hljs-params">(root)</span></span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n中序遍历：&quot;</span>;<br>  s.<span class="hljs-built_in">push</span>(current);<br>  <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (++current.TimesPop == <span class="hljs-number">2</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class="hljs-keyword">if</span> (current.node -&gt; right != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; right));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(current);<br>      <span class="hljs-keyword">if</span> (current.node -&gt; left != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="后序遍历-2">后序遍历</h5><ol type="1"><li>根节点入栈</li><li>左子树入栈</li><li>右子树入栈</li><li>栈顶元素出栈并输出值</li><li>循环直至栈为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  <span class="hljs-function">StNode <span class="hljs-title">current</span><span class="hljs-params">(root)</span></span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n后序遍历：&quot;</span>;<br>  s.<span class="hljs-built_in">push</span>(current);<br>  <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (++current.TimesPop == <span class="hljs-number">3</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(current);<br>      <span class="hljs-keyword">if</span> (current.node -&gt; right != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; right));<br>      &#125;<br>      <span class="hljs-keyword">if</span> (current.node -&gt; left != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h3><h4 id="字符的机内表示">字符的机内表示</h4><ul><li>用二进制数来表示字符</li><li>前缀编码<ul><li>字符只放在叶结点中</li><li>字符编码可以有不同的长度</li><li>每个字符的编码都不可能是其他字符编码的前缀</li><li>可以被唯一解码</li></ul></li></ul><h4 id="哈夫曼树">哈夫曼树</h4><ul><li>最小代价，即带权路径长度最小的二叉树</li><li>所有字符都在叶结点上</li><li>权值大的字符离根节点近，权值小的字符离根节点远</li><li>哈夫曼编码是一种前缀编码</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png" alt="huffmanTree" /><figcaption aria-hidden="true">huffmanTree</figcaption></figure><h4 id="哈夫曼算法">哈夫曼算法</h4><ol type="1"><li>给定一个具有 <span class="math inline">\(n\)</span> 个权值 <span class="math inline">\(\{w_1 , w_2 , \ldots , w_4\}\)</span> 的节点的集合 <span class="math inline">\(\mathbb{A}\)</span> <span class="math inline">\(\mathbb{F} = \{T_1 , T_2 , \ldots , T_n\}\)</span></li><li>初始时，设集合 <span class="math inline">\(\mathbb{A} = \mathbb{F}\)</span></li><li>执行从 <span class="math inline">\(i\)</span> 到 <span class="math inline">\(n-1\)</span> 的循环<ol type="1"><li>从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点 <span class="math inline">\(b_i\)</span> 的左右儿子，<span class="math inline">\(b_i\)</span> 的权值为这两个节点的权值之和</li><li>集合中去除这两个节点，将 <span class="math inline">\(b_i\)</span> 加入其中</li></ol></li><li>循环结束后，集合 <span class="math inline">\(\mathbb{A}\)</span>中只剩下一个节点 <span class="math inline">\(b_n\)</span>，即为哈夫曼树的根节点</li></ol><h4 id="哈夫曼编码">哈夫曼编码</h4><ul><li>每个节点的编码是从根节点到该节点的路径</li><li>左子树为 <code>0</code>，右子树为 <code>1</code></li></ul><h4 id="哈夫曼树类的实现">哈夫曼树类的实现</h4><ol type="1"><li>接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码</li><li>有两个公有的成员函数<ol type="1"><li>构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树</li><li><code>getCode</code>：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码</li></ol></li></ol><h5 id="哈夫曼树的存储">哈夫曼树的存储</h5><ul><li>在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为 <span class="math inline">\(2\)</span> 的节点</li><li>若待编码的元素个数为 <span class="math inline">\(n\)</span>，则哈夫曼树的节点数为 <span class="math inline">\(2n-1\)</span></li><li>哈夫曼树使用一个大小为 <span class="math inline">\(2n\)</span> 的数组来存储，不使用 <span class="math inline">\(0\)</span> 节点，将根节点存储在下标为 <span class="math inline">\(1\)</span> 的位置，叶节点依次存储在下标为 <span class="math inline">\(n+1\)</span> 到 <span class="math inline">\(2n\)</span> 的位置，<span class="math inline">\(0\)</span> 结点作为结束的判断依据</li><li>每个数组保存 <strong>节点的数据</strong>，<strong>节点的权值</strong>，<strong>节点的父节点下标</strong>，<strong>左子节点下标</strong>，<strong>右子节点下标</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hfTree</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>      Type data; <span class="hljs-comment">//节点数据</span><br>      <span class="hljs-type">int</span> weight; <span class="hljs-comment">//节点权值</span><br>      <span class="hljs-type">int</span> parent; <span class="hljs-comment">//父节点下标</span><br>      <span class="hljs-type">int</span> left , right; <span class="hljs-comment">//左右子节点下标</span><br>    &#125;;<br><br>    Node *elem;<br>    <span class="hljs-type">int</span> length;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hfCode</span><br>    &#123;<br>      Type data; <span class="hljs-comment">//节点数据</span><br>      string code; <span class="hljs-comment">//哈夫曼编码</span><br>    &#125;;<br><br>    <span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *v , <span class="hljs-type">const</span> <span class="hljs-type">int</span> *w , <span class="hljs-type">int</span> size);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCode</span><span class="hljs-params">(hfCode result[])</span></span>;<br>    ~<span class="hljs-built_in">hfTree</span>()<br>    &#123;<br>      <span class="hljs-keyword">delete</span> [] elem;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="构造函数-8">构造函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>hfTree&lt;Type&gt;::<span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *v , <span class="hljs-type">const</span> <span class="hljs-type">int</span> *w , <span class="hljs-type">int</span> size)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_INT = <span class="hljs-number">32767</span>;<br>  <span class="hljs-type">int</span> min1 , min2; <span class="hljs-comment">// 最小树、次最小树的权值</span><br>  <span class="hljs-type">int</span> x , y ; <span class="hljs-comment">// 最小树、次最小树的下标</span><br><br>  <span class="hljs-comment">/* 初始化 */</span><br>  length = <span class="hljs-number">2</span> * size ;                                            <span class="hljs-comment">// 哈夫曼树的节点数为 $2\text&#123;size&#125;-1$，但我们只需要存储 $2\text&#123;size&#125;$ 个节点</span><br>  elem = <span class="hljs-keyword">new</span> Node[length];                                       <span class="hljs-comment">// 创建一个大小为 $2\text&#123;size&#125;$ 的数组来存储哈夫曼树的节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; i &lt; length ; i++)                          <span class="hljs-comment">// 对数组 `elem` 中的节点进行初始化，前 $\text&#123;size&#125;$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值</span><br>  &#123;<br>    elem[i].weight = w[i-size]; <span class="hljs-comment">// 储存权值</span><br>    elem[i].data = v[i-size]; <span class="hljs-comment">// 储存待编码的元素</span><br>    elem[i].parent = elem[i].left = elem[i].right = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 初始化父节点、左子节点和右子节点的下标为 `0`</span><br>  &#125;<br><br>  <span class="hljs-comment">/* 构造新的二叉树 */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span> ; i--)                           <span class="hljs-comment">// 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点</span><br>  &#123;<br>    min1 = min2 = MAX_INT;                                       <span class="hljs-comment">// 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值</span><br>    x = y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; length ; j++)                       <span class="hljs-comment">// 遍历当前节点之后的所有节点</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (elem[j].parent == <span class="hljs-number">0</span>)                                   <span class="hljs-comment">// 判断是否未加入树中</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (elem[j].weight &lt; min1)                               <span class="hljs-comment">// 找到真正的最小值和次小值以及他们对应的下标</span><br>        &#123;<br>          min2 = min1;<br>          min1 = elem[j].weight;<br>          x = y;<br>          y = j;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(elem[j].weight &lt; min2)<br>        &#123;<br>          min2 = elem[j].weight;<br>          x = j;<br>        &#125;<br>      &#125;<br>    &#125;<br>    elem[i].weight = min1 + min2;                                <span class="hljs-comment">// 将最小值和次小值的权值相加，作为当前节点的权值</span><br>    elem[i].left = x;                                            <span class="hljs-comment">// 将最小值的节点作为当前节点的左子节点</span><br>    elem[i].right = y;                                           <span class="hljs-comment">// 将次小值的节点作为当前节点的右子节点</span><br>    elem[x].parent = i;                                          <span class="hljs-comment">// 将当前节点作为最小值节点的父节点</span><br>    elem[y].parent = i;                                          <span class="hljs-comment">// 将当前节点作为次小值节点的父节点</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="getcode"><code>getCode</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">void</span> hdTree&lt;Type&gt;::<span class="hljs-built_in">getcode</span>(hfCode result[])<br>&#123;<br>  <span class="hljs-type">int</span> size = length / <span class="hljs-number">2</span> ;<br>  <span class="hljs-type">int</span> p , s ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &lt; length; ++i)<br>  &#123;<br>    result[i -size].data = elem[i].data;<br>    result[i -size].code = <span class="hljs-string">&quot;&quot;</span>;<br>    p = elem[i].parent; s = i;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (elem[p].left == s)<br>      &#123;<br>        result[i -size].code = <span class="hljs-string">&#x27;0&#x27;</span> + result[i -size].code;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        result[i -size].code = <span class="hljs-string">&#x27;1&#x27;</span> + result[i -size].code;<br>      &#125;<br>      s = p;<br>      p = elem[p].parent;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树和森林">树和森林</h3><h4 id="树的存储实现">树的存储实现</h4><ul><li><strong>标准形式</strong>：除了数据字段之外，还有 <span class="math inline">\(K\)</span> 个指针字段，指向 <span class="math inline">\(K\)</span> 个孩子节点，其中 <span class="math inline">\(K\)</span> 是树的度</li><li><strong>广义标准形式</strong>：除了数据字段之外，还有 <span class="math inline">\(K\)</span> 个指针字段，指向 <span class="math inline">\(K\)</span> 个孩子节点和一个指针字段，指向父节点</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png" alt="树的存储实现" /><figcaption aria-hidden="true">树的存储实现</figcaption></figure><h4 id="树的表示方法">树的表示方法</h4><h5 id="孩子链表示法">孩子链表示法</h5><ul><li><p>每个节点的所有孩子组织成一个链表</p></li><li><p>节点由两个部分组成</p><ul><li>储存数据元素值的数据部分</li><li>指向孩子链的指针</li></ul></li><li><p><strong>静态</strong>的孩子链表：树的所有节点存放在一个名叫表头数组的<strong>数组</strong>中</p></li><li><p><strong>动态</strong>的孩子链表：树的所有节点组织成一个<strong>链表</strong></p></li></ul><h5 id="孩子兄弟链表示法">孩子兄弟链表示法</h5><ul><li>将一棵树转化为二叉树</li><li>左子树指向第一颗子树树根的指针</li><li>右子树指向兄弟节点的指针</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png" alt="孩子兄弟链" /><figcaption aria-hidden="true">孩子兄弟链</figcaption></figure><h5 id="双亲表示法">双亲表示法</h5><ul><li>每一个节点由两个部分组成<ul><li>储存数据元素的数据字段</li><li>储存父节点的父指针字段</li></ul></li><li>便于查找节点的祖先，但是不便于查找指定节点的子孙</li></ul><h3 id="树的遍历">树的遍历</h3><h4 id="前序遍历-3">前序遍历</h4><ol type="1"><li>访问根节点</li><li>依次前序遍历所有子树</li></ol><h4 id="后序遍历-3">后序遍历</h4><ol type="1"><li>依次后序遍历所有子树</li><li>访问根节点</li></ol><h4 id="层次遍历-2">层次遍历</h4><ol type="1"><li>访问根节点</li><li>若第 <span class="math inline">\(i\)</span> 层已被访问，且第 <span class="math inline">\(i+1\)</span> 层的结点尚未被访问，则从左到右依次访问第 <span class="math inline">\(i+1\)</span> 层的结点</li></ol><h4 id="特点">特点</h4><ul><li>树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的</li><li>树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的</li></ul><p>由前序遍历和后序遍历可以唯一确定一棵树</p><h3 id="树森林和二叉树">树、森林和二叉树</h3><h4 id="森林的定义">森林的定义</h4><ul><li>森林通常被定义为树的集合或树的序列</li><li>存储<ul><li>存储森林的每一棵树</li><li>表示这些树属于同一个森林</li></ul></li></ul><h4 id="森林的二叉树存储">森林的二叉树存储</h4><ol type="1"><li>将每棵树 <span class="math inline">\(T_i\)</span> 转化为二叉树 <span class="math inline">\(B_i\)</span></li><li>将 <span class="math inline">\(B_i\)</span> 作为 <span class="math inline">\(B_{i-1}\)</span> 根节点的右子树</li></ol><h2 id="优先级队列">优先级队列</h2><h3 id="优先级队列的定义">优先级队列的定义</h3><ul><li>节点之间的关系是由节点的优先级决定的</li><li>优先级高的先出队，优先级低的后出队</li><li>继承于队列的抽象类</li></ul><h3 id="优先级队列的简单实现">优先级队列的简单实现</h3><ol type="1"><li>入队时进行排序，出队操作不变 入队时间复杂度为 <span class="math inline">\(O(n)\)</span>，出队时间复杂度为 <span class="math inline">\(O(1)\)</span></li><li>出队时进行排序，入队操作不变 入队时间复杂度为 <span class="math inline">\(O(1)\)</span>，出队时间复杂度为 <span class="math inline">\(O(n)\)</span></li></ol><h3 id="二叉堆">二叉堆</h3><ul><li>二叉堆是一个完全二叉树</li><li>二叉堆满足下述关系之一（下标是按层次遍历的次序）<ol type="1"><li><strong>最大化堆</strong>：<span class="math inline">\(k_i &gt; k_{2i},\quad k_i &gt; k{2i+1} \quad (i = 1,2,\ldots,\lfloor \frac{n}{2}\rfloor\)</span></li><li><strong>最小化堆</strong>：<span class="math inline">\(k_i &lt; k_{2i},\quad k_i &lt; k{2i+1} \quad (i = 1,2,\ldots,\lfloor \frac{n}{2}\rfloor)\)</span></li></ol></li><li>后面的讨论都以最小化堆为例</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png" alt="binaryHeap" /><figcaption aria-hidden="true">binaryHeap</figcaption></figure><h4 id="二叉堆的特性">二叉堆的特性</h4><ul><li><strong>结构性</strong><ul><li>符合完全二叉树的结构</li></ul></li><li><strong>有序性</strong><ul><li>父节点小于子节点（最小化堆）</li><li>父节点大于子节点（最大化堆）</li></ul></li></ul><h3 id="基于二叉堆的优先级队列">基于二叉堆的优先级队列</h3><ul><li>如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列</li><li>最小化堆中，最小元素为根元素，存放在数组下标为 <code>1</code> 的位置<ul><li>获取队头元素的操作为返回下标为 <code>1</code> 的元素值</li><li>出队操作为删除下标为 <code>1</code> 的元素，重新调整堆</li><li>入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆</li></ul></li></ul><h3 id="优先级队列类的定义">优先级队列类的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span>:<span class="hljs-keyword">public</span> quque&lt;T&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> currentSize;<br>    T *array;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">voif <span class="hljs-title">buildHeap</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 建堆，被 priorityQueue() 调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">int</span> hole)</span></span>; <span class="hljs-comment">// 向下过滤</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">100</span>) <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>      array = <span class="hljs-keyword">new</span> T[capacity];<br>      maxSize = capacity;<br>      currentSize = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> T data[] , <span class="hljs-type">int</span> size); <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">priorityQueue</span>(); <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 是否为空</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentSize == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>; <span class="hljs-comment">//入队</span><br>    <span class="hljs-function">T <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 获取队头元素</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> array[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="enqueue-2"><code>enQueue</code></h4><ul><li>在堆中插入一个新元素</li><li>在最大序号中的元素之后插入新的元素或者节点</li><li>如果没有违反堆的<strong>有序性</strong>，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> priorityQueue&lt;T&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (currentSize == maxSize - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 向上过滤</span><br>  <span class="hljs-type">int</span> hole = ++currentSize;<br>  <span class="hljs-keyword">for</span> (;hole &gt; <span class="hljs-number">1</span> &amp;&amp; x &lt; array[hole/<span class="hljs-number">2</span>] ; hole /= <span class="hljs-number">2</span>)<br>  &#123;<br>    array[hole] = array[hole/<span class="hljs-number">2</span>];<br>  &#125;<br>  array[hole] = x;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最坏情况时间复杂度为 <span class="math inline">\(O(\log n)\)</span></li><li>平均情况来说，过滤会提前结束。资料表明平均为 <span class="math inline">\(2.6\)</span> 次比较，即平均上移 <span class="math inline">\(1.6\)</span> 层</li></ul><h4 id="dequeue-2"><code>deQueue</code></h4><ul><li>删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树</li><li>空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T priorityQueue&lt;T&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  T minItem;<br>  minItem = array[<span class="hljs-number">1</span>];<br>  array[<span class="hljs-number">1</span>] = array[currentSize--];<br>  <span class="hljs-built_in">percolateDown</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> minItem;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="percolatedown"><code>percolateDown</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> priorityQueue&lt;T&gt;::<span class="hljs-built_in">precolateDown</span>(<span class="hljs-type">int</span> hole)<br>&#123;<br>  <span class="hljs-type">int</span> child;<br>  T tmp = array[hole];<br><br>  <span class="hljs-keyword">for</span> (;hole * <span class="hljs-number">2</span> &lt;= currentSize; hole = child)<br>  &#123;<br>    child = hole * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (child != currentSIze &amp;&amp; array[child + <span class="hljs-number">1</span>] &lt; array[child])<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[child] &lt; tmp)<br>    &#123;<br>      array[hole] = array[child];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  array[hole] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="buildheap"><code>buildHeap</code></h4><h5 id="连续插入">连续插入</h5><ul><li>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span></li></ul><h5 id="自上而下调整二叉树">自上而下调整二叉树</h5><ul><li>对左子树和右子树递归调用 <code>buildHeaap</code>，再对根节点向下过滤</li><li>时间复杂度为 <span class="math inline">\(O(n)\)</span></li></ul><h5 id="非递归实现-1">非递归实现</h5><p>从编号最大的非叶节点 <span class="math inline">\(\lfloor \frac{n}{2} \rfloor\)</span> 开始逆层次遍历，每个节点调用 <code>percolateDown</code>，直到根节点</p><h2 id="集合与静态查找表">集合与静态查找表</h2><h3 id="集合的基本概念">集合的基本概念</h3><ol type="1"><li>数据元素除了属于同一集合之外，没有任何逻辑关系</li><li>每个数据元素有一个区别于其他元素的唯一标识，称为<strong>键值</strong>或者<strong>关键字值</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;calss KEY , <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SET</span><br>&#123;<br>  KEY key; <span class="hljs-comment">// 关键字值</span><br>  OTHER other; <span class="hljs-comment">// 其他信息</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运算</p><ul><li><strong>查找</strong> 某一元素是否存在</li><li>将集合中的元素按照它的唯一标识排序</li></ul><p>这些都是对 <code>key</code> 的操作</p><h3 id="集合的存储">集合的存储</h3><ul><li>任何容器都能存储集合</li><li>常用的表达形式是借鉴于<strong>线性表</strong>和<strong>树</strong></li><li>唯一一个仅适合于存储和处理集合的数据结构是<strong>散列表</strong></li></ul><h3 id="查找">查找</h3><h4 id="查找的基本概念">查找的基本概念</h4><ul><li>用于查找的集合称之为<strong>查找表</strong></li><li>查找表的分类<ul><li>静态查找表</li><li>动态查找表</li><li>内部查找</li><li>外部查找</li></ul></li></ul><h4 id="静态查找表">静态查找表</h4><ul><li>数据元素的个数和值不允许变化的查找表称为静态查找表</li><li>不允许插入和删除操作</li><li>实例：字典</li><li>可以用顺序表 <code>seqList</code> 存储，或直接存储在 C++的原始数组中</li></ul><h4 id="无序表的查找">无序表的查找</h4><ul><li><p>只能做顺序查找</p></li><li><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p></li><li><p>可以使用哨兵减少 <span class="math inline">\(n\)</span> 次查找</p></li><li><p>优化后的顺序查找</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  data[<span class="hljs-number">0</span>].key = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; x != data[i].key; --i)<br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h4 id="有序表的查找">有序表的查找</h4><h5 id="顺序查找">顺序查找</h5><ul><li><p>与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头</p></li><li><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p></li><li><p>有序表的顺序查找</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(SET&lt;KEY , OTHER&gt; data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  data[<span class="hljs-number">0</span>].key = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; x &lt; data[i].key; --i);<br>  <span class="hljs-keyword">if</span> (x == data[i].key)<br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二分查找">二分查找</h5><ol type="1"><li>每次检查中间的元素（向下取整）</li><li>若中间的元素等于要查找的元素，则查找成功</li><li>若中间的元素大于要查找的元素，则在左半部分继续查找</li><li>若中间的元素小于要查找的元素，则在右半部分继续查找</li></ol><ul><li>时间复杂度为 <span class="math inline">\(O(\log n)\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(SET&lt;KEY , OTHER&gt;data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>,  high = size, mid;<br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;                 <span class="hljs-comment">//查找区间存在</span><br>      mid = (low + high) / <span class="hljs-number">2</span>;         <span class="hljs-comment">//计算中间位置</span><br>      <span class="hljs-keyword">if</span> ( x == data[mid].key )<br>      &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (x &lt; data[mid].key)<br>      &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插值查找">插值查找</h5><ul><li>适用于数据分布较为均匀的情况</li><li>计算中间位置的公式为</li></ul><p><span class="math display">\[\text{next} = \text{low} + \frac{(x - a[\text{low}])}{(a[\text{high}] - a[\text{low}])} \times (\text{high} - \text{low}+1)\]</span></p><ul><li>缺点：计算量大</li></ul><h5 id="分块查找">分块查找</h5><ul><li>将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的</li><li>查找分为两个阶段<ol type="1"><li>查找索引</li><li>查找块 设表长为 <span class="math inline">\(n\)</span>，块长为 <span class="math inline">\(m\)</span> 则平均所需的时间为 <span class="math inline">\(\frac{m+1}{2}+\frac{\frac{n}{m}+1}{2}\)</span> 当 <span class="math inline">\(m=\sqrt{n}\)</span> 时，平均所需的时间<strong>最短</strong>，为 <span class="math inline">\(O(\sqrt{n})\)</span></li></ol></li></ul><h2 id="动态查找表">动态查找表</h2><h3 id="二叉查找树">二叉查找树</h3><h4 id="抽象类-1">抽象类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的定义">二叉查找树的定义</h4><ul><li>对于任意一个节点 <code>p</code><ul><li><code>p</code> 的左子树中所有节点的值都小于 <code>p</code> 的值</li><li><code>p</code> 的右子树中所有节点的值都大于 <code>p</code> 的值</li><li><code>p</code> 的左子树和右子树都是二叉查找树</li></ul></li><li>二叉查找树的<strong>中序遍历</strong>是排好序的，又称为<strong>排序树</strong></li><li>最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的</li></ul><h4 id="二叉查找树的存储实现">二叉查找树的存储实现</h4><ul><li>使用二叉链表存储，需要一个指向根节点的数据成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryNode</span><br>    &#123;<br>      SET&lt;KEY, OTHER&gt; data;<br>      BinaryNode*left;<br>      BinaryNode*right;<br>      <span class="hljs-built_in">BinaryNode</span>( <span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; thedata,<br>      BinaryNode *lt = <span class="hljs-literal">nullptr</span> , BinaryNode *rt = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(thedata) , <span class="hljs-built_in">left</span>(lt) , <span class="hljs-built_in">right</span>(rt)&#123;&#125;<br>    &#125;;<br>    BinaryNode*root;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BinarySearchTree</span>();<br>    ~<span class="hljs-built_in">BinarySearchTree</span>();<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *&amp;t)</span></span>;<br>    <span class="hljs-function">SET&lt;KEY , OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *t )</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">(BinaryNode *t)</span></span>;<span class="hljs-comment">//析构用，同二叉树的clear</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的操作">二叉查找树的操作</h4><h5 id="查找-1">查找</h5><ol type="1"><li>检查根节点的关键字值</li><li>如果等于要查找的值，则查找成功，返回根节点地址</li><li>如果小于要查找的值，则在右子树中查找</li><li>如果大于要查找的值，则在左子树中查找</li></ol><ul><li>公有函数 <code>find(const KEY &amp;x)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x ) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>( x, root );<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有辅助函数 <code>find(const KEY &amp;x, BinaryNode *t)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x, BinaryNode *t ) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span> || t-&gt;data.key == x)<br>  &#123;<br>    <span class="hljs-keyword">return</span> (SET&lt;KEY , OTHER&gt; *)t;<span class="hljs-comment">//强制类型转换</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(x &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x , t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x , t-&gt;right );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入">插入</h5><ul><li><p>若二叉树为空树，则插入的节点为根节点</p></li><li><p>若二叉树非空</p><ul><li>判断是左儿子还是右儿子，作为叶节点插入</li></ul></li><li><p>公有的 <code>insert(const SET&lt;KEY, OTHER&gt; &amp;x)</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-built_in">insert</span>(x, root);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有的 <code>insert(const SET&lt;KEY, OTHER&gt; &amp;x, BinaryNode *&amp;t)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)<br>  t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryNode</span>(x , <span class="hljs-literal">nullptr</span> , <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key&lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x, t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; “is exist” &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除">删除</h5><ul><li><p><span class="math inline">\(P_L\)</span> 和 <span class="math inline">\(P_R\)</span> 分别是 <span class="math inline">\(P\)</span> 的左子树和右子树</p><ol type="1"><li>如果 <span class="math inline">\(P\)</span> 是叶节点，则直接删除</li><li>如果 <span class="math inline">\(P\)</span> 只有一个子树，则将 <span class="math inline">\(P\)</span> 的父节点指向 <span class="math inline">\(P\)</span> 的子树</li><li>如果 <span class="math inline">\(P\)</span> 有两个子树，则<ol type="1"><li>找到 <span class="math inline">\(P\)</span> 的右子树中最左的节点或者左子树的最右节点 <span class="math inline">\(Q\)</span></li><li>将 <span class="math inline">\(Q\)</span> 的值赋给 <span class="math inline">\(P\)</span></li><li>删除 <span class="math inline">\(Q\)</span> 节点</li></ol></li></ol></li><li><p>公有的 <code>remove(const KEY &amp;x)</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-built_in">remove</span>(x , root);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有的 <code>remove(const KEY &amp;x, BinaryNode *&amp;t)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; <span class="hljs-string">&quot;is not exist&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">remove</span>(x , t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">remove</span>(x , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;right != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    BinaryNode *p = t-&gt;right;<br>    <span class="hljs-keyword">while</span>(p-&gt;left != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      p = p-&gt;left;<br>    &#125;<br>    t-&gt;data = p-&gt;data;<br>    <span class="hljs-built_in">remove</span>(p-&gt;data.key , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    BinaryNode *oldNode = t;<br>    t = (t-&gt;left != <span class="hljs-literal">nullptr</span>) ? t-&gt;left : t-&gt;right;<br>    <span class="hljs-keyword">delete</span> oldNode;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二叉查找树的性能">二叉查找树的性能</h4><ul><li>二叉查找树的操作的时间复杂度为树的高度</li><li>如果二叉查找树是平衡的，则访问的代价是 <span class="math inline">\(O(\log n)\)</span></li><li>最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 <span class="math inline">\(O(n)\)</span></li></ul><p><strong>平均性能</strong></p><p>具有 <span class="math inline">\(n\)</span> 个节点的二叉查找树可能有 <span class="math inline">\(n\)</span> 种不同的形态 <span class="math inline">\((0,1,n-1) , (1 , 1 n-2) , (2 , 1 , n-3) , \ldots , (n-1 , 1 , 0)\)</span> 若设这些形态出现的概率是相同的，设 <span class="math inline">\(P(n)\)</span> 为查找 <span class="math inline">\(n\)</span> 个节点的二叉查找树的平均查找时间，则有如下递归关系式：</p><p><span class="math display">\[P(n) = \frac{\sum_{i = 0}^{n-1} \left[ 1 + (P(i)+1) \cdot i + (P( n - i - 1)+1)\cdot (n-i-1)\right]}{n} \leq 2(1 + \frac{1}{n})\ln{n} \approx 1.33 \log{n}\]</span></p><h3 id="avl-树">AVL 树</h3><h4 id="avl-树的定义">AVL 树的定义</h4><ul><li>也叫平衡树<ul><li>对于任意一个节点的两棵子树的高度至多相差 1</li></ul></li><li>平衡因子<ul><li>节点的左子树的高度减去右子树的高度</li><li>平衡因子只能是 <span class="math inline">\(-1\)</span>，<span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span></li></ul></li><li>优点<ul><li>查找，插入和删除操作的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span></li></ul></li></ul><h5 id="查找性能">查找性能</h5><ul><li><p>与二叉树的高度成正比</p></li><li><p>定理：</p><ul><li>具有 <span class="math inline">\(n\)</span> 个节点的平衡树，高度 <span class="math inline">\(h\)</span> 满足 <span class="math inline">\(\log_2(n+1) \leq h \leq 1.44\log_2(n+2)-0.328\)</span></li><li>因此，平衡二叉树的操作都是 <span class="math inline">\(O(\log n)\)</span></li></ul></li></ul><h5 id="斐波那契树">斐波那契树</h5><ul><li><p>斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为 1</p></li><li><p>定义</p><ol type="1"><li>空树是高度为 0 的斐波那契树</li><li>单个节点是高度为 1 的斐波那契树</li><li>若 <span class="math inline">\(T_{h-1}\)</span> 和 <span class="math inline">\(T_{h-2}\)</span> 分别为高度为 <span class="math inline">\(h-1\)</span> 和 <span class="math inline">\(h-2\)</span> 的斐波那契树，则 <span class="math inline">\(T_h ={T_{h-1},x,T_{h-2}}\)</span> 是高度为 <span class="math inline">\(h\)</span> 的斐波那契树</li><li>没有其他的树是斐波那契树</li></ol></li></ul><h6 id="斐波那契树的特点">斐波那契树的特点</h6><p>对于高度为 <span class="math inline">\(h\)</span> 的斐波那契树，节点数 <span class="math inline">\(n\)</span> 满足</p><ul><li><span class="math inline">\(n_0 = 0\)</span></li><li><span class="math inline">\(n_1 = 1\)</span></li><li><span class="math inline">\(n_h = n_{h-1} + n_{h-2} + 1\)</span></li></ul><h4 id="avl-树的存储实现">AVL 树的存储实现</h4><ul><li>使用二叉链表</li><li>每个节点必须保存平衡信息<ul><li>每棵树的高度</li><li>平衡度即左右子树的高度差</li></ul></li></ul><h5 id="avl-树类的实现">AVL 树类的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;clas KEY,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AvlTree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AvlNode</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data ; <span class="hljs-comment">// 关键字</span><br>      AvlNode *left , *right; <span class="hljs-comment">// 左右子树指针</span><br>      <span class="hljs-type">int</span> height;            <span class="hljs-comment">// 节点高度</span><br><br>      <span class="hljs-built_in">AvlNode</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;element , AvlNode *lt ,AvlNode   *rt , <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>):<span class="hljs-built_in">data</span>(elemeent) , <span class="hljs-built_in">left</span>(lt) , <span class="hljs-built_in">right</span>(rt) , <span class="hljs-built_in">height</span>  (h) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    &#125;;<br><br>    AvlNode *root; <span class="hljs-comment">// 根节点</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AvlTree</span>() <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>      root = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AvlTree</span>() <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>      <span class="hljs-built_in">makeEmpty</span>(root);<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp; x)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">( <span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t )</span> </span>; <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">( <span class="hljs-type">const</span> KEY &amp; x, AvlNode * &amp; t )</span> </span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">( AvlNode *t )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(AvlNode *t)</span> <span class="hljs-type">const</span>  <span class="hljs-comment">// 返回节点的高度</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> t == <span class="hljs-literal">nullptr</span> ? <span class="hljs-number">0</span> : t -&gt; height;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LL</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 左旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RR</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 右旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LR</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 左右旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RL</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 右左旋</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>     <span class="hljs-comment">// 返回两个数中较大的一个</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">adjust</span><span class="hljs-params">(AvlNode *&amp;t, <span class="hljs-type">int</span> subTree)</span></span>; <span class="hljs-comment">//用于删除</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="avl-树的查找">AVL 树的查找</h4><ul><li>与二叉查找树相同</li><li>二叉查找树类采用递归实现</li><li>AVL 树类展示非递归实现</li></ul><h5 id="查找的非递归实现">查找的非递归实现</h5><ol type="1"><li>设当前节点为根节点</li><li>若当前节点非空<ol type="1"><li>若当前节点的值等于 <code>x</code>，则返回当前节点</li><li>若当前节点的值大于 <code>x</code>，则将当前节点指向左子树</li><li>若当前节点的值小于 <code>x</code>，则将当前节点指向右子树</li></ol></li><li>若当前节点为空，则返回空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *AvlTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp; x) <span class="hljs-type">const</span><br>&#123;<br>  AvlNode *t = root; <br>  <span class="hljs-keyword">while</span> (t!=<span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;data.key != x)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; t-&gt;data.key)<br>    &#123;<br>      t = t-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      t = t-&gt;right;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> t-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="avl-树的插入">AVL 树的插入</h4><ul><li>与二叉查找树相同<ul><li>可能改变了根到插入节点的路径上某些节点的平衡度</li><li>需要向上修改树的结构</li></ul></li></ul><h5 id="可能引起节点不平衡的情况">可能引起节点不平衡的情况</h5><ul><li>节点的左孩子的左子树上插入（LL）</li><li>节点的左孩子的右子树上插入（LR）</li><li>节点的右孩子的左子树上插入（RL）</li><li>节点的右孩子的右子树上插入（RR）</li></ul><h5 id="重构的方法">重构的方法</h5><ul><li>指针调整<ul><li>按照投影序保持结点相邻关系不变</li><li>辈分可以改变</li></ul></li></ul><h6 id="ll-问题">LL 问题</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png" alt="LL" /><figcaption aria-hidden="true">LL</figcaption></figure><ul><li><strong>左旋</strong><ol type="1"><li>将失衡点的左儿子作为新的根节点</li><li>左儿子的右儿子作为原根节点的左儿子</li></ol></li><li>若为 RR 问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为<strong>右旋</strong></li><li>左旋和右旋统称为<strong>单旋转</strong>，保留了树的有序性和原先的高度</li></ul><h6 id="lr-问题">LR 问题</h6><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png" alt="LR" /><figcaption aria-hidden="true">LR</figcaption></figure><ul><li><strong>双旋转</strong><ol type="1"><li>将失衡点的左儿子右旋</li><li>将失衡点左旋</li></ol></li><li>若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋</li><li>先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使<strong>原先的孙子变成根</strong></li></ul><h5 id="私有的insert-函数">私有的<code>insert</code> 函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AvlNode</span>(x , <span class="hljs-literal">nullptr</span> , <span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;left);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) - <span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (x.key &lt; t-&gt;left-&gt;data.key)<br>      &#123;<br>        <span class="hljs-built_in">LL</span>(t);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">LR</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;right);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) - <span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (x.key &gt; t-&gt;right-&gt;data.key)<br>      &#123;<br>        <span class="hljs-built_in">RR</span>(t);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">RL</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新高度</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="ll"><code>LL</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">LL</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;left;<br>  t-&gt;left = t1-&gt;right;<br>  t1-&gt;right = t;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>;<br>  t1-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t1-&gt;left) , <span class="hljs-built_in">height</span>(t1-&gt;right)) + <span class="hljs-number">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="rr"><code>RR</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">RR</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;right;<br>  t-&gt;right = t1-&gt;left;<br>  t1-&gt;left = t;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>;<br>  t1-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t1-&gt;left) , <span class="hljs-built_in">height</span>(t1-&gt;right)) + <span class="hljs-number">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="lr"><code>LR</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">LR</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class="hljs-built_in">RR</span>(t-&gt;left);<br>  <span class="hljs-built_in">LL</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="rl"><code>RL</code></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">RL</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class="hljs-built_in">LL</span>(t-&gt;right);<br>  <span class="hljs-built_in">RR</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>所有旋转的算法时间复杂度都是 <span class="math inline">\(O(1)\)</span>，且只运行一次，所以 <code>insert</code> 的时间复杂度为 <span class="math inline">\(O(\log n)\)</span></p><h4 id="avl-树的删除">AVL 树的删除</h4><ol type="1"><li>在 AVL 树上删除节点 <code>x</code>，删除操作和二叉查找树相同</li><li>调整平衡，与插入操作相同</li></ol><h4 id="调整">调整</h4><ul><li>与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度</li><li>删除时无法保证子树在平衡调整之后的高度不变</li><li>递归的删除函数有一个 bool 型的返回值，当返回值为 <code>true</code> 时，调整停止</li></ul><h4 id="五种情况">五种情况</h4><h5 id="情况-a">情况 a</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png" alt="Sitiationa" /><figcaption aria-hidden="true">Sitiationa</figcaption></figure><p>此时没有失衡，高度也没有改变，返回<code>true</code></p><h5 id="情况-b">情况 b</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png" alt="Situationb" /><figcaption aria-hidden="true">Situationb</figcaption></figure><p>此时没有失衡，但是高度变矮，返回<code>false</code></p><h5 id="情况-c">情况 c</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png" alt="Situationc" /><figcaption aria-hidden="true">Situationc</figcaption></figure><p>经过 RR 旋转后高度变矮，返回<code>false</code></p><h5 id="情况-d">情况 d</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png" alt="Situationd" /><figcaption aria-hidden="true">Situationd</figcaption></figure><p>经过 RL 旋转后高度变矮，返回<code>false</code></p><h5 id="情况-e">情况 e</h5><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png" alt="Situatione" /><figcaption aria-hidden="true">Situatione</figcaption></figure><p>经过 RR 或 RL 旋转后高度不变，返回<code>true</code></p><h4 id="删除总结">删除总结</h4><ul><li>节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回 <code>false</code></li><li>在每次调用后，检查返回值，如果是 <code>true</code>，则返回 <code>true</code>，否则分 5 种情况进行处理</li></ul><h4 id="私有的-remove-函数">私有的 <code>remove</code> 函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x , AvlNOde *&amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t = <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 被删除节点不存在</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x == t-&gt; data.key)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;left == <span class="hljs-literal">nullptr</span> || t-&gt; right == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      AvlNode *oldNode = t;<br>      t = (t-&gt;left == <span class="hljs-literal">nullptr</span>) ? t-&gt;right : t-&gt;left; <span class="hljs-comment">// 删除节点的孩子节点</span><br>      <span class="hljs-keyword">delete</span> oldNode;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 删除了一个节点，返回 `false`</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      AvlNode *tmp = t-&gt; right;<br>      <span class="hljs-keyword">while</span> (tmp-&gt;left != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 找到右子树的最小节点</span><br>      &#123;<br>        tmp = tmp-&gt;left;<br>      &#125;<br>      t-&gt;data = tmp.data;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(tmp-&gt;data,key , t-&gt;right))<br>      &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &lt; t-&gt;data,key)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x,t-&gt;left))<br>    &#123;<br>      teturn <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x , t-&gt;right))<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="adjust"><code>adjust</code></h4><ul><li>进入调整函数的条件是某棵子树变矮了</li><li>调整函数需要检查节点是否失衡，若失衡则进行相应的调整</li><li>函数的返回值是子树是否变矮<ul><li><code>true</code>：子树没有变矮</li><li><code>false</code>：子树变矮</li></ul></li><li>需要传入两个参数<ul><li><code>AVlNode *&amp;t</code>：传入的节点</li><li><code>int subTree</code>：参数 <code>t</code> 变矮的子树<ul><li><code>0</code>：左子树</li><li><code>1</code>：右子树</li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span> , classs OTHER&gt;<br><span class="hljs-type">bool</span> AvlTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">adjust</span>(AvlNode *&amp;t , <span class="hljs-type">int</span> SubTree)<br>&#123;<br>  <span class="hljs-keyword">if</span> (subTree) <span class="hljs-comment">// 在右子树上删除</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) - <span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-number">1</span>) <span class="hljs-comment">// Situation a</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left)) <span class="hljs-comment">// Situation b</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left-&gt;right) &gt; <span class="hljs-built_in">height</span>(t-&gt;left-&gt;left)) <span class="hljs-comment">// Situation d</span><br>    &#123;<br>      <span class="hljs-built_in">LR</span>(t);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">LL</span>(t); <span class="hljs-comment">// Situation c and e</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-built_in">height</span>(t-&gt;right))s<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">// 在左子树上删除</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) - <span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-number">1</span>) <span class="hljs-comment">// Situation a</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left)) <span class="hljs-comment">// Situation b</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-function">s</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))</span> <span class="hljs-comment">// Situation d</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-built_in">RL</span>(t);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">RR</span>(t); <span class="hljs-comment">// Situation c and e</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left))<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="散列表">散列表</h3><ul><li>也叫哈希表</li><li>通过所求节点的关键字词 <code>KEY</code> 找到这个节点</li><li>时间复杂度为 <span class="math inline">\(O(1)\)</span></li></ul><h4 id="基本概念">基本概念</h4><ol type="1"><li>初始化 将数组转化为一个特殊的、表示单元为空的值</li><li><code>insert(i)</code> 将 <code>i</code> 存放到 <code>a[i.key]</code> 中</li><li><code>find(i)</code> 取出 <code>a[i.key]</code> 中的值</li><li><code>remove(i)</code> 将 <code>a[i.key]</code> 中的值置为空</li></ol><h4 id="散列函数">散列函数</h4><p>将一个项映射成一个较小的下标的函数称为散列函数（hush function）</p><ul><li><span class="math inline">\(D = H(key)\)</span> D 为存储地址，key 为关键值，H 为散列函数</li><li>散列函数的要求<ul><li>计算速度快</li><li>散列地址均匀分布</li></ul></li></ul><h4 id="常用的散列函数">常用的散列函数</h4><h5 id="直接地址法">直接地址法</h5><p><span class="math inline">\(H(key) = key\)</span> 或 <span class="math inline">\(H(key) = a \times key + b\)</span></p><h5 id="除留余数法"><strong>除留余数法</strong></h5><p><span class="math inline">\(H(key) = key \mod p\)</span> 或 <span class="math inline">\(H(key) = key \mod p + c\)</span> 这里的 <span class="math inline">\(p\)</span> 是一个小于等于 <span class="math inline">\(m\)</span> 的素数</p><h5 id="数字分析法">数字分析法</h5><p>对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分</p><h5 id="平方取中法">平方取中法</h5><p>如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字<strong>平方后</strong>，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。</p><h5 id="折叠法">折叠法</h5><ul><li>如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法</li><li>选取一个长度后，将关键字按此长度分组相加</li></ul><h4 id="冲突问题">冲突问题</h4><p>当两个以上的关键字映射到一个存储单元时，称为<strong>冲突或碰撞</strong></p><ul><li>解决冲突的方法<ul><li>闭散列表：利用本散列表中的空余单元<ul><li>线性探测法</li><li>二次探测法</li><li>再次散列法</li></ul></li><li>开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）</li></ul></li></ul><h5 id="闭散列表类的实现">闭散列表类的实现</h5><ul><li>支持三种操作<ul><li><code>insert</code>：插入一个元素</li><li><code>remove</code>：删除一个元素</li><li><code>find</code>：查找一个元素</li></ul></li><li>由一个数组实现，数组的大小由用户定义散列表时指定</li><li>由于删除时的迟删除，每个数组元素还要保存一个状态值<ul><li><code>0</code>：空</li><li><code>1</code>：有效</li><li><code>2</code>：删除</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">closeHashTable</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY, OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>  <span class="hljs-comment">//散列表的结点类</span><br>    &#123;<br>      SET &lt;KEY, OTHER&gt; data;<br>      <span class="hljs-type">int</span> state; <span class="hljs-comment">//0 -- empty 1 -- active 2 -- deleted</span><br>      <span class="hljs-built_in">node</span>()<br>      &#123;<br>        state = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;;<br>    node *array;<br><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-built_in">int</span> (*key)(<span class="hljs-type">const</span> KEY &amp;x);<span class="hljs-comment">//哈希函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultKey</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> x;<br>    &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">closeHashTable</span>(<span class="hljs-type">int</span> length = <span class="hljs-number">101</span>, <span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x) = defaultKey)<br>    ~<span class="hljs-built_in">closeHashTable</span>()<br>    &#123;<br>      <span class="hljs-keyword">delete</span> [] array;<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">closeHashTable</span>(<span class="hljs-type">int</span> length, <span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x))<br>&#123;<br>  size = length;<br>  array = <span class="hljs-keyword">new</span> node[size];<br>  key = f; <span class="hljs-comment">//哈希函数为f</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos= pos = <span class="hljs-built_in">key</span>(x.key) % size; <span class="hljs-comment">//%size保护作用，避免越界</span><br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state != <span class="hljs-number">1</span>)<br>    &#123; <span class="hljs-comment">// 0或2，找到空单元</span><br>      array[pos].data = x;<br>      array[pos].state = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size;<br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>remove</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos= pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//没找到</span><br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">1</span> &amp;&amp; array[pos].data.key== x)<span class="hljs-comment">// 找到，删除</span><br>    &#123;<br>      array[pos].state = <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size; <span class="hljs-comment">//没找到，需要往后找</span><br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>find</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos = pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有找到</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">1</span> &amp;&amp; array[pos].data.key == x) <span class="hljs-comment">// 找到</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> (SET&lt;KEY,OTHER&gt; *)&amp;array[pos];<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size;<br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="线性探测法">线性探测法</h6><p>当散列发生冲突时，依次<strong>探测下一个单元</strong>，直到发现一个空单元</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png" alt="线性探测法" /><figcaption aria-hidden="true">线性探测法</figcaption></figure><h6 id="二次探测法">二次探测法</h6><p>以此向后探测 <span class="math inline">\(1^2\)</span>，<span class="math inline">\(2^2\)</span>，<span class="math inline">\(3^2\)</span>，<span class="math inline">\(4^2\)</span>，<span class="math inline">\(5^2\)</span>，<span class="math inline">\(\ldots\)</span></p><p><strong>定理</strong></p><ul><li>如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子 <span class="math inline">\(&lt;0.5\)</span>），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次</li></ul><h6 id="再次散列法">再次散列法</h6><ul><li>采用一个新的散列函数 <span class="math inline">\(H_2(key)\)</span></li><li><span class="math inline">\(H_1(x)\)</span>，<span class="math inline">\(H_1(x)+H_2(x)\)</span> ，<span class="math inline">\(H_1(x)+2H_2(x)\)</span>，<span class="math inline">\(H_1(x)+3H_2(x)\)</span>，<span class="math inline">\(\ldots\)</span></li></ul><h5 id="开散列表">开散列表</h5><p>链地址法</p><ul><li>将具有同一散列地址的结点保存于 <code>M</code> 存区的各自的链表之中</li></ul><h6 id="开散列表的实现">开散列表的实现</h6><ul><li>将所有散列到同一地址的元素链接成一个单链表</li><li>采用不带头结点的单链表</li><li>散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span> , <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">openHashTable</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEU , OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data;<br>      node *next;<br>      <span class="hljs-built_in">node</span> (<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;d , nde *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = d;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>()<br>      &#123;<br>        next = <span class="hljs-literal">nullptr</span>;<br>      &#125;<br>    &#125;;<br>    node **array; <span class="hljs-comment">// 散列表，指针数组</span><br>     <span class="hljs-type">int</span> size;<br>     <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultKry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function">     </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>     &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">openHashTable</span>(<span class="hljs-type">int</span> length = <span class="hljs-number">101</span>,<span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x) = defaultKey);<br>    ~<span class="hljs-built_in">openashTable</span>();<br>    <span class="hljs-function">SET&lt;KEY,OTHER&gt; *<span class="hljs-title">finf</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY,OTHER&gt; &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>openHashTable&lt;KEY, OTHER&gt;::~<span class="hljs-built_in">openHashTable</span>()<br>&#123;<br>  node *p, *q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; size; ++i)<br>  &#123;<br>    p = array[i];<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      q= p-&gt;next; <span class="hljs-keyword">delete</span> p; p = q;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">delete</span> [] array；<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> pos;<br>  node *p;<br>  <span class="hljs-comment">//插入单链表的头部</span><br>  pos = <span class="hljs-built_in">key</span>(x.key) % size;<br>  array[pos] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x, array[pos]);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>remove</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> pos ;<br>  node *p, *q;<br>  pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">if</span> (array[pos] == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  p = array[pos];<br>  <span class="hljs-keyword">if</span> (array[pos]-&gt;data.key== x)<br>  &#123; <span class="hljs-comment">// 删除第一个结点</span><br>    array[pos] = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; !(p-&gt;next-&gt;data.key== x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p-&gt;next != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-keyword">delete</span> q;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>find</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> pos ;<br>  node *p;<br>  pos = <span class="hljs-built_in">key</span>(x) % size;<br>  p = array[pos];<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; !(p-&gt;data.key == x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">return</span> (SET&lt;KEY, OTHER&gt; *)p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序">排序</h2><h3 id="基本概念-1">基本概念</h3><ul><li>按照关键字的非递减或非递增序排成一个序列</li><li><strong>稳定与非稳定排序</strong>:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序</li><li>内排序与外排序<ul><li><strong>内排序：</strong>排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置</li><li><strong>外排序：</strong>在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置</li></ul></li></ul><h3 id="插入排序">插入排序</h3><p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1 个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的</p><h4 id="直接插入排序">直接插入排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simpleInsertSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt;a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> k;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;size; ++j)<br>  &#123;<br>  tmp = a[j];<br>  <span class="hljs-keyword">for</span> ( k = j<span class="hljs-number">-1</span>; tmp.key &lt; a[k].key &amp;&amp; k &gt;= <span class="hljs-number">0</span>; --k)<br>  &#123;<br>    a[k<span class="hljs-number">+1</span>] = a[k];<br>  &#125;<br>  a[k<span class="hljs-number">+1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li><li>稳定性：稳定</li><li>时间复杂度<ul><li>最好：<span class="math inline">\(O(n)\)</span></li><li>最坏：<span class="math inline">\(O(n^2)\)</span></li><li>平均：<span class="math inline">\(O(n^2)\)</span></li></ul></li><li>适用情况：短序列或者几乎已经排好序的</li></ul><h4 id="折半插入排序">折半插入排序</h4><p>先用二分排序找到插入位置</p><ul><li>时间复杂度<ul><li>最好：<span class="math inline">\(O(n\log n)\)</span></li><li>最坏：<span class="math inline">\(O(n^2)\)</span></li><li>平均：<span class="math inline">\(O(n^2)\)</span></li></ul></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li><li>稳定性：稳定</li></ul><p>改进很小，对于接近排好序的序列甚至<strong>更差</strong></p><h4 id="希尔排序">希尔排序</h4><ul><li>相隔一定的距离的记录组成一个子序列</li><li>逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态</li><li>最后再用直接插入排序对整个序列进行一次排序</li></ul><h5 id="步长序列的选择">步长序列的选择</h5><ul><li><p><span class="math inline">\(1,2,4,8,\ldots\)</span></p></li><li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li><li><p>Knuth 推荐：<span class="math inline">\(1,3,7,15,31,63,\ldots\)</span></p></li><li><p>时间复杂度：<span class="math inline">\(O(n^{1.5})\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li><li><p>不稳定</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> step, i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (step = size/<span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span>) <span class="hljs-comment">//step为希尔增量</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> (i = step; i &lt; size; ++i)<br>    &#123;<br>      tmp = a[i];<br>      <span class="hljs-keyword">for</span> (j = i -step; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j].key &gt; tmp.key; j -= step)<br>      &#123;<br>        a[j+step] = a[j];<br>      &#125;<br>      a[j+step] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序">选择排序</h3><ol type="1"><li>在 <span class="math inline">\(n\)</span> 个元素中选出最小的元素</li><li>从剩下的 <span class="math inline">\(n-1\)</span> 个元素中选出最小的元素</li><li>以此类推，直到最后一个元素</li></ol><h4 id="直接选择排序">直接选择排序</h4><ol type="1"><li>在所有元素中逐个比较找到最小元素，与第一个元素交换</li><li>在剩下的元素中逐个比较找到最小元素，与第二个元素交换</li><li>以此类推，直到最后一个元素</li></ol><ul><li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li><li>不稳定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simpleSelectSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i, j, min;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size <span class="hljs-number">-1</span>; ++i)<br>  &#123;<br>  min = i;<br>  <span class="hljs-keyword">for</span> (j = i<span class="hljs-number">+1</span>; j &lt; size; ++j)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (a[j].key &lt; a[min].key)<br>    &#123;<br>      min = j;<br>    &#125;<br>  &#125;<br>  tmp = a[i]; a[i] = a[min]; a[min] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序">堆排序</h4><ol type="1"><li>建立一个最大堆</li><li>执行 <span class="math inline">\(n\)</span> 次 <code>deQuqeue</code> 操作取出每个项</li></ol><ul><li><p>时间复杂度 <span class="math inline">\(O(n\log n)\)</span></p></li><li><p>堆排序</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  SET&lt;KEY, OTHER&gt; tmp; <span class="hljs-comment">// 创建初始的堆</span><br>  <span class="hljs-keyword">for</span>( i = size / <span class="hljs-number">2</span> <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>  &#123;<br>    <span class="hljs-built_in">percolateDown</span>( a, i, size );<br>  &#125;<br>  <span class="hljs-comment">//执行n-1次deQueue</span><br>  <span class="hljs-keyword">for</span> ( i = size <span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; --i)\<br>  &#123;<br>  tmp = a[<span class="hljs-number">0</span>]; a[<span class="hljs-number">0</span>] = a[i]; a[i] = tmp; <span class="hljs-comment">//delete a[0]</span><br>  <span class="hljs-built_in">percolateDown</span>( a, <span class="hljs-number">0</span>, i );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>precolateDown</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">( SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> hole, <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> child;<br>  SET&lt;KEY, OTHER&gt; tmp= a[ hole ];<br>  <span class="hljs-keyword">for</span>( ; hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; size; hole = child )<br>  &#123;<br>    child = hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>( child != size <span class="hljs-number">-1</span> &amp;&amp; a[ child + <span class="hljs-number">1</span> ].key &gt; a[ child ].key )<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( a[ child ].key &gt;tmp.key)<br>    &#123;<br>      a[ hole ] = a[ child ];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  a[ hole ] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交换排序">交换排序</h3><p>通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动</p><h4 id="冒泡排序">冒泡排序</h4><p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡</p><p>然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置</p><p>依次类推，经过第 <span class="math inline">\(n-1\)</span> 趟起泡，将倒数第 <span class="math inline">\(n-1\)</span> 个大的元素放入第 2 个单元</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//记录一趟起泡中有没有发生过交换</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; size&amp;&amp; flag; ++i)<br>  &#123; <span class="hljs-comment">//size-1次起泡</span><br>    flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; size-i; ++j) <span class="hljs-comment">//第i次起泡</span><br>    <span class="hljs-keyword">if</span> (a[j<span class="hljs-number">+1</span>].key &lt; a[j].key)<br>    &#123;<br>      tmp = a[j]; a[j] = a[j<span class="hljs-number">+1</span>]; a[j<span class="hljs-number">+1</span>] = tmp;<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序">快速排序</h4><ul><li>选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边</li><li>然后对基准元素左边和右边的子序列进行递归排序</li></ul><h5 id="选择中心点">选择中心点</h5><ul><li>第一个元素</li><li>随机</li><li>中值（采样得到）</li></ul><h5 id="划分第一个元素为中心点">划分（第一个元素为中心点）</h5><ol type="1"><li>序列的下标上界为 <code>high</code>，下届为 <code>low</code>，中心点选取第一个元素，关键值为 <code>K</code>，<code>low</code> 位置空出</li><li>从右向左开始检查：如果 <code>high</code> 的关键值大于 <code>K</code>，该位置中的值位置正确，<code>high</code> 减 <span class="math inline">\(1\)</span>，继续往前检查，直到遇到一个小于 <code>K</code> 的值</li><li>将小于 <code>k</code> 的这个值放入 <code>low</code> 的位置，此时 <code>high</code> 的位置又空出。然后从 <code>low</code> 位置开始从左向右检查，直到遇到一个大于 <code>K</code> 的值</li><li>将 <code>low</code> 位置的值放入 <code>high</code> 位置，重复第 2 步，直到 <code>low</code> 和 <code>high</code> 重叠，将 <code>K</code> 放入此位置</li></ol><p>划分函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">( SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>  SET&lt;KEY, OTHER&gt; k = a[low];<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[high].key &gt;= k.key)<br>    &#123;<br>      --high;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>      a[low] = a[high]; ++low;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[low].key &lt;= k.key)<br>    &#123;<br>      ++low;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>      a[high] = a[low]; --high;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (low != high);<br>  a[low] = k;<br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><ul><li>将待排序的序列分成两个子序列，分别进行排序</li><li>将两个有序的子序列合并成一个有序的序列</li><li>递归进行</li></ul><h3 id="基数排序">基数排序</h3><ul><li>称为口袋排序法</li><li>通过分配的方法进行排序</li><li>基数（r）：子关键字的值域的元素的个数<ul><li>十进制数：<span class="math inline">\(0,1,2,\ldots,9\)</span>，基数为 <span class="math inline">\(10\)</span></li><li>二进制数：<span class="math inline">\(0,1\)</span>，基数为 <span class="math inline">\(2\)</span></li><li>英文字符：<span class="math inline">\(A,B,C,\ldots,Z\)</span>，基数为 <span class="math inline">\(26\)</span></li></ul></li></ul><h4 id="高位优先法msd">高位优先法（MSD）</h4><ul><li>先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列</li></ul><h4 id="低位优先法lsd">低位优先法（LSD）</h4><ul><li>先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起</li><li>然后将次低位进入口袋进行排序，依次类推</li><li>最后将所有记录按照口袋的顺序收在一起</li></ul><h2 id="外存储器中的查找和排序">外存储器中的查找和排序</h2><h3 id="主存储器与外存储器">主存储器与外存储器</h3><ul><li>主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据</li><li>外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息<ul><li>价格低廉、存储量大、永久保存、<strong>访问速度慢</strong></li></ul></li></ul><h3 id="外部查找">外部查找</h3><h4 id="b-树">B 树</h4><p>B 树是一棵平衡的 M 叉查找树，需要 <span class="math inline">\(M-1\)</span> 个关键字来判断到哪个分支查找</p><h5 id="b-树的定义">B 树的定义</h5><ul><li>一棵 <span class="math inline">\(m\)</span> 阶 B 树要么为空，要么满足一下条件<ul><li>根节点要么是叶节点，要么至少有两个儿子，至多有 <span class="math inline">\(m\)</span> 个儿子</li><li>每个非根节点至少有 <span class="math inline">\(\lceil m/2 \rceil\)</span> 个儿子，至多有 <span class="math inline">\(m\)</span> 个儿子</li><li>有 <span class="math inline">\(s\)</span> 个儿子的非叶节点具有 <span class="math inline">\(n=s-1\)</span> 个关键字</li><li>所有的叶子节点都出现在同一层上</li></ul></li></ul><h5 id="b-树的插入">B 树的插入</h5><ul><li>在最底层进行插入</li></ul><ol type="1"><li>在 <span class="math inline">\(m\)</span> 阶 B 树上进行查找操作，确定新插入的关键字 <code>key</code> 在最底层非叶节点的插入位置</li><li>如果被插入节点的关键字个数小于等于 <span class="math inline">\(m-1\)</span>，则插入结束</li><li>如果被插入节点的关键字个数大于 <span class="math inline">\(m-1\)</span>，则需要进行分裂</li></ol><ul><li>被插入节点分为三个部分<ul><li>前半部分：前 <span class="math inline">\(m/2\)</span> 个关键字</li><li>中间部分：中间的关键字</li><li>后半部分：后 <span class="math inline">\(m/2\)</span> 个关键字</li></ul></li><li>中间部分的关键字上升到父节点</li><li>前后半部分生成新的两个节点</li></ul><h5 id="b-树的删除">B 树的删除</h5><ul><li>采用替身法，替身为右子树的最小值或者左子树的最大值</li></ul><ol type="1"><li>删除节点，替身进入</li><li>如果删除后的替身原来在的节点满足，则直接删除</li><li>如果删除后的关键字小于下限，<ul><li>向该节点的左或右兄弟借一个关键字</li><li>如果兄弟节点的关键字个数等于下限，则需要进行合并</li></ul></li></ol><h5 id="m-的选择">M 的选择</h5><h4 id="b树">B+树</h4><p>B+树是既能提供随机查找，也能提供顺序访问的存储结构</p><h5 id="b树的定义">B+树的定义</h5><ul><li>所有数据都记录在叶节点中，所有叶节点连成一个单链表</li><li>非叶节点至多保存 <span class="math inline">\(m-1\)</span> 个关键字来引导查找，键 <span class="math inline">\(i\)</span> 表示子树 <span class="math inline">\(i+1\)</span> 中键的最小值</li><li>根节点或者是叶节点，或者有 <span class="math inline">\(2\)</span> 到 <span class="math inline">\(m\)</span> 个子树</li><li>除了根节点之外的所有非叶节点至少有 <span class="math inline">\(m/2\)</span> 个儿子，最多有 <span class="math inline">\(m\)</span> 个儿子</li><li>所有的叶节点都在同一层上，并且每个叶子有 <span class="math inline">\(\lceil L/2 \rceil\)</span> 到 <span class="math inline">\(L\)</span> 个关键字</li></ul><h5 id="b树的插入">B+树的插入</h5><ul><li>叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序</li><li>叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项<ul><li>更新父结点</li><li>如果父亲的儿子数量已经满了，就继续分裂父亲</li></ul></li></ul><h3 id="外排序">外排序</h3><p>一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O 操作）</p><h4 id="外排序模型">外排序模型</h4><ul><li>外排序由两个阶段组成<ol type="1"><li>预处理阶段：根据内存的大小将一个有 n 个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段</li><li>归并阶段：将这些有序片段逐步归并成一个有序文件</li></ol></li></ul><p>减少 I/O 操作的关键</p><ol type="1"><li>减少归并轮数</li><li>减少有序片段数量</li><li>增加合并路数</li></ol><h4 id="预处理">预处理</h4><h5 id="减少有序片段数量">减少有序片段数量</h5><ul><li>每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少</li><li>最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段</li></ul><h5 id="置换排序">置换排序</h5><p>置换选择可以在只能容纳 <span class="math inline">\(p\)</span> 个记录的内存中生成平均长度为 <span class="math inline">\(2p\)</span> 的初始的已排序片段</p><p>只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段</p><p>具体方法</p><ol type="1"><li>初始时，将 <span class="math inline">\(m\)</span> 个元素读入内存，用 <code>buildHeap</code> 建立一个优先级队列</li><li>执行一次 <code>deQuqeue</code>，将最小的元素写入输出文件</li><li>从输入磁带读入下一个元素<ul><li>如果它比刚才写进去的元素大，那么将它加入到优先级队列中</li><li>否则，则无法写入队列，进行下一次 <code>deQuqeue</code></li></ul></li><li>重复第 2、3 步，直到输入文件读完</li><li>重新执行 <code>buildHeap</code>，使用存放在空余位置中的元素</li></ol><h4 id="归并">归并</h4><h5 id="二路归并">二路归并</h5><ul><li>归并时，每次将两个有序文件归并为一个有序文件</li><li>如果生成的有序片段数量为 <span class="math inline">\(M\)</span>，则归并次数为 <span class="math inline">\(\lceil \log_2 M \rceil\)</span></li></ul><h5 id="多路归并">多路归并</h5><ul><li>归并时，每次将 <span class="math inline">\(k\)</span> 个有序文件归并为一个有序文件</li><li>优点：减少归并次数，为 <span class="math inline">\(\lceil \log_k M \rceil\)</span> 次</li><li>缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列</li></ul><h5 id="多阶段归并">多阶段归并</h5><ul><li>可以仅使用 <span class="math inline">\(K+1\)</span> 条磁带实现 <span class="math inline">\(K\)</span> 路归并，称为<strong>多阶段归并</strong></li></ul><p><strong>实现的过程</strong></p><ol type="1"><li>按照非均匀的方法分解原来的已排序的片段</li><li>将每个片段分成 <span class="math inline">\(K\)</span> 个子片段</li></ol><h2 id="图">图</h2><h3 id="图的定义">图的定义</h3><ul><li>图可以用 <span class="math inline">\(G=(V, E)\)</span> 表示。其中，<span class="math inline">\(V\)</span> 是顶点集，<span class="math inline">\(E\)</span> 是边集。</li><li>如果边是有方向的，称为<strong>有向图</strong>.有向图的边用 <span class="math inline">\(\langle \rangle\)</span> 表示<ul><li><span class="math inline">\(\langle A, B \rangle\)</span> 表示从 <span class="math inline">\(A\)</span> 到 <span class="math inline">\(B\)</span> 的一条边</li></ul></li><li>如果边是无方向的，称为<strong>无向图</strong>.无向图的边用 <span class="math inline">\(()\)</span> 表示<ul><li><span class="math inline">\((A, B)\)</span> 表示 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 之间有一条边</li><li>无向图也称为双向图</li></ul></li><li><strong>加权图：</strong> 边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图<ul><li>加权图中边的表示：<span class="math inline">\((V_i,V_j,W)\)</span></li></ul></li></ul><h3 id="图的基本术语">图的基本术语</h3><ul><li>邻接<ul><li>若 <span class="math inline">\((V_i,V_j)\)</span> 是图 <span class="math inline">\(G\)</span> 的一条边，则称 <span class="math inline">\(V_i\)</span> 和 <span class="math inline">\(V_j\)</span> 是邻接的；若 <span class="math inline">\(\langle V_i,V_j \rangle\)</span> 是图 <span class="math inline">\(G\)</span> 的一条边，则称 <span class="math inline">\(V_i\)</span> 邻接到 <span class="math inline">\(V_j\)</span>，<span class="math inline">\(V_j\)</span> 和 <span class="math inline">\(V_i\)</span> 邻接</li></ul></li><li>度 无向图中邻接与某一顶点的边的总数</li><li>入度 有向图中进入某一顶点的边数</li><li>出度 有向图中离开某一顶点的边数</li><li>边与度的关系 <span class="math inline">\(\displaystyle e=\frac{1}{2}\sum_{i=1}^n d_i\)</span>，其中 <span class="math inline">\(e\)</span> 是边数，<span class="math inline">\(d_i\)</span> 是顶点 <span class="math inline">\(V_i\)</span> 的度</li></ul><h4 id="子图">子图</h4><p>设有两个图 <span class="math inline">\(G_1=(V_1,E_1)\)</span> 和 <span class="math inline">\(G_2=(V_2,E_2)\)</span>，如果 <span class="math inline">\(V_1 \subseteq V_2\)</span>，<span class="math inline">\(E_1 \subseteq E_2\)</span>，则称 <span class="math inline">\(G_1\)</span> 是 <span class="math inline">\(G_2\)</span> 的子图</p><h4 id="路径和路径长度">路径和路径长度</h4><ul><li>对于 <span class="math inline">\(1&lt;i&lt;N\)</span>，顶点序列 <span class="math inline">\(w_1,w_2,\ldots,w_N\)</span> 中的顶点对 <span class="math inline">\((w_i,w_{i+1})\)</span> 都有 <span class="math inline">\((W_i,w_{i+1})\in E\)</span> 或 <span class="math inline">\(\langle w_i,w_{i+1} \rangle \in E\)</span>，则称 <span class="math inline">\(w_1,w_2,\ldots,w_N\)</span> 是图中的一条<strong>路径</strong></li><li><strong>非加权的路径长度</strong>就是组成路径的边数，对于路径 <span class="math inline">\(w_1,w_2,\ldots,w_N\)</span>，路径长度为 <span class="math inline">\(N-1\)</span></li><li><strong>加权的路径长度</strong>是指路径上所有边的权值之和</li><li><strong>简单路径和环：</strong> 如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为 <span class="math inline">\(1\)</span></li></ul><h4 id="无向图的连通性">无向图的连通性</h4><ul><li><strong>连通：</strong> 顶点 <span class="math inline">\(V\)</span> 和顶点 <span class="math inline">\(V&#39;\)</span> 之间又路径存在</li><li><strong>连通图：</strong> 无向图 G 的任意两点之间都是连通的</li><li><strong>连通分量：</strong> 非连通图中的极大连通子图</li></ul><h4 id="有向图的连通性">有向图的连通性</h4><ul><li><strong>强连通图：</strong> 有向图 G 的任意两点之间都是连通的，则称 G 是强连通图</li><li><strong>强连通分量：</strong> 极大连通子图</li><li><strong>弱连通图：</strong> 如有向图 G 不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的</li></ul><h4 id="完全图">完全图</h4><ul><li><strong>完全图：</strong> 每两个顶点之间都有边的无向图称为完全图。完全图有 <span class="math inline">\(\frac{n(n-1)}{2}\)</span> 条边，即 <span class="math inline">\(C_n^2\)</span></li><li><strong>有向完全图：</strong> 每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 <span class="math inline">\(n(n-1)\)</span> 条边，即 <span class="math inline">\(P_n^2\)</span></li><li><strong>有向无环图：</strong> 不含环的有向图</li></ul><h4 id="生成树与最小生成树">生成树与最小生成树</h4><ul><li><strong>生成树</strong>是图 G 的<strong>极小</strong>连通子图 G’，其中 <span class="math inline">\(V(G&#39;)=V(G)\)</span></li><li>用一棵树把图 G 的所有顶点都连起来，并且没有回路</li><li>生成树有 <span class="math inline">\(n\)</span> 个顶点，<span class="math inline">\(n-1\)</span> 条边</li><li>生成树可以有多个</li><li><strong>最小生成树</strong>是所有生成树中权值之和最小的生成树</li></ul><h3 id="图的运算">图的运算</h3><ul><li>常规操作<ul><li>构造一个由若干个顶点、若干条边组成的图</li><li>判断两个顶点之间是否有边存在</li><li>在图中添加或删除一条边</li><li>返回图中的顶点数或边数</li><li>按某种规则<strong>遍历</strong>图中的所有顶点</li></ul></li><li>和应用紧密结合的运算<ul><li>拓扑排序和关键路径</li><li>找最小生成树</li><li>找最短路径等</li></ul></li></ul><h3 id="图的抽象类">图的抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y, TypeOfEdge w)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfVer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> Vers;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfEdge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> Edges;<br>    &#125;<br> <br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> Vers, Edges;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="图的存储">图的存储</h3><h4 id="邻接矩阵和加权邻接矩阵">邻接矩阵和加权邻接矩阵</h4><h5 id="有向图的邻接矩阵">有向图的邻接矩阵</h5><p>设有向图有 <span class="math inline">\(n\)</span> 个顶点，则用一个 <span class="math inline">\(n \times n\)</span> 的布尔矩阵 <span class="math inline">\(A\)</span> 来表示该有向图</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png" alt="有向图的邻接矩阵" /><figcaption aria-hidden="true">有向图的邻接矩阵</figcaption></figure><ul><li>分别使用 <span class="math inline">\(0,1,2,\ldots,n-1\)</span> 表示 顶点 <span class="math inline">\(V_0,V_1,\ldots,V_{n-1}\)</span>，如果存在一条从 <span class="math inline">\(V_i\)</span> 到 <span class="math inline">\(V_j\)</span> 的边，则 <span class="math inline">\(A[i][j]=1\)</span>，否则 <span class="math inline">\(A[i][j]=0\)</span></li><li>出度：<span class="math inline">\(i\)</span> 行之和</li><li>入度：<span class="math inline">\(j\)</span> 列之和</li><li>真正的顶点数据字段之值放入一个一维数组之中</li></ul><h5 id="无向图的邻接矩阵">无向图的邻接矩阵</h5><p>设无向图有 <span class="math inline">\(n\)</span> 个顶点，则用一个 <span class="math inline">\(n \times n\)</span> 的布尔矩阵 <span class="math inline">\(A\)</span> 来表示该无向图</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png" alt="无向图的邻接矩阵" /><figcaption aria-hidden="true">无向图的邻接矩阵</figcaption></figure><ul><li>分别使用 <span class="math inline">\(0,1,2,\ldots,n-1\)</span> 表示 顶点 <span class="math inline">\(V_0,V_1,\ldots,V_{n-1}\)</span>，如果存在一条从 <span class="math inline">\(V_i\)</span> 到 <span class="math inline">\(V_j\)</span> 的边，则 <span class="math inline">\(A[i][j]=A[j][i]=1\)</span>，否则 <span class="math inline">\(A[i][j]=A[j][i]=0\)</span></li><li>顶点 <span class="math inline">\(i\)</span> 的度：第 <span class="math inline">\(i\)</span> 行或第 <span class="math inline">\(i\)</span> 列之和</li><li>无向图的邻接矩阵是一个三角对称矩阵</li></ul><h5 id="邻接矩阵的特点">邻接矩阵的特点</h5><ul><li>优点：判断任意两点之间是否有边方便，仅耗费 <span class="math inline">\(O(1)\)</span> 时间</li><li>缺点：即使 <span class="math inline">\(\ll n_2\)</span> 条边，也需内存 <span class="math inline">\(n_2\)</span> 单元，太多; 仅读入数据耗费 <span class="math inline">\(O(n_2)\)</span> 时间，太长。而大多数的图的边数远远小于 <span class="math inline">\(n_2\)</span>。<strong>适合稠密网</strong></li><li>不适合增减顶点</li></ul><h4 id="邻接表">邻接表</h4><ul><li><p>设有向图或者无向图由 <span class="math inline">\(n\)</span> 个顶点，则用<strong>顶点表</strong>和<strong>边表</strong>来表示该有向图或无向图</p></li><li><p><strong>顶点表：</strong> 用数组或单链表的形式存放所有的顶点</p><ul><li>如果顶点数 <span class="math inline">\(n\)</span> 已知，则采用数组</li><li>如果顶点数未知，则采用单链表</li><li>每个元素包含两个部分<ul><li>顶点值</li><li>指向该顶点对应的边表的首地址</li></ul></li></ul></li><li><p><strong>边表：</strong> 每条边用一个节点进行表示</p><p>同一个顶点出发的所有的边形成它的边界点单链表</p></li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png" alt="邻接表" /><figcaption aria-hidden="true">邻接表</figcaption></figure><h4 id="邻接表的特点">邻接表的特点</h4><ul><li>邻接表是图的<strong>标准</strong>存储方式</li><li>优点<ul><li><span class="math inline">\(\text{内存} = \text{顶点数} +\text{边数}\)</span>，时间复杂度为 <span class="math inline">\(O\left(\vert V\vert +\vert E\vert \right)\)</span>，<strong>适合稀疏网</strong></li></ul></li><li>当谈及图的线性算法时，一般指的是 <span class="math inline">\(O\left(\vert V\vert +\vert E\vert \right)\)</span></li><li>缺点<ul><li>确定 <span class="math inline">\(i\rightarrow j\)</span> 是否有边，最坏需耗费 <span class="math inline">\(O(n)\)</span> 时间</li><li>无向图同一条边表示两次。边表空间浪费一倍</li><li>有向图中寻找进入某结点的边，非常困难（逆邻接表）</li></ul></li></ul><h3 id="图的遍历">图的遍历</h3><p>按照某种次序系统地访问图中的所有顶点，并且使得<strong>每个顶点需且只能被访问一次</strong></p><p>需对访问过的顶点加以<strong>标记</strong></p><h4 id="深度优先搜索">深度优先搜索</h4><ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li></ol><p>出现了问题</p><h5 id="存在的问题">存在的问题</h5><p><span id="DFSdamn">如果图不是连通或强连通，在进行 DFS 时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span></p><h5 id="深度优先生成森林">深度优先生成森林</h5><p>在<a href="##图###图的遍历####深度优先搜索#####存在的问题">这种情况</a>下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止</p><p>此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成<strong>森林</strong></p><p>所以将深度优先搜索的流程改为</p><ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li><li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li><li>所有的顶点都被访问到，则结束</li></ol><h5 id="深度优先搜索的实现">深度优先搜索的实现</h5><ul><li>公有的 <code>dfs</code> 函数的伪代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  visited [v] =<span class="hljs-literal">false</span>; <span class="hljs-comment">//对每个节点标记为未访问</span><br><br>  <span class="hljs-keyword">while</span>(v=尚未访问的节点)<br>  &#123;<br>    <span class="hljs-built_in">dfs</span>(v,visited);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>私有的 <code>dfs</code> 函数的伪代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(v,visited)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">visited</span>(v)=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> 每个 v 的邻接点 w<br>  &#123;<br>    <span class="hljs-keyword">if</span>(!visited[w])<br>    &#123;<br>      <span class="hljs-built_in">dfs</span>(w,visited);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="广度优先搜索">广度优先搜索</h4><ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次访问已访问顶点的未被访问过的第 <span class="math inline">\(1\)</span> 个、第 <span class="math inline">\(2\)</span> 个、第 <span class="math inline">\(3\)</span> 个、<span class="math inline">\(\ldots\)</span> 、第 <span class="math inline">\(m\)</span> 个邻接顶点 <span class="math inline">\(W_1,W_2,W_3,\ldots,W_m\)</span> ，进行访问且进行标记，转向 3</li><li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li><li>所有的顶点都被访问到，则结束</li></ol><p>按照顶点序号小的先访问，大的后访问的原则以<strong>队列</strong>的形式实现</p><p>同样能够生成广度优先生成森林</p><h5 id="广度优先搜索的实现">广度优先搜索的实现</h5><ol type="1"><li>将序号最小的顶点放入队列</li><li>重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问<ul><li>如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队</li></ul></li><li>检查是否还有顶点未被访问。如果有，重复上述两个步骤</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class="hljs-built_in">bfs</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">bool</span> *visited = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[Vers];<br>  <span class="hljs-type">int</span> currentNode;<br>  linkQueue&lt;<span class="hljs-type">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>   visited[i] = <span class="hljs-literal">false</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;当前图的广度优先遍历序列为：&quot;</span>&lt;&lt; endl;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-comment">//连续访问队列的队头，将其拉出，若其后继非空则拉入队列</span><br>    &#123;<br>      currentNode = q.<span class="hljs-built_in">deQueue</span>();<br>      <span class="hljs-keyword">if</span> (visited[currentNode] == <span class="hljs-literal">true</span>)<br>      &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      cout &lt;&lt; verList[currentNode].ver &lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span>;<br>      visited[currentNode] = <span class="hljs-literal">true</span>;<br>      p = verList[currentNode].head;<br>      <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (visited[p-&gt;end] == <span class="hljs-literal">false</span>)<br>        q.<span class="hljs-built_in">enQueue</span>(p-&gt;end);<br>        p = p-&gt;next;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图遍历的应用">图遍历的应用</h3><h4 id="无向图的连通性-1">无向图的连通性</h4><ul><li>如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先<strong>生成树</strong></li><li>如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先<strong>生成森林</strong>。每棵树就是一个<strong>连通分量</strong>。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量</li><li>在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量</li></ul><h4 id="有向图的连通性-1">有向图的连通性</h4><ul><li>对有向图，深度优先搜索可以<strong>测试是否强连通</strong>，并<strong>找出所有强连通分量</strong><ol type="1"><li>从任意顶点开始<strong>深度优先遍历</strong> <span class="math inline">\(G\)</span></li><li>对森林中的每棵树进行<strong>后序遍历</strong>，并按遍历的顺序给每个顶点编号</li><li>将 <span class="math inline">\(G\)</span> 的每条边逆向，形成 <span class="math inline">\(G_r\)</span></li><li>从编号<strong>最大</strong>的顶点开始<strong>深度优先遍历 <span class="math inline">\(G_r\)</span></strong>。得到的深度优先遍历森林的每棵树就是 <span class="math inline">\(G\)</span> 的强连通分量</li></ol></li></ul><h4 id="欧拉回路">欧拉回路</h4><ul><li>哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径</li></ul><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png" alt="哥尼斯堡七桥问题" /><figcaption aria-hidden="true">哥尼斯堡七桥问题</figcaption></figure><h5 id="欧拉的证明">欧拉的证明</h5><ul><li>如果都是偶数桥，从任意地方出发都能回到原点 <strong>（欧拉回路）</strong></li><li>如果都是偶数桥，从任意地方出发都能回到原点 <strong>（欧拉路径）</strong></li><li>如果有奇数桥的地方不止两个，满足要求的路径是找不到的</li></ul><h5 id="查找欧拉回路的基本想法">查找欧拉回路的基本想法</h5><ul><li>执行一次<strong>不允许回溯</strong>的 <code>DFS</code> ，也被称为一笔画问题</li><li>但是很多搜索都是不符合的</li></ul><h5 id="解决方法">解决方法</h5><p>找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问</p><figure><img src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png" alt="欧拉回路解决方法" /><figcaption aria-hidden="true">欧拉回路解决方法</figcaption></figure><h4 id="拓扑排序">拓扑排序</h4><p>设 <span class="math inline">\(G=(V,E)\)</span> 是一个具有 <span class="math inline">\(n\)</span> 个顶点的<strong>有向无环图</strong></p><p>若 <span class="math inline">\(V\)</span> 中的顶点序列 <span class="math inline">\(V_1,V_2,\ldots ,V_n\)</span> 满足下列条件</p><ul><li>在 <span class="math inline">\(G\)</span> 中，从 <span class="math inline">\(V_i\)</span> 到 <span class="math inline">\(V_j\)</span> 有一条路径</li><li>在序列中 <span class="math inline">\(V_i\)</span> 在 <span class="math inline">\(V_j\)</span> 之前</li></ul><p>则称 <span class="math inline">\(V_1,V_2,\ldots ,V_n\)</span> 是 <span class="math inline">\(G\)</span> 的一个<strong>拓扑排序</strong></p><p>拓扑排序将图转换为线性序，相对前去后继关系不变</p><h5 id="顶点活动网络activu-on-vertex-network">顶点活动网络（Activu on vertex network）</h5><ul><li>顶点表示各项子任务</li><li>有向边表示具有先决条件关系</li><li>仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施</li></ul><p><strong>AOV</strong>的特点</p><ol type="1"><li>有起始顶点</li><li>无回路</li></ol><h5 id="找出拓扑排序的过程">找出拓扑排序的过程</h5><ul><li>第一个输出的顶点必须无前驱，即入度为 <span class="math inline">\(0\)</span></li><li>无前驱以及后继的顶点在任何时候都可以输出</li><li>逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度 <span class="math inline">\(-1\)</span></li></ul><h5 id="拓扑排序的实现">拓扑排序的实现</h5><ul><li>计算每个顶点的入度，保存在数组 <code>inDegree</code> 中</li><li>检查 <code>inDegree</code> 中的每个元素，将入度为 <span class="math inline">\(0\)</span> 的顶点入队</li><li>不断从队列中将入度为 <span class="math inline">\(0\)</span> 的顶点入队，输出此顶点，并将该顶点的入度 <span class="math inline">\(-1\)</span>，如果某个邻接点的入度为 <span class="math inline">\(0\)</span>，则将其入队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class="hljs-built_in">topSort</span>() <span class="hljs-type">const</span><br>&#123;<br>  linkQueue&lt;<span class="hljs-type">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class="hljs-type">int</span> current, *inDegree = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[Vers];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    inDegree[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (p = verList[i].head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next)<br>    &#123;<br>    ++inDegree[p-&gt;end];<br>    &#125;<br>  &#125;                                                                 <span class="hljs-comment">//计算入度</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)   <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">enQueue</span>(i);  <span class="hljs-comment">//入度0节点入队</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;拓扑排序为：&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = q.<span class="hljs-built_in">deQueue</span>( );<br>    cout &lt;&lt; verList[current].ver &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (p = verList[current].head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next)<br>    <span class="hljs-keyword">if</span>( --inDegree[p-&gt;end] == <span class="hljs-number">0</span> )    q.<span class="hljs-built_in">enQueue</span>( p-&gt;end );<br>  &#125;                                                                 <span class="hljs-comment">//出队，删除关联的边</span><br>  cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><ul><li>若图以邻接表表示</li><li>计算入度的时间复杂度为 <span class="math inline">\(O(\vert V\vert +\vert E\vert)\)</span>，搜索入度为 <span class="math inline">\(0\)</span> 的顶点的时间复杂度为 <span class="math inline">\(O(\vert V\vert)\)</span>，出队和删除边的时间复杂度为 <span class="math inline">\(O(\vert E\vert)\)</span>，总执行时间为 <span class="math inline">\(O(\vert V\vert +\vert E\vert)\)</span></li></ul><h4 id="关键路径">关键路径</h4><h5 id="边活动网络activity-on-edge">边活动网络（Activity on Edge）</h5><ul><li><strong>AOE 网络：</strong> 加权有向无环图<ul><li>顶点表示事件，边表示活动</li><li>有向边的权值表示活动的持续时间</li><li>有向边的方向表示事件发生的先后次序</li><li>顶点的进入表示事件发生后允许开始的活动</li><li>有一个源点、一个终点</li></ul></li></ul><h5 id="关键路径的定义">关键路径的定义</h5><p>AOE 网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序</p><p>再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
