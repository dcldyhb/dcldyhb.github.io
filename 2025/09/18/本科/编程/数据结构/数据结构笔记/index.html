

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="东川路第一寒冰">
  <meta name="keywords" content="">
  
    <meta name="description" content="oiWiki 中的数据结构 引言 算法与数据结构 数据结构的研究内容  数据之间的逻辑关系，以及这种关系对应的操作 储存实现：数据及逻辑关系的存储 运算实现：具体存储模式下，运算的实现，即算法  数据的逻辑结构  集合结构 次序任意，元素之间除了同处于一个集合内之外没有任意其他的关系. 线性结构 数据元素的有序排列，除了头尾的元素外其余元素都有一个前趋和一个后继. 树形结构 除了根元素之外，每个节">
<meta property="og:type" content="article">
<meta property="og:title" content="中缀计算式转换为后缀计算式">
<meta property="og:url" content="http://dcldyhb.github.io/2025/09/18/%E6%9C%AC%E7%A7%91/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="东川路第一寒冰的笔记">
<meta property="og:description" content="oiWiki 中的数据结构 引言 算法与数据结构 数据结构的研究内容  数据之间的逻辑关系，以及这种关系对应的操作 储存实现：数据及逻辑关系的存储 运算实现：具体存储模式下，运算的实现，即算法  数据的逻辑结构  集合结构 次序任意，元素之间除了同处于一个集合内之外没有任意其他的关系. 线性结构 数据元素的有序排列，除了头尾的元素外其余元素都有一个前趋和一个后继. 树形结构 除了根元素之外，每个节">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-18T06:46:31.255Z">
<meta property="article:modified_time" content="2025-09-18T06:46:31.255Z">
<meta property="article:author" content="东川路第一寒冰">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>中缀计算式转换为后缀计算式 - 东川路第一寒冰的笔记</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"dcldyhb.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.jpeg","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>哦耶</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="中缀计算式转换为后缀计算式"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-18 14:46" pubdate>
          2025年9月18日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          216 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">中缀计算式转换为后缀计算式</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds">oiWiki 中的数据结构</a></p>
<h2 id="引言">引言</h2>
<h3 id="算法与数据结构">算法与数据结构</h3>
<p>数据结构的研究内容</p>
<ol type="1">
<li>数据之间的<strong>逻辑关系</strong>，以及这种关系对应的操作</li>
<li><strong>储存实现</strong>：数据及逻辑关系的存储</li>
<li><strong>运算实现</strong>：具体存储模式下，运算的实现，即<strong>算法</strong></li>
</ol>
<h4 id="数据的逻辑结构">数据的逻辑结构</h4>
<ul>
<li><strong>集合结构</strong>
次序任意，元素之间除了<strong>同处于一个集合内</strong>之外没有任意其他的关系.</li>
<li><strong>线性结构</strong>
数据元素的<strong>有序</strong>排列，除了头尾的元素外其余元素都有一个前趋和一个后继.</li>
<li><strong>树形结构</strong>
除了根元素之外，每个节点都有且仅有一个前趋，但是后继数量不限.</li>
<li><strong>图形结构</strong> 每个元素的前趋和后继数量都不限 <img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/FourLogicalDataStructures.png" srcset="/img/loading.jpeg" lazyload
alt="FourLogicalDataStructures" /></li>
</ul>
<h4 id="数据结构的操作">数据结构的操作</h4>
<ul>
<li><strong>创造</strong></li>
<li><strong>清除</strong></li>
<li><strong>插入</strong></li>
<li><strong>删除</strong></li>
<li><strong>更新</strong></li>
<li><strong>搜索</strong></li>
<li><strong>访问</strong></li>
<li><strong>遍历（traverse）</strong>：按照某种次序访问数据结构中的每一元素，使每个元素恰好被访问一次</li>
<li>每一种数据结构的特定操作</li>
</ul>
<p>数据结构的<strong>五大类</strong>：构建类、属性类、数据操纵类、遍历类、特定类</p>
<h3 id="存储实现">存储实现</h3>
<h3 id="算法分析">算法分析</h3>
<h4 id="时间复杂度的概念">时间复杂度的概念</h4>
<ul>
<li>是一种抽象的度量，表示运算量和问题规模（输入规模）之间的关系，<span
class="math inline">\(T(n)\)</span></li>
<li>算法的时间复杂度也与被处理的数据分布有关</li>
<li>算法的时间复杂度分为三种
<ul>
<li>最好的</li>
<li>最坏的</li>
<li>平均</li>
</ul></li>
</ul>
<h4 id="算法运算量的计算">算法运算量的计算</h4>
<h4 id="渐进时间复杂度">渐进时间复杂度</h4>
<h4 id="算法的优化">算法的优化</h4>
<h4 id="空间复杂度的概念">空间复杂度的概念</h4>
<ul>
<li>渐进的空间复杂度</li>
<li>一般只考虑<strong>辅助</strong>空间的占用情况</li>
<li>空间复杂度一般按照最坏情况处理</li>
<li>空间复杂度的计算、表示方法与时间复杂度相同</li>
</ul>
<h3 id="面向对象方法">面向对象方法</h3>
<h4 id="类模板的定义">类模板的定义</h4>
<p>类模板允许用户为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数或返回值能取任意数据类型</p>
<h5 id="定义格式">定义格式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 标识符&gt;<br><span class="hljs-keyword">class</span> 类名<br>&#123;<br>    <span class="hljs-comment">// 类成员声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="类定义的一般格式">类定义的一般格式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 类名<br>&#123;<br>  [<span class="hljs-keyword">private</span>:]<br>    <span class="hljs-comment">// 私有数据成员和成员函数声明</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公有数据成员和成员函数声明</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="虚函数">虚函数</h4>
<ul>
<li><p>在基类中用关键词 <code>virtual</code>
声明的成员函数，并在派生类中重新定义的函数称为虚函数</p></li>
<li><p>虚函数的一般格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> 返回类型 函数名(参数表)<br>&#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>在派生类中重新定义时，其函数原型，包括返回类型、函数名、参数个数和参数类型的顺序都必须与基类中的原型完全相同（<strong>继承</strong>）</p></li>
<li><p>当把一个函数定义为虚函数时，等于告诉编译器，这个成员函数在派生类中可能有不同的实现。必须在执行时根据传递的参数来决定调用哪一个函数</p></li>
<li><p>虚函数在基类中有默认实现，派生类可以选择性地对其进行重写</p></li>
</ul>
<h4 id="纯虚函数">纯虚函数</h4>
<ul>
<li><p>是一个在基类中说明的虚函数，它在该基类中没有实现，但要在它的派生类里定义和实现自己的版本，或重新说明为纯虚函数</p></li>
<li><p>纯虚函数的一般形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> 返回类型 函数名(参数表) = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li>
<li><p>纯虚函数在基类中无实现，只有函数原型，派生类必须实现</p></li>
</ul>
<h4 id="抽象类">抽象类</h4>
<ul>
<li>如果一个类中<strong>至少有一个纯虚函数</strong>，那么这个类就是抽象类</li>
<li>抽象类只能作为其他类的基类，不能建立抽象类的对象</li>
</ul>
<h4 id="继承">继承</h4>
<ul>
<li>在已有类的基础上建立新的类</li>
<li>基类（父类）和派生类（子类）</li>
<li>继承可以让程序员在已有类的基础上通过增加或修改少量代码的方法得到新的类，从而解决代码重用的问题</li>
</ul>
<h5 id="派生类">派生类</h5>
<ul>
<li><p>一般格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> 派生类名 : [派生方式] 基类名<br>&#123;<br>  <span class="hljs-comment">// 派生类新增的数据成员和成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>派生方法</p>
<ul>
<li>公有派生：<code>public</code></li>
<li>私有派生：<code>protected</code></li>
<li>保护派生：<code>private</code></li>
</ul></li>
<li><p><code>class</code> 默认是 <code>private</code> 继承，
<code>struct</code> 默认是 <code>public</code> 继承</p></li>
</ul>
<h6 id="派生类对基类成员的访问性">派生类对基类成员的访问性</h6>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>public</code> 继承</th>
<th style="text-align: center;"><code>protected</code> 继承</th>
<th style="text-align: center;"><code>private</code> 继承</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>public</code> 成员</td>
<td style="text-align: center;">public</td>
<td style="text-align: center;">protected</td>
<td style="text-align: center;">private</td>
</tr>
<tr>
<td style="text-align: center;"><code>protected</code> 成员</td>
<td style="text-align: center;">protected</td>
<td style="text-align: center;">protected</td>
<td style="text-align: center;">private</td>
</tr>
<tr>
<td style="text-align: center;"><code>private</code> 成员</td>
<td style="text-align: center;">不可访问</td>
<td style="text-align: center;">不可访问</td>
<td style="text-align: center;">不可访问</td>
</tr>
</tbody>
</table>
<h4
id="类定义时常见的两种const用法">类定义时常见的两种<code>const</code>用法</h4>
<p>以函数 <code>int search(constelemType&amp;x) const</code> 为例</p>
<ol type="1">
<li>修饰参数 <code>x</code> 的 <code>const</code> 和 <code>&amp;</code>
组合
<ul>
<li><code>const</code> 修饰参数 <code>x</code>，表示函数
<code>search</code> 不会修改参数 <code>x</code> 的值</li>
<li>参数加了 <code>const</code>
之后，编译器会在程序编译阶段帮助程序检查函数实现代码中是否含有对参数
<code>x</code> 的修改操作，若有则会报错</li>
<li><strong>如果确认函数实现中不准备改变 <code>x</code> 的值，养成加
<code>const</code>的习惯</strong></li>
<li><code>&amp;</code> 修饰参数 <code>x</code>，表示参数 <code>x</code>
是引用传递，即传递的是实参的地址，而不是实参的值</li>
</ul></li>
<li>修饰函数 <code>search</code> 的 <code>const</code>
<ul>
<li>参数表后的 <code>const</code> 保护调用对象的值不被修改</li>
<li>如果没有 <code>const</code> 修饰，那么在调用对象为
<code>const</code> 类型时，不能调用该函数 常量对象只能调用参数表后带
<code>const</code> 的常量成员函数</li>
</ul></li>
</ol>
<h2 id="线性表">线性表</h2>
<h3 id="线性表的定义">线性表的定义</h3>
<h4 id="线性表的概念">线性表的概念</h4>
<ul>
<li><p>是一种<strong>线性结构</strong>，是由 <span
class="math inline">\(n(n\geq0)\)</span>
个数据元素组成的有限序列</p></li>
<li><p>除了首节点 <span class="math inline">\(A_0\)</span> 和尾节点
<span class="math inline">\(A_{n-1}\)</span> 之外，每个节点 <span
class="math inline">\(A_i\)</span> 有且仅有一个前趋 <span
class="math inline">\(A_{i-1}\)</span> 和一个后继 <span
class="math inline">\(A_{i+1}\)</span></p></li>
<li><p><span class="math inline">\(A_0\)</span> 只有后趋，<span
class="math inline">\(A_{n-1}\)</span> 只有前趋</p>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271603830.png" srcset="/img/loading.jpeg" lazyload
alt="线性表" />
<figcaption aria-hidden="true">线性表</figcaption>
</figure></li>
</ul>
<h4 id="表的基本操作">表的基本操作</h4>
<ul>
<li><strong>创建 <code>create()</code></strong>：创建一个空的线性表</li>
<li><strong>清除
<code>clear()</code></strong>：删除线性表中的所有数据元素</li>
<li><strong>长度 <code>length()</code></strong>：返回线性表的长度</li>
<li><strong>插入 <code>insert(i,x)</code></strong>：在线性表的第 <span
class="math inline">\(i\)</span> 个位置插入一个新元素
<code>x</code></li>
<li><strong>删除 <code>remove(i)</code></strong>：删除线性表中第 <span
class="math inline">\(i\)</span> 个位置的元素</li>
<li><strong>搜索 <code>search(x)</code></strong>：在线性表中搜索元素
<code>x</code>，返回其位置</li>
<li><strong>访问 <code>visit(i)</code></strong>：返回线性表中第 <span
class="math inline">\(i\)</span> 个位置的元素</li>
<li><strong>遍历
<code>traverse()</code></strong>：依次访问线性表中的每个元素</li>
</ul>
<h4 id="线性表的抽象类">线性表的抽象类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                           <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 返回长度</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 访问</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">list</span>() &#123;&#125;                                  <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>抽象类定义了线性表基本的操作，全是用纯虚函数定义，不做实现</li>
<li><strong>抽象类无构造函数</strong></li>
</ul>
<h3 id="线性表的顺序实现">线性表的顺序实现</h3>
<h4 id="顺序存储结构">顺序存储结构</h4>
<ul>
<li>节点存储在存储器的一块<strong>连续</strong>的空间中</li>
<li>节点依照逻辑顺序依次<strong>存放</strong></li>
<li>节点存放的物理位置和逻辑顺序是对应的</li>
<li>线性表的顺序实现通常被称为<strong>顺序表</strong></li>
</ul>
<h4 id="顺序表类的定义">顺序表类的定义</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqList</span> : <span class="hljs-keyword">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *data;<br>    <span class="hljs-type">int</span> currentLength;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);             <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqList</span>()                              <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>      <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>                            <span class="hljs-comment">//清空</span></span><br><span class="hljs-function">    </span>&#123;<br>      currentLength = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                      <span class="hljs-comment">// 返回长度</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> elemType &amp;x)</span></span>;  <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;                     <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">// 搜索</span><br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                  <span class="hljs-comment">// 遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="函数实现">函数实现</h4>
<h5 id="构造函数">构造函数</h5>
<ul>
<li>定义对象时自动调用，用于初始化对象的数据成员</li>
<li><strong>函数名与类名相同</strong></li>
<li>可以有任何类型的参数，也可以没有参数，但是<strong>不能有返回类型</strong>，所以定义时不能说明类型</li>
<li>若没有给出构造函数，编译器会自动生成一个默认的构造函数，只为对象开辟空间，里面的内容为随机数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqList&lt;elemType&gt;::<span class="hljs-built_in">seqList</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  data = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271640573.png" srcset="/img/loading.jpeg" lazyload
alt="seqList" />
<figcaption aria-hidden="true">seqList</figcaption>
</figure>
<h5 id="析构函数">析构函数</h5>
<ul>
<li>用于释放对象所占用的内存空间，由编译系统自动调用</li>
<li><strong>函数名与类名相同，前面加 <code>~</code></strong></li>
<li>不能有参数，也不能有返回类型</li>
<li>若没有给出析构函数，编译器会自动生成一个默认的析构函数</li>
<li>不是所有类都要由析构函数</li>
<li>一般在构造函数中动态申请内存的，必须有析构函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">seqList</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] data;<br>&#125;  <span class="hljs-comment">//在线性表的类中已经实现了，不用到类外定义</span><br></code></pre></td></tr></table></figure>
<h5 id="顺序表的运算实现">顺序表的运算实现</h5>
<h6 id="search"><code>search</code></h6>
<p>从数组的第 0 个下标变量开始一次往后检查每一个元素，直到找到
<code>x</code> 或找到表尾</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">int</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> elemType &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> i ;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span> ; i &lt; currentLength &amp;&amp; data[i] != x ; ++i);<br>  <span class="hljs-keyword">if</span> (i == currentLength)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="traverse"><code>traverse</code></h6>
<p>从数组的第 0 个下标变量开始一次往后访问每一个元素，直到表尾</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemtype</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; currentLength ; ++i)<br>  &#123;<br>    cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="insert"><code>insert</code></h6>
<ul>
<li>在第 <code>i</code> 个位置插入元素 <code>x</code></li>
<li>若插入后表长超过 <code>maxSize</code>，则将 <code>maxSize</code>
扩大一倍</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503271747022.png" srcset="/img/loading.jpeg" lazyload
alt="seqList::insert" />
<figcaption aria-hidden="true">seqList::insert</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (currentSize = maxSize)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = currentLength ; j &gt; i ; --j)<br>  &#123;<br>    data[j] = data[j - <span class="hljs-number">1</span>];<br>  &#125;<br>  data[i] = x;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="doublespace-操作的实现"><code>doubleSpace</code> 操作的实现</h6>
<ul>
<li>重新申请一个更大规模的动态数组，将原有数组的内容拷贝到新数组中，释放原有数组空间，将新数组作为存储线性表的存储区</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281230588.png" srcset="/img/loading.jpeg" lazyload
alt="seqList::doublespace" />
<figcaption aria-hidden="true">seqList::doublespace</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">doublespace</span>()<br>&#123;<br>  elemtype *tmp = data;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  data = <span class="hljs-keyword">new</span> elemtype[maxSize];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; currentLength ; +<span class="hljs-number">+1</span>)<br>  &#123;<br>    data[i] = tmp[i];<br>  &#125;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="remove"><code>remove</code></h6>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281238735.png" srcset="/img/loading.jpeg" lazyload
alt="seqlist::remove" />
<figcaption aria-hidden="true">seqlist::remove</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> ||i &gt; currentlength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i ; j &lt; currentlength <span class="hljs-number">-1</span> ; ++j)<br>  &#123;<br>    data[j] = data[j + <span class="hljs-number">1</span>];<br>  &#125;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线性表的链接存储">线性表的链接存储</h3>
<h4 id="单链表">单链表</h4>
<ul>
<li>每个节点附加指针字段，如
<code>next</code>，指向直接后继节点，最后一个节点的 <code>next</code>
指向 <code>nullptr</code></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281247119.png" srcset="/img/loading.jpeg" lazyload
alt="单链表" />
<figcaption aria-hidden="true">单链表</figcaption>
</figure>
<h5 id="头节点头指针">头节点、头指针</h5>
<ul>
<li>在表头额外增加一个相同类型的特殊结点</li>
<li>不是线性表中的组成部分</li>
<li>头节点使得在表头位置上进行插入和删除和在其他节点位置上是完全一致的，使得插入和删除算法得到简化</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281407312.png" srcset="/img/loading.jpeg" lazyload
alt="带头节点的单链表" />
<figcaption aria-hidden="true">带头节点的单链表</figcaption>
</figure>
<h5 id="结点及其组成">结点及其组成</h5>
<ul>
<li>链表的节点包含两个部分
<ul>
<li>数据字段
<ul>
<li>可以存储任何类型的数据，仍然使用 <code>elemType</code> 表示</li>
</ul></li>
<li>指针字段
<ul>
<li>用于存储<strong>后继节点</strong>的地址值</li>
</ul></li>
<li>结点类型是链表专用的，可以设为内嵌类</li>
<li>将节点类定义为 <code>struct</code> 方便链表类访问</li>
</ul></li>
</ul>
<h5 id="单链表类的定义">单链表类的定义</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sLinkList</span>:<span class="hljs-keyword">public</span> list&lt;elemtype&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>                                    <span class="hljs-comment">// 节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br><br>    node *head;<br>    <span class="hljs-type">int</span> currentLength;<br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sLinkList</span>();<br>    ~<span class="hljs-built_in">sLinkList</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-1">构造函数</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281418321.png" srcset="/img/loading.jpeg" lazyload
alt="sLinklist" />
<figcaption aria-hidden="true">sLinklist</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>sLinkList&lt;elemType&gt;::<span class="hljs-built_in">sLinkList</span>()<br>&#123;<br>  head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="clear"><code>clear</code></h5>
<ul>
<li>将单链表变成一个空表</li>
<li>回收节点空间</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281420756.png" srcset="/img/loading.jpeg" lazyload
alt="sLinkList::clear" />
<figcaption aria-hidden="true">sLinkList::clear</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>  node *p = head-&gt;next , *q;<br><br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)        <span class="hljs-comment">// 删除节点</span><br>  &#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="move"><code>move</code></h5>
<ul>
<li>返回第 <span class="math inline">\(i\)</span> 个元素的指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sLinkList</span>&lt;elemType&gt;::node *sLinkList&lt;elemType&gt;::<span class="hljs-built_in">move</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>  node *p = head;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span> ; j &lt; i ; ++j)<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="insert-1"><code>insert</code></h5>
<ol type="1">
<li>指针 <code>p</code> 指向要插入的位置 <code>i</code>
的前一个节点</li>
<li>申请一个新节点 <code>s</code></li>
<li>将 <code>s</code> 的 <code>next</code> 指向 <code>p</code> 的
<code>next</code></li>
<li>将 <code>p</code> 的 <code>next</code> 指向 <code>s</code></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281437080.png" srcset="/img/loading.jpeg" lazyload
alt="sLinkList::insert" />
<figcaption aria-hidden="true">sLinkList::insert</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sinkList&lt;elemtype&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  node *p = <span class="hljs-built_in">move</span>(i<span class="hljs-number">-1</span>);<br>  node *s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x , p-&gt;next);<br>  p-&gt;next = s;<br>  ++currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="remove-1"><code>remove</code></h5>
<ol type="1">
<li>找到被删除节点的前一个节点 <code>pos</code></li>
<li>让 <code>delp</code> 指向被删除节点</li>
<li>让 <code>pos</code> 的 <code>next</code> 指向 <code>delp</code> 的
<code>next</code></li>
<li>释放 <code>delp</code> 的空间</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503281444167.png" srcset="/img/loading.jpeg" lazyload
alt="sLinkList::remove" />
<figcaption aria-hidden="true">sLinkList::remove</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  node *pos = <span class="hljs-built_in">move</span>(i<span class="hljs-number">-1</span>);<br>  node *delp = pos-&gt;next;<br>  pos-&gt;next = delp-&gt;next;<br>  <span class="hljs-keyword">delete</span> delp;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="search-1"><code>search</code></h5>
<ul>
<li>从头节点开始，依次访问每个节点，直到找到 <code>x</code>
或到达表尾</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">int</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> elemtype <span class="hljs-number">7</span>x) <span class="hljs-type">const</span><br>&#123;<br>  node *p = head -&gt; next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; p-&gt;data != x) <span class="hljs-comment">// 访问每个节点，条件的顺序不能交换</span><br>  &#123;<br>    p = p-&gt;next;<br>    ++i;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果判定条件改为
<code>p-&gt;data != x &amp;&amp; p != nullptr</code>，会在
<code>p</code> 为空时试图访问
<code>p-&gt;data</code>，导致访问空指针，从而产生未定义行为</li>
</ul>
<h5 id="visit"><code>visit</code></h5>
<ol type="1">
<li>找到第 <code>i</code> 个节点</li>
<li>返回 <code>p-&gt;data</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType sLinkList&lt;elemType&gt;::<span class="hljs-built_in">visit</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= currentLength)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">OutOfBound</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">move</span>(i)-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="traverse-1"><code>traverse</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> sLinkList&lt;elemType&gt;::<span class="hljs-built_in">traverse</span>() <span class="hljs-type">const</span><br>&#123;<br>  node *p = head-&gt;next;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    p = p-&gt;next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="双链表">双链表</h4>
<ul>
<li>每个节点有两个指针字段
<ul>
<li><code>next</code> 指向直接后继节点</li>
<li><code>prev</code> 指向直接前驱节点</li>
</ul></li>
</ul>
<h5 id="双链表的头尾节点">双链表的头尾节点</h5>
<ul>
<li>头节点
<ul>
<li><code>prev</code> 指向 <code>nullptr</code></li>
<li><code>next</code> 指向首节点</li>
</ul></li>
<li>尾节点 <code>tail</code>
<ul>
<li><code>prev</code> 指向最后一个节点</li>
<li><code>next</code> 指向 <code>nullptr</code></li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291712872.png" srcset="/img/loading.jpeg" lazyload
alt="双链表" />
<figcaption aria-hidden="true">双链表</figcaption>
</figure>
<h5 id="双链表类的定义">双链表类的定义</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dLinkList</span>:<span class="hljs-keyword">public</span> list&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>                                                         <span class="hljs-comment">// 双链表中的节点类</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      node *prev;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *p = <span class="hljs-literal">nullptr</span> , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        prev = p;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *head , *tail;                                                  <span class="hljs-comment">// 头节点和尾节点</span><br>    <span class="hljs-type">int</span> currentLength;                                                   <span class="hljs-comment">// 当前长度</span><br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;                                             <span class="hljs-comment">// 返回第 i 个节点的指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">dLinkList</span>();<br>    ~<span class="hljs-built_in">dLinkList</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentLength;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i , <span class="hljs-type">const</span> elemType &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">elemType <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-2">构造函数</h5>
<ul>
<li>申请头节点和尾节点</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291715359.png" srcset="/img/loading.jpeg" lazyload
alt="dLinkList" />
<figcaption aria-hidden="true">dLinkList</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>dLinkList&lt;elemType&gt;::<span class="hljs-built_in">dLinkList</span>()<br>&#123;<br>  head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>  head-&gt;next = tail;<br>  tail-&gt;prev = head;<br>  currentLength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="insert-2"><code>insert</code></h5>
<ol type="1">
<li>申请一个新节点 <code>tmp</code>，找到要插入的位置
<code>pos</code></li>
<li>将 <code>tmp</code> 的 <code>prev</code> 指向 <code>pos</code> 的
<code>prev</code>，<code>tmp</code> 的 <code>next</code> 指向
<code>pos</code></li>
<li>将 <code>pos</code> 的前一个结点的 <code>next</code> 指向
<code>tmp</code></li>
<li>将 <code>pos</code> 的 <code>prev</code> 指向 <code>tmp</code></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291718343.png" srcset="/img/loading.jpeg" lazyload
alt="dLinkList::insert" />
<figcaption aria-hidden="true">dLinkList::insert</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> dLinkList&lt;elemtype&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i ,<span class="hljs-type">const</span> elemTypr &amp;x)<br>[<br>  node *pos , *tmp;<br><br>  pos = <span class="hljs-built_in">move</span>(i);<br>  temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x,pos -&gt; prev , pos);<br>  pos-&gt;prev-&gt;next = tmp;<br>  pos-&gt;prev = tmp;<br><br>  ++currentLength;<br>]<br></code></pre></td></tr></table></figure>
<h5 id="remove-2"><code>remove</code></h5>
<ol type="1">
<li>找到要删除的节点 <code>pos</code></li>
<li>将 <code>pos</code> 的前一个节点的 <code>next</code> 指向
<code>pos</code> 的后一个节点</li>
<li>将 <code>pos</code> 的后一个节点的 <code>prev</code> 指向
<code>pos</code> 的前一个节点</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291730399.png" srcset="/img/loading.jpeg" lazyload
alt="dLinkList::remove" />
<figcaption aria-hidden="true">dLinkList::remove</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> dLinkList&lt;elemType&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)<br>&#123;<br>  node *pos = <span class="hljs-built_in">move</span>(i);<br><br>  pos-&gt;prev-&gt;next = pos-&gt;next;<br>  pos-&gt;next-&gt;prev = pos-&gt;prev;<br><br>  <span class="hljs-keyword">delete</span> pos;<br>  --currentLength;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="单循环链表">单循环链表</h4>
<ul>
<li>一般单循环链表不带头节点</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291732560.png" srcset="/img/loading.jpeg" lazyload
alt="单循环链表" />
<figcaption aria-hidden="true">单循环链表</figcaption>
</figure>
<h4 id="双循环链表">双循环链表</h4>
<ul>
<li>头结点中 <code>prev</code> 字段给出尾结点的地址，尾结点中
<code>next</code> 字段给出头结点的地址</li>
<li>一般也不设置头尾节点</li>
</ul>
<h2 id="栈">栈</h2>
<h3 id="栈的定义">栈的定义</h3>
<ul>
<li>栈是一种特殊的线性表</li>
<li>只允许在一段进行插入和删除操作</li>
<li>先进后出（LIFO，Last In First Out）</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291811552.png" srcset="/img/loading.jpeg" lazyload
alt="栈" />
<figcaption aria-hidden="true">栈</figcaption>
</figure>
<h4 id="栈的基本操作">栈的基本操作</h4>
<ul>
<li><strong>创建 <code>create()</code></strong>：创建一个空栈</li>
<li><strong>进栈 <code>push(x)</code></strong>：将元素 <code>x</code>
压入栈顶</li>
<li><strong>出栈
<code>pop()</code></strong>：删除栈顶元素并返回其值</li>
<li><strong>访问栈顶元素
<code>top()</code></strong>：返回栈顶元素的值但是不删除</li>
<li><strong>判断是否为空 <code>isEmpty()</code></strong>：若栈空返回
<code>true</code>，否则返回 <code>false</code></li>
</ul>
<h4 id="栈的抽象类">栈的抽象类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">stack</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;       <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 访问栈顶元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">stack</span>() &#123;&#125;                             <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="栈的顺序实现">栈的顺序实现</h3>
<ul>
<li>使用数组储存栈中的节点</li>
<li>进栈和出栈都是在栈顶进行，不会引起类似顺序表中的大量元素的移动，数组的后端为栈顶</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291817453.png" srcset="/img/loading.jpeg" lazyload
alt="顺序栈" />
<figcaption aria-hidden="true">顺序栈</figcaption>
</figure>
<h4 id="顺序栈类">顺序栈类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *data;                     <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-type">int</span> top_p;                          <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> maxSize;                        <span class="hljs-comment">// 栈的最大容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);        <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqStack</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;       <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                    <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="顺序存储的运算实现">顺序存储的运算实现</h4>
<h5 id="构造函数-3">构造函数</h5>
<ul>
<li>按照用户估计的栈的规模申请一个动态数组，将数组地址保存在
<code>elem</code> 中，数组规模保存在 <code>maxSize</code> 中，并设
<code>top_p</code> 的值为 <span class="math inline">\(-1\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::<span class="hljs-built_in">seqStack</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  elem = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  top_p = <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="push"><code>push</code></h4>
<ul>
<li>先判断栈是否已满，若满则调用 <code>doubleSpace</code>
扩大栈的容量</li>
<li>将 <code>top_p</code> 加 1，指向栈顶元素</li>
<li>将 <code>x</code> 压入栈顶</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (top_p == maxSize - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  elem[++top_p] = x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="doublespace"><code>doubleSpace</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class="hljs-keyword">new</span> elemType[maxSize * <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[i];<br>  &#125;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="pop"><code>pop</code></h5>
<ul>
<li>返回 <code>top_p</code> 指向的元素</li>
<li>将 <code>top_p</code> 减 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> elem[top_p--];<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="top"><code>top</code></h5>
<ul>
<li>返回 <code>top_p</code> 指向的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqStack&lt;elemType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> elem[top_p];<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="isempty"><code>isEmpty</code></h5>
<ul>
<li>判断 <code>top_p</code> 是否为 <span
class="math inline">\(-1\)</span>，若是则栈空</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqStack&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="析构函数-1">析构函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqStack&lt;elemType&gt;::~<span class="hljs-built_in">seqStack</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="性能分析">性能分析</h4>
<ul>
<li>所有运算实现的时间复杂度都为 <span
class="math inline">\(O(1)\)</span></li>
<li>进栈运算在最坏的情况下的时间复杂度为 <span
class="math inline">\(O(n)\)</span> （需要 <code>doublespace</code>
时）</li>
</ul>
<h3 id="栈的链接实现">栈的链接实现</h3>
<ul>
<li>使用<strong>不含头结点的单链表</strong>实现栈</li>
<li>从使用方便性上看，将单链表的头指针指向栈顶</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503291834782.png" srcset="/img/loading.jpeg" lazyload
alt="链接栈" />
<figcaption aria-hidden="true">链接栈</figcaption>
</figure>
<h4 id="链接栈类">链接栈类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>:<span class="hljs-keyword">public</span> stack&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *top_p;                       <span class="hljs-comment">// 栈顶指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedStack</span>();                    <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">LinkedStack</span>();                   <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;     <span class="hljs-comment">// 进栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;                   <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function">elemType <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 访问栈顶元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="链接存储的运算实现">链接存储的运算实现</h4>
<h5 id="构造函数-4">构造函数</h5>
<ul>
<li>将 <code>top_p</code> 初始化为 <code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">LinkedStack</span>()<br>&#123;<br>  top_p = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="析构函数-2">析构函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>LinkStack&lt;elemType&gt;::~<span class="hljs-built_in">LinkStack</span>()<br>&#123;<br>  node *tmp;<br>  <span class="hljs-keyword">while</span> (top_p != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    tmp = top_p;<br>    top_p = top_p-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="push-1"><code>push</code></h5>
<ul>
<li>在表头插入</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  top_p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x , top_p);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="pop-1"><code>pop</code></h5>
<ul>
<li>删除表头节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br>  node *tmp = top_p;<br>  elemType x = top_p-&gt;data;<br>  top_p = top_p-&gt;next;<br>  <span class="hljs-keyword">delete</span> tmp;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="top-1"><code>top</code></h5>
<ul>
<li>返回 <code>top_p</code> 指向的节点的 <code>data</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="isempty-1"><code>isEmpty</code></h5>
<ul>
<li>判断 <code>top_p</code> 是否为 <code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> LinkedStack&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> top_p == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="性能分析-1">性能分析</h4>
<ul>
<li>所有运算实现的时间复杂度都为 <span
class="math inline">\(O(1)\)</span>，因为都是对栈顶进行操作</li>
</ul>
<h3 id="栈的应用">栈的应用</h3>
<h4 id="递归函数的非递归实现">递归函数的非递归实现</h4>
<h5 id="函数调用">函数调用</h5>
<ul>
<li>递归的本质是函数调用，函数调用又是通过栈实现的，递归时会产生隐式栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  r1:<span class="hljs-built_in">f1</span>();<br>  r2:<br>  ..<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  t1:<span class="hljs-built_in">f2</span>();<br>  t2:<br>  ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/img/202503301445662.png" srcset="/img/loading.jpeg" lazyload
alt="函数执行过程" />
<figcaption aria-hidden="true">函数执行过程</figcaption>
</figure>
<ul>
<li>设置一个栈模拟函数调用，当调用发生时，将函数压入栈中</li>
<li>函数返回时，将栈顶元素弹出</li>
</ul>
<h6 id="递归算法的例子">递归算法的例子</h6>
<p>hanoi 塔算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">(<span class="hljs-type">int</span> Height , <span class="hljs-type">int</span> FromNeedle ,<span class="hljs-type">int</span> ToNeedle ,<span class="hljs-type">int</span> UsingNeedle)</span> <span class="hljs-comment">// FromNeedle是起始针，ToNeedle是目标针，UsingNeedle是辅助针</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (Height &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">Move</span>(Height - <span class="hljs-number">1</span>，FromNeedle , UsingNeeedle,ToNeedle); <span class="hljs-comment">// 将上面n-1个盘子从FromNeedle移动到UsingNeedle</span><br>    cout &lt;&lt; FromNeedle &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; ToNeedle &lt;&lt; endl; <span class="hljs-comment">// 将最底下的盘子从FromNeedle移动到ToNeedle&gt;</span><br>    <span class="hljs-built_in">Move</span>(Height - <span class="hljs-number">1</span>,UsingNeedle , ToNeedle , FromNeedle); <span class="hljs-comment">// 将上面的盘子从UsingNeedle移动到ToNeedle</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="递归算法的时间复杂度">递归算法的时间复杂度</h5>
<h6 id="数学归纳法">数学归纳法</h6>
<p>以 Hanio 塔问题为例</p>
<p><span class="math display">\[
\begin{dcases}
T(n) = 2T(n-1) + 1 &amp;\\
T(1) = 1 &amp;
\end{dcases}
\]</span></p>
<p>可以使用数学归纳法证明 <span class="math inline">\(T(n) = 2^n -
1\)</span></p>
<h6 id="递归方程">递归方程</h6>
<p><strong>主定理</strong>：设 <span class="math inline">\(a \geq
1\)</span>，<span class="math inline">\(b &gt; 1\)</span> 为常数，<span
class="math inline">\(f(n)\)</span> 是一个函数，则递归方程</p>
<p><span class="math display">\[
T(n) = aT(\frac{n}{b}) + f(n) \quad (n &gt; 1)
\]</span></p>
<p>的解为</p>
<ol type="1">
<li>若 <span class="math inline">\(f(n) &lt;
O\left(n^{\log_{b}a}\right)\)</span>，则 <span
class="math inline">\(T(n)=O\left(n^{\log_{b}a}\right)\)</span></li>
<li>若 <span class="math inline">\(f(n) =
O\left(n^{\log_{b}a}\right)\)</span>，则 <span
class="math inline">\(T(n)=O\left(n^{\log_{b}a}\log_{2}n\right)\)</span></li>
<li>若 <span class="math inline">\(f(n) &gt;
O\left(n^{\log_{b}a}\right)\)</span>，则 <span
class="math inline">\(T(n)=O\left(f(n)\right)\)</span></li>
</ol>
<h6 id="生成函数">生成函数</h6>
<p><strong>定义</strong>：设 <span class="math inline">\(u_0 , u_1 , u_2
, \ldots , u_n ,\ldots\)</span> 是一无穷序列，称形式幂级数 <span
class="math inline">\(\displaystyle G(t) = \sum_{i\geq0}u_it^i\)</span>
为其生成函数</p>
<p>利用生成函数求通项的方法</p>
<ol type="1">
<li>按照递归关系式消去无限延长的部分</li>
<li>展开为 <span class="math inline">\(t\)</span> 的幂级数求通项</li>
</ol>
<p>以 Fibonacci 数列为例</p>
<p><span class="math display">\[
\begin{dcases}
F_{0} =0 &amp; \\
F_{1} =1 &amp; \\
F_{n} =F_{n-1} +F_{n-2} &amp;
\end{dcases}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
  &amp;G(t) = F_{0}t^0 + F_{1}t^1 + F_{2}t^2 + F_{3}t^3 + \cdots \\
  &amp;G(t) = t + t^2 + t^3 + \cdots \\
  &amp;tG(t)=t^2 + t^3 + t^4 + \cdots \\
  &amp;t^2G(t)=t^3 + t^4 + t^5 + \cdots \\
  &amp;(1-t-t^2)G(t) = t \\
  &amp;G(t) = \frac{t}{1-t-t^2} = \frac{1}{\sqrt{5}}
\left(\frac{1}{1-\frac{1+\sqrt{5}}{2}t} -
\frac{1}{1-\frac{1-\sqrt{5}}{2}t}\right) \\
\end{aligned}
\]</span></p>
<p>令 <span class="math inline">\(\Phi =
\frac{1}{2}(1+\sqrt{5})\)</span>，<span
class="math inline">\(\hat{\Phi}=\frac{1}{2}(1-\sqrt{5})\)</span></p>
<p><span class="math display">\[
G(t) =\frac{1}{\sqrt{5}}(\frac{1}{1-\Phi t} - \frac{1}{1-\hat{\Phi}t})
\]</span></p>
<p>有 <span class="math inline">\(\displaystyle\frac{1}{1-\Phi t} =
\sum_{n=0}^{\infty} \Phi^n t^n\)</span></p>
<p><span class="math display">\[
G(t) = \frac{1}{\sqrt{5}} \sum_{n=0}^{\infty} (\Phi^n t^n - \hat{\Phi}^n
t^n)
\]</span></p>
<p>则</p>
<p><span class="math display">\[
F_n = \frac{1}{\sqrt{5}}(\Phi^n - \hat{\Phi}^n)
\]</span></p>
<h4 id="递归消除">递归消除</h4>
<p>以打印正整数为例</p>
<h5 id="递归实现">递归实现</h5>
<h6 id="代码">代码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">10</span>)<br>  &#123;<br>    <span class="hljs-built_in">printNum</span>(num / <span class="hljs-number">10</span>);<br>    cout.<span class="hljs-built_in">put</span>(num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout.<span class="hljs-built_in">put</span>(num + <span class="hljs-string">&#x27;0&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="代码运行过程中栈的变化">代码运行过程中栈的变化</h6>
<ol type="1">
<li><code>push(1234)</code></li>
<li><code>pop(1234)</code>，<code>push(4)</code>，<code>push(123)</code></li>
<li><code>pop(123)</code>，<code>push(3)</code>，<code>push(12)</code></li>
<li><code>pop(12)</code>，<code>push(2)</code>，<code>push(1)</code></li>
<li><code>pop(1)</code>，<code>pop(2)</code>，<code>pop(3)</code>，<code>pop(4)</code></li>
</ol>
<h5 id="非递归实现">非递归实现</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>  LinkStack&lt;<span class="hljs-type">int</span>&gt; s;<br>  <span class="hljs-type">int</span> tmp;<br>  s.<span class="hljs-built_in">push</span>(num);<br>  <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (tmp &gt; <span class="hljs-number">9</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp % <span class="hljs-number">10</span>);<br>      s.<span class="hljs-built_in">push</span>(tmp / <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      cout.<span class="hljs-built_in">put</span>(tmp + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="括号匹配">括号匹配</h3>
<ul>
<li>判断一个表达式中的括号是否匹配</li>
<li>遇到左括号就入栈，遇到右括号就出栈</li>
</ul>
<p>判断错误的原则</p>
<ol type="1">
<li>栈空时遇到右括号</li>
<li>出栈时遇到不匹配的括号</li>
<li>栈不空时结束</li>
</ol>
<h3 id="简单的计算数学表达式">简单的计算数学表达式</h3>
<h4 id="前缀式中缀式和后缀式">前缀式、中缀式和后缀式</h4>
<p>对于一个表达式 <span class="math inline">\(a+b\)</span></p>
<ul>
<li>前缀式 <code>+ab</code>，波兰式</li>
<li>中缀式 <code>a+b</code></li>
<li>后缀式 <code>ab+</code>，逆波兰式</li>
</ul>
<h4 id="后缀式的优点">后缀式的优点</h4>
<ul>
<li>不需要括号</li>
<li>不需要考虑运算符的优先级</li>
<li>计算机容易处理</li>
</ul>
<h4 id="后缀式的计算">后缀式的计算</h4>
<ul>
<li>使用栈来存储操作数</li>
<li>遇到操作数就入栈</li>
<li>遇到操作符就出栈两个操作数，进行计算，将结果入栈</li>
<li>最后栈中只剩下一个元素，就是结果</li>
</ul>
<h4 id="中缀式转换为后缀式的算法">中缀式转换为后缀式的算法</h4>
<p>操作方法见<a
href="/本科/编程/数据结构/中缀计算式转换为后缀计算式.md">中缀计算式转换为后缀计算式</a></p>
<h2 id="队列">队列</h2>
<ul>
<li><p>队列的定义</p></li>
<li><p>先进先出（FIFO，First In First Out）</p></li>
<li><p>只允许在一端（队首）进行插入操作，另一端（队尾）进行删除操作</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503310847159.png" srcset="/img/loading.jpeg" lazyload
alt="队列" />
<figcaption aria-hidden="true">队列</figcaption>
</figure>
<h4 id="队列的基本操作">队列的基本操作</h4>
<ul>
<li><strong>创建 <code>create()</code></strong>：创建一个空队列</li>
<li><strong>入队 <code>enQueue(x)</code></strong>：将元素 <code>x</code>
入队</li>
<li><strong>出队
<code>deQueue()</code></strong>：删除队首元素并返回其值</li>
<li><strong>访问队首元素
<code>getHead()</code></strong>：返回队首元素的值但不删除</li>
<li><strong>判断是否为空 <code>isEmpty()</code></strong>：若队列空返回
<code>true</code>，否则返回 <code>false</code></li>
</ul>
<h4 id="队列的抽象类">队列的抽象类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">queue</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span> </span>= <span class="hljs-number">0</span>;       <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;              <span class="hljs-comment">// 访问队首元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">queue</span>() &#123;&#125;                                 <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="队列的顺序实现">队列的顺序实现</h3>
<ul>
<li>使用数组来存储队列中的元素</li>
<li>元素下标的范围为 <span class="math inline">\(0\)</span> 到
<code>maxSize - 1</code></li>
<li>存储队里的三种组织方法
<ol type="1">
<li>队头位置固定</li>
<li>队头位置不固定</li>
<li>循环队列</li>
</ol></li>
</ul>
<h4 id="队头位置固定">队头位置固定</h4>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311613560.png" srcset="/img/loading.jpeg" lazyload
alt="队头位置固定" />
<figcaption aria-hidden="true">队头位置固定</figcaption>
</figure>
<p><strong>缺点</strong>：出队的时间复杂度为 <span
class="math inline">\(O(n)\)</span>，因为出队时需要将所有元素向前移动一位</p>
<h4 id="队头位置不固定">队头位置不固定</h4>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311614368.png" srcset="/img/loading.jpeg" lazyload
alt="队头位置不固定" />
<figcaption aria-hidden="true">队头位置不固定</figcaption>
</figure>
<p><strong>优点</strong>：所有操作的时间复杂度均为 <span
class="math inline">\(O(1)\)</span>
<strong>缺点</strong>：浪费大量的空间</p>
<h4 id="循环队列">循环队列</h4>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311626377.png" srcset="/img/loading.jpeg" lazyload
alt="循环队列" />
<figcaption aria-hidden="true">循环队列</figcaption>
</figure>
<ul>
<li>入队
<ul>
<li><code>rear = (rear + 1) % maxSize</code>;
<code>elem[rear] = x</code></li>
</ul></li>
<li>出队
<ul>
<li><code>front = (front + 1) % maxSize</code>;
<code>return elem[front]</code></li>
</ul></li>
</ul>
<p>为了解决队列空和队列满的判断问题，令 <code>front</code>
指向的单元不能存储队列元素，只能起到标志作用</p>
<ul>
<li>队列空：<code>front == rear</code></li>
<li>队列满：<code>(rear + 1) % maxSize == front</code></li>
</ul>
<h6 id="循环队列类的定义">循环队列类的定义</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqQueue</span>:<span class="hljs-keyword">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    elemType *elem;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-type">int</span> front , rear;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> initSize = <span class="hljs-number">10</span>);        <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">seqQueue</span>();                        <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;                     <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span></span>;                 <span class="hljs-comment">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-5">构造函数</h5>
<ul>
<li>申请一块空间，将 <code>front</code> 和 <code>rear</code> 初始化为
<span class="math inline">\(0\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::<span class="hljs-built_in">seqQueue</span>(<span class="hljs-type">int</span> initSize)<br>&#123;<br>  elem = <span class="hljs-keyword">new</span> elemType[initSize];<br>  maxSize = initSize;<br>  front = rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="析构函数-3">析构函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>seqQueue&lt;elemType&gt;::~<span class="hljs-built_in">seqQueue</span>()<br>&#123;<br>  <span class="hljs-keyword">delete</span>[] elem;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="enqueue"><code>enQueue</code></h5>
<ul>
<li>先判断队列是否已满，若满则调用 <code>doubleSpace</code>
扩大队列的容量</li>
<li>将 <code>rear</code> 加 1，指向队尾元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> ((rear + <span class="hljs-number">1</span>) % maxSize == front)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br>  rear = (rear + <span class="hljs-number">1</span>) % maxSize;<br>  elem[rear] = x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="doublespace-1"><code>doubleSpace</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">doubleSpace</span>()<br>&#123;<br>  elemType *tmp = elem;<br>  elem = <span class="hljs-keyword">new</span> elemType[maxSize * <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; maxSize ; ++i)<br>  &#123;<br>    elem[i] = tmp[(front + i) % maxSize];<br>  &#125;<br>  front = <span class="hljs-number">0</span>;<br>  rear = maxSize - <span class="hljs-number">1</span>;<br>  maxSize *= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">delete</span>[] tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="dequeue"><code>deQueue</code></h5>
<ul>
<li>将 <code>front</code> 加 1，指向队首元素</li>
<li>返回 <code>elem[front]</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  front = (front + <span class="hljs-number">1</span>) % maxSize;<br>  <span class="hljs-keyword">return</span> elem[front];<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="gethead"><code>getHead</code></h5>
<ul>
<li>返回 <code>elem[(front + 1) % maxSize]</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType seqQueue&lt;elemType&gt;::<span class="hljs-built_in">getHead</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> elem[(front + <span class="hljs-number">1</span>) % maxSize];<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="isempty-2"><code>isEmpty</code></h5>
<ul>
<li>判断 <code>front</code> 是否等于 <code>rear</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> seqQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> front == rear;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="队列的链接实现">队列的链接实现</h3>
<ul>
<li>为了方便操作，使用含头节点和尾节点的单链表实现</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311804800.png" srcset="/img/loading.jpeg" lazyload
alt="链接队列" />
<figcaption aria-hidden="true">链接队列</figcaption>
</figure>
<p><strong>链接队列的特点</strong></p>
<ul>
<li>不会出现队列满的情况，但是会出现队列空的情况</li>
<li>队列为空时，单链表中没有节点存在，即头尾指针都为
<code>nullptr</code></li>
<li>保存一个链接队列只需要两个分别指向单链表节点的指针
<code>front</code> 和 <code>rear</code>
<ul>
<li><code>front</code> 指向队首元素</li>
<li><code>rear</code> 指向队尾元素</li>
</ul></li>
</ul>
<h4 id="连接队列类">连接队列类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linkQueue</span>:<span class="hljs-keyword">public</span> queue&lt;elemType&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      elemType data;<br>      node *next;<br>      <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> elemType &amp;x , node *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = x;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>      ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>    &#125;;<br>    node *front , *rear;                <span class="hljs-comment">// 队头和队尾指针</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">linkQueue</span>();                       <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">linkQueue</span>();                      <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>;              <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> elemType &amp;x)</span></span>;   <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>;                <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">elemType <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 访问队首元素</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-6">构造函数</h5>
<ul>
<li>将 <code>front</code> 和 <code>rear</code> 初始化为
<code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::<span class="hljs-built_in">linkQueue</span>()<br>&#123;<br>  front = rear = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="enqueue-1"><code>enQueue</code></h5>
<ol type="1">
<li>申请一个节点空间 <code>x</code></li>
<li>将 <code>rear</code> 指向的节点的 <code>next</code> 指向
<code>x</code></li>
<li>将 <code>rear</code> 指向 <code>x</code></li>
</ol>
<p><strong>注意</strong>：存在队列为空的情况，此时我们只需要将
<code>front</code> 和 <code>rear</code> 都指向 <code>x</code> 即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> linkQueue&lt;elemType&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> elemType &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (rear == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    front = rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    rear = rear-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="dequeue-1"><code>deQueue</code></h5>
<ol type="1">
<li>返回 <code>front</code> 指向的节点的 <code>data</code></li>
<li>将 <code>front</code> 指向的节点从链表中摘下</li>
<li>释放空间</li>
</ol>
<p><strong>注意</strong>：当队列中只有一个元素时，删除后队列为空，此时需要将
<code>front</code> 和 <code>rear</code> 都置为 <code>nullptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">void</span> LinkQueue&lt;elemType&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  node *tmp = front;<br>  <span class="hljs-keyword">if</span> (front)<br>  &#123;<br>    emelType value = front-&gt;data;<br>    front = front-&gt;next;<br>    <span class="hljs-keyword">if</span> (front == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      rear = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> tmp;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="gethead-1"><code>getHead</code></h5>
<ul>
<li>返回 <code>front</code> 指向的节点的 <code>data</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>elemType linkQueue&lt;elemType&gt;::<span class="hljs-built_in">getHead</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> front-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="isempty-3"><code>isEmpty</code></h5>
<ul>
<li>判断 <code>front</code> 或 <code>rear</code> 是否为
<code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br><span class="hljs-type">bool</span> linkQueue&lt;elemType&gt;::<span class="hljs-built_in">isEmpty</span>()<br>&#123;<br>  <span class="hljs-keyword">return</span> front == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="析构函数-4">析构函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">elemType</span>&gt;<br>linkQueue&lt;elemType&gt;::~<span class="hljs-built_in">linkQueue</span>()<br>&#123;<br>  node *tmp;<br>  <span class="hljs-keyword">while</span> (front != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    tmp = front;<br>    front = front-&gt;next;<br>    <span class="hljs-keyword">delete</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="树的定义">树的定义</h3>
<h4 id="树的递归定义">树的递归定义</h4>
<ul>
<li>树是 <span class="math inline">\(n\)</span>
个节点的有限集合，它或者是空集，或者满足
<ul>
<li>有一个特殊的节点称为根节点</li>
<li>除根节点外，其他节点分为 <span class="math inline">\(m\)</span>
个互不相交的有限集合 <span class="math inline">\(T_1 , T_2 , \ldots ,
T_m\)</span>，每个集合都是一棵树</li>
</ul></li>
</ul>
<h4 id="树的术语">树的术语</h4>
<ul>
<li><strong>根节点、叶节点、内部节点</strong>：
<ul>
<li>根节点：没有父节点的节点</li>
<li>叶节点：没有子节点的节点</li>
<li>内部节点：有子节点的节点</li>
</ul></li>
<li><strong>节点的度和树的度</strong>：
<ul>
<li>节点的度：节点的子树个数</li>
<li>树的度：树中所有节点的度的最大值</li>
</ul></li>
<li><strong>儿子节点</strong></li>
<li><strong>父亲节点</strong></li>
<li><strong>兄弟节点</strong></li>
<li><strong>祖先节点</strong></li>
<li><strong>子孙节点</strong></li>
<li><strong>节点所处层次</strong></li>
<li><strong>树的高度</strong></li>
<li><strong>有序树</strong></li>
<li><strong>无序树</strong></li>
<li><strong>森林</strong></li>
</ul>
<h4 id="树的运算">树的运算</h4>
<ul>
<li><strong>建树 <code>create()</code></strong>：创建一个空树</li>
<li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li>
<li><strong>判空 <code>IsEmpty()</code></strong>：判断是否为空树</li>
<li><strong>找根节点
<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li>
<li><strong>找父节点
<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li>
<li><strong>找子节点
<code>child()</code></strong>：找到节点的某个子节点，若该节点不存在或没有子节点则返回特殊值</li>
<li><strong>剪枝 <code>remove()</code></strong>：删除节点的某棵子树</li>
<li><strong>遍历
<code>traverse()</code></strong>：访问树上的每个节点</li>
</ul>
<h4 id="树的抽象类">树的抽象类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tree</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">child</span><span class="hljs-params">(T x , <span class="hljs-type">int</span> i , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树">二叉树</h3>
<h4 id="二叉树的定义">二叉树的定义</h4>
<ul>
<li>二叉树（Binary
Tree）是节点的有限集合，要么为空，要么由一个根节点以及两棵互不相交的左右子树构成，而其左右子树也是二叉树</li>
</ul>
<p><strong>注意</strong>：二叉树是<strong>有序树</strong>，必须严格区分左右子树，即使只有一棵子树也要说明是左子树还是右子树，交换左右子树得到另一棵二叉树</p>
<p>二叉树有五种基本形态</p>
<ol type="1">
<li>空树</li>
<li>只有一个节点的树</li>
<li>只有左子树的树</li>
<li>只有右子树的树</li>
<li>左右子树都有的树</li>
</ol>
<h5 id="满二叉树">满二叉树</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311916690.png" srcset="/img/loading.jpeg" lazyload
alt="满二叉树" />
<figcaption aria-hidden="true">满二叉树</figcaption>
</figure>
<ul>
<li>每个节点的度都为 <span class="math inline">\(0\)</span> 或 <span
class="math inline">\(2\)</span> 的二叉树称为满二叉树</li>
<li>性质
<ul>
<li>高度为 <span class="math inline">\(h\)</span> 的满二叉树有 <span
class="math inline">\(2^h - 1\)</span> 个节点</li>
<li>任意一层的节点个数达到了上限 <span
class="math inline">\(2^{n-1}\)</span></li>
</ul></li>
</ul>
<h5 id="完全二叉树">完全二叉树</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202503311917668.png" srcset="/img/loading.jpeg" lazyload
alt="完全二叉树" />
<figcaption aria-hidden="true">完全二叉树</figcaption>
</figure>
<ul>
<li>在满二叉树的最底层从右向左依次删除若干个节点得到的树为完全二叉树</li>
<li>满二叉树是完全二叉树，完全二叉树不一定是满二叉树</li>
<li>性质
<ul>
<li>所有的叶节点都出现在最低的两层生</li>
<li>对于任意节点，如果其右子树的高度为 <span
class="math inline">\(h\)</span>，则其左子树的高度为 <span
class="math inline">\(h\)</span> 或 <span
class="math inline">\(h+1\)</span></li>
</ul></li>
</ul>
<h4 id="二叉树的性质">二叉树的性质</h4>
<ol type="1">
<li>二叉树的第 <span class="math inline">\(i\)</span> 层最多有 <span
class="math inline">\(2^{i-1}\)</span> 个节点</li>
<li>二叉树的深度为 <span class="math inline">\(h\)</span>，则最多有
<span class="math inline">\(2^h - 1\)</span> 个节点</li>
<li>对于一棵非空二叉树，若其叶节点个数为 <span
class="math inline">\(n_0\)</span>，则其度为 <span
class="math inline">\(2\)</span> 的节点个数为 <span
class="math inline">\(n_2\)</span>，则有 <span class="math inline">\(n_0
= n_2 + 1\)</span></li>
<li>具有 <span class="math inline">\(n\)</span> 个节点的二叉树的高度为
<span class="math inline">\(h\)</span>，则 <span class="math inline">\(h
= \lfloor \log_2n \rfloor +1\)</span></li>
<li>对于一棵具有 <span class="math inline">\(n\)</span>
个节点的完全二叉树中的节点按层自上而下，每层从左到右编号，若设根节点的编号为
<span class="math inline">\(1\)</span>，则对任一编号为 <span
class="math inline">\(u\)</span> 的节点，有
<ol type="1">
<li>如果 <span class="math inline">\(i=1\)</span>，则 <span
class="math inline">\(u\)</span> 为根节点</li>
<li>如果 <span class="math inline">\(i&gt;1\)</span>，则 <span
class="math inline">\(u\)</span> 的父节点编号为 <span
class="math inline">\(\lfloor \frac{u}{2} \rfloor\)</span></li>
<li>如果 <span class="math inline">\(2i \geq n\)</span>，则编号为 <span
class="math inline">\(i\)</span>
的节点为叶子节点，没有儿子；否则，其左子编号为 <span
class="math inline">\(2i\)</span></li>
<li>如果 <span class="math inline">\(2i+1 \geq n\)</span>，则编号为
<span class="math inline">\(i\)</span>
的节点无右儿子；否则，其右子编号为 <span
class="math inline">\(2i+1\)</span></li>
</ol></li>
</ol>
<h4 id="二叉树的基本运算">二叉树的基本运算</h4>
<ul>
<li><strong>建树 <code>create()</code></strong>：创建一棵空树</li>
<li><strong>清空 <code>clear()</code></strong>：删除树中所有节点</li>
<li><strong>判空 <code>isEmpty()</code></strong>：判断是否为空树</li>
<li><strong>找根节点
<code>root()</code></strong>：找出树的根节点值，若为空树则返回特殊值</li>
<li><strong>找父节点
<code>parent()</code></strong>：找到节点的父节点，若该节点不存在或为根节点则返回特殊值</li>
<li><strong>找左子节点
<code>lchild()</code></strong>：找到节点的左子节点，若该节点不存在或没有左子节点则返回特殊值</li>
<li><strong>找右子节点
<code>rchild()</code></strong>：找到节点的右子节点，若该节点不存在或没有右子节点则返回特殊值</li>
<li><strong>删除左子树
<code>delLeft()</code></strong>：删除节点的左子树</li>
<li><strong>删除右子树
<code>delRight()</code></strong>：删除节点的右子树</li>
<li><strong>遍历
<code>traverse()</code></strong>：访问树上的每个节点</li>
</ul>
<h4 id="二叉树的遍历">二叉树的遍历</h4>
<h5 id="前序遍历">前序遍历</h5>
<ul>
<li>如果树为空，则操作为空</li>
<li>如果树不空，则访问根节点，然后前序遍历左子树，最后前序遍历右子树</li>
</ul>
<h5 id="中序遍历">中序遍历</h5>
<ul>
<li>如果树为空，则操作为空</li>
<li>如果树不空，则中序遍历左子树，然后访问根节点，最后中序遍历右子树</li>
</ul>
<h5 id="后序遍历">后序遍历</h5>
<ul>
<li>如果树为空，则操作为空</li>
<li>如果树不空，则后序遍历左子树，然后后序遍历右子树，最后访问根节点</li>
</ul>
<h5 id="层次遍历">层次遍历</h5>
<ul>
<li>从上到下，从左到右访问树的每个节点</li>
</ul>
<h5 id="性质">性质</h5>
<ul>
<li>由前序遍历和中序遍历可以唯一确定一棵二叉树</li>
<li>由中序遍历和后序遍历可以唯一确定一棵二叉树</li>
<li>由前序遍历和后序遍历<strong>不能</strong>唯一确定一棵二叉树</li>
</ul>
<h4 id="二叉树抽象类">二叉树抽象类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;             <span class="hljs-comment">// 找根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">parent</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找父节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">lchild</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找左子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">rchild</span><span class="hljs-params">(T x , T flag)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 找右子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;                <span class="hljs-comment">// 删除左子树</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(T x)</span> </span>= <span class="hljs-number">0</span>;               <span class="hljs-comment">// 删除右子树</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;            <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;           <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;          <span class="hljs-comment">// 层次遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="二叉树的实现">二叉树的实现</h4>
<h5 id="二叉树的顺序实现">二叉树的顺序实现</h5>
<ul>
<li>使用数组来存储二叉树中的节点</li>
<li>将二叉树补全为完全二叉树再进行存储</li>
<li>会导致空间浪费</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504031058255.png" srcset="/img/loading.jpeg" lazyload
alt="顺序二叉树" />
<figcaption aria-hidden="true">顺序二叉树</figcaption>
</figure>
<h5 id="二叉树的链接实现">二叉树的链接实现</h5>
<ul>
<li>使用链表来存储二叉树中的节点
<ul>
<li>标准形式：<code>left</code>，<code>data</code>，<code>right</code></li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445826.png" srcset="/img/loading.jpeg" lazyload
alt="标准形式" />
<figcaption aria-hidden="true">标准形式</figcaption>
</figure>
<ul>
<li>广义标准形式：<code>data</code>，<code>left</code>，<code>parent</code>，<code>right</code></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504041445472.png" srcset="/img/loading.jpeg" lazyload
alt="广义标准形式" />
<figcaption aria-hidden="true">广义标准形式</figcaption>
</figure>
<h4 id="二叉树类">二叉树类</h4>
<h5 id="节点类">节点类</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    Node *left *right;                                                                <span class="hljs-comment">// 左右子树指针</span><br>    T data;                                                                           <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;                                             <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Node</span>(T item , Node *L = <span class="hljs-literal">nullptr</span>,Node *R = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(item),<span class="hljs-built_in">left</span>(L),<span class="hljs-built_in">right</span>(R)&#123;&#125;  <span class="hljs-comment">// 带参数的构造函数</span><br>    ~<span class="hljs-built_in">Node</span>()&#123;&#125;                                                                         <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="二叉树类-1">二叉树类</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binaryTree</span>:<span class="hljs-keyword">public</span> tree&lt;T&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(<span class="hljs-type">const</span> binaryTree &amp;t, t flag)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>      <span class="hljs-keyword">public</span>:<br>        Node *left *right;<br>        T data;<br>        <span class="hljs-built_in">Node</span>():<span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(T item , Node *L = <span class="hljs-literal">nullptr</span>,Node *R = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(item),<span class="hljs-built_in">left</span>(L),<span class="hljs-built_in">right</span>(R)&#123;&#125;<br>        ~<span class="hljs-built_in">Node</span>()&#123;&#125;<br>    &#125;<br>    Node *root;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">binaryTree</span>():<span class="hljs-built_in">root</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;                    <span class="hljs-comment">// 构造函数,创建空树</span><br>    <span class="hljs-built_in">binaryTree</span>(T x):<span class="hljs-built_in">root</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x))&#123;&#125;             <span class="hljs-comment">// 构造函数,创建只有根节点的树</span><br>    ~<span class="hljs-built_in">binaryTree</span>()&#123;&#125;                                 <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;                                   <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                           <span class="hljs-comment">// 是否为空</span><br>    <span class="hljs-function">T <span class="hljs-title">Root</span><span class="hljs-params">(T flag)</span> <span class="hljs-type">const</span></span>;                           <span class="hljs-comment">// 找根节点</span><br>    <span class="hljs-function">T <span class="hljs-title">lchild</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 找左子节点</span><br>    <span class="hljs-function">T <span class="hljs-title">rchild</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 找右子节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delLeft</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;                       <span class="hljs-comment">// 删除左子树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delRight</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>;                      <span class="hljs-comment">// 删除右子树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                          <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                          <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                         <span class="hljs-comment">// 后序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;                        <span class="hljs-comment">// 层次遍历</span><br>    <span class="hljs-function">coid <span class="hljs-title">creatTree</span><span class="hljs-params">(T flag)</span></span>;                         <span class="hljs-comment">// 创建树</span><br>    <span class="hljs-function">T <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x , T flag)</span> <span class="hljs-type">const</span>             <span class="hljs-comment">// 找父节点</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x, Node *t)</span> <span class="hljs-type">const</span></span>;            <span class="hljs-comment">// 查找节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(Node *&amp;x)</span></span>;                             <span class="hljs-comment">// 清空</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                     <span class="hljs-comment">// 前序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                     <span class="hljs-comment">// 中序遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node *t)</span> <span class="hljs-type">const</span></span>;                    <span class="hljs-comment">// 后序遍历</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-7">构造函数</h5>
<p>将 <code>root</code> 初始化为 <code>nullptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>binaryTree&lt;T&gt;::<span class="hljs-built_in">binaryTree</span>()<br>&#123;<br>  root = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="isempty-4"><code>isEmpty</code></h5>
<ul>
<li>判断 <code>root</code> 是否为 <code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">bool</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">isEmpty</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> root == <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="root"><code>Root</code></h5>
<p>返回 <code>Root</code> 指向的节点的数据，若为空树则返回特殊值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">Root</span>(T flag)<span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> root-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="二叉树的遍历-1">二叉树的遍历</h5>
<h6 id="前序遍历-1">前序遍历</h6>
<ol type="1">
<li>访问根节点</li>
<li>前序遍历左子树</li>
<li>前序遍历右子树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(t -&gt; left);<br>    <span class="hljs-built_in">preorder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n前序遍历：&quot;</span><br>  <span class="hljs-built_in">preOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="中序遍历-1">中序遍历</h6>
<ol type="1">
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">midOrder</span>(t -&gt; left);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">midOrder</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n中序遍历：&quot;</span><br>  <span class="hljs-built_in">midOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="后序遍历-1">后序遍历</h6>
<ol type="1">
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">postOrder</span>(t -&gt; left);<br>    <span class="hljs-built_in">postOrder</span>(t -&gt; right);<br>    cout &lt;&lt; t -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n后序遍历：&quot;</span><br>  <span class="hljs-built_in">postOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="size"><code>size</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;t&gt;::<span class="hljs-built_in">size</span>(binarytree&lt;t&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t = <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">sizze</span>(t -&gt; left)+<span class="hljs-built_in">size</span>(t -&gt; right);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="height"><code>height</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">size</span>(binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-type">int</span> lt = <span class="hljs-built_in">height</span>(t -&gt; left);<br>    <span class="hljs-type">int</span> rt = <span class="hljs-built_in">height</span>(t -&gt; right);<br>    <span class="hljs-keyword">return</span> (lt &gt; rt ? lt : rt) + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">height</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="层次遍历-1">层次遍历</h5>
<ul>
<li>使用链接队列实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">levelOrder</span>() <span class="hljs-type">const</span><br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n层次遍历：&quot;</span>;<br>  que.<span class="hljs-built_in">enQueue</span>(root);<br>  <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = que.<span class="hljs-built_in">deQueue</span>();<br>    cout &lt;&lt; tmp -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span> (tmp.left)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp.right)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="clear-1"><code>clear</code></h5>
<ul>
<li>递归删除树中所有节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">clear</span>(Node *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">clear</span>(t -&gt; left);<br>    <span class="hljs-built_in">clear</span>(t -&gt; right);<br>    <span class="hljs-keyword">delete</span> t;<br>    t = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">clear</span>()<br>&#123;<br>  <span class="hljs-built_in">clear</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="析构函数-5">析构函数</h5>
<ul>
<li>调用 <code>clear</code> 函数删除树中所有节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>binaryTree&lt;T&gt;::~<span class="hljs-built_in">binaryTree</span>()<br>&#123;<br>  <span class="hljs-built_in">clear</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="find"><code>Find</code></h5>
<ul>
<li>使用前序遍历查找 <code>x</code> 节点</li>
<li>首先检查根节点是否存放 <code>x</code>
的值，若是则返回根节点地址</li>
<li>对左子树递归调用 <code>Find</code> 函数，若返回空指针则说明
<code>x</code> 不在左子树中</li>
<li>对右子树递归调用 <code>Find</code> 函数，若返回空指针则说明
<code>x</code> 不在右子树中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">binaryTree</span>&lt;T&gt;:: Node *binaryTree&lt;T&gt;::<span class="hljs-built_in">Find</span>(<span class="hljs-type">const</span> T &amp;x ,binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t -&gt; data == x)<br>  &#123;<br>    <span class="hljs-keyword">return</span> t;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (tmp = <span class="hljs-built_in">Find</span>(x,t-&gt;left))<br>    &#123;<br>      <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(x,t-&gt;right);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="delleft"><code>delLeft</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">delLeft</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root);<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">clear</span>(tmp -&gt; left);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="delright"><code>delRight</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">delRight</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root);<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">clear</span>(tmp -&gt; right);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="lchild"><code>lchild</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">lchild</span>(<span class="hljs-type">const</span> T &amp;x ,T flag) <span class="hljs-type">const</span><br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root)<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span> || tmp -&gt; left ==<span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> tmp -&gt; left;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="rchild"><code>rchild</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T binaryTree&lt;T&gt;::<span class="hljs-built_in">rchild</span>(<span class="hljs-type">const</span> T &amp;x ,T flag) <span class="hljs-type">const</span><br>&#123;<br>  Node *tmp = <span class="hljs-built_in">Find</span>(x,root)<br>  <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">nullptr</span> || tmp -&gt; right ==<span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> tmp -&gt; right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="createtree"><code>createTree</code></h5>
<ul>
<li>创建过程（类似层次遍历？）
<ol type="1">
<li>输入根节点的值，创建根节点</li>
<li>对已添加到树上的每个节点，依次输入它的两个儿子的值，若没有儿子则输入
<code>flag</code></li>
</ol></li>
<li>实现过程
<ul>
<li>使用队列，将新加入到书中的节点添加到队列中</li>
<li>依次出队，对每个出队的元素输入它的儿子</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">createTree</span>(T flag)<br>&#123;<br>  linkQueue&lt;Node *&gt; que;<br>  Node *tmp;<br>  T x , ldata , rdata;<br><br>  <span class="hljs-comment">// 创建树，flag表示空</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n输入根节点：&quot;</span><br>  cin &gt;&gt; x;<br>  root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x);<br>  que.<span class="hljs-built_in">enQueue</span>(root);<br>  <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = que,<span class="hljs-built_in">deQueue</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n输入&quot;</span> &lt;&lt; tmp -&gt; data &lt;&lt; <span class="hljs-string">&quot;的两个儿子（&quot;</span>&lt;&lt;flag&lt;&lt;<span class="hljs-string">&quot;表示空节点）：&quot;</span>;<br>    cin &gt;&gt; ldata &gt;&gt; rdata;<br>    <span class="hljs-keyword">if</span> (ldata != flag)<br>    &#123;<br>      tmp -&gt; left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(ldata);<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rdata != flag)<br>    &#123;<br>      tmp -&gt; right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(rdata);<br>      que.<span class="hljs-built_in">enQueue</span>(tmp -&gt; right);<br>    &#125;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;that&#x27;s good!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="printtree"><code>printTree</code></h5>
<ul>
<li>层次遍历输出每个节点和它的左右孩子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTree</span><span class="hljs-params">(<span class="hljs-type">const</span> binaryTree&lt;T&gt; &amp;t,T flag)</span></span><br><span class="hljs-function"></span>&#123;<br>  linkQueue&lt;T&gt; que;<br>  que.<span class="hljs-built_in">enQueue</span>(t.<span class="hljs-built_in">root</span>());<br>  <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    T tmp = que.<span class="hljs-built_in">deQueue</span>();<br>    T l = tmp.<span class="hljs-built_in">lchild</span>(tmp , flag);<br>    T r = tmp.<span class="hljs-built_in">rchild</span>(tmp , flag);<br>    cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (l != flag)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(l);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r != flag)<br>    &#123;<br>      que.<span class="hljs-built_in">enQueue</span>(r);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二叉树遍历的非递归实现">二叉树遍历的非递归实现</h4>
<h5 id="前序遍历-2">前序遍历</h5>
<ol type="1">
<li>将根节点入栈</li>
<li>栈顶元素出栈并输出值</li>
<li>将左右子树入栈（先右后左，以便输出时先输出左子树）</li>
<li>循环直至栈为空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">preOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  Node *tmp = t;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n前序遍历：&quot;</span>;<br>  <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    tmp = s.<span class="hljs-built_in">pop</span>();<br>    cout &lt;&lt; tm -&gt; data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span> (tmp -&gt; right != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp -&gt; right);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tmp -&gt; left != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(tmp -&gt; left);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="中序遍历-2">中序遍历</h5>
<ol type="1">
<li>根节点入栈</li>
<li>左子树入栈</li>
<li>栈顶元素出栈并输出值</li>
<li>左子树出栈完成之后根节点出栈</li>
<li>右子树入栈</li>
<li>循环直至栈为空</li>
</ol>
<p>栈的设计</p>
<ul>
<li>根节点入栈出栈两次
<ul>
<li>第一次出栈时不能被访问，立刻重新入栈，并将左子树入栈</li>
<li>第二次出栈后返回值，并且将右子树入栈</li>
</ul></li>
<li>对于根节点要记住
<ul>
<li>在哪棵树上</li>
<li>第几次出栈</li>
</ul></li>
<li>每个节点在某种意义上都是根节点</li>
</ul>
<h6 id="stnode-类定义"><code>StNode</code> 类定义</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StNode</span><br>&#123;<br>  Node *node;<br>  <span class="hljs-type">int</span> TimesPop;<br>  <span class="hljs-built_in">StNode</span>(Node *N=<span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">node</span>(N),<span class="hljs-built_in">TimesPop</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h6 id="中序遍历的非递归实现">中序遍历的非递归实现</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">midOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *t&gt; s;<br>  <span class="hljs-function">StNode <span class="hljs-title">current</span><span class="hljs-params">(root)</span></span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n中序遍历：&quot;</span>;<br>  s.<span class="hljs-built_in">push</span>(current);<br>  <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (++current.TimesPop == <span class="hljs-number">2</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class="hljs-keyword">if</span> (current.node -&gt; right != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; right));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(current);<br>      <span class="hljs-keyword">if</span> (current.node -&gt; left != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="后序遍历-2">后序遍历</h5>
<ol type="1">
<li>根节点入栈</li>
<li>左子树入栈</li>
<li>右子树入栈</li>
<li>栈顶元素出栈并输出值</li>
<li>循环直至栈为空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> binaryTree&lt;T&gt;::<span class="hljs-built_in">postOrder</span>(<span class="hljs-type">const</span> binaryTree&lt;T&gt;::Node *t) <span class="hljs-type">const</span><br>&#123;<br>  linkStack&lt;Node *&gt; s;<br>  <span class="hljs-function">StNode <span class="hljs-title">current</span><span class="hljs-params">(root)</span></span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n后序遍历：&quot;</span>;<br>  s.<span class="hljs-built_in">push</span>(current);<br>  <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = s.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (++current.TimesPop == <span class="hljs-number">3</span>)<br>    &#123;<br>      cout &lt;&lt; current.node -&gt; data;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      s.<span class="hljs-built_in">push</span>(current);<br>      <span class="hljs-keyword">if</span> (current.node -&gt; right != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; right));<br>      &#125;<br>      <span class="hljs-keyword">if</span> (current.node -&gt; left != <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">StNode</span>(current.node -&gt; left));<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h3>
<h4 id="字符的机内表示">字符的机内表示</h4>
<ul>
<li>用二进制数来表示字符</li>
<li>前缀编码
<ul>
<li>字符只放在叶结点中</li>
<li>字符编码可以有不同的长度</li>
<li>每个字符的编码都不可能是其他字符编码的前缀</li>
<li>可以被唯一解码</li>
</ul></li>
</ul>
<h4 id="哈夫曼树">哈夫曼树</h4>
<ul>
<li>最小代价，即带权路径长度最小的二叉树</li>
<li>所有字符都在叶结点上</li>
<li>权值大的字符离根节点近，权值小的字符离根节点远</li>
<li>哈夫曼编码是一种前缀编码</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141528425.png" srcset="/img/loading.jpeg" lazyload
alt="huffmanTree" />
<figcaption aria-hidden="true">huffmanTree</figcaption>
</figure>
<h4 id="哈夫曼算法">哈夫曼算法</h4>
<ol type="1">
<li>给定一个具有 <span class="math inline">\(n\)</span> 个权值 <span
class="math inline">\(\{w_1 , w_2 , \ldots , w_4\}\)</span> 的节点的集合
<span class="math inline">\(\mathbb{A}\)</span> <span
class="math inline">\(\mathbb{F} = \{T_1 , T_2 , \ldots ,
T_n\}\)</span></li>
<li>初始时，设集合 <span class="math inline">\(\mathbb{A} =
\mathbb{F}\)</span></li>
<li>执行从 <span class="math inline">\(i\)</span> 到 <span
class="math inline">\(n-1\)</span> 的循环
<ol type="1">
<li>从当前集合中选取权值最小、次最小的两个节点，以这两个节点作为内部节点
<span class="math inline">\(b_i\)</span> 的左右儿子，<span
class="math inline">\(b_i\)</span> 的权值为这两个节点的权值之和</li>
<li>集合中去除这两个节点，将 <span class="math inline">\(b_i\)</span>
加入其中</li>
</ol></li>
<li>循环结束后，集合 <span
class="math inline">\(\mathbb{A}\)</span>中只剩下一个节点 <span
class="math inline">\(b_n\)</span>，即为哈夫曼树的根节点</li>
</ol>
<h4 id="哈夫曼编码">哈夫曼编码</h4>
<ul>
<li>每个节点的编码是从根节点到该节点的路径</li>
<li>左子树为 <code>0</code>，右子树为 <code>1</code></li>
</ul>
<h4 id="哈夫曼树类的实现">哈夫曼树类的实现</h4>
<ol type="1">
<li>接受一组符号以及对应的权值,并返回每个符号对应的哈夫曼编码</li>
<li>有两个公有的成员函数
<ol type="1">
<li>构造函数：接受一组待编码的符号以及它们的权值，构造哈夫曼树</li>
<li><code>getCode</code>：根据保存的哈夫曼树，返回每个符号对应的哈夫曼编码</li>
</ol></li>
</ol>
<h5 id="哈夫曼树的存储">哈夫曼树的存储</h5>
<ul>
<li>在哈夫曼树中，每个要编码的元素都是一个叶节点，其余的节点都是度为
<span class="math inline">\(2\)</span> 的节点</li>
<li>若待编码的元素个数为 <span
class="math inline">\(n\)</span>，则哈夫曼树的节点数为 <span
class="math inline">\(2n-1\)</span></li>
<li>哈夫曼树使用一个大小为 <span class="math inline">\(2n\)</span>
的数组来存储，不使用 <span class="math inline">\(0\)</span>
节点，将根节点存储在下标为 <span class="math inline">\(1\)</span>
的位置，叶节点依次存储在下标为 <span class="math inline">\(n+1\)</span>
到 <span class="math inline">\(2n\)</span> 的位置，<span
class="math inline">\(0\)</span> 结点作为结束的判断依据</li>
<li>每个数组保存
<strong>节点的数据</strong>，<strong>节点的权值</strong>，<strong>节点的父节点下标</strong>，<strong>左子节点下标</strong>，<strong>右子节点下标</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hfTree</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>      Type data; <span class="hljs-comment">//节点数据</span><br>      <span class="hljs-type">int</span> weight; <span class="hljs-comment">//节点权值</span><br>      <span class="hljs-type">int</span> parent; <span class="hljs-comment">//父节点下标</span><br>      <span class="hljs-type">int</span> left , right; <span class="hljs-comment">//左右子节点下标</span><br>    &#125;;<br><br>    Node *elem;<br>    <span class="hljs-type">int</span> length;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hfCode</span><br>    &#123;<br>      Type data; <span class="hljs-comment">//节点数据</span><br>      string code; <span class="hljs-comment">//哈夫曼编码</span><br>    &#125;;<br><br>    <span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *v , <span class="hljs-type">const</span> <span class="hljs-type">int</span> *w , <span class="hljs-type">int</span> size);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getCode</span><span class="hljs-params">(hfCode result[])</span></span>;<br>    ~<span class="hljs-built_in">hfTree</span>()<br>    &#123;<br>      <span class="hljs-keyword">delete</span> [] elem;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h5 id="构造函数-8">构造函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br>hfTree&lt;Type&gt;::<span class="hljs-built_in">hfTree</span>(<span class="hljs-type">const</span> Type *v , <span class="hljs-type">const</span> <span class="hljs-type">int</span> *w , <span class="hljs-type">int</span> size)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_INT = <span class="hljs-number">32767</span>;<br>  <span class="hljs-type">int</span> min1 , min2; <span class="hljs-comment">// 最小树、次最小树的权值</span><br>  <span class="hljs-type">int</span> x , y ; <span class="hljs-comment">// 最小树、次最小树的下标</span><br><br>  <span class="hljs-comment">/* 初始化 */</span><br>  length = <span class="hljs-number">2</span> * size ;                                            <span class="hljs-comment">// 哈夫曼树的节点数为 $2\text&#123;size&#125;-1$，但我们只需要存储 $2\text&#123;size&#125;$ 个节点</span><br>  elem = <span class="hljs-keyword">new</span> Node[length];                                       <span class="hljs-comment">// 创建一个大小为 $2\text&#123;size&#125;$ 的数组来存储哈夫曼树的节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; i &lt; length ; i++)                          <span class="hljs-comment">// 对数组 `elem` 中的节点进行初始化，前 $\text&#123;size&#125;$ 个节点存储待编码的元素，从下标 `size` 开始，依次存储待编码的元素的权值</span><br>  &#123;<br>    elem[i].weight = w[i-size]; <span class="hljs-comment">// 储存权值</span><br>    elem[i].data = v[i-size]; <span class="hljs-comment">// 储存待编码的元素</span><br>    elem[i].parent = elem[i].left = elem[i].right = <span class="hljs-number">0</span>;           <span class="hljs-comment">// 初始化父节点、左子节点和右子节点的下标为 `0`</span><br>  &#125;<br><br>  <span class="hljs-comment">/* 构造新的二叉树 */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size - <span class="hljs-number">1</span> ; i &gt; <span class="hljs-number">0</span> ; i--)                           <span class="hljs-comment">// 从下标为 `size-1` 的节点开始，依次向上构造哈夫曼树的节点</span><br>  &#123;<br>    min1 = min2 = MAX_INT;                                       <span class="hljs-comment">// 初始化这两个变量为一个很大的值，以确保能够找到真正最小和次小的权值</span><br>    x = y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span> ; j &lt; length ; j++)                       <span class="hljs-comment">// 遍历当前节点之后的所有节点</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (elem[j].parent == <span class="hljs-number">0</span>)                                   <span class="hljs-comment">// 判断是否未加入树中</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (elem[j].weight &lt; min1)                               <span class="hljs-comment">// 找到真正的最小值和次小值以及他们对应的下标</span><br>        &#123;<br>          min2 = min1;<br>          min1 = elem[j].weight;<br>          x = y;<br>          y = j;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(elem[j].weight &lt; min2)<br>        &#123;<br>          min2 = elem[j].weight;<br>          x = j;<br>        &#125;<br>      &#125;<br>    &#125;<br>    elem[i].weight = min1 + min2;                                <span class="hljs-comment">// 将最小值和次小值的权值相加，作为当前节点的权值</span><br>    elem[i].left = x;                                            <span class="hljs-comment">// 将最小值的节点作为当前节点的左子节点</span><br>    elem[i].right = y;                                           <span class="hljs-comment">// 将次小值的节点作为当前节点的右子节点</span><br>    elem[x].parent = i;                                          <span class="hljs-comment">// 将当前节点作为最小值节点的父节点</span><br>    elem[y].parent = i;                                          <span class="hljs-comment">// 将当前节点作为次小值节点的父节点</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="getcode"><code>getCode</code></h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Type</span>&gt;<br><span class="hljs-type">void</span> hdTree&lt;Type&gt;::<span class="hljs-built_in">getcode</span>(hfCode result[])<br>&#123;<br>  <span class="hljs-type">int</span> size = length / <span class="hljs-number">2</span> ;<br>  <span class="hljs-type">int</span> p , s ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &lt; length; ++i)<br>  &#123;<br>    result[i -size].data = elem[i].data;<br>    result[i -size].code = <span class="hljs-string">&quot;&quot;</span>;<br>    p = elem[i].parent; s = i;<br>    <span class="hljs-keyword">while</span> (p)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (elem[p].left == s)<br>      &#123;<br>        result[i -size].code = <span class="hljs-string">&#x27;0&#x27;</span> + result[i -size].code;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        result[i -size].code = <span class="hljs-string">&#x27;1&#x27;</span> + result[i -size].code;<br>      &#125;<br>      s = p;<br>      p = elem[p].parent;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="树和森林">树和森林</h3>
<h4 id="树的存储实现">树的存储实现</h4>
<ul>
<li><strong>标准形式</strong>：除了数据字段之外，还有 <span
class="math inline">\(K\)</span> 个指针字段，指向 <span
class="math inline">\(K\)</span> 个孩子节点，其中 <span
class="math inline">\(K\)</span> 是树的度</li>
<li><strong>广义标准形式</strong>：除了数据字段之外，还有 <span
class="math inline">\(K\)</span> 个指针字段，指向 <span
class="math inline">\(K\)</span>
个孩子节点和一个指针字段，指向父节点</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211450009.png" srcset="/img/loading.jpeg" lazyload
alt="树的存储实现" />
<figcaption aria-hidden="true">树的存储实现</figcaption>
</figure>
<h4 id="树的表示方法">树的表示方法</h4>
<h5 id="孩子链表示法">孩子链表示法</h5>
<ul>
<li><p>每个节点的所有孩子组织成一个链表</p></li>
<li><p>节点由两个部分组成</p>
<ul>
<li>储存数据元素值的数据部分</li>
<li>指向孩子链的指针</li>
</ul></li>
<li><p><strong>静态</strong>的孩子链表：树的所有节点存放在一个名叫表头数组的<strong>数组</strong>中</p></li>
<li><p><strong>动态</strong>的孩子链表：树的所有节点组织成一个<strong>链表</strong></p></li>
</ul>
<h5 id="孩子兄弟链表示法">孩子兄弟链表示法</h5>
<ul>
<li>将一棵树转化为二叉树</li>
<li>左子树指向第一颗子树树根的指针</li>
<li>右子树指向兄弟节点的指针</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504211559361.png" srcset="/img/loading.jpeg" lazyload
alt="孩子兄弟链" />
<figcaption aria-hidden="true">孩子兄弟链</figcaption>
</figure>
<h5 id="双亲表示法">双亲表示法</h5>
<ul>
<li>每一个节点由两个部分组成
<ul>
<li>储存数据元素的数据字段</li>
<li>储存父节点的父指针字段</li>
</ul></li>
<li>便于查找节点的祖先，但是不便于查找指定节点的子孙</li>
</ul>
<h3 id="树的遍历">树的遍历</h3>
<h4 id="前序遍历-3">前序遍历</h4>
<ol type="1">
<li>访问根节点</li>
<li>依次前序遍历所有子树</li>
</ol>
<h4 id="后序遍历-3">后序遍历</h4>
<ol type="1">
<li>依次后序遍历所有子树</li>
<li>访问根节点</li>
</ol>
<h4 id="层次遍历-2">层次遍历</h4>
<ol type="1">
<li>访问根节点</li>
<li>若第 <span class="math inline">\(i\)</span> 层已被访问，且第 <span
class="math inline">\(i+1\)</span>
层的结点尚未被访问，则从左到右依次访问第 <span
class="math inline">\(i+1\)</span> 层的结点</li>
</ol>
<h4 id="特点">特点</h4>
<ul>
<li>树的前序遍历和用儿子兄弟链表示法转化的二叉树的前序遍历是相同的</li>
<li>树的后序遍历和用儿子兄弟链表示法转化的二叉树的中序遍历是相同的</li>
</ul>
<p>由前序遍历和后序遍历可以唯一确定一棵树</p>
<h3 id="树森林和二叉树">树、森林和二叉树</h3>
<h4 id="森林的定义">森林的定义</h4>
<ul>
<li>森林通常被定义为树的集合或树的序列</li>
<li>存储
<ul>
<li>存储森林的每一棵树</li>
<li>表示这些树属于同一个森林</li>
</ul></li>
</ul>
<h4 id="森林的二叉树存储">森林的二叉树存储</h4>
<ol type="1">
<li>将每棵树 <span class="math inline">\(T_i\)</span> 转化为二叉树 <span
class="math inline">\(B_i\)</span></li>
<li>将 <span class="math inline">\(B_i\)</span> 作为 <span
class="math inline">\(B_{i-1}\)</span> 根节点的右子树</li>
</ol>
<h2 id="优先级队列">优先级队列</h2>
<h3 id="优先级队列的定义">优先级队列的定义</h3>
<ul>
<li>节点之间的关系是由节点的优先级决定的</li>
<li>优先级高的先出队，优先级低的后出队</li>
<li>继承于队列的抽象类</li>
</ul>
<h3 id="优先级队列的简单实现">优先级队列的简单实现</h3>
<ol type="1">
<li>入队时进行排序，出队操作不变 入队时间复杂度为 <span
class="math inline">\(O(n)\)</span>，出队时间复杂度为 <span
class="math inline">\(O(1)\)</span></li>
<li>出队时进行排序，入队操作不变 入队时间复杂度为 <span
class="math inline">\(O(1)\)</span>，出队时间复杂度为 <span
class="math inline">\(O(n)\)</span></li>
</ol>
<h3 id="二叉堆">二叉堆</h3>
<ul>
<li>二叉堆是一个完全二叉树</li>
<li>二叉堆满足下述关系之一（下标是按层次遍历的次序）
<ol type="1">
<li><strong>最大化堆</strong>：<span class="math inline">\(k_i &gt;
k_{2i},\quad k_i &gt; k{2i+1} \quad (i = 1,2,\ldots,\lfloor
\frac{n}{2}\rfloor\)</span></li>
<li><strong>最小化堆</strong>：<span class="math inline">\(k_i &lt;
k_{2i},\quad k_i &lt; k{2i+1} \quad (i = 1,2,\ldots,\lfloor
\frac{n}{2}\rfloor)\)</span></li>
</ol></li>
<li>后面的讨论都以最小化堆为例</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504081709343.png" srcset="/img/loading.jpeg" lazyload
alt="binaryHeap" />
<figcaption aria-hidden="true">binaryHeap</figcaption>
</figure>
<h4 id="二叉堆的特性">二叉堆的特性</h4>
<ul>
<li><strong>结构性</strong>
<ul>
<li>符合完全二叉树的结构</li>
</ul></li>
<li><strong>有序性</strong>
<ul>
<li>父节点小于子节点（最小化堆）</li>
<li>父节点大于子节点（最大化堆）</li>
</ul></li>
</ul>
<h3 id="基于二叉堆的优先级队列">基于二叉堆的优先级队列</h3>
<ul>
<li>如果数值越小，优先级越高，则可以用一个最小化堆存储优先级队列</li>
<li>最小化堆中，最小元素为根元素，存放在数组下标为 <code>1</code> 的位置
<ul>
<li>获取队头元素的操作为返回下标为 <code>1</code> 的元素值</li>
<li>出队操作为删除下标为 <code>1</code> 的元素，重新调整堆</li>
<li>入队操作为将新元素插入到堆的最后一个位置，然后向上调整堆</li>
</ul></li>
</ul>
<h3 id="优先级队列类的定义">优先级队列类的定义</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">priorityQueue</span>:<span class="hljs-keyword">public</span> quque&lt;T&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> currentSize;<br>    T *array;<br>    <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleSpace</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">voif <span class="hljs-title">buildHeap</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 建堆，被 priorityQueue() 调用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">(<span class="hljs-type">int</span> hole)</span></span>; <span class="hljs-comment">// 向下过滤</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">int</span> capacity = <span class="hljs-number">100</span>) <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>      array = <span class="hljs-keyword">new</span> T[capacity];<br>      maxSize = capacity;<br>      currentSize = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">priorityQueue</span>(<span class="hljs-type">const</span> T data[] , <span class="hljs-type">int</span> size); <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">priorityQueue</span>(); <span class="hljs-comment">// 析构函数</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 是否为空</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> currentSize == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span>; <span class="hljs-comment">//入队</span><br>    <span class="hljs-function">T <span class="hljs-title">deQueue</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function">T <span class="hljs-title">getHead</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">// 获取队头元素</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> array[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="enqueue-2"><code>enQueue</code></h4>
<ul>
<li>在堆中插入一个新元素</li>
<li>在最大序号中的元素之后插入新的元素或者节点</li>
<li>如果没有违反堆的<strong>有序性</strong>，则操作结束，否则向父节点移动，直到满足有序性或者到达根节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> priorityQueue&lt;T&gt;::<span class="hljs-built_in">enQueue</span>(<span class="hljs-type">const</span> T &amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (currentSize == maxSize - <span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-built_in">doubleSpace</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 向上过滤</span><br>  <span class="hljs-type">int</span> hole = ++currentSize;<br>  <span class="hljs-keyword">for</span> (;hole &gt; <span class="hljs-number">1</span> &amp;&amp; x &lt; array[hole/<span class="hljs-number">2</span>] ; hole /= <span class="hljs-number">2</span>)<br>  &#123;<br>    array[hole] = array[hole/<span class="hljs-number">2</span>];<br>  &#125;<br>  array[hole] = x;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>最坏情况时间复杂度为 <span class="math inline">\(O(\log
n)\)</span></li>
<li>平均情况来说，过滤会提前结束。资料表明平均为 <span
class="math inline">\(2.6\)</span> 次比较，即平均上移 <span
class="math inline">\(1.6\)</span> 层</li>
</ul>
<h4 id="dequeue-2"><code>deQueue</code></h4>
<ul>
<li>删除堆顶元素，同时删除最后一个节点，以满足是完全二叉树</li>
<li>空节点向下过滤，找到一个较小的子节点，将该儿子放入空节点，空节点向下推一层，直至删除的节点能够被放入空节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T priorityQueue&lt;T&gt;::<span class="hljs-built_in">deQueue</span>()<br>&#123;<br>  T minItem;<br>  minItem = array[<span class="hljs-number">1</span>];<br>  array[<span class="hljs-number">1</span>] = array[currentSize--];<br>  <span class="hljs-built_in">percolateDown</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> minItem;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="percolatedown"><code>percolateDown</code></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> priorityQueue&lt;T&gt;::<span class="hljs-built_in">precolateDown</span>(<span class="hljs-type">int</span> hole)<br>&#123;<br>  <span class="hljs-type">int</span> child;<br>  T tmp = array[hole];<br><br>  <span class="hljs-keyword">for</span> (;hole * <span class="hljs-number">2</span> &lt;= currentSize; hole = child)<br>  &#123;<br>    child = hole * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (child != currentSIze &amp;&amp; array[child + <span class="hljs-number">1</span>] &lt; array[child])<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[child] &lt; tmp)<br>    &#123;<br>      array[hole] = array[child];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  array[hole] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="buildheap"><code>buildHeap</code></h4>
<h5 id="连续插入">连续插入</h5>
<ul>
<li>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span></li>
</ul>
<h5 id="自上而下调整二叉树">自上而下调整二叉树</h5>
<ul>
<li>对左子树和右子树递归调用
<code>buildHeaap</code>，再对根节点向下过滤</li>
<li>时间复杂度为 <span class="math inline">\(O(n)\)</span></li>
</ul>
<h5 id="非递归实现-1">非递归实现</h5>
<p>从编号最大的非叶节点 <span class="math inline">\(\lfloor \frac{n}{2}
\rfloor\)</span> 开始逆层次遍历，每个节点调用
<code>percolateDown</code>，直到根节点</p>
<h2 id="集合与静态查找表">集合与静态查找表</h2>
<h3 id="集合的基本概念">集合的基本概念</h3>
<ol type="1">
<li>数据元素除了属于同一集合之外，没有任何逻辑关系</li>
<li>每个数据元素有一个区别于其他元素的唯一标识，称为<strong>键值</strong>或者<strong>关键字值</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;calss KEY , <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SET</span><br>&#123;<br>  KEY key; <span class="hljs-comment">// 关键字值</span><br>  OTHER other; <span class="hljs-comment">// 其他信息</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>运算</p>
<ul>
<li><strong>查找</strong> 某一元素是否存在</li>
<li>将集合中的元素按照它的唯一标识排序</li>
</ul>
<p>这些都是对 <code>key</code> 的操作</p>
<h3 id="集合的存储">集合的存储</h3>
<ul>
<li>任何容器都能存储集合</li>
<li>常用的表达形式是借鉴于<strong>线性表</strong>和<strong>树</strong></li>
<li>唯一一个仅适合于存储和处理集合的数据结构是<strong>散列表</strong></li>
</ul>
<h3 id="查找">查找</h3>
<h4 id="查找的基本概念">查找的基本概念</h4>
<ul>
<li>用于查找的集合称之为<strong>查找表</strong></li>
<li>查找表的分类
<ul>
<li>静态查找表</li>
<li>动态查找表</li>
<li>内部查找</li>
<li>外部查找</li>
</ul></li>
</ul>
<h4 id="静态查找表">静态查找表</h4>
<ul>
<li>数据元素的个数和值不允许变化的查找表称为静态查找表</li>
<li>不允许插入和删除操作</li>
<li>实例：字典</li>
<li>可以用顺序表 <code>seqList</code> 存储，或直接存储在
C++的原始数组中</li>
</ul>
<h4 id="无序表的查找">无序表的查找</h4>
<ul>
<li><p>只能做顺序查找</p></li>
<li><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p></li>
<li><p>可以使用哨兵减少 <span class="math inline">\(n\)</span>
次查找</p></li>
<li><p>优化后的顺序查找</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  data[<span class="hljs-number">0</span>].key = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; x != data[i].key; --i)<br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure>
<h4 id="有序表的查找">有序表的查找</h4>
<h5 id="顺序查找">顺序查找</h5>
<ul>
<li><p>与无序表的顺序查找类似，只是当被查元素在表中不存在时，不需要查到表头</p></li>
<li><p>时间复杂度为 <span class="math inline">\(O(n)\)</span></p></li>
<li><p>有序表的顺序查找</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(SET&lt;KEY , OTHER&gt; data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  data[<span class="hljs-number">0</span>].key = x;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size ; x &lt; data[i].key; --i);<br>  <span class="hljs-keyword">if</span> (x == data[i].key)<br>  &#123;<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="二分查找">二分查找</h5>
<ol type="1">
<li>每次检查中间的元素（向下取整）</li>
<li>若中间的元素等于要查找的元素，则查找成功</li>
<li>若中间的元素大于要查找的元素，则在左半部分继续查找</li>
<li>若中间的元素小于要查找的元素，则在右半部分继续查找</li>
</ol>
<ul>
<li>时间复杂度为 <span class="math inline">\(O(\log n)\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(SET&lt;KEY , OTHER&gt;data[] , <span class="hljs-type">int</span> size , <span class="hljs-type">const</span> KEY &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>,  high = size, mid;<br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;                 <span class="hljs-comment">//查找区间存在</span><br>      mid = (low + high) / <span class="hljs-number">2</span>;         <span class="hljs-comment">//计算中间位置</span><br>      <span class="hljs-keyword">if</span> ( x == data[mid].key )<br>      &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (x &lt; data[mid].key)<br>      &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="插值查找">插值查找</h5>
<ul>
<li>适用于数据分布较为均匀的情况</li>
<li>计算中间位置的公式为</li>
</ul>
<p><span class="math display">\[
\text{next} = \text{low} + \frac{(x - a[\text{low}])}{(a[\text{high}] -
a[\text{low}])} \times (\text{high} - \text{low}+1)
\]</span></p>
<ul>
<li>缺点：计算量大</li>
</ul>
<h5 id="分块查找">分块查找</h5>
<ul>
<li>将数据分成若干个块，每个块内可以是有序和无序的，但块之间是有序的</li>
<li>查找分为两个阶段
<ol type="1">
<li>查找索引</li>
<li>查找块 设表长为 <span class="math inline">\(n\)</span>，块长为 <span
class="math inline">\(m\)</span> 则平均所需的时间为 <span
class="math inline">\(\frac{m+1}{2}+\frac{\frac{n}{m}+1}{2}\)</span> 当
<span class="math inline">\(m=\sqrt{n}\)</span>
时，平均所需的时间<strong>最短</strong>，为 <span
class="math inline">\(O(\sqrt{n})\)</span></li>
</ol></li>
</ul>
<h2 id="动态查找表">动态查找表</h2>
<h3 id="二叉查找树">二叉查找树</h3>
<h4 id="抽象类-1">抽象类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dynamicSearchTable</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">dynamicSearchTable</span>() &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="二叉查找树的定义">二叉查找树的定义</h4>
<ul>
<li>对于任意一个节点 <code>p</code>
<ul>
<li><code>p</code> 的左子树中所有节点的值都小于 <code>p</code> 的值</li>
<li><code>p</code> 的右子树中所有节点的值都大于 <code>p</code> 的值</li>
<li><code>p</code> 的左子树和右子树都是二叉查找树</li>
</ul></li>
<li>二叉查找树的<strong>中序遍历</strong>是排好序的，又称为<strong>排序树</strong></li>
<li>最大和最小的元素不一定存放在叶节点中，但是最大节点的右子树、最小节点的左子树都是空的</li>
</ul>
<h4 id="二叉查找树的存储实现">二叉查找树的存储实现</h4>
<ul>
<li>使用二叉链表存储，需要一个指向根节点的数据成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearchTree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BinaryNode</span><br>    &#123;<br>      SET&lt;KEY, OTHER&gt; data;<br>      BinaryNode*left;<br>      BinaryNode*right;<br>      <span class="hljs-built_in">BinaryNode</span>( <span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; thedata,<br>      BinaryNode *lt = <span class="hljs-literal">nullptr</span> , BinaryNode *rt = <span class="hljs-literal">nullptr</span>):<span class="hljs-built_in">data</span>(thedata) , <span class="hljs-built_in">left</span>(lt) , <span class="hljs-built_in">right</span>(rt)&#123;&#125;<br>    &#125;;<br>    BinaryNode*root;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BinarySearchTree</span>();<br>    ~<span class="hljs-built_in">BinarySearchTree</span>();<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span> </span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *&amp;t)</span></span>;<br>    <span class="hljs-function">SET&lt;KEY , OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *t )</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">(BinaryNode *t)</span></span>;<span class="hljs-comment">//析构用，同二叉树的clear</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="二叉查找树的操作">二叉查找树的操作</h4>
<h5 id="查找-1">查找</h5>
<ol type="1">
<li>检查根节点的关键字值</li>
<li>如果等于要查找的值，则查找成功，返回根节点地址</li>
<li>如果小于要查找的值，则在右子树中查找</li>
<li>如果大于要查找的值，则在左子树中查找</li>
</ol>
<ul>
<li>公有函数 <code>find(const KEY &amp;x)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x ) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>( x, root );<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>私有辅助函数 <code>find(const KEY &amp;x, BinaryNode *t)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x, BinaryNode *t ) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span> || t-&gt;data.key == x)<br>  &#123;<br>    <span class="hljs-keyword">return</span> (SET&lt;KEY , OTHER&gt; *)t;<span class="hljs-comment">//强制类型转换</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(x &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x , t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x , t-&gt;right );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="插入">插入</h5>
<ul>
<li><p>若二叉树为空树，则插入的节点为根节点</p></li>
<li><p>若二叉树非空</p>
<ul>
<li>判断是左儿子还是右儿子，作为叶节点插入</li>
</ul></li>
<li><p>公有的
<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x)</code></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-built_in">insert</span>(x, root);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>私有的
<code>insert(const SET&lt;KEY, OTHER&gt; &amp;x, BinaryNode *&amp;t)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;x, BinaryNode *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)<br>  t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BinaryNode</span>(x , <span class="hljs-literal">nullptr</span> , <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key&lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x, t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; “is exist” &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="删除">删除</h5>
<ul>
<li><p><span class="math inline">\(P_L\)</span> 和 <span
class="math inline">\(P_R\)</span> 分别是 <span
class="math inline">\(P\)</span> 的左子树和右子树</p>
<ol type="1">
<li>如果 <span class="math inline">\(P\)</span>
是叶节点，则直接删除</li>
<li>如果 <span class="math inline">\(P\)</span> 只有一个子树，则将 <span
class="math inline">\(P\)</span> 的父节点指向 <span
class="math inline">\(P\)</span> 的子树</li>
<li>如果 <span class="math inline">\(P\)</span> 有两个子树，则
<ol type="1">
<li>找到 <span class="math inline">\(P\)</span>
的右子树中最左的节点或者左子树的最右节点 <span
class="math inline">\(Q\)</span></li>
<li>将 <span class="math inline">\(Q\)</span> 的值赋给 <span
class="math inline">\(P\)</span></li>
<li>删除 <span class="math inline">\(Q\)</span> 节点</li>
</ol></li>
</ol></li>
<li><p>公有的 <code>remove(const KEY &amp;x)</code></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-built_in">remove</span>(x , root);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>私有的
<code>remove(const KEY &amp;x, BinaryNode *&amp;t)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> BinarySearchTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x , BinaryNode *&amp;t)<br>&#123;<br>  <span class="hljs-keyword">if</span>(t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    cout &lt;&lt; x.key &lt;&lt; <span class="hljs-string">&quot;is not exist&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">remove</span>(x , t-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">remove</span>(x , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;right != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    BinaryNode *p = t-&gt;right;<br>    <span class="hljs-keyword">while</span>(p-&gt;left != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      p = p-&gt;left;<br>    &#125;<br>    t-&gt;data = p-&gt;data;<br>    <span class="hljs-built_in">remove</span>(p-&gt;data.key , t-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    BinaryNode *oldNode = t;<br>    t = (t-&gt;left != <span class="hljs-literal">nullptr</span>) ? t-&gt;left : t-&gt;right;<br>    <span class="hljs-keyword">delete</span> oldNode;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二叉查找树的性能">二叉查找树的性能</h4>
<ul>
<li>二叉查找树的操作的时间复杂度为树的高度</li>
<li>如果二叉查找树是平衡的，则访问的代价是 <span
class="math inline">\(O(\log n)\)</span></li>
<li>最坏的情况下，二叉查找树会退化成一个单链表，时间复杂度为 <span
class="math inline">\(O(n)\)</span></li>
</ul>
<p><strong>平均性能</strong></p>
<p>具有 <span class="math inline">\(n\)</span> 个节点的二叉查找树可能有
<span class="math inline">\(n\)</span> 种不同的形态 <span
class="math inline">\((0,1,n-1) , (1 , 1 n-2) , (2 , 1 , n-3) , \ldots ,
(n-1 , 1 , 0)\)</span> 若设这些形态出现的概率是相同的，设 <span
class="math inline">\(P(n)\)</span> 为查找 <span
class="math inline">\(n\)</span>
个节点的二叉查找树的平均查找时间，则有如下递归关系式：</p>
<p><span class="math display">\[
P(n) = \frac{\sum_{i = 0}^{n-1} \left[ 1 + (P(i)+1) \cdot i + (P( n - i
- 1)+1)\cdot (n-i-1)\right]}{n} \leq 2(1 + \frac{1}{n})\ln{n} \approx
1.33 \log{n}
\]</span></p>
<h3 id="avl-树">AVL 树</h3>
<h4 id="avl-树的定义">AVL 树的定义</h4>
<ul>
<li>也叫平衡树
<ul>
<li>对于任意一个节点的两棵子树的高度至多相差 1</li>
</ul></li>
<li>平衡因子
<ul>
<li>节点的左子树的高度减去右子树的高度</li>
<li>平衡因子只能是 <span class="math inline">\(-1\)</span>，<span
class="math inline">\(0\)</span>，<span
class="math inline">\(1\)</span></li>
</ul></li>
<li>优点
<ul>
<li>查找，插入和删除操作的时间复杂度都是 <span
class="math inline">\(O(\log n)\)</span></li>
</ul></li>
</ul>
<h5 id="查找性能">查找性能</h5>
<ul>
<li><p>与二叉树的高度成正比</p></li>
<li><p>定理：</p>
<ul>
<li>具有 <span class="math inline">\(n\)</span> 个节点的平衡树，高度
<span class="math inline">\(h\)</span> 满足 <span
class="math inline">\(\log_2(n+1) \leq h \leq
1.44\log_2(n+2)-0.328\)</span></li>
<li>因此，平衡二叉树的操作都是 <span class="math inline">\(O(\log
n)\)</span></li>
</ul></li>
</ul>
<h5 id="斐波那契树">斐波那契树</h5>
<ul>
<li><p>斐波那契树是平衡树的最坏情况，其每一子树的左右子树高度差都为
1</p></li>
<li><p>定义</p>
<ol type="1">
<li>空树是高度为 0 的斐波那契树</li>
<li>单个节点是高度为 1 的斐波那契树</li>
<li>若 <span class="math inline">\(T_{h-1}\)</span> 和 <span
class="math inline">\(T_{h-2}\)</span> 分别为高度为 <span
class="math inline">\(h-1\)</span> 和 <span
class="math inline">\(h-2\)</span> 的斐波那契树，则 <span
class="math inline">\(T_h ={T_{h-1},x,T_{h-2}}\)</span> 是高度为 <span
class="math inline">\(h\)</span> 的斐波那契树</li>
<li>没有其他的树是斐波那契树</li>
</ol></li>
</ul>
<h6 id="斐波那契树的特点">斐波那契树的特点</h6>
<p>对于高度为 <span class="math inline">\(h\)</span>
的斐波那契树，节点数 <span class="math inline">\(n\)</span> 满足</p>
<ul>
<li><span class="math inline">\(n_0 = 0\)</span></li>
<li><span class="math inline">\(n_1 = 1\)</span></li>
<li><span class="math inline">\(n_h = n_{h-1} + n_{h-2} +
1\)</span></li>
</ul>
<h4 id="avl-树的存储实现">AVL 树的存储实现</h4>
<ul>
<li>使用二叉链表</li>
<li>每个节点必须保存平衡信息
<ul>
<li>每棵树的高度</li>
<li>平衡度即左右子树的高度差</li>
</ul></li>
</ul>
<h5 id="avl-树类的实现">AVL 树类的实现</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;clas KEY,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AvlTree</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY , OTHER&gt;<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">AvlNode</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data ; <span class="hljs-comment">// 关键字</span><br>      AvlNode *left , *right; <span class="hljs-comment">// 左右子树指针</span><br>      <span class="hljs-type">int</span> height;            <span class="hljs-comment">// 节点高度</span><br><br>      <span class="hljs-built_in">AvlNode</span>(<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;element , AvlNode *lt ,AvlNode   *rt , <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>):<span class="hljs-built_in">data</span>(elemeent) , <span class="hljs-built_in">left</span>(lt) , <span class="hljs-built_in">right</span>(rt) , <span class="hljs-built_in">height</span>  (h) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    &#125;;<br><br>    AvlNode *root; <span class="hljs-comment">// 根节点</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AvlTree</span>() <span class="hljs-comment">// 构造函数</span><br>    &#123;<br>      root = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">AvlTree</span>() <span class="hljs-comment">// 析构函数</span><br>    &#123;<br>      <span class="hljs-built_in">makeEmpty</span>(root);<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp; x)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">( <span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t )</span> </span>; <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">( <span class="hljs-type">const</span> KEY &amp; x, AvlNode * &amp; t )</span> </span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeEmpty</span><span class="hljs-params">( AvlNode *t )</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(AvlNode *t)</span> <span class="hljs-type">const</span>  <span class="hljs-comment">// 返回节点的高度</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> t == <span class="hljs-literal">nullptr</span> ? <span class="hljs-number">0</span> : t -&gt; height;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LL</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 左旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RR</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 右旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LR</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 左右旋</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RL</span><span class="hljs-params">( AvlNode * &amp; t )</span></span>; <span class="hljs-comment">// 右左旋</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>     <span class="hljs-comment">// 返回两个数中较大的一个</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">adjust</span><span class="hljs-params">(AvlNode *&amp;t, <span class="hljs-type">int</span> subTree)</span></span>; <span class="hljs-comment">//用于删除</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="avl-树的查找">AVL 树的查找</h4>
<ul>
<li>与二叉查找树相同</li>
<li>二叉查找树类采用递归实现</li>
<li>AVL 树类展示非递归实现</li>
</ul>
<h5 id="查找的非递归实现">查找的非递归实现</h5>
<ol type="1">
<li>设当前节点为根节点</li>
<li>若当前节点非空
<ol type="1">
<li>若当前节点的值等于 <code>x</code>，则返回当前节点</li>
<li>若当前节点的值大于 <code>x</code>，则将当前节点指向左子树</li>
<li>若当前节点的值小于 <code>x</code>，则将当前节点指向右子树</li>
</ol></li>
<li>若当前节点为空，则返回空</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *AvlTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp; x) <span class="hljs-type">const</span><br>&#123;<br>  AvlNode *t = root; <br>  <span class="hljs-keyword">while</span> (t!=<span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;data.key != x)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; t-&gt;data.key)<br>    &#123;<br>      t = t-&gt;left;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      t = t-&gt;right;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> t-&gt;data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="avl-树的插入">AVL 树的插入</h4>
<ul>
<li>与二叉查找树相同
<ul>
<li>可能改变了根到插入节点的路径上某些节点的平衡度</li>
<li>需要向上修改树的结构</li>
</ul></li>
</ul>
<h5 id="可能引起节点不平衡的情况">可能引起节点不平衡的情况</h5>
<ul>
<li>节点的左孩子的左子树上插入（LL）</li>
<li>节点的左孩子的右子树上插入（LR）</li>
<li>节点的右孩子的左子树上插入（RL）</li>
<li>节点的右孩子的右子树上插入（RR）</li>
</ul>
<h5 id="重构的方法">重构的方法</h5>
<ul>
<li>指针调整
<ul>
<li>按照投影序保持结点相邻关系不变</li>
<li>辈分可以改变</li>
</ul></li>
</ul>
<h6 id="ll-问题">LL 问题</h6>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141158768.png" srcset="/img/loading.jpeg" lazyload
alt="LL" />
<figcaption aria-hidden="true">LL</figcaption>
</figure>
<ul>
<li><strong>左旋</strong>
<ol type="1">
<li>将失衡点的左儿子作为新的根节点</li>
<li>左儿子的右儿子作为原根节点的左儿子</li>
</ol></li>
<li>若为 RR
问题，则将失衡点的右儿子作为新的根节点，右儿子的左儿子作为原根节点的右儿子，称为<strong>右旋</strong></li>
<li>左旋和右旋统称为<strong>单旋转</strong>，保留了树的有序性和原先的高度</li>
</ul>
<h6 id="lr-问题">LR 问题</h6>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504141206204.png" srcset="/img/loading.jpeg" lazyload
alt="LR" />
<figcaption aria-hidden="true">LR</figcaption>
</figure>
<ul>
<li><strong>双旋转</strong>
<ol type="1">
<li>将失衡点的左儿子右旋</li>
<li>将失衡点左旋</li>
</ol></li>
<li>若为 RL 问题，则将失衡点的右儿子左旋，再将失衡点右旋</li>
<li>先对失衡结点的儿子和孙子进行一次单旋转，使孙子变成儿子。然后是失衡结点和新的儿子进行一次单旋转，使<strong>原先的孙子变成根</strong></li>
</ul>
<h5 id="私有的insert-函数">私有的<code>insert</code> 函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp; x, AvlNode * &amp; t)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AvlNode</span>(x , <span class="hljs-literal">nullptr</span> , <span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &lt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;left);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) - <span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (x.key &lt; t-&gt;left-&gt;data.key)<br>      &#123;<br>        <span class="hljs-built_in">LL</span>(t);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">LR</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.key &gt; t-&gt;data.key)<br>  &#123;<br>    <span class="hljs-built_in">insert</span>(x , t-&gt;right);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) - <span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-number">2</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (x.key &gt; t-&gt;right-&gt;data.key)<br>      &#123;<br>        <span class="hljs-built_in">RR</span>(t);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">RL</span>(t);<br>      &#125;<br>    &#125;<br>  &#125;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新高度</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="ll"><code>LL</code></h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">LL</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;left;<br>  t-&gt;left = t1-&gt;right;<br>  t1-&gt;right = t;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>;<br>  t1-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t1-&gt;left) , <span class="hljs-built_in">height</span>(t1-&gt;right)) + <span class="hljs-number">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="rr"><code>RR</code></h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">RR</span>(AvlNode *&amp; t)<br>&#123;<br>  AvlNode *t1 = t-&gt;right;<br>  t-&gt;right = t1-&gt;left;<br>  t1-&gt;left = t;<br>  t-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t-&gt;left) , <span class="hljs-built_in">height</span>(t-&gt;right)) + <span class="hljs-number">1</span>;<br>  t1-&gt;height = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(t1-&gt;left) , <span class="hljs-built_in">height</span>(t1-&gt;right)) + <span class="hljs-number">1</span>;<br>  t = t1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="lr"><code>LR</code></h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">LR</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class="hljs-built_in">RR</span>(t-&gt;left);<br>  <span class="hljs-built_in">LL</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="rl"><code>RL</code></h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY,OTHER&gt;::<span class="hljs-built_in">RL</span>(AvlNode *&amp; t)<br>&#123;<br>  <span class="hljs-built_in">LL</span>(t-&gt;right);<br>  <span class="hljs-built_in">RR</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所有旋转的算法时间复杂度都是 <span
class="math inline">\(O(1)\)</span>，且只运行一次，所以
<code>insert</code> 的时间复杂度为 <span class="math inline">\(O(\log
n)\)</span></p>
<h4 id="avl-树的删除">AVL 树的删除</h4>
<ol type="1">
<li>在 AVL 树上删除节点 <code>x</code>，删除操作和二叉查找树相同</li>
<li>调整平衡，与插入操作相同</li>
</ol>
<h4 id="调整">调整</h4>
<ul>
<li>与插入操作相同，失衡节点存在于被删的节点到根节点的路径上。删除一个节点之后，必须沿着到根节点的路径向上回溯，随时调整路径上的节点的平衡度</li>
<li>删除时无法保证子树在平衡调整之后的高度不变</li>
<li>递归的删除函数有一个 bool 型的返回值，当返回值为 <code>true</code>
时，调整停止</li>
</ul>
<h4 id="五种情况">五种情况</h4>
<h5 id="情况-a">情况 a</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191603536.png" srcset="/img/loading.jpeg" lazyload
alt="Sitiationa" />
<figcaption aria-hidden="true">Sitiationa</figcaption>
</figure>
<p>此时没有失衡，高度也没有改变，返回<code>true</code></p>
<h5 id="情况-b">情况 b</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191604348.png" srcset="/img/loading.jpeg" lazyload
alt="Situationb" />
<figcaption aria-hidden="true">Situationb</figcaption>
</figure>
<p>此时没有失衡，但是高度变矮，返回<code>false</code></p>
<h5 id="情况-c">情况 c</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191607359.png" srcset="/img/loading.jpeg" lazyload
alt="Situationc" />
<figcaption aria-hidden="true">Situationc</figcaption>
</figure>
<p>经过 RR 旋转后高度变矮，返回<code>false</code></p>
<h5 id="情况-d">情况 d</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191609189.png" srcset="/img/loading.jpeg" lazyload
alt="Situationd" />
<figcaption aria-hidden="true">Situationd</figcaption>
</figure>
<p>经过 RL 旋转后高度变矮，返回<code>false</code></p>
<h5 id="情况-e">情况 e</h5>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504191613240.png" srcset="/img/loading.jpeg" lazyload
alt="Situatione" />
<figcaption aria-hidden="true">Situatione</figcaption>
</figure>
<p>经过 RR 或 RL 旋转后高度不变，返回<code>true</code></p>
<h4 id="删除总结">删除总结</h4>
<ul>
<li>节点删除同二叉查找树。在删除了叶节点或者只有一个孩子的节点后，子树变矮，返回
<code>false</code></li>
<li>在每次调用后，检查返回值，如果是 <code>true</code>，则返回
<code>true</code>，否则分 5 种情况进行处理</li>
</ul>
<h4 id="私有的-remove-函数">私有的 <code>remove</code> 函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> AvlTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x , AvlNOde *&amp;x)<br>&#123;<br>  <span class="hljs-keyword">if</span> (t = <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 被删除节点不存在</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x == t-&gt; data.key)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;left == <span class="hljs-literal">nullptr</span> || t-&gt; right == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      AvlNode *oldNode = t;<br>      t = (t-&gt;left == <span class="hljs-literal">nullptr</span>) ? t-&gt;right : t-&gt;left; <span class="hljs-comment">// 删除节点的孩子节点</span><br>      <span class="hljs-keyword">delete</span> oldNode;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 删除了一个节点，返回 `false`</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      AvlNode *tmp = t-&gt; right;<br>      <span class="hljs-keyword">while</span> (tmp-&gt;left != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 找到右子树的最小节点</span><br>      &#123;<br>        tmp = tmp-&gt;left;<br>      &#125;<br>      t-&gt;data = tmp.data;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(tmp-&gt;data,key , t-&gt;right))<br>      &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &lt; t-&gt;data,key)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x,t-&gt;left))<br>    &#123;<br>      teturn <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remove</span>(x , t-&gt;right))<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">adjust</span>(t,<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="adjust"><code>adjust</code></h4>
<ul>
<li>进入调整函数的条件是某棵子树变矮了</li>
<li>调整函数需要检查节点是否失衡，若失衡则进行相应的调整</li>
<li>函数的返回值是子树是否变矮
<ul>
<li><code>true</code>：子树没有变矮</li>
<li><code>false</code>：子树变矮</li>
</ul></li>
<li>需要传入两个参数
<ul>
<li><code>AVlNode *&amp;t</code>：传入的节点</li>
<li><code>int subTree</code>：参数 <code>t</code> 变矮的子树
<ul>
<li><code>0</code>：左子树</li>
<li><code>1</code>：右子树</li>
</ul></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span> , classs OTHER&gt;<br><span class="hljs-type">bool</span> AvlTree&lt;KEY , OTHER&gt;::<span class="hljs-built_in">adjust</span>(AvlNode *&amp;t , <span class="hljs-type">int</span> SubTree)<br>&#123;<br>  <span class="hljs-keyword">if</span> (subTree) <span class="hljs-comment">// 在右子树上删除</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) - <span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-number">1</span>) <span class="hljs-comment">// Situation a</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left)) <span class="hljs-comment">// Situation b</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left-&gt;right) &gt; <span class="hljs-built_in">height</span>(t-&gt;left-&gt;left)) <span class="hljs-comment">// Situation d</span><br>    &#123;<br>      <span class="hljs-built_in">LR</span>(t);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">LL</span>(t); <span class="hljs-comment">// Situation c and e</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-built_in">height</span>(t-&gt;right))s<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-comment">// 在左子树上删除</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) - <span class="hljs-built_in">height</span>(t-&gt;left) == <span class="hljs-number">1</span>) <span class="hljs-comment">// Situation a</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left)) <span class="hljs-comment">// Situation b</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-function">s</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(height(t-&gt;right-&gt;left) &gt; height(t-&gt;right-&gt;right))</span> <span class="hljs-comment">// Situation d</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-built_in">RL</span>(t);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">RR</span>(t); <span class="hljs-comment">// Situation c and e</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(t-&gt;right) == <span class="hljs-built_in">height</span>(t-&gt;left))<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="散列表">散列表</h3>
<ul>
<li>也叫哈希表</li>
<li>通过所求节点的关键字词 <code>KEY</code> 找到这个节点</li>
<li>时间复杂度为 <span class="math inline">\(O(1)\)</span></li>
</ul>
<h4 id="基本概念">基本概念</h4>
<ol type="1">
<li>初始化 将数组转化为一个特殊的、表示单元为空的值</li>
<li><code>insert(i)</code> 将 <code>i</code> 存放到
<code>a[i.key]</code> 中</li>
<li><code>find(i)</code> 取出 <code>a[i.key]</code> 中的值</li>
<li><code>remove(i)</code> 将 <code>a[i.key]</code> 中的值置为空</li>
</ol>
<h4 id="散列函数">散列函数</h4>
<p>将一个项映射成一个较小的下标的函数称为散列函数（hush function）</p>
<ul>
<li><span class="math inline">\(D = H(key)\)</span> D 为存储地址，key
为关键值，H 为散列函数</li>
<li>散列函数的要求
<ul>
<li>计算速度快</li>
<li>散列地址均匀分布</li>
</ul></li>
</ul>
<h4 id="常用的散列函数">常用的散列函数</h4>
<h5 id="直接地址法">直接地址法</h5>
<p><span class="math inline">\(H(key) = key\)</span> 或 <span
class="math inline">\(H(key) = a \times key + b\)</span></p>
<h5 id="除留余数法"><strong>除留余数法</strong></h5>
<p><span class="math inline">\(H(key) = key \mod p\)</span> 或 <span
class="math inline">\(H(key) = key \mod p + c\)</span> 这里的 <span
class="math inline">\(p\)</span> 是一个小于等于 <span
class="math inline">\(m\)</span> 的素数</p>
<h5 id="数字分析法">数字分析法</h5>
<p>对关键字集合中的所有关键字，分析每一位上数字分布。取数字分布均匀的位作为地址的组成部分</p>
<h5 id="平方取中法">平方取中法</h5>
<p>如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字<strong>平方后</strong>，取其结果的中间各位作为散列函数值。由于中间各位和每一位数字都有关系，因此均匀分布的可能性较大。</p>
<h5 id="折叠法">折叠法</h5>
<ul>
<li>如果关键字相当长，以至于和散列表的单元总数相比大得多时，可采用此法</li>
<li>选取一个长度后，将关键字按此长度分组相加</li>
</ul>
<h4 id="冲突问题">冲突问题</h4>
<p>当两个以上的关键字映射到一个存储单元时，称为<strong>冲突或碰撞</strong></p>
<ul>
<li>解决冲突的方法
<ul>
<li>闭散列表：利用本散列表中的空余单元
<ul>
<li>线性探测法</li>
<li>二次探测法</li>
<li>再次散列法</li>
</ul></li>
<li>开散列表：将碰撞的节点存放在散列表外的各自的线性表中（链接法）</li>
</ul></li>
</ul>
<h5 id="闭散列表类的实现">闭散列表类的实现</h5>
<ul>
<li>支持三种操作
<ul>
<li><code>insert</code>：插入一个元素</li>
<li><code>remove</code>：删除一个元素</li>
<li><code>find</code>：查找一个元素</li>
</ul></li>
<li>由一个数组实现，数组的大小由用户定义散列表时指定</li>
<li>由于删除时的迟删除，每个数组元素还要保存一个状态值
<ul>
<li><code>0</code>：空</li>
<li><code>1</code>：有效</li>
<li><code>2</code>：删除</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">closeHashTable</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEY, OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>  <span class="hljs-comment">//散列表的结点类</span><br>    &#123;<br>      SET &lt;KEY, OTHER&gt; data;<br>      <span class="hljs-type">int</span> state; <span class="hljs-comment">//0 -- empty 1 -- active 2 -- deleted</span><br>      <span class="hljs-built_in">node</span>()<br>      &#123;<br>        state = <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;;<br>    node *array;<br><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-built_in">int</span> (*key)(<span class="hljs-type">const</span> KEY &amp;x);<span class="hljs-comment">//哈希函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultKey</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> x;<br>    &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">closeHashTable</span>(<span class="hljs-type">int</span> length = <span class="hljs-number">101</span>, <span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x) = defaultKey)<br>    ~<span class="hljs-built_in">closeHashTable</span>()<br>    &#123;<br>      <span class="hljs-keyword">delete</span> [] array;<br>    &#125;<br>    <span class="hljs-function">SET&lt;KEY, OTHER&gt; *<span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">closeHashTable</span>(<span class="hljs-type">int</span> length, <span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x))<br>&#123;<br>  size = length;<br>  array = <span class="hljs-keyword">new</span> node[size];<br>  key = f; <span class="hljs-comment">//哈希函数为f</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>insert</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos= pos = <span class="hljs-built_in">key</span>(x.key) % size; <span class="hljs-comment">//%size保护作用，避免越界</span><br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state != <span class="hljs-number">1</span>)<br>    &#123; <span class="hljs-comment">// 0或2，找到空单元</span><br>      array[pos].data = x;<br>      array[pos].state = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size;<br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>remove</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos= pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//没找到</span><br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">1</span> &amp;&amp; array[pos].data.key== x)<span class="hljs-comment">// 找到，删除</span><br>    &#123;<br>      array[pos].state = <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size; <span class="hljs-comment">//没找到，需要往后找</span><br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>find</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *closeHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> initPos, pos ;<br>  initPos = pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有找到</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (array[pos].state == <span class="hljs-number">1</span> &amp;&amp; array[pos].data.key == x) <span class="hljs-comment">// 找到</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> (SET&lt;KEY,OTHER&gt; *)&amp;array[pos];<br>    &#125;<br>    pos = (pos<span class="hljs-number">+1</span>) % size;<br>  &#125; <span class="hljs-keyword">while</span> (pos != initPos);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="线性探测法">线性探测法</h6>
<p>当散列发生冲突时，依次<strong>探测下一个单元</strong>，直到发现一个空单元</p>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202504210826498.png" srcset="/img/loading.jpeg" lazyload
alt="线性探测法" />
<figcaption aria-hidden="true">线性探测法</figcaption>
</figure>
<h6 id="二次探测法">二次探测法</h6>
<p>以此向后探测 <span class="math inline">\(1^2\)</span>，<span
class="math inline">\(2^2\)</span>，<span
class="math inline">\(3^2\)</span>，<span
class="math inline">\(4^2\)</span>，<span
class="math inline">\(5^2\)</span>，<span
class="math inline">\(\ldots\)</span></p>
<p><strong>定理</strong></p>
<ul>
<li>如果采用二次探测法，并且表的大小是一个素数，那么，如果表至少有一半是空的（负载因子
<span
class="math inline">\(&lt;0.5\)</span>），新的元素总能被插入。并且在插入过程中，没有一个单元被探测两次</li>
</ul>
<h6 id="再次散列法">再次散列法</h6>
<ul>
<li>采用一个新的散列函数 <span
class="math inline">\(H_2(key)\)</span></li>
<li><span class="math inline">\(H_1(x)\)</span>，<span
class="math inline">\(H_1(x)+H_2(x)\)</span> ，<span
class="math inline">\(H_1(x)+2H_2(x)\)</span>，<span
class="math inline">\(H_1(x)+3H_2(x)\)</span>，<span
class="math inline">\(\ldots\)</span></li>
</ul>
<h5 id="开散列表">开散列表</h5>
<p>链地址法</p>
<ul>
<li>将具有同一散列地址的结点保存于 <code>M</code>
存区的各自的链表之中</li>
</ul>
<h6 id="开散列表的实现">开散列表的实现</h6>
<ul>
<li>将所有散列到同一地址的元素链接成一个单链表</li>
<li>采用不带头结点的单链表</li>
<li>散列表保存在一个数组中，每个元素是一个指向对应单链表的首地址的指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span> , <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">openHashTable</span>:<span class="hljs-keyword">public</span> dynamicSearchTable&lt;KEU , OTHER&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>      SET&lt;KEY , OTHER&gt; data;<br>      node *next;<br>      <span class="hljs-built_in">node</span> (<span class="hljs-type">const</span> SET&lt;KEY , OTHER&gt; &amp;d , nde *n = <span class="hljs-literal">nullptr</span>)<br>      &#123;<br>        data = d;<br>        next = n;<br>      &#125;<br>      <span class="hljs-built_in">node</span>()<br>      &#123;<br>        next = <span class="hljs-literal">nullptr</span>;<br>      &#125;<br>    &#125;;<br>    node **array; <span class="hljs-comment">// 散列表，指针数组</span><br>     <span class="hljs-type">int</span> size;<br>     <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">defaultKry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span></span><br><span class="hljs-function">     </span>&#123;<br>        <span class="hljs-keyword">return</span> x;<br>     &#125;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">openHashTable</span>(<span class="hljs-type">int</span> length = <span class="hljs-number">101</span>,<span class="hljs-built_in">int</span> (*f)(<span class="hljs-type">const</span> KEY &amp;x) = defaultKey);<br>    ~<span class="hljs-built_in">openashTable</span>();<br>    <span class="hljs-function">SET&lt;KEY,OTHER&gt; *<span class="hljs-title">finf</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> SET&lt;KEY,OTHER&gt; &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> KEY &amp;x)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>openHashTable&lt;KEY, OTHER&gt;::~<span class="hljs-built_in">openHashTable</span>()<br>&#123;<br>  node *p, *q;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; size; ++i)<br>  &#123;<br>    p = array[i];<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>      q= p-&gt;next; <span class="hljs-keyword">delete</span> p; p = q;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">delete</span> [] array；<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>insert</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> SET&lt;KEY, OTHER&gt; &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> pos;<br>  node *p;<br>  <span class="hljs-comment">//插入单链表的头部</span><br>  pos = <span class="hljs-built_in">key</span>(x.key) % size;<br>  array[pos] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x, array[pos]);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>remove</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-type">void</span> openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> KEY &amp;x)<br>&#123;<br>  <span class="hljs-type">int</span> pos ;<br>  node *p, *q;<br>  pos = <span class="hljs-built_in">key</span>(x) % size;<br>  <span class="hljs-keyword">if</span> (array[pos] == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  p = array[pos];<br>  <span class="hljs-keyword">if</span> (array[pos]-&gt;data.key== x)<br>  &#123; <span class="hljs-comment">// 删除第一个结点</span><br>    array[pos] = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (p-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; !(p-&gt;next-&gt;data.key== x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p-&gt;next != <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-keyword">delete</span> q;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>find</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br>SET&lt;KEY, OTHER&gt; *openHashTable&lt;KEY, OTHER&gt;::<span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> KEY &amp;x) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">int</span> pos ;<br>  node *p;<br>  pos = <span class="hljs-built_in">key</span>(x) % size;<br>  p = array[pos];<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span> &amp;&amp; !(p-&gt;data.key == x))<br>  &#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">return</span> (SET&lt;KEY, OTHER&gt; *)p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>按照关键字的非递减或非递增序排成一个序列</li>
<li><strong>稳定与非稳定排序</strong>:关键字值相同的数据元素在排序前后的相对次序保持不变，则称为稳定排序，否则称为不稳定排序</li>
<li>内排序与外排序
<ul>
<li><strong>内排序：</strong>排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置</li>
<li><strong>外排序：</strong>在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置</li>
</ul></li>
</ul>
<h3 id="插入排序">插入排序</h3>
<p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 n-1
个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的</p>
<h4 id="直接插入排序">直接插入排序</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simpleInsertSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt;a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> k;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;size; ++j)<br>  &#123;<br>  tmp = a[j];<br>  <span class="hljs-keyword">for</span> ( k = j<span class="hljs-number">-1</span>; tmp.key &lt; a[k].key &amp;&amp; k &gt;= <span class="hljs-number">0</span>; --k)<br>  &#123;<br>    a[k<span class="hljs-number">+1</span>] = a[k];<br>  &#125;<br>  a[k<span class="hljs-number">+1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
<li>稳定性：稳定</li>
<li>时间复杂度
<ul>
<li>最好：<span class="math inline">\(O(n)\)</span></li>
<li>最坏：<span class="math inline">\(O(n^2)\)</span></li>
<li>平均：<span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>适用情况：短序列或者几乎已经排好序的</li>
</ul>
<h4 id="折半插入排序">折半插入排序</h4>
<p>先用二分排序找到插入位置</p>
<ul>
<li>时间复杂度
<ul>
<li>最好：<span class="math inline">\(O(n\log n)\)</span></li>
<li>最坏：<span class="math inline">\(O(n^2)\)</span></li>
<li>平均：<span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
<li>稳定性：稳定</li>
</ul>
<p>改进很小，对于接近排好序的序列甚至<strong>更差</strong></p>
<h4 id="希尔排序">希尔排序</h4>
<ul>
<li>相隔一定的距离的记录组成一个子序列</li>
<li>逐渐扩大小序列的规模，减小序列的个数，使得待排序列处于更有序的状态</li>
<li>最后再用直接插入排序对整个序列进行一次排序</li>
</ul>
<h5 id="步长序列的选择">步长序列的选择</h5>
<ul>
<li><p><span class="math inline">\(1,2,4,8,\ldots\)</span></p></li>
<li><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p></li>
<li><p>Knuth 推荐：<span
class="math inline">\(1,3,7,15,31,63,\ldots\)</span></p></li>
<li><p>时间复杂度：<span
class="math inline">\(O(n^{1.5})\)</span></p></li>
<li><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></li>
<li><p>不稳定</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> step, i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (step = size/<span class="hljs-number">2</span>; step &gt; <span class="hljs-number">0</span>; step /= <span class="hljs-number">2</span>) <span class="hljs-comment">//step为希尔增量</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> (i = step; i &lt; size; ++i)<br>    &#123;<br>      tmp = a[i];<br>      <span class="hljs-keyword">for</span> (j = i -step; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j].key &gt; tmp.key; j -= step)<br>      &#123;<br>        a[j+step] = a[j];<br>      &#125;<br>      a[j+step] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="选择排序">选择排序</h3>
<ol type="1">
<li>在 <span class="math inline">\(n\)</span>
个元素中选出最小的元素</li>
<li>从剩下的 <span class="math inline">\(n-1\)</span>
个元素中选出最小的元素</li>
<li>以此类推，直到最后一个元素</li>
</ol>
<h4 id="直接选择排序">直接选择排序</h4>
<ol type="1">
<li>在所有元素中逐个比较找到最小元素，与第一个元素交换</li>
<li>在剩下的元素中逐个比较找到最小元素，与第二个元素交换</li>
<li>以此类推，直到最后一个元素</li>
</ol>
<ul>
<li>时间复杂度：<span class="math inline">\(O(n^2)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span></li>
<li>不稳定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simpleSelectSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i, j, min;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size <span class="hljs-number">-1</span>; ++i)<br>  &#123;<br>  min = i;<br>  <span class="hljs-keyword">for</span> (j = i<span class="hljs-number">+1</span>; j &lt; size; ++j)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (a[j].key &lt; a[min].key)<br>    &#123;<br>      min = j;<br>    &#125;<br>  &#125;<br>  tmp = a[i]; a[i] = a[min]; a[min] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="堆排序">堆排序</h4>
<ol type="1">
<li>建立一个最大堆</li>
<li>执行 <span class="math inline">\(n\)</span> 次 <code>deQuqeue</code>
操作取出每个项</li>
</ol>
<ul>
<li><p>时间复杂度 <span class="math inline">\(O(n\log
n)\)</span></p></li>
<li><p>堆排序</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i;<br>  SET&lt;KEY, OTHER&gt; tmp; <span class="hljs-comment">// 创建初始的堆</span><br>  <span class="hljs-keyword">for</span>( i = size / <span class="hljs-number">2</span> <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>  &#123;<br>    <span class="hljs-built_in">percolateDown</span>( a, i, size );<br>  &#125;<br>  <span class="hljs-comment">//执行n-1次deQueue</span><br>  <span class="hljs-keyword">for</span> ( i = size <span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; --i)\<br>  &#123;<br>  tmp = a[<span class="hljs-number">0</span>]; a[<span class="hljs-number">0</span>] = a[i]; a[i] = tmp; <span class="hljs-comment">//delete a[0]</span><br>  <span class="hljs-built_in">percolateDown</span>( a, <span class="hljs-number">0</span>, i );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>precolateDown</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">percolateDown</span><span class="hljs-params">( SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> hole, <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> child;<br>  SET&lt;KEY, OTHER&gt; tmp= a[ hole ];<br>  <span class="hljs-keyword">for</span>( ; hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; size; hole = child )<br>  &#123;<br>    child = hole * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>( child != size <span class="hljs-number">-1</span> &amp;&amp; a[ child + <span class="hljs-number">1</span> ].key &gt; a[ child ].key )<br>    &#123;<br>      child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( a[ child ].key &gt;tmp.key)<br>    &#123;<br>      a[ hole ] = a[ child ];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  a[ hole ] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="交换排序">交换排序</h3>
<p>通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动</p>
<h4 id="冒泡排序">冒泡排序</h4>
<p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟起泡</p>
<p>然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置</p>
<p>依次类推，经过第 <span class="math inline">\(n-1\)</span>
趟起泡，将倒数第 <span class="math inline">\(n-1\)</span>
个大的元素放入第 2 个单元</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i, j;<br>  SET&lt;KEY, OTHER&gt; tmp;<br>  <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//记录一趟起泡中有没有发生过交换</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; size&amp;&amp; flag; ++i)<br>  &#123; <span class="hljs-comment">//size-1次起泡</span><br>    flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; size-i; ++j) <span class="hljs-comment">//第i次起泡</span><br>    <span class="hljs-keyword">if</span> (a[j<span class="hljs-number">+1</span>].key &lt; a[j].key)<br>    &#123;<br>      tmp = a[j]; a[j] = a[j<span class="hljs-number">+1</span>]; a[j<span class="hljs-number">+1</span>] = tmp;<br>      flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="快速排序">快速排序</h4>
<ul>
<li>选择一个基准元素，将比基准元素小的元素放在左边，比基准元素大的元素放在右边</li>
<li>然后对基准元素左边和右边的子序列进行递归排序</li>
</ul>
<h5 id="选择中心点">选择中心点</h5>
<ul>
<li>第一个元素</li>
<li>随机</li>
<li>中值（采样得到）</li>
</ul>
<h5 id="划分第一个元素为中心点">划分（第一个元素为中心点）</h5>
<ol type="1">
<li>序列的下标上界为 <code>high</code>，下届为
<code>low</code>，中心点选取第一个元素，关键值为
<code>K</code>，<code>low</code> 位置空出</li>
<li>从右向左开始检查：如果 <code>high</code> 的关键值大于
<code>K</code>，该位置中的值位置正确，<code>high</code> 减 <span
class="math inline">\(1\)</span>，继续往前检查，直到遇到一个小于
<code>K</code> 的值</li>
<li>将小于 <code>k</code> 的这个值放入 <code>low</code> 的位置，此时
<code>high</code> 的位置又空出。然后从 <code>low</code>
位置开始从左向右检查，直到遇到一个大于 <code>K</code> 的值</li>
<li>将 <code>low</code> 位置的值放入 <code>high</code> 位置，重复第 2
步，直到 <code>low</code> 和 <code>high</code> 重叠，将 <code>K</code>
放入此位置</li>
</ol>
<p>划分函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">KEY</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OTHER</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">divide</span><span class="hljs-params">( SET&lt;KEY, OTHER&gt; a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>  SET&lt;KEY, OTHER&gt; k = a[low];<br>  <span class="hljs-keyword">do</span><br>  &#123;<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[high].key &gt;= k.key)<br>    &#123;<br>      --high;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>      a[low] = a[high]; ++low;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; a[low].key &lt;= k.key)<br>    &#123;<br>      ++low;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>      a[high] = a[low]; --high;<br>    &#125;<br>  &#125; <span class="hljs-keyword">while</span> (low != high);<br>  a[low] = k;<br>  <span class="hljs-keyword">return</span> low;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="归并排序">归并排序</h3>
<ul>
<li>将待排序的序列分成两个子序列，分别进行排序</li>
<li>将两个有序的子序列合并成一个有序的序列</li>
<li>递归进行</li>
</ul>
<h3 id="基数排序">基数排序</h3>
<ul>
<li>称为口袋排序法</li>
<li>通过分配的方法进行排序</li>
<li>基数（r）：子关键字的值域的元素的个数
<ul>
<li>十进制数：<span
class="math inline">\(0,1,2,\ldots,9\)</span>，基数为 <span
class="math inline">\(10\)</span></li>
<li>二进制数：<span class="math inline">\(0,1\)</span>，基数为 <span
class="math inline">\(2\)</span></li>
<li>英文字符：<span
class="math inline">\(A,B,C,\ldots,Z\)</span>，基数为 <span
class="math inline">\(26\)</span></li>
</ul></li>
</ul>
<h4 id="高位优先法msd">高位优先法（MSD）</h4>
<ul>
<li>先将高位进入口袋中你进行排序，再将低位放入口袋中进入排序，最终将最小的口袋依次链接在一起形成有序序列</li>
</ul>
<h4 id="低位优先法lsd">低位优先法（LSD）</h4>
<ul>
<li>先将最低为进入口袋进行排序，再将所有记录按照口袋的顺序收在一起</li>
<li>然后将次低位进入口袋进行排序，依次类推</li>
<li>最后将所有记录按照口袋的顺序收在一起</li>
</ul>
<h2 id="外存储器中的查找和排序">外存储器中的查找和排序</h2>
<h3 id="主存储器与外存储器">主存储器与外存储器</h3>
<ul>
<li>主存储器：计算机的内存，用于存储正在运行的程序代码以及处理数据</li>
<li>外存储器：计算机的硬盘、光盘、磁带等，用于长期存储数据和程序，用于存储长期保存的信息
<ul>
<li>价格低廉、存储量大、永久保存、<strong>访问速度慢</strong></li>
</ul></li>
</ul>
<h3 id="外部查找">外部查找</h3>
<h4 id="b-树">B 树</h4>
<p>B 树是一棵平衡的 M 叉查找树，需要 <span
class="math inline">\(M-1\)</span> 个关键字来判断到哪个分支查找</p>
<h5 id="b-树的定义">B 树的定义</h5>
<ul>
<li>一棵 <span class="math inline">\(m\)</span> 阶 B
树要么为空，要么满足一下条件
<ul>
<li>根节点要么是叶节点，要么至少有两个儿子，至多有 <span
class="math inline">\(m\)</span> 个儿子</li>
<li>每个非根节点至少有 <span class="math inline">\(\lceil m/2
\rceil\)</span> 个儿子，至多有 <span class="math inline">\(m\)</span>
个儿子</li>
<li>有 <span class="math inline">\(s\)</span> 个儿子的非叶节点具有 <span
class="math inline">\(n=s-1\)</span> 个关键字</li>
<li>所有的叶子节点都出现在同一层上</li>
</ul></li>
</ul>
<h5 id="b-树的插入">B 树的插入</h5>
<ul>
<li>在最底层进行插入</li>
</ul>
<ol type="1">
<li>在 <span class="math inline">\(m\)</span> 阶 B
树上进行查找操作，确定新插入的关键字 <code>key</code>
在最底层非叶节点的插入位置</li>
<li>如果被插入节点的关键字个数小于等于 <span
class="math inline">\(m-1\)</span>，则插入结束</li>
<li>如果被插入节点的关键字个数大于 <span
class="math inline">\(m-1\)</span>，则需要进行分裂</li>
</ol>
<ul>
<li>被插入节点分为三个部分
<ul>
<li>前半部分：前 <span class="math inline">\(m/2\)</span> 个关键字</li>
<li>中间部分：中间的关键字</li>
<li>后半部分：后 <span class="math inline">\(m/2\)</span> 个关键字</li>
</ul></li>
<li>中间部分的关键字上升到父节点</li>
<li>前后半部分生成新的两个节点</li>
</ul>
<h5 id="b-树的删除">B 树的删除</h5>
<ul>
<li>采用替身法，替身为右子树的最小值或者左子树的最大值</li>
</ul>
<ol type="1">
<li>删除节点，替身进入</li>
<li>如果删除后的替身原来在的节点满足，则直接删除</li>
<li>如果删除后的关键字小于下限，
<ul>
<li>向该节点的左或右兄弟借一个关键字</li>
<li>如果兄弟节点的关键字个数等于下限，则需要进行合并</li>
</ul></li>
</ol>
<h5 id="m-的选择">M 的选择</h5>
<h4 id="b树">B+树</h4>
<p>B+树是既能提供随机查找，也能提供顺序访问的存储结构</p>
<h5 id="b树的定义">B+树的定义</h5>
<ul>
<li>所有数据都记录在叶节点中，所有叶节点连成一个单链表</li>
<li>非叶节点至多保存 <span class="math inline">\(m-1\)</span>
个关键字来引导查找，键 <span class="math inline">\(i\)</span> 表示子树
<span class="math inline">\(i+1\)</span> 中键的最小值</li>
<li>根节点或者是叶节点，或者有 <span class="math inline">\(2\)</span> 到
<span class="math inline">\(m\)</span> 个子树</li>
<li>除了根节点之外的所有非叶节点至少有 <span
class="math inline">\(m/2\)</span> 个儿子，最多有 <span
class="math inline">\(m\)</span> 个儿子</li>
<li>所有的叶节点都在同一层上，并且每个叶子有 <span
class="math inline">\(\lceil L/2 \rceil\)</span> 到 <span
class="math inline">\(L\)</span> 个关键字</li>
</ul>
<h5 id="b树的插入">B+树的插入</h5>
<ul>
<li>叶结点不满：把新结点插入叶子，重新调整该叶子中数据的顺序</li>
<li>叶子已经装满 ：通过分裂该叶子，形成两个半满的叶子来插入一个新的项
<ul>
<li>更新父结点</li>
<li>如果父亲的儿子数量已经满了，就继续分裂父亲</li>
</ul></li>
</ul>
<h3 id="外排序">外排序</h3>
<p>一次外存操作所需的时间可以执行数百条甚至上千条指令，因此在外排序中主要考虑的是如何减少外存储器的读写（I/O
操作）</p>
<h4 id="外排序模型">外排序模型</h4>
<ul>
<li>外排序由两个阶段组成
<ol type="1">
<li>预处理阶段：根据内存的大小将一个有 n
个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段</li>
<li>归并阶段：将这些有序片段逐步归并成一个有序文件</li>
</ol></li>
</ul>
<p>减少 I/O 操作的关键</p>
<ol type="1">
<li>减少归并轮数</li>
<li>减少有序片段数量</li>
<li>增加合并路数</li>
</ol>
<h4 id="预处理">预处理</h4>
<h5 id="减少有序片段数量">减少有序片段数量</h5>
<ul>
<li>每次读入的记录数越多，形成的初始的已排序的片段越少，归并的次数也越少</li>
<li>最简单的方法是按照内存的容量尽可能多地读入数据记录，然后再内存中进行排序，排序地结果写入文件，形成一个已排序片段</li>
</ul>
<h5 id="置换排序">置换排序</h5>
<p>置换选择可以在只能容纳 <span class="math inline">\(p\)</span>
个记录的内存中生成平均长度为 <span class="math inline">\(2p\)</span>
的初始的已排序片段</p>
<p>只要前面的元素被写到文件上，它所用的内存空间就可以给别的元素使用。如果输入文件中的下一个元素比刚刚输出的元素大，它能被放入这个已排序片段</p>
<p>具体方法</p>
<ol type="1">
<li>初始时，将 <span class="math inline">\(m\)</span> 个元素读入内存，用
<code>buildHeap</code> 建立一个优先级队列</li>
<li>执行一次 <code>deQuqeue</code>，将最小的元素写入输出文件</li>
<li>从输入磁带读入下一个元素
<ul>
<li>如果它比刚才写进去的元素大，那么将它加入到优先级队列中</li>
<li>否则，则无法写入队列，进行下一次 <code>deQuqeue</code></li>
</ul></li>
<li>重复第 2、3 步，直到输入文件读完</li>
<li>重新执行 <code>buildHeap</code>，使用存放在空余位置中的元素</li>
</ol>
<h4 id="归并">归并</h4>
<h5 id="二路归并">二路归并</h5>
<ul>
<li>归并时，每次将两个有序文件归并为一个有序文件</li>
<li>如果生成的有序片段数量为 <span
class="math inline">\(M\)</span>，则归并次数为 <span
class="math inline">\(\lceil \log_2 M \rceil\)</span></li>
</ul>
<h5 id="多路归并">多路归并</h5>
<ul>
<li>归并时，每次将 <span class="math inline">\(k\)</span>
个有序文件归并为一个有序文件</li>
<li>优点：减少归并次数，为 <span class="math inline">\(\lceil \log_k M
\rceil\)</span> 次</li>
<li>缺点：寻找最小元素的操作复杂，通常可以将每个文件的第一个记录组成一个优先级队列</li>
</ul>
<h5 id="多阶段归并">多阶段归并</h5>
<ul>
<li>可以仅使用 <span class="math inline">\(K+1\)</span> 条磁带实现 <span
class="math inline">\(K\)</span>
路归并，称为<strong>多阶段归并</strong></li>
</ul>
<p><strong>实现的过程</strong></p>
<ol type="1">
<li>按照非均匀的方法分解原来的已排序的片段</li>
<li>将每个片段分成 <span class="math inline">\(K\)</span> 个子片段</li>
</ol>
<h2 id="图">图</h2>
<h3 id="图的定义">图的定义</h3>
<ul>
<li>图可以用 <span class="math inline">\(G=(V, E)\)</span>
表示。其中，<span class="math inline">\(V\)</span> 是顶点集，<span
class="math inline">\(E\)</span> 是边集。</li>
<li>如果边是有方向的，称为<strong>有向图</strong>.有向图的边用 <span
class="math inline">\(\langle \rangle\)</span> 表示
<ul>
<li><span class="math inline">\(\langle A, B \rangle\)</span> 表示从
<span class="math inline">\(A\)</span> 到 <span
class="math inline">\(B\)</span> 的一条边</li>
</ul></li>
<li>如果边是无方向的，称为<strong>无向图</strong>.无向图的边用 <span
class="math inline">\(()\)</span> 表示
<ul>
<li><span class="math inline">\((A, B)\)</span> 表示 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 之间有一条边</li>
<li>无向图也称为双向图</li>
</ul></li>
<li><strong>加权图：</strong>
边被赋予一个权值的图称为加权图.如果图是有向的，称为加权有向图，如果是无向的，称为加权无向图
<ul>
<li>加权图中边的表示：<span
class="math inline">\((V_i,V_j,W)\)</span></li>
</ul></li>
</ul>
<h3 id="图的基本术语">图的基本术语</h3>
<ul>
<li>邻接
<ul>
<li>若 <span class="math inline">\((V_i,V_j)\)</span> 是图 <span
class="math inline">\(G\)</span> 的一条边，则称 <span
class="math inline">\(V_i\)</span> 和 <span
class="math inline">\(V_j\)</span> 是邻接的；若 <span
class="math inline">\(\langle V_i,V_j \rangle\)</span> 是图 <span
class="math inline">\(G\)</span> 的一条边，则称 <span
class="math inline">\(V_i\)</span> 邻接到 <span
class="math inline">\(V_j\)</span>，<span
class="math inline">\(V_j\)</span> 和 <span
class="math inline">\(V_i\)</span> 邻接</li>
</ul></li>
<li>度 无向图中邻接与某一顶点的边的总数</li>
<li>入度 有向图中进入某一顶点的边数</li>
<li>出度 有向图中离开某一顶点的边数</li>
<li>边与度的关系 <span class="math inline">\(\displaystyle
e=\frac{1}{2}\sum_{i=1}^n d_i\)</span>，其中 <span
class="math inline">\(e\)</span> 是边数，<span
class="math inline">\(d_i\)</span> 是顶点 <span
class="math inline">\(V_i\)</span> 的度</li>
</ul>
<h4 id="子图">子图</h4>
<p>设有两个图 <span class="math inline">\(G_1=(V_1,E_1)\)</span> 和
<span class="math inline">\(G_2=(V_2,E_2)\)</span>，如果 <span
class="math inline">\(V_1 \subseteq V_2\)</span>，<span
class="math inline">\(E_1 \subseteq E_2\)</span>，则称 <span
class="math inline">\(G_1\)</span> 是 <span
class="math inline">\(G_2\)</span> 的子图</p>
<h4 id="路径和路径长度">路径和路径长度</h4>
<ul>
<li>对于 <span class="math inline">\(1&lt;i&lt;N\)</span>，顶点序列
<span class="math inline">\(w_1,w_2,\ldots,w_N\)</span> 中的顶点对 <span
class="math inline">\((w_i,w_{i+1})\)</span> 都有 <span
class="math inline">\((W_i,w_{i+1})\in E\)</span> 或 <span
class="math inline">\(\langle w_i,w_{i+1} \rangle \in E\)</span>，则称
<span class="math inline">\(w_1,w_2,\ldots,w_N\)</span>
是图中的一条<strong>路径</strong></li>
<li><strong>非加权的路径长度</strong>就是组成路径的边数，对于路径 <span
class="math inline">\(w_1,w_2,\ldots,w_N\)</span>，路径长度为 <span
class="math inline">\(N-1\)</span></li>
<li><strong>加权的路径长度</strong>是指路径上所有边的权值之和</li>
<li><strong>简单路径和环：</strong>
如果一条路径上所有顶点，除了起始顶点和终止顶点可能相同外，其余的顶点都不相同，则称其为简单路径。一个回路或环是一条简单路径，其起始顶点和终止顶点相同，且路径长度至少为
<span class="math inline">\(1\)</span></li>
</ul>
<h4 id="无向图的连通性">无向图的连通性</h4>
<ul>
<li><strong>连通：</strong> 顶点 <span class="math inline">\(V\)</span>
和顶点 <span class="math inline">\(V&#39;\)</span> 之间又路径存在</li>
<li><strong>连通图：</strong> 无向图 G 的任意两点之间都是连通的</li>
<li><strong>连通分量：</strong> 非连通图中的极大连通子图</li>
</ul>
<h4 id="有向图的连通性">有向图的连通性</h4>
<ul>
<li><strong>强连通图：</strong> 有向图 G 的任意两点之间都是连通的，则称
G 是强连通图</li>
<li><strong>强连通分量：</strong> 极大连通子图</li>
<li><strong>弱连通图：</strong> 如有向图 G
不是强连通的，但是如果把它看作是无向图时则是连通的，则称该图是弱连通的</li>
</ul>
<h4 id="完全图">完全图</h4>
<ul>
<li><strong>完全图：</strong>
每两个顶点之间都有边的无向图称为完全图。完全图有 <span
class="math inline">\(\frac{n(n-1)}{2}\)</span> 条边，即 <span
class="math inline">\(C_n^2\)</span></li>
<li><strong>有向完全图：</strong>
每两个顶点之间都有两条边的有向图称为有向完全图。有向完全图有 <span
class="math inline">\(n(n-1)\)</span> 条边，即 <span
class="math inline">\(P_n^2\)</span></li>
<li><strong>有向无环图：</strong> 不含环的有向图</li>
</ul>
<h4 id="生成树与最小生成树">生成树与最小生成树</h4>
<ul>
<li><strong>生成树</strong>是图 G 的<strong>极小</strong>连通子图
G’，其中 <span class="math inline">\(V(G&#39;)=V(G)\)</span></li>
<li>用一棵树把图 G 的所有顶点都连起来，并且没有回路</li>
<li>生成树有 <span class="math inline">\(n\)</span> 个顶点，<span
class="math inline">\(n-1\)</span> 条边</li>
<li>生成树可以有多个</li>
<li><strong>最小生成树</strong>是所有生成树中权值之和最小的生成树</li>
</ul>
<h3 id="图的运算">图的运算</h3>
<ul>
<li>常规操作
<ul>
<li>构造一个由若干个顶点、若干条边组成的图</li>
<li>判断两个顶点之间是否有边存在</li>
<li>在图中添加或删除一条边</li>
<li>返回图中的顶点数或边数</li>
<li>按某种规则<strong>遍历</strong>图中的所有顶点</li>
</ul></li>
<li>和应用紧密结合的运算
<ul>
<li>拓扑排序和关键路径</li>
<li>找最小生成树</li>
<li>找最短路径等</li>
</ul></li>
</ul>
<h3 id="图的抽象类">图的抽象类</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y, TypeOfEdge w)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(TypeOfVer x, TypeOfVer y)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfVer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> Vers;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numOfEdge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>      <span class="hljs-keyword">return</span> Edges;<br>    &#125;<br> <br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> Vers, Edges;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="图的存储">图的存储</h3>
<h4 id="邻接矩阵和加权邻接矩阵">邻接矩阵和加权邻接矩阵</h4>
<h5 id="有向图的邻接矩阵">有向图的邻接矩阵</h5>
<p>设有向图有 <span class="math inline">\(n\)</span> 个顶点，则用一个
<span class="math inline">\(n \times n\)</span> 的布尔矩阵 <span
class="math inline">\(A\)</span> 来表示该有向图</p>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212328867.png" srcset="/img/loading.jpeg" lazyload
alt="有向图的邻接矩阵" />
<figcaption aria-hidden="true">有向图的邻接矩阵</figcaption>
</figure>
<ul>
<li>分别使用 <span class="math inline">\(0,1,2,\ldots,n-1\)</span> 表示
顶点 <span
class="math inline">\(V_0,V_1,\ldots,V_{n-1}\)</span>，如果存在一条从
<span class="math inline">\(V_i\)</span> 到 <span
class="math inline">\(V_j\)</span> 的边，则 <span
class="math inline">\(A[i][j]=1\)</span>，否则 <span
class="math inline">\(A[i][j]=0\)</span></li>
<li>出度：<span class="math inline">\(i\)</span> 行之和</li>
<li>入度：<span class="math inline">\(j\)</span> 列之和</li>
<li>真正的顶点数据字段之值放入一个一维数组之中</li>
</ul>
<h5 id="无向图的邻接矩阵">无向图的邻接矩阵</h5>
<p>设无向图有 <span class="math inline">\(n\)</span> 个顶点，则用一个
<span class="math inline">\(n \times n\)</span> 的布尔矩阵 <span
class="math inline">\(A\)</span> 来表示该无向图</p>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505212332916.png" srcset="/img/loading.jpeg" lazyload
alt="无向图的邻接矩阵" />
<figcaption aria-hidden="true">无向图的邻接矩阵</figcaption>
</figure>
<ul>
<li>分别使用 <span class="math inline">\(0,1,2,\ldots,n-1\)</span> 表示
顶点 <span
class="math inline">\(V_0,V_1,\ldots,V_{n-1}\)</span>，如果存在一条从
<span class="math inline">\(V_i\)</span> 到 <span
class="math inline">\(V_j\)</span> 的边，则 <span
class="math inline">\(A[i][j]=A[j][i]=1\)</span>，否则 <span
class="math inline">\(A[i][j]=A[j][i]=0\)</span></li>
<li>顶点 <span class="math inline">\(i\)</span> 的度：第 <span
class="math inline">\(i\)</span> 行或第 <span
class="math inline">\(i\)</span> 列之和</li>
<li>无向图的邻接矩阵是一个三角对称矩阵</li>
</ul>
<h5 id="邻接矩阵的特点">邻接矩阵的特点</h5>
<ul>
<li>优点：判断任意两点之间是否有边方便，仅耗费 <span
class="math inline">\(O(1)\)</span> 时间</li>
<li>缺点：即使 <span class="math inline">\(\ll n_2\)</span>
条边，也需内存 <span class="math inline">\(n_2\)</span> 单元，太多;
仅读入数据耗费 <span class="math inline">\(O(n_2)\)</span>
时间，太长。而大多数的图的边数远远小于 <span
class="math inline">\(n_2\)</span>。<strong>适合稠密网</strong></li>
<li>不适合增减顶点</li>
</ul>
<h4 id="邻接表">邻接表</h4>
<ul>
<li><p>设有向图或者无向图由 <span class="math inline">\(n\)</span>
个顶点，则用<strong>顶点表</strong>和<strong>边表</strong>来表示该有向图或无向图</p></li>
<li><p><strong>顶点表：</strong> 用数组或单链表的形式存放所有的顶点</p>
<ul>
<li>如果顶点数 <span class="math inline">\(n\)</span>
已知，则采用数组</li>
<li>如果顶点数未知，则采用单链表</li>
<li>每个元素包含两个部分
<ul>
<li>顶点值</li>
<li>指向该顶点对应的边表的首地址</li>
</ul></li>
</ul></li>
<li><p><strong>边表：</strong> 每条边用一个节点进行表示</p>
<p>同一个顶点出发的所有的边形成它的边界点单链表</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505222230615.png" srcset="/img/loading.jpeg" lazyload
alt="邻接表" />
<figcaption aria-hidden="true">邻接表</figcaption>
</figure>
<h4 id="邻接表的特点">邻接表的特点</h4>
<ul>
<li>邻接表是图的<strong>标准</strong>存储方式</li>
<li>优点
<ul>
<li><span class="math inline">\(\text{内存} = \text{顶点数}
+\text{边数}\)</span>，时间复杂度为 <span
class="math inline">\(O\left(\vert V\vert +\vert E\vert
\right)\)</span>，<strong>适合稀疏网</strong></li>
</ul></li>
<li>当谈及图的线性算法时，一般指的是 <span
class="math inline">\(O\left(\vert V\vert +\vert E\vert
\right)\)</span></li>
<li>缺点
<ul>
<li>确定 <span class="math inline">\(i\rightarrow j\)</span>
是否有边，最坏需耗费 <span class="math inline">\(O(n)\)</span> 时间</li>
<li>无向图同一条边表示两次。边表空间浪费一倍</li>
<li>有向图中寻找进入某结点的边，非常困难（逆邻接表）</li>
</ul></li>
</ul>
<h3 id="图的遍历">图的遍历</h3>
<p>按照某种次序系统地访问图中的所有顶点，并且使得<strong>每个顶点需且只能被访问一次</strong></p>
<p>需对访问过的顶点加以<strong>标记</strong></p>
<h4 id="深度优先搜索">深度优先搜索</h4>
<ol type="1">
<li>选中第一个被访问的顶点</li>
<li>对顶点作已访问过的标志</li>
<li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li>
</ol>
<p>出现了问题</p>
<h5 id="存在的问题">存在的问题</h5>
<p><span id="DFSdamn">如果图不是连通或强连通，在进行 DFS
时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点</span></p>
<h5 id="深度优先生成森林">深度优先生成森林</h5>
<p>在<a
href="##图###图的遍历####深度优先搜索#####存在的问题">这种情况</a>下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问过为止</p>
<p>此时生成的是一组树而不是一棵树，这一组树被称为深度优先生成<strong>森林</strong></p>
<p>所以将深度优先搜索的流程改为</p>
<ol type="1">
<li>选中第一个被访问的顶点</li>
<li>对顶点作已访问过的标志</li>
<li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发，进行深度优先搜索</li>
<li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li>
<li>所有的顶点都被访问到，则结束</li>
</ol>
<h5 id="深度优先搜索的实现">深度优先搜索的实现</h5>
<ul>
<li>公有的 <code>dfs</code> 函数的伪代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  visited [v] =<span class="hljs-literal">false</span>; <span class="hljs-comment">//对每个节点标记为未访问</span><br><br>  <span class="hljs-keyword">while</span>(v=尚未访问的节点)<br>  &#123;<br>    <span class="hljs-built_in">dfs</span>(v,visited);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>私有的 <code>dfs</code> 函数的伪代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(v,visited)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">visited</span>(v)=<span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> 每个 v 的邻接点 w<br>  &#123;<br>    <span class="hljs-keyword">if</span>(!visited[w])<br>    &#123;<br>      <span class="hljs-built_in">dfs</span>(w,visited);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="广度优先搜索">广度优先搜索</h4>
<ol type="1">
<li>选中第一个被访问的顶点</li>
<li>对顶点作已访问过的标志</li>
<li>依次访问已访问顶点的未被访问过的第 <span
class="math inline">\(1\)</span> 个、第 <span
class="math inline">\(2\)</span> 个、第 <span
class="math inline">\(3\)</span> 个、<span
class="math inline">\(\ldots\)</span> 、第 <span
class="math inline">\(m\)</span> 个邻接顶点 <span
class="math inline">\(W_1,W_2,W_3,\ldots,W_m\)</span>
，进行访问且进行标记，转向 3</li>
<li>如果还有顶点未被访问，则选中一个起始顶点，转向 2</li>
<li>所有的顶点都被访问到，则结束</li>
</ol>
<p>按照顶点序号小的先访问，大的后访问的原则以<strong>队列</strong>的形式实现</p>
<p>同样能够生成广度优先生成森林</p>
<h5 id="广度优先搜索的实现">广度优先搜索的实现</h5>
<ol type="1">
<li>将序号最小的顶点放入队列</li>
<li>重复取队列的队头元素进行处理，直到队列为空。对出队的每个元素，首先检查该元素是否已被访问
<ul>
<li>如果没有被访问过，则访问该元素，并将它的所有的没有被访问过的后继入队</li>
</ul></li>
<li>检查是否还有顶点未被访问。如果有，重复上述两个步骤</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class="hljs-built_in">bfs</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-type">bool</span> *visited = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[Vers];<br>  <span class="hljs-type">int</span> currentNode;<br>  linkQueue&lt;<span class="hljs-type">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>   visited[i] = <span class="hljs-literal">false</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;当前图的广度优先遍历序列为：&quot;</span>&lt;&lt; endl;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-comment">//连续访问队列的队头，将其拉出，若其后继非空则拉入队列</span><br>    &#123;<br>      currentNode = q.<span class="hljs-built_in">deQueue</span>();<br>      <span class="hljs-keyword">if</span> (visited[currentNode] == <span class="hljs-literal">true</span>)<br>      &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      cout &lt;&lt; verList[currentNode].ver &lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span>;<br>      visited[currentNode] = <span class="hljs-literal">true</span>;<br>      p = verList[currentNode].head;<br>      <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (visited[p-&gt;end] == <span class="hljs-literal">false</span>)<br>        q.<span class="hljs-built_in">enQueue</span>(p-&gt;end);<br>        p = p-&gt;next;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="图遍历的应用">图遍历的应用</h3>
<h4 id="无向图的连通性-1">无向图的连通性</h4>
<ul>
<li>如果无向图是连通的，则从无向图中的任意顶点出发进行深度优先搜索或广度优先搜索都可以访问到每一个顶点。访问的次序是一棵深度/广度优先<strong>生成树</strong></li>
<li>如果图是非连通的，深度/广度优先搜索可以找到一片深度/广度优先<strong>生成森林</strong>。每棵树就是一个<strong>连通分量</strong>。对无向图来说，深度/广度优先搜索可以找到了它的所有连通分量</li>
<li>在深度优先搜索和广度优先搜索函数的输出中，每一行代表一个连通分量</li>
</ul>
<h4 id="有向图的连通性-1">有向图的连通性</h4>
<ul>
<li>对有向图，深度优先搜索可以<strong>测试是否强连通</strong>，并<strong>找出所有强连通分量</strong>
<ol type="1">
<li>从任意顶点开始<strong>深度优先遍历</strong> <span
class="math inline">\(G\)</span></li>
<li>对森林中的每棵树进行<strong>后序遍历</strong>，并按遍历的顺序给每个顶点编号</li>
<li>将 <span class="math inline">\(G\)</span> 的每条边逆向，形成 <span
class="math inline">\(G_r\)</span></li>
<li>从编号<strong>最大</strong>的顶点开始<strong>深度优先遍历 <span
class="math inline">\(G_r\)</span></strong>。得到的深度优先遍历森林的每棵树就是
<span class="math inline">\(G\)</span> 的强连通分量</li>
</ol></li>
</ul>
<h4 id="欧拉回路">欧拉回路</h4>
<ul>
<li>哥尼斯堡七桥问题：能否找到一条走遍这七座桥，而且每座桥只经过一次，最后又回到原出发点的路径</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230120835.png" srcset="/img/loading.jpeg" lazyload
alt="哥尼斯堡七桥问题" />
<figcaption aria-hidden="true">哥尼斯堡七桥问题</figcaption>
</figure>
<h5 id="欧拉的证明">欧拉的证明</h5>
<ul>
<li>如果都是偶数桥，从任意地方出发都能回到原点
<strong>（欧拉回路）</strong></li>
<li>如果都是偶数桥，从任意地方出发都能回到原点
<strong>（欧拉路径）</strong></li>
<li>如果有奇数桥的地方不止两个，满足要求的路径是找不到的</li>
</ul>
<h5 id="查找欧拉回路的基本想法">查找欧拉回路的基本想法</h5>
<ul>
<li>执行一次<strong>不允许回溯</strong>的 <code>DFS</code>
，也被称为一笔画问题</li>
<li>但是很多搜索都是不符合的</li>
</ul>
<h5 id="解决方法">解决方法</h5>
<p>找出路径上的另外一个尚有未访问的边的顶点，开始另一次深度优先的搜索，将得到的遍历序列拼接到原来的序列中，直到所有的边都已被访问</p>
<figure>
<img
src="https://raw.githubusercontent.com/dcldyhb/Freshman-Notes-Image-Host/main/202505230128080.png" srcset="/img/loading.jpeg" lazyload
alt="欧拉回路解决方法" />
<figcaption aria-hidden="true">欧拉回路解决方法</figcaption>
</figure>
<h4 id="拓扑排序">拓扑排序</h4>
<p>设 <span class="math inline">\(G=(V,E)\)</span> 是一个具有 <span
class="math inline">\(n\)</span> 个顶点的<strong>有向无环图</strong></p>
<p>若 <span class="math inline">\(V\)</span> 中的顶点序列 <span
class="math inline">\(V_1,V_2,\ldots ,V_n\)</span> 满足下列条件</p>
<ul>
<li>在 <span class="math inline">\(G\)</span> 中，从 <span
class="math inline">\(V_i\)</span> 到 <span
class="math inline">\(V_j\)</span> 有一条路径</li>
<li>在序列中 <span class="math inline">\(V_i\)</span> 在 <span
class="math inline">\(V_j\)</span> 之前</li>
</ul>
<p>则称 <span class="math inline">\(V_1,V_2,\ldots ,V_n\)</span> 是
<span class="math inline">\(G\)</span>
的一个<strong>拓扑排序</strong></p>
<p>拓扑排序将图转换为线性序，相对前去后继关系不变</p>
<h5 id="顶点活动网络activu-on-vertex-network">顶点活动网络（Activu on
vertex network）</h5>
<ul>
<li>顶点表示各项子任务</li>
<li>有向边表示具有先决条件关系</li>
<li>仅当作为某一子任务的所有作为先决条件的子任务实施完成后，该子任务才能得以实施</li>
</ul>
<p><strong>AOV</strong>的特点</p>
<ol type="1">
<li>有起始顶点</li>
<li>无回路</li>
</ol>
<h5 id="找出拓扑排序的过程">找出拓扑排序的过程</h5>
<ul>
<li>第一个输出的顶点必须无前驱，即入度为 <span
class="math inline">\(0\)</span></li>
<li>无前驱以及后继的顶点在任何时候都可以输出</li>
<li>逻辑删除法：当某个顶点被输出之后，该顶点以及从该顶点出发的边都被删除，所有以该顶点作为前驱的入度的所有顶点的入度
<span class="math inline">\(-1\)</span></li>
</ul>
<h5 id="拓扑排序的实现">拓扑排序的实现</h5>
<ul>
<li>计算每个顶点的入度，保存在数组 <code>inDegree</code> 中</li>
<li>检查 <code>inDegree</code> 中的每个元素，将入度为 <span
class="math inline">\(0\)</span> 的顶点入队</li>
<li>不断从队列中将入度为 <span class="math inline">\(0\)</span>
的顶点入队，输出此顶点，并将该顶点的入度 <span
class="math inline">\(-1\)</span>，如果某个邻接点的入度为 <span
class="math inline">\(0\)</span>，则将其入队</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfVer</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeOfEdge</span>&gt;<br><span class="hljs-type">void</span> adjListGraph&lt;TypeOfVer, TypeOfEdge&gt;::<span class="hljs-built_in">topSort</span>() <span class="hljs-type">const</span><br>&#123;<br>  linkQueue&lt;<span class="hljs-type">int</span>&gt; q;<br>  edgeNode *p;<br>  <span class="hljs-type">int</span> current, *inDegree = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[Vers];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    inDegree[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (p = verList[i].head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next)<br>    &#123;<br>    ++inDegree[p-&gt;end];<br>    &#125;<br>  &#125;                                                                 <span class="hljs-comment">//计算入度</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Vers; ++i)   <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">enQueue</span>(i);  <span class="hljs-comment">//入度0节点入队</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;拓扑排序为：&quot;</span> &lt;&lt; endl;<br>  <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">isEmpty</span>())<br>  &#123;<br>    current = q.<span class="hljs-built_in">deQueue</span>( );<br>    cout &lt;&lt; verList[current].ver &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (p = verList[current].head; p != <span class="hljs-literal">NULL</span>; p = p-&gt;next)<br>    <span class="hljs-keyword">if</span>( --inDegree[p-&gt;end] == <span class="hljs-number">0</span> )    q.<span class="hljs-built_in">enQueue</span>( p-&gt;end );<br>  &#125;                                                                 <span class="hljs-comment">//出队，删除关联的边</span><br>  cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时间复杂度：</strong></p>
<ul>
<li>若图以邻接表表示</li>
<li>计算入度的时间复杂度为 <span class="math inline">\(O(\vert V\vert
+\vert E\vert)\)</span>，搜索入度为 <span
class="math inline">\(0\)</span> 的顶点的时间复杂度为 <span
class="math inline">\(O(\vert
V\vert)\)</span>，出队和删除边的时间复杂度为 <span
class="math inline">\(O(\vert E\vert)\)</span>，总执行时间为 <span
class="math inline">\(O(\vert V\vert +\vert E\vert)\)</span></li>
</ul>
<h4 id="关键路径">关键路径</h4>
<h5 id="边活动网络activity-on-edge">边活动网络（Activity on Edge）</h5>
<ul>
<li><strong>AOE 网络：</strong> 加权有向无环图
<ul>
<li>顶点表示事件，边表示活动</li>
<li>有向边的权值表示活动的持续时间</li>
<li>有向边的方向表示事件发生的先后次序</li>
<li>顶点的进入表示事件发生后允许开始的活动</li>
<li>有一个源点、一个终点</li>
</ul></li>
</ul>
<h5 id="关键路径的定义">关键路径的定义</h5>
<p>AOE
网路可用于描述整个工程的各个活动之间的关系，活动安排的先后次序</p>
<p>再次基础上可以用来估算工程的完成时间以及哪些活动是关键的活动</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/" class="category-chain-item">专业课程</a>
  
  
    <span>></span>
    
  <a href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="category-chain-item">计算机</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="print-no-link">#课程笔记</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>中缀计算式转换为后缀计算式</div>
      <div>http://dcldyhb.github.io/2025/09/18/本科/编程/数据结构/数据结构笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>东川路第一寒冰</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
